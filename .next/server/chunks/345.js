exports.id = 345;
exports.ids = [345];
exports.modules = {

/***/ 24622:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

//
// Main
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.strategies = exports.memoize = void 0;
function memoize(fn, options) {
    var cache = options && options.cache ? options.cache : cacheDefault;
    var serializer = options && options.serializer ? options.serializer : serializerDefault;
    var strategy = options && options.strategy ? options.strategy : strategyDefault;
    return strategy(fn, {
        cache: cache,
        serializer: serializer,
    });
}
exports.memoize = memoize;
//
// Strategy
//
function isPrimitive(value) {
    return (value == null || typeof value === 'number' || typeof value === 'boolean'); // || typeof value === "string" 'unsafe' primitive for our needs
}
function monadic(fn, cache, serializer, arg) {
    var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
    var computedValue = cache.get(cacheKey);
    if (typeof computedValue === 'undefined') {
        computedValue = fn.call(this, arg);
        cache.set(cacheKey, computedValue);
    }
    return computedValue;
}
function variadic(fn, cache, serializer) {
    var args = Array.prototype.slice.call(arguments, 3);
    var cacheKey = serializer(args);
    var computedValue = cache.get(cacheKey);
    if (typeof computedValue === 'undefined') {
        computedValue = fn.apply(this, args);
        cache.set(cacheKey, computedValue);
    }
    return computedValue;
}
function assemble(fn, context, strategy, cache, serialize) {
    return strategy.bind(context, fn, cache, serialize);
}
function strategyDefault(fn, options) {
    var strategy = fn.length === 1 ? monadic : variadic;
    return assemble(fn, this, strategy, options.cache.create(), options.serializer);
}
function strategyVariadic(fn, options) {
    return assemble(fn, this, variadic, options.cache.create(), options.serializer);
}
function strategyMonadic(fn, options) {
    return assemble(fn, this, monadic, options.cache.create(), options.serializer);
}
//
// Serializer
//
var serializerDefault = function () {
    return JSON.stringify(arguments);
};
//
// Cache
//
function ObjectWithoutPrototypeCache() {
    this.cache = Object.create(null);
}
ObjectWithoutPrototypeCache.prototype.get = function (key) {
    return this.cache[key];
};
ObjectWithoutPrototypeCache.prototype.set = function (key, value) {
    this.cache[key] = value;
};
var cacheDefault = {
    create: function create() {
        // @ts-ignore
        return new ObjectWithoutPrototypeCache();
    },
};
exports.strategies = {
    variadic: strategyVariadic,
    monadic: strategyMonadic,
};


/***/ }),

/***/ 2005:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBestPattern = void 0;
var time_data_generated_1 = __webpack_require__(66593);
/**
 * Returns the best matching date time pattern if a date time skeleton
 * pattern is provided with a locale. Follows the Unicode specification:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#table-mapping-requested-time-skeletons-to-patterns
 * @param skeleton date time skeleton pattern that possibly includes j, J or C
 * @param locale
 */
function getBestPattern(skeleton, locale) {
    var skeletonCopy = '';
    for (var patternPos = 0; patternPos < skeleton.length; patternPos++) {
        var patternChar = skeleton.charAt(patternPos);
        if (patternChar === 'j') {
            var extraLength = 0;
            while (patternPos + 1 < skeleton.length &&
                skeleton.charAt(patternPos + 1) === patternChar) {
                extraLength++;
                patternPos++;
            }
            var hourLen = 1 + (extraLength & 1);
            var dayPeriodLen = extraLength < 2 ? 1 : 3 + (extraLength >> 1);
            var dayPeriodChar = 'a';
            var hourChar = getDefaultHourSymbolFromLocale(locale);
            if (hourChar == 'H' || hourChar == 'k') {
                dayPeriodLen = 0;
            }
            while (dayPeriodLen-- > 0) {
                skeletonCopy += dayPeriodChar;
            }
            while (hourLen-- > 0) {
                skeletonCopy = hourChar + skeletonCopy;
            }
        }
        else if (patternChar === 'J') {
            skeletonCopy += 'H';
        }
        else {
            skeletonCopy += patternChar;
        }
    }
    return skeletonCopy;
}
exports.getBestPattern = getBestPattern;
/**
 * Maps the [hour cycle type](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale/hourCycle)
 * of the given `locale` to the corresponding time pattern.
 * @param locale
 */
function getDefaultHourSymbolFromLocale(locale) {
    var hourCycle = locale.hourCycle;
    if (hourCycle === undefined &&
        // @ts-ignore hourCycle(s) is not identified yet
        locale.hourCycles &&
        // @ts-ignore
        locale.hourCycles.length) {
        // @ts-ignore
        hourCycle = locale.hourCycles[0];
    }
    if (hourCycle) {
        switch (hourCycle) {
            case 'h24':
                return 'k';
            case 'h23':
                return 'H';
            case 'h12':
                return 'h';
            case 'h11':
                return 'K';
            default:
                throw new Error('Invalid hourCycle');
        }
    }
    // TODO: Once hourCycle is fully supported remove the following with data generation
    var languageTag = locale.language;
    var regionTag;
    if (languageTag !== 'root') {
        regionTag = locale.maximize().region;
    }
    var hourCycles = time_data_generated_1.timeData[regionTag || ''] ||
        time_data_generated_1.timeData[languageTag || ''] ||
        time_data_generated_1.timeData["".concat(languageTag, "-001")] ||
        time_data_generated_1.timeData['001'];
    return hourCycles[0];
}


/***/ }),

/***/ 39321:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ErrorKind = void 0;
var ErrorKind;
(function (ErrorKind) {
    /** Argument is unclosed (e.g. `{0`) */
    ErrorKind[ErrorKind["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
    /** Argument is empty (e.g. `{}`). */
    ErrorKind[ErrorKind["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
    /** Argument is malformed (e.g. `{foo!}``) */
    ErrorKind[ErrorKind["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
    /** Expect an argument type (e.g. `{foo,}`) */
    ErrorKind[ErrorKind["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
    /** Unsupported argument type (e.g. `{foo,foo}`) */
    ErrorKind[ErrorKind["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
    /** Expect an argument style (e.g. `{foo, number, }`) */
    ErrorKind[ErrorKind["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
    /** The number skeleton is invalid. */
    ErrorKind[ErrorKind["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
    /** The date time skeleton is invalid. */
    ErrorKind[ErrorKind["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
    /** Exepct a number skeleton following the `::` (e.g. `{foo, number, ::}`) */
    ErrorKind[ErrorKind["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
    /** Exepct a date time skeleton following the `::` (e.g. `{foo, date, ::}`) */
    ErrorKind[ErrorKind["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
    /** Unmatched apostrophes in the argument style (e.g. `{foo, number, 'test`) */
    ErrorKind[ErrorKind["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
    /** Missing select argument options (e.g. `{foo, select}`) */
    ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
    /** Expecting an offset value in `plural` or `selectordinal` argument (e.g `{foo, plural, offset}`) */
    ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
    /** Offset value in `plural` or `selectordinal` is invalid (e.g. `{foo, plural, offset: x}`) */
    ErrorKind[ErrorKind["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
    /** Expecting a selector in `select` argument (e.g `{foo, select}`) */
    ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
    /** Expecting a selector in `plural` or `selectordinal` argument (e.g `{foo, plural}`) */
    ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
    /** Expecting a message fragment after the `select` selector (e.g. `{foo, select, apple}`) */
    ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
    /**
     * Expecting a message fragment after the `plural` or `selectordinal` selector
     * (e.g. `{foo, plural, one}`)
     */
    ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
    /** Selector in `plural` or `selectordinal` is malformed (e.g. `{foo, plural, =x {#}}`) */
    ErrorKind[ErrorKind["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
    /**
     * Duplicate selectors in `plural` or `selectordinal` argument.
     * (e.g. {foo, plural, one {#} one {#}})
     */
    ErrorKind[ErrorKind["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
    /** Duplicate selectors in `select` argument.
     * (e.g. {foo, select, apple {apple} apple {apple}})
     */
    ErrorKind[ErrorKind["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
    /** Plural or select argument option must have `other` clause. */
    ErrorKind[ErrorKind["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
    /** The tag is malformed. (e.g. `<bold!>foo</bold!>) */
    ErrorKind[ErrorKind["INVALID_TAG"] = 23] = "INVALID_TAG";
    /** The tag name is invalid. (e.g. `<123>foo</123>`) */
    ErrorKind[ErrorKind["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
    /** The closing tag does not match the opening tag. (e.g. `<bold>foo</italic>`) */
    ErrorKind[ErrorKind["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
    /** The opening tag has unmatched closing tag. (e.g. `<bold>foo`) */
    ErrorKind[ErrorKind["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
})(ErrorKind = exports.ErrorKind || (exports.ErrorKind = {}));


/***/ }),

/***/ 28553:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._Parser = exports.parse = void 0;
var tslib_1 = __webpack_require__(61915);
var error_1 = __webpack_require__(39321);
var parser_1 = __webpack_require__(43354);
var types_1 = __webpack_require__(5497);
function pruneLocation(els) {
    els.forEach(function (el) {
        delete el.location;
        if ((0, types_1.isSelectElement)(el) || (0, types_1.isPluralElement)(el)) {
            for (var k in el.options) {
                delete el.options[k].location;
                pruneLocation(el.options[k].value);
            }
        }
        else if ((0, types_1.isNumberElement)(el) && (0, types_1.isNumberSkeleton)(el.style)) {
            delete el.style.location;
        }
        else if (((0, types_1.isDateElement)(el) || (0, types_1.isTimeElement)(el)) &&
            (0, types_1.isDateTimeSkeleton)(el.style)) {
            delete el.style.location;
        }
        else if ((0, types_1.isTagElement)(el)) {
            pruneLocation(el.children);
        }
    });
}
function parse(message, opts) {
    if (opts === void 0) { opts = {}; }
    opts = tslib_1.__assign({ shouldParseSkeletons: true, requiresOtherClause: true }, opts);
    var result = new parser_1.Parser(message, opts).parse();
    if (result.err) {
        var error = SyntaxError(error_1.ErrorKind[result.err.kind]);
        // @ts-expect-error Assign to error object
        error.location = result.err.location;
        // @ts-expect-error Assign to error object
        error.originalMessage = result.err.message;
        throw error;
    }
    if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {
        pruneLocation(result.val);
    }
    return result.val;
}
exports.parse = parse;
tslib_1.__exportStar(__webpack_require__(5497), exports);
// only for testing
exports._Parser = parser_1.Parser;


/***/ }),

/***/ 43354:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Parser = void 0;
var tslib_1 = __webpack_require__(61915);
var error_1 = __webpack_require__(39321);
var types_1 = __webpack_require__(5497);
var regex_generated_1 = __webpack_require__(42290);
var icu_skeleton_parser_1 = __webpack_require__(9313);
var date_time_pattern_generator_1 = __webpack_require__(2005);
var SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(regex_generated_1.SPACE_SEPARATOR_REGEX.source, "*"));
var SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(regex_generated_1.SPACE_SEPARATOR_REGEX.source, "*$"));
function createLocation(start, end) {
    return { start: start, end: end };
}
// #region Ponyfills
// Consolidate these variables up top for easier toggling during debugging
var hasNativeStartsWith = !!String.prototype.startsWith;
var hasNativeFromCodePoint = !!String.fromCodePoint;
var hasNativeFromEntries = !!Object.fromEntries;
var hasNativeCodePointAt = !!String.prototype.codePointAt;
var hasTrimStart = !!String.prototype.trimStart;
var hasTrimEnd = !!String.prototype.trimEnd;
var hasNativeIsSafeInteger = !!Number.isSafeInteger;
var isSafeInteger = hasNativeIsSafeInteger
    ? Number.isSafeInteger
    : function (n) {
        return (typeof n === 'number' &&
            isFinite(n) &&
            Math.floor(n) === n &&
            Math.abs(n) <= 0x1fffffffffffff);
    };
// IE11 does not support y and u.
var REGEX_SUPPORTS_U_AND_Y = true;
try {
    var re = RE('([^\\p{White_Space}\\p{Pattern_Syntax}]*)', 'yu');
    /**
     * legacy Edge or Xbox One browser
     * Unicode flag support: supported
     * Pattern_Syntax support: not supported
     * See https://github.com/formatjs/formatjs/issues/2822
     */
    REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec('a')) === null || _a === void 0 ? void 0 : _a[0]) === 'a';
}
catch (_) {
    REGEX_SUPPORTS_U_AND_Y = false;
}
var startsWith = hasNativeStartsWith
    ? // Native
        function startsWith(s, search, position) {
            return s.startsWith(search, position);
        }
    : // For IE11
        function startsWith(s, search, position) {
            return s.slice(position, position + search.length) === search;
        };
var fromCodePoint = hasNativeFromCodePoint
    ? String.fromCodePoint
    : // IE11
        function fromCodePoint() {
            var codePoints = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                codePoints[_i] = arguments[_i];
            }
            var elements = '';
            var length = codePoints.length;
            var i = 0;
            var code;
            while (length > i) {
                code = codePoints[i++];
                if (code > 0x10ffff)
                    throw RangeError(code + ' is not a valid code point');
                elements +=
                    code < 0x10000
                        ? String.fromCharCode(code)
                        : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, (code % 0x400) + 0xdc00);
            }
            return elements;
        };
var fromEntries = 
// native
hasNativeFromEntries
    ? Object.fromEntries
    : // Ponyfill
        function fromEntries(entries) {
            var obj = {};
            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                var _a = entries_1[_i], k = _a[0], v = _a[1];
                obj[k] = v;
            }
            return obj;
        };
var codePointAt = hasNativeCodePointAt
    ? // Native
        function codePointAt(s, index) {
            return s.codePointAt(index);
        }
    : // IE 11
        function codePointAt(s, index) {
            var size = s.length;
            if (index < 0 || index >= size) {
                return undefined;
            }
            var first = s.charCodeAt(index);
            var second;
            return first < 0xd800 ||
                first > 0xdbff ||
                index + 1 === size ||
                (second = s.charCodeAt(index + 1)) < 0xdc00 ||
                second > 0xdfff
                ? first
                : ((first - 0xd800) << 10) + (second - 0xdc00) + 0x10000;
        };
var trimStart = hasTrimStart
    ? // Native
        function trimStart(s) {
            return s.trimStart();
        }
    : // Ponyfill
        function trimStart(s) {
            return s.replace(SPACE_SEPARATOR_START_REGEX, '');
        };
var trimEnd = hasTrimEnd
    ? // Native
        function trimEnd(s) {
            return s.trimEnd();
        }
    : // Ponyfill
        function trimEnd(s) {
            return s.replace(SPACE_SEPARATOR_END_REGEX, '');
        };
// Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.
function RE(s, flag) {
    return new RegExp(s, flag);
}
// #endregion
var matchIdentifierAtIndex;
if (REGEX_SUPPORTS_U_AND_Y) {
    // Native
    var IDENTIFIER_PREFIX_RE_1 = RE('([^\\p{White_Space}\\p{Pattern_Syntax}]*)', 'yu');
    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {
        var _a;
        IDENTIFIER_PREFIX_RE_1.lastIndex = index;
        var match = IDENTIFIER_PREFIX_RE_1.exec(s);
        return (_a = match[1]) !== null && _a !== void 0 ? _a : '';
    };
}
else {
    // IE11
    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {
        var match = [];
        while (true) {
            var c = codePointAt(s, index);
            if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {
                break;
            }
            match.push(c);
            index += c >= 0x10000 ? 2 : 1;
        }
        return fromCodePoint.apply(void 0, match);
    };
}
var Parser = /** @class */ (function () {
    function Parser(message, options) {
        if (options === void 0) { options = {}; }
        this.message = message;
        this.position = { offset: 0, line: 1, column: 1 };
        this.ignoreTag = !!options.ignoreTag;
        this.locale = options.locale;
        this.requiresOtherClause = !!options.requiresOtherClause;
        this.shouldParseSkeletons = !!options.shouldParseSkeletons;
    }
    Parser.prototype.parse = function () {
        if (this.offset() !== 0) {
            throw Error('parser can only be used once');
        }
        return this.parseMessage(0, '', false);
    };
    Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {
        var elements = [];
        while (!this.isEOF()) {
            var char = this.char();
            if (char === 123 /* `{` */) {
                var result = this.parseArgument(nestingLevel, expectingCloseTag);
                if (result.err) {
                    return result;
                }
                elements.push(result.val);
            }
            else if (char === 125 /* `}` */ && nestingLevel > 0) {
                break;
            }
            else if (char === 35 /* `#` */ &&
                (parentArgType === 'plural' || parentArgType === 'selectordinal')) {
                var position = this.clonePosition();
                this.bump();
                elements.push({
                    type: types_1.TYPE.pound,
                    location: createLocation(position, this.clonePosition()),
                });
            }
            else if (char === 60 /* `<` */ &&
                !this.ignoreTag &&
                this.peek() === 47 // char code for '/'
            ) {
                if (expectingCloseTag) {
                    break;
                }
                else {
                    return this.error(error_1.ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
                }
            }
            else if (char === 60 /* `<` */ &&
                !this.ignoreTag &&
                _isAlpha(this.peek() || 0)) {
                var result = this.parseTag(nestingLevel, parentArgType);
                if (result.err) {
                    return result;
                }
                elements.push(result.val);
            }
            else {
                var result = this.parseLiteral(nestingLevel, parentArgType);
                if (result.err) {
                    return result;
                }
                elements.push(result.val);
            }
        }
        return { val: elements, err: null };
    };
    /**
     * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the
     * [custom element name][] except that a dash is NOT always mandatory and uppercase letters
     * are accepted:
     *
     * ```
     * tag ::= "<" tagName (whitespace)* "/>" | "<" tagName (whitespace)* ">" message "</" tagName (whitespace)* ">"
     * tagName ::= [a-z] (PENChar)*
     * PENChar ::=
     *     "-" | "." | [0-9] | "_" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |
     *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |
     *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
     * ```
     *
     * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
     * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do
     * since other tag-based engines like React allow it
     */
    Parser.prototype.parseTag = function (nestingLevel, parentArgType) {
        var startPosition = this.clonePosition();
        this.bump(); // `<`
        var tagName = this.parseTagName();
        this.bumpSpace();
        if (this.bumpIf('/>')) {
            // Self closing tag
            return {
                val: {
                    type: types_1.TYPE.literal,
                    value: "<".concat(tagName, "/>"),
                    location: createLocation(startPosition, this.clonePosition()),
                },
                err: null,
            };
        }
        else if (this.bumpIf('>')) {
            var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
            if (childrenResult.err) {
                return childrenResult;
            }
            var children = childrenResult.val;
            // Expecting a close tag
            var endTagStartPosition = this.clonePosition();
            if (this.bumpIf('</')) {
                if (this.isEOF() || !_isAlpha(this.char())) {
                    return this.error(error_1.ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
                }
                var closingTagNameStartPosition = this.clonePosition();
                var closingTagName = this.parseTagName();
                if (tagName !== closingTagName) {
                    return this.error(error_1.ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
                }
                this.bumpSpace();
                if (!this.bumpIf('>')) {
                    return this.error(error_1.ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
                }
                return {
                    val: {
                        type: types_1.TYPE.tag,
                        value: tagName,
                        children: children,
                        location: createLocation(startPosition, this.clonePosition()),
                    },
                    err: null,
                };
            }
            else {
                return this.error(error_1.ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
            }
        }
        else {
            return this.error(error_1.ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));
        }
    };
    /**
     * This method assumes that the caller has peeked ahead for the first tag character.
     */
    Parser.prototype.parseTagName = function () {
        var startOffset = this.offset();
        this.bump(); // the first tag name character
        while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {
            this.bump();
        }
        return this.message.slice(startOffset, this.offset());
    };
    Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {
        var start = this.clonePosition();
        var value = '';
        while (true) {
            var parseQuoteResult = this.tryParseQuote(parentArgType);
            if (parseQuoteResult) {
                value += parseQuoteResult;
                continue;
            }
            var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
            if (parseUnquotedResult) {
                value += parseUnquotedResult;
                continue;
            }
            var parseLeftAngleResult = this.tryParseLeftAngleBracket();
            if (parseLeftAngleResult) {
                value += parseLeftAngleResult;
                continue;
            }
            break;
        }
        var location = createLocation(start, this.clonePosition());
        return {
            val: { type: types_1.TYPE.literal, value: value, location: location },
            err: null,
        };
    };
    Parser.prototype.tryParseLeftAngleBracket = function () {
        if (!this.isEOF() &&
            this.char() === 60 /* `<` */ &&
            (this.ignoreTag ||
                // If at the opening tag or closing tag position, bail.
                !_isAlphaOrSlash(this.peek() || 0))) {
            this.bump(); // `<`
            return '<';
        }
        return null;
    };
    /**
     * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes
     * a character that requires quoting (that is, "only where needed"), and works the same in
     * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.
     */
    Parser.prototype.tryParseQuote = function (parentArgType) {
        if (this.isEOF() || this.char() !== 39 /* `'` */) {
            return null;
        }
        // Parse escaped char following the apostrophe, or early return if there is no escaped char.
        // Check if is valid escaped character
        switch (this.peek()) {
            case 39 /* `'` */:
                // double quote, should return as a single quote.
                this.bump();
                this.bump();
                return "'";
            // '{', '<', '>', '}'
            case 123:
            case 60:
            case 62:
            case 125:
                break;
            case 35: // '#'
                if (parentArgType === 'plural' || parentArgType === 'selectordinal') {
                    break;
                }
                return null;
            default:
                return null;
        }
        this.bump(); // apostrophe
        var codePoints = [this.char()]; // escaped char
        this.bump();
        // read chars until the optional closing apostrophe is found
        while (!this.isEOF()) {
            var ch = this.char();
            if (ch === 39 /* `'` */) {
                if (this.peek() === 39 /* `'` */) {
                    codePoints.push(39);
                    // Bump one more time because we need to skip 2 characters.
                    this.bump();
                }
                else {
                    // Optional closing apostrophe.
                    this.bump();
                    break;
                }
            }
            else {
                codePoints.push(ch);
            }
            this.bump();
        }
        return fromCodePoint.apply(void 0, codePoints);
    };
    Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {
        if (this.isEOF()) {
            return null;
        }
        var ch = this.char();
        if (ch === 60 /* `<` */ ||
            ch === 123 /* `{` */ ||
            (ch === 35 /* `#` */ &&
                (parentArgType === 'plural' || parentArgType === 'selectordinal')) ||
            (ch === 125 /* `}` */ && nestingLevel > 0)) {
            return null;
        }
        else {
            this.bump();
            return fromCodePoint(ch);
        }
    };
    Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {
        var openingBracePosition = this.clonePosition();
        this.bump(); // `{`
        this.bumpSpace();
        if (this.isEOF()) {
            return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
        }
        if (this.char() === 125 /* `}` */) {
            this.bump();
            return this.error(error_1.ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
        }
        // argument name
        var value = this.parseIdentifierIfPossible().value;
        if (!value) {
            return this.error(error_1.ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
        }
        this.bumpSpace();
        if (this.isEOF()) {
            return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
        }
        switch (this.char()) {
            // Simple argument: `{name}`
            case 125 /* `}` */: {
                this.bump(); // `}`
                return {
                    val: {
                        type: types_1.TYPE.argument,
                        // value does not include the opening and closing braces.
                        value: value,
                        location: createLocation(openingBracePosition, this.clonePosition()),
                    },
                    err: null,
                };
            }
            // Argument with options: `{name, format, ...}`
            case 44 /* `,` */: {
                this.bump(); // `,`
                this.bumpSpace();
                if (this.isEOF()) {
                    return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
                }
                return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);
            }
            default:
                return this.error(error_1.ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
        }
    };
    /**
     * Advance the parser until the end of the identifier, if it is currently on
     * an identifier character. Return an empty string otherwise.
     */
    Parser.prototype.parseIdentifierIfPossible = function () {
        var startingPosition = this.clonePosition();
        var startOffset = this.offset();
        var value = matchIdentifierAtIndex(this.message, startOffset);
        var endOffset = startOffset + value.length;
        this.bumpTo(endOffset);
        var endPosition = this.clonePosition();
        var location = createLocation(startingPosition, endPosition);
        return { value: value, location: location };
    };
    Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {
        var _a;
        // Parse this range:
        // {name, type, style}
        //        ^---^
        var typeStartPosition = this.clonePosition();
        var argType = this.parseIdentifierIfPossible().value;
        var typeEndPosition = this.clonePosition();
        switch (argType) {
            case '':
                // Expecting a style string number, date, time, plural, selectordinal, or select.
                return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
            case 'number':
            case 'date':
            case 'time': {
                // Parse this range:
                // {name, number, style}
                //              ^-------^
                this.bumpSpace();
                var styleAndLocation = null;
                if (this.bumpIf(',')) {
                    this.bumpSpace();
                    var styleStartPosition = this.clonePosition();
                    var result = this.parseSimpleArgStyleIfPossible();
                    if (result.err) {
                        return result;
                    }
                    var style = trimEnd(result.val);
                    if (style.length === 0) {
                        return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
                    }
                    var styleLocation = createLocation(styleStartPosition, this.clonePosition());
                    styleAndLocation = { style: style, styleLocation: styleLocation };
                }
                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
                if (argCloseResult.err) {
                    return argCloseResult;
                }
                var location_1 = createLocation(openingBracePosition, this.clonePosition());
                // Extract style or skeleton
                if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {
                    // Skeleton starts with `::`.
                    var skeleton = trimStart(styleAndLocation.style.slice(2));
                    if (argType === 'number') {
                        var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
                        if (result.err) {
                            return result;
                        }
                        return {
                            val: { type: types_1.TYPE.number, value: value, location: location_1, style: result.val },
                            err: null,
                        };
                    }
                    else {
                        if (skeleton.length === 0) {
                            return this.error(error_1.ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);
                        }
                        var dateTimePattern = skeleton;
                        // Get "best match" pattern only if locale is passed, if not, let it
                        // pass as-is where `parseDateTimeSkeleton()` will throw an error
                        // for unsupported patterns.
                        if (this.locale) {
                            dateTimePattern = (0, date_time_pattern_generator_1.getBestPattern)(skeleton, this.locale);
                        }
                        var style = {
                            type: types_1.SKELETON_TYPE.dateTime,
                            pattern: dateTimePattern,
                            location: styleAndLocation.styleLocation,
                            parsedOptions: this.shouldParseSkeletons
                                ? (0, icu_skeleton_parser_1.parseDateTimeSkeleton)(dateTimePattern)
                                : {},
                        };
                        var type = argType === 'date' ? types_1.TYPE.date : types_1.TYPE.time;
                        return {
                            val: { type: type, value: value, location: location_1, style: style },
                            err: null,
                        };
                    }
                }
                // Regular style or no style.
                return {
                    val: {
                        type: argType === 'number'
                            ? types_1.TYPE.number
                            : argType === 'date'
                                ? types_1.TYPE.date
                                : types_1.TYPE.time,
                        value: value,
                        location: location_1,
                        style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null,
                    },
                    err: null,
                };
            }
            case 'plural':
            case 'selectordinal':
            case 'select': {
                // Parse this range:
                // {name, plural, options}
                //              ^---------^
                var typeEndPosition_1 = this.clonePosition();
                this.bumpSpace();
                if (!this.bumpIf(',')) {
                    return this.error(error_1.ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, tslib_1.__assign({}, typeEndPosition_1)));
                }
                this.bumpSpace();
                // Parse offset:
                // {name, plural, offset:1, options}
                //                ^-----^
                //
                // or the first option:
                //
                // {name, plural, one {...} other {...}}
                //                ^--^
                var identifierAndLocation = this.parseIdentifierIfPossible();
                var pluralOffset = 0;
                if (argType !== 'select' && identifierAndLocation.value === 'offset') {
                    if (!this.bumpIf(':')) {
                        return this.error(error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
                    }
                    this.bumpSpace();
                    var result = this.tryParseDecimalInteger(error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, error_1.ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
                    if (result.err) {
                        return result;
                    }
                    // Parse another identifier for option parsing
                    this.bumpSpace();
                    identifierAndLocation = this.parseIdentifierIfPossible();
                    pluralOffset = result.val;
                }
                var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
                if (optionsResult.err) {
                    return optionsResult;
                }
                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
                if (argCloseResult.err) {
                    return argCloseResult;
                }
                var location_2 = createLocation(openingBracePosition, this.clonePosition());
                if (argType === 'select') {
                    return {
                        val: {
                            type: types_1.TYPE.select,
                            value: value,
                            options: fromEntries(optionsResult.val),
                            location: location_2,
                        },
                        err: null,
                    };
                }
                else {
                    return {
                        val: {
                            type: types_1.TYPE.plural,
                            value: value,
                            options: fromEntries(optionsResult.val),
                            offset: pluralOffset,
                            pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',
                            location: location_2,
                        },
                        err: null,
                    };
                }
            }
            default:
                return this.error(error_1.ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
        }
    };
    Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {
        // Parse: {value, number, ::currency/GBP }
        //
        if (this.isEOF() || this.char() !== 125 /* `}` */) {
            return this.error(error_1.ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
        }
        this.bump(); // `}`
        return { val: true, err: null };
    };
    /**
     * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659
     */
    Parser.prototype.parseSimpleArgStyleIfPossible = function () {
        var nestedBraces = 0;
        var startPosition = this.clonePosition();
        while (!this.isEOF()) {
            var ch = this.char();
            switch (ch) {
                case 39 /* `'` */: {
                    // Treat apostrophe as quoting but include it in the style part.
                    // Find the end of the quoted literal text.
                    this.bump();
                    var apostrophePosition = this.clonePosition();
                    if (!this.bumpUntil("'")) {
                        return this.error(error_1.ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
                    }
                    this.bump();
                    break;
                }
                case 123 /* `{` */: {
                    nestedBraces += 1;
                    this.bump();
                    break;
                }
                case 125 /* `}` */: {
                    if (nestedBraces > 0) {
                        nestedBraces -= 1;
                    }
                    else {
                        return {
                            val: this.message.slice(startPosition.offset, this.offset()),
                            err: null,
                        };
                    }
                    break;
                }
                default:
                    this.bump();
                    break;
            }
        }
        return {
            val: this.message.slice(startPosition.offset, this.offset()),
            err: null,
        };
    };
    Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {
        var tokens = [];
        try {
            tokens = (0, icu_skeleton_parser_1.parseNumberSkeletonFromString)(skeleton);
        }
        catch (e) {
            return this.error(error_1.ErrorKind.INVALID_NUMBER_SKELETON, location);
        }
        return {
            val: {
                type: types_1.SKELETON_TYPE.number,
                tokens: tokens,
                location: location,
                parsedOptions: this.shouldParseSkeletons
                    ? (0, icu_skeleton_parser_1.parseNumberSkeleton)(tokens)
                    : {},
            },
            err: null,
        };
    };
    /**
     * @param nesting_level The current nesting level of messages.
     *     This can be positive when parsing message fragment in select or plural argument options.
     * @param parent_arg_type The parent argument's type.
     * @param parsed_first_identifier If provided, this is the first identifier-like selector of
     *     the argument. It is a by-product of a previous parsing attempt.
     * @param expecting_close_tag If true, this message is directly or indirectly nested inside
     *     between a pair of opening and closing tags. The nested message will not parse beyond
     *     the closing tag boundary.
     */
    Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
        var _a;
        var hasOtherClause = false;
        var options = [];
        var parsedSelectors = new Set();
        var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;
        // Parse:
        // one {one apple}
        // ^--^
        while (true) {
            if (selector.length === 0) {
                var startPosition = this.clonePosition();
                if (parentArgType !== 'select' && this.bumpIf('=')) {
                    // Try parse `={number}` selector
                    var result = this.tryParseDecimalInteger(error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, error_1.ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
                    if (result.err) {
                        return result;
                    }
                    selectorLocation = createLocation(startPosition, this.clonePosition());
                    selector = this.message.slice(startPosition.offset, this.offset());
                }
                else {
                    break;
                }
            }
            // Duplicate selector clauses
            if (parsedSelectors.has(selector)) {
                return this.error(parentArgType === 'select'
                    ? error_1.ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR
                    : error_1.ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
            }
            if (selector === 'other') {
                hasOtherClause = true;
            }
            // Parse:
            // one {one apple}
            //     ^----------^
            this.bumpSpace();
            var openingBracePosition = this.clonePosition();
            if (!this.bumpIf('{')) {
                return this.error(parentArgType === 'select'
                    ? error_1.ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT
                    : error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
            }
            var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
            if (fragmentResult.err) {
                return fragmentResult;
            }
            var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
            if (argCloseResult.err) {
                return argCloseResult;
            }
            options.push([
                selector,
                {
                    value: fragmentResult.val,
                    location: createLocation(openingBracePosition, this.clonePosition()),
                },
            ]);
            // Keep track of the existing selectors
            parsedSelectors.add(selector);
            // Prep next selector clause.
            this.bumpSpace();
            (_a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location);
        }
        if (options.length === 0) {
            return this.error(parentArgType === 'select'
                ? error_1.ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR
                : error_1.ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
        }
        if (this.requiresOtherClause && !hasOtherClause) {
            return this.error(error_1.ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
        }
        return { val: options, err: null };
    };
    Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {
        var sign = 1;
        var startingPosition = this.clonePosition();
        if (this.bumpIf('+')) {
        }
        else if (this.bumpIf('-')) {
            sign = -1;
        }
        var hasDigits = false;
        var decimal = 0;
        while (!this.isEOF()) {
            var ch = this.char();
            if (ch >= 48 /* `0` */ && ch <= 57 /* `9` */) {
                hasDigits = true;
                decimal = decimal * 10 + (ch - 48);
                this.bump();
            }
            else {
                break;
            }
        }
        var location = createLocation(startingPosition, this.clonePosition());
        if (!hasDigits) {
            return this.error(expectNumberError, location);
        }
        decimal *= sign;
        if (!isSafeInteger(decimal)) {
            return this.error(invalidNumberError, location);
        }
        return { val: decimal, err: null };
    };
    Parser.prototype.offset = function () {
        return this.position.offset;
    };
    Parser.prototype.isEOF = function () {
        return this.offset() === this.message.length;
    };
    Parser.prototype.clonePosition = function () {
        // This is much faster than `Object.assign` or spread.
        return {
            offset: this.position.offset,
            line: this.position.line,
            column: this.position.column,
        };
    };
    /**
     * Return the code point at the current position of the parser.
     * Throws if the index is out of bound.
     */
    Parser.prototype.char = function () {
        var offset = this.position.offset;
        if (offset >= this.message.length) {
            throw Error('out of bound');
        }
        var code = codePointAt(this.message, offset);
        if (code === undefined) {
            throw Error("Offset ".concat(offset, " is at invalid UTF-16 code unit boundary"));
        }
        return code;
    };
    Parser.prototype.error = function (kind, location) {
        return {
            val: null,
            err: {
                kind: kind,
                message: this.message,
                location: location,
            },
        };
    };
    /** Bump the parser to the next UTF-16 code unit. */
    Parser.prototype.bump = function () {
        if (this.isEOF()) {
            return;
        }
        var code = this.char();
        if (code === 10 /* '\n' */) {
            this.position.line += 1;
            this.position.column = 1;
            this.position.offset += 1;
        }
        else {
            this.position.column += 1;
            // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.
            this.position.offset += code < 0x10000 ? 1 : 2;
        }
    };
    /**
     * If the substring starting at the current position of the parser has
     * the given prefix, then bump the parser to the character immediately
     * following the prefix and return true. Otherwise, don't bump the parser
     * and return false.
     */
    Parser.prototype.bumpIf = function (prefix) {
        if (startsWith(this.message, prefix, this.offset())) {
            for (var i = 0; i < prefix.length; i++) {
                this.bump();
            }
            return true;
        }
        return false;
    };
    /**
     * Bump the parser until the pattern character is found and return `true`.
     * Otherwise bump to the end of the file and return `false`.
     */
    Parser.prototype.bumpUntil = function (pattern) {
        var currentOffset = this.offset();
        var index = this.message.indexOf(pattern, currentOffset);
        if (index >= 0) {
            this.bumpTo(index);
            return true;
        }
        else {
            this.bumpTo(this.message.length);
            return false;
        }
    };
    /**
     * Bump the parser to the target offset.
     * If target offset is beyond the end of the input, bump the parser to the end of the input.
     */
    Parser.prototype.bumpTo = function (targetOffset) {
        if (this.offset() > targetOffset) {
            throw Error("targetOffset ".concat(targetOffset, " must be greater than or equal to the current offset ").concat(this.offset()));
        }
        targetOffset = Math.min(targetOffset, this.message.length);
        while (true) {
            var offset = this.offset();
            if (offset === targetOffset) {
                break;
            }
            if (offset > targetOffset) {
                throw Error("targetOffset ".concat(targetOffset, " is at invalid UTF-16 code unit boundary"));
            }
            this.bump();
            if (this.isEOF()) {
                break;
            }
        }
    };
    /** advance the parser through all whitespace to the next non-whitespace code unit. */
    Parser.prototype.bumpSpace = function () {
        while (!this.isEOF() && _isWhiteSpace(this.char())) {
            this.bump();
        }
    };
    /**
     * Peek at the *next* Unicode codepoint in the input without advancing the parser.
     * If the input has been exhausted, then this returns null.
     */
    Parser.prototype.peek = function () {
        if (this.isEOF()) {
            return null;
        }
        var code = this.char();
        var offset = this.offset();
        var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));
        return nextCode !== null && nextCode !== void 0 ? nextCode : null;
    };
    return Parser;
}());
exports.Parser = Parser;
/**
 * This check if codepoint is alphabet (lower & uppercase)
 * @param codepoint
 * @returns
 */
function _isAlpha(codepoint) {
    return ((codepoint >= 97 && codepoint <= 122) ||
        (codepoint >= 65 && codepoint <= 90));
}
function _isAlphaOrSlash(codepoint) {
    return _isAlpha(codepoint) || codepoint === 47; /* '/' */
}
/** See `parseTag` function docs. */
function _isPotentialElementNameChar(c) {
    return (c === 45 /* '-' */ ||
        c === 46 /* '.' */ ||
        (c >= 48 && c <= 57) /* 0..9 */ ||
        c === 95 /* '_' */ ||
        (c >= 97 && c <= 122) /** a..z */ ||
        (c >= 65 && c <= 90) /* A..Z */ ||
        c == 0xb7 ||
        (c >= 0xc0 && c <= 0xd6) ||
        (c >= 0xd8 && c <= 0xf6) ||
        (c >= 0xf8 && c <= 0x37d) ||
        (c >= 0x37f && c <= 0x1fff) ||
        (c >= 0x200c && c <= 0x200d) ||
        (c >= 0x203f && c <= 0x2040) ||
        (c >= 0x2070 && c <= 0x218f) ||
        (c >= 0x2c00 && c <= 0x2fef) ||
        (c >= 0x3001 && c <= 0xd7ff) ||
        (c >= 0xf900 && c <= 0xfdcf) ||
        (c >= 0xfdf0 && c <= 0xfffd) ||
        (c >= 0x10000 && c <= 0xeffff));
}
/**
 * Code point equivalent of regex `\p{White_Space}`.
 * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt
 */
function _isWhiteSpace(c) {
    return ((c >= 0x0009 && c <= 0x000d) ||
        c === 0x0020 ||
        c === 0x0085 ||
        (c >= 0x200e && c <= 0x200f) ||
        c === 0x2028 ||
        c === 0x2029);
}
/**
 * Code point equivalent of regex `\p{Pattern_Syntax}`.
 * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt
 */
function _isPatternSyntax(c) {
    return ((c >= 0x0021 && c <= 0x0023) ||
        c === 0x0024 ||
        (c >= 0x0025 && c <= 0x0027) ||
        c === 0x0028 ||
        c === 0x0029 ||
        c === 0x002a ||
        c === 0x002b ||
        c === 0x002c ||
        c === 0x002d ||
        (c >= 0x002e && c <= 0x002f) ||
        (c >= 0x003a && c <= 0x003b) ||
        (c >= 0x003c && c <= 0x003e) ||
        (c >= 0x003f && c <= 0x0040) ||
        c === 0x005b ||
        c === 0x005c ||
        c === 0x005d ||
        c === 0x005e ||
        c === 0x0060 ||
        c === 0x007b ||
        c === 0x007c ||
        c === 0x007d ||
        c === 0x007e ||
        c === 0x00a1 ||
        (c >= 0x00a2 && c <= 0x00a5) ||
        c === 0x00a6 ||
        c === 0x00a7 ||
        c === 0x00a9 ||
        c === 0x00ab ||
        c === 0x00ac ||
        c === 0x00ae ||
        c === 0x00b0 ||
        c === 0x00b1 ||
        c === 0x00b6 ||
        c === 0x00bb ||
        c === 0x00bf ||
        c === 0x00d7 ||
        c === 0x00f7 ||
        (c >= 0x2010 && c <= 0x2015) ||
        (c >= 0x2016 && c <= 0x2017) ||
        c === 0x2018 ||
        c === 0x2019 ||
        c === 0x201a ||
        (c >= 0x201b && c <= 0x201c) ||
        c === 0x201d ||
        c === 0x201e ||
        c === 0x201f ||
        (c >= 0x2020 && c <= 0x2027) ||
        (c >= 0x2030 && c <= 0x2038) ||
        c === 0x2039 ||
        c === 0x203a ||
        (c >= 0x203b && c <= 0x203e) ||
        (c >= 0x2041 && c <= 0x2043) ||
        c === 0x2044 ||
        c === 0x2045 ||
        c === 0x2046 ||
        (c >= 0x2047 && c <= 0x2051) ||
        c === 0x2052 ||
        c === 0x2053 ||
        (c >= 0x2055 && c <= 0x205e) ||
        (c >= 0x2190 && c <= 0x2194) ||
        (c >= 0x2195 && c <= 0x2199) ||
        (c >= 0x219a && c <= 0x219b) ||
        (c >= 0x219c && c <= 0x219f) ||
        c === 0x21a0 ||
        (c >= 0x21a1 && c <= 0x21a2) ||
        c === 0x21a3 ||
        (c >= 0x21a4 && c <= 0x21a5) ||
        c === 0x21a6 ||
        (c >= 0x21a7 && c <= 0x21ad) ||
        c === 0x21ae ||
        (c >= 0x21af && c <= 0x21cd) ||
        (c >= 0x21ce && c <= 0x21cf) ||
        (c >= 0x21d0 && c <= 0x21d1) ||
        c === 0x21d2 ||
        c === 0x21d3 ||
        c === 0x21d4 ||
        (c >= 0x21d5 && c <= 0x21f3) ||
        (c >= 0x21f4 && c <= 0x22ff) ||
        (c >= 0x2300 && c <= 0x2307) ||
        c === 0x2308 ||
        c === 0x2309 ||
        c === 0x230a ||
        c === 0x230b ||
        (c >= 0x230c && c <= 0x231f) ||
        (c >= 0x2320 && c <= 0x2321) ||
        (c >= 0x2322 && c <= 0x2328) ||
        c === 0x2329 ||
        c === 0x232a ||
        (c >= 0x232b && c <= 0x237b) ||
        c === 0x237c ||
        (c >= 0x237d && c <= 0x239a) ||
        (c >= 0x239b && c <= 0x23b3) ||
        (c >= 0x23b4 && c <= 0x23db) ||
        (c >= 0x23dc && c <= 0x23e1) ||
        (c >= 0x23e2 && c <= 0x2426) ||
        (c >= 0x2427 && c <= 0x243f) ||
        (c >= 0x2440 && c <= 0x244a) ||
        (c >= 0x244b && c <= 0x245f) ||
        (c >= 0x2500 && c <= 0x25b6) ||
        c === 0x25b7 ||
        (c >= 0x25b8 && c <= 0x25c0) ||
        c === 0x25c1 ||
        (c >= 0x25c2 && c <= 0x25f7) ||
        (c >= 0x25f8 && c <= 0x25ff) ||
        (c >= 0x2600 && c <= 0x266e) ||
        c === 0x266f ||
        (c >= 0x2670 && c <= 0x2767) ||
        c === 0x2768 ||
        c === 0x2769 ||
        c === 0x276a ||
        c === 0x276b ||
        c === 0x276c ||
        c === 0x276d ||
        c === 0x276e ||
        c === 0x276f ||
        c === 0x2770 ||
        c === 0x2771 ||
        c === 0x2772 ||
        c === 0x2773 ||
        c === 0x2774 ||
        c === 0x2775 ||
        (c >= 0x2794 && c <= 0x27bf) ||
        (c >= 0x27c0 && c <= 0x27c4) ||
        c === 0x27c5 ||
        c === 0x27c6 ||
        (c >= 0x27c7 && c <= 0x27e5) ||
        c === 0x27e6 ||
        c === 0x27e7 ||
        c === 0x27e8 ||
        c === 0x27e9 ||
        c === 0x27ea ||
        c === 0x27eb ||
        c === 0x27ec ||
        c === 0x27ed ||
        c === 0x27ee ||
        c === 0x27ef ||
        (c >= 0x27f0 && c <= 0x27ff) ||
        (c >= 0x2800 && c <= 0x28ff) ||
        (c >= 0x2900 && c <= 0x2982) ||
        c === 0x2983 ||
        c === 0x2984 ||
        c === 0x2985 ||
        c === 0x2986 ||
        c === 0x2987 ||
        c === 0x2988 ||
        c === 0x2989 ||
        c === 0x298a ||
        c === 0x298b ||
        c === 0x298c ||
        c === 0x298d ||
        c === 0x298e ||
        c === 0x298f ||
        c === 0x2990 ||
        c === 0x2991 ||
        c === 0x2992 ||
        c === 0x2993 ||
        c === 0x2994 ||
        c === 0x2995 ||
        c === 0x2996 ||
        c === 0x2997 ||
        c === 0x2998 ||
        (c >= 0x2999 && c <= 0x29d7) ||
        c === 0x29d8 ||
        c === 0x29d9 ||
        c === 0x29da ||
        c === 0x29db ||
        (c >= 0x29dc && c <= 0x29fb) ||
        c === 0x29fc ||
        c === 0x29fd ||
        (c >= 0x29fe && c <= 0x2aff) ||
        (c >= 0x2b00 && c <= 0x2b2f) ||
        (c >= 0x2b30 && c <= 0x2b44) ||
        (c >= 0x2b45 && c <= 0x2b46) ||
        (c >= 0x2b47 && c <= 0x2b4c) ||
        (c >= 0x2b4d && c <= 0x2b73) ||
        (c >= 0x2b74 && c <= 0x2b75) ||
        (c >= 0x2b76 && c <= 0x2b95) ||
        c === 0x2b96 ||
        (c >= 0x2b97 && c <= 0x2bff) ||
        (c >= 0x2e00 && c <= 0x2e01) ||
        c === 0x2e02 ||
        c === 0x2e03 ||
        c === 0x2e04 ||
        c === 0x2e05 ||
        (c >= 0x2e06 && c <= 0x2e08) ||
        c === 0x2e09 ||
        c === 0x2e0a ||
        c === 0x2e0b ||
        c === 0x2e0c ||
        c === 0x2e0d ||
        (c >= 0x2e0e && c <= 0x2e16) ||
        c === 0x2e17 ||
        (c >= 0x2e18 && c <= 0x2e19) ||
        c === 0x2e1a ||
        c === 0x2e1b ||
        c === 0x2e1c ||
        c === 0x2e1d ||
        (c >= 0x2e1e && c <= 0x2e1f) ||
        c === 0x2e20 ||
        c === 0x2e21 ||
        c === 0x2e22 ||
        c === 0x2e23 ||
        c === 0x2e24 ||
        c === 0x2e25 ||
        c === 0x2e26 ||
        c === 0x2e27 ||
        c === 0x2e28 ||
        c === 0x2e29 ||
        (c >= 0x2e2a && c <= 0x2e2e) ||
        c === 0x2e2f ||
        (c >= 0x2e30 && c <= 0x2e39) ||
        (c >= 0x2e3a && c <= 0x2e3b) ||
        (c >= 0x2e3c && c <= 0x2e3f) ||
        c === 0x2e40 ||
        c === 0x2e41 ||
        c === 0x2e42 ||
        (c >= 0x2e43 && c <= 0x2e4f) ||
        (c >= 0x2e50 && c <= 0x2e51) ||
        c === 0x2e52 ||
        (c >= 0x2e53 && c <= 0x2e7f) ||
        (c >= 0x3001 && c <= 0x3003) ||
        c === 0x3008 ||
        c === 0x3009 ||
        c === 0x300a ||
        c === 0x300b ||
        c === 0x300c ||
        c === 0x300d ||
        c === 0x300e ||
        c === 0x300f ||
        c === 0x3010 ||
        c === 0x3011 ||
        (c >= 0x3012 && c <= 0x3013) ||
        c === 0x3014 ||
        c === 0x3015 ||
        c === 0x3016 ||
        c === 0x3017 ||
        c === 0x3018 ||
        c === 0x3019 ||
        c === 0x301a ||
        c === 0x301b ||
        c === 0x301c ||
        c === 0x301d ||
        (c >= 0x301e && c <= 0x301f) ||
        c === 0x3020 ||
        c === 0x3030 ||
        c === 0xfd3e ||
        c === 0xfd3f ||
        (c >= 0xfe45 && c <= 0xfe46));
}


/***/ }),

/***/ 42290:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WHITE_SPACE_REGEX = exports.SPACE_SEPARATOR_REGEX = void 0;
// @generated from regex-gen.ts
exports.SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;
exports.WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/;


/***/ }),

/***/ 66593:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.timeData = void 0;
// @generated from time-data-gen.ts
// prettier-ignore  
exports.timeData = {
    "001": [
        "H",
        "h"
    ],
    "AC": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "AD": [
        "H",
        "hB"
    ],
    "AE": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "AF": [
        "H",
        "hb",
        "hB",
        "h"
    ],
    "AG": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "AI": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "AL": [
        "h",
        "H",
        "hB"
    ],
    "AM": [
        "H",
        "hB"
    ],
    "AO": [
        "H",
        "hB"
    ],
    "AR": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "AS": [
        "h",
        "H"
    ],
    "AT": [
        "H",
        "hB"
    ],
    "AU": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "AW": [
        "H",
        "hB"
    ],
    "AX": [
        "H"
    ],
    "AZ": [
        "H",
        "hB",
        "h"
    ],
    "BA": [
        "H",
        "hB",
        "h"
    ],
    "BB": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "BD": [
        "h",
        "hB",
        "H"
    ],
    "BE": [
        "H",
        "hB"
    ],
    "BF": [
        "H",
        "hB"
    ],
    "BG": [
        "H",
        "hB",
        "h"
    ],
    "BH": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "BJ": [
        "H",
        "hB"
    ],
    "BL": [
        "H",
        "hB"
    ],
    "BM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "BN": [
        "hb",
        "hB",
        "h",
        "H"
    ],
    "BO": [
        "H",
        "hB",
        "h",
        "hb"
    ],
    "BQ": [
        "H"
    ],
    "BR": [
        "H",
        "hB"
    ],
    "BS": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "BT": [
        "h",
        "H"
    ],
    "BW": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "BZ": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "CA": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "CC": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "CD": [
        "hB",
        "H"
    ],
    "CF": [
        "H",
        "h",
        "hB"
    ],
    "CG": [
        "H",
        "hB"
    ],
    "CH": [
        "H",
        "hB",
        "h"
    ],
    "CI": [
        "H",
        "hB"
    ],
    "CK": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "CL": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "CM": [
        "H",
        "h",
        "hB"
    ],
    "CN": [
        "H",
        "hB",
        "hb",
        "h"
    ],
    "CO": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "CP": [
        "H"
    ],
    "CR": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "CU": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "CV": [
        "H",
        "hB"
    ],
    "CX": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "CY": [
        "h",
        "H",
        "hb",
        "hB"
    ],
    "CZ": [
        "H"
    ],
    "DE": [
        "H",
        "hB"
    ],
    "DG": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "DJ": [
        "h",
        "H"
    ],
    "DK": [
        "H"
    ],
    "DM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "DO": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "DZ": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "EA": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "EC": [
        "H",
        "hB",
        "h",
        "hb"
    ],
    "EE": [
        "H",
        "hB"
    ],
    "EG": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "EH": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "ER": [
        "h",
        "H"
    ],
    "ES": [
        "H",
        "hB",
        "h",
        "hb"
    ],
    "ET": [
        "hB",
        "hb",
        "h",
        "H"
    ],
    "FI": [
        "H"
    ],
    "FJ": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "FK": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "FM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "FR": [
        "H",
        "hB"
    ],
    "GA": [
        "H",
        "hB"
    ],
    "GB": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "GD": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "GE": [
        "H",
        "hB",
        "h"
    ],
    "GF": [
        "H",
        "hB"
    ],
    "GG": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "GH": [
        "h",
        "H"
    ],
    "GI": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "GM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "GN": [
        "H",
        "hB"
    ],
    "GP": [
        "H",
        "hB"
    ],
    "GQ": [
        "H",
        "hB",
        "h",
        "hb"
    ],
    "GR": [
        "h",
        "H",
        "hb",
        "hB"
    ],
    "GT": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "GU": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "GW": [
        "H",
        "hB"
    ],
    "GY": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "HK": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "HN": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "HR": [
        "H",
        "hB"
    ],
    "IC": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "ID": [
        "H"
    ],
    "IE": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "IL": [
        "H",
        "hB"
    ],
    "IM": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "IN": [
        "h",
        "H"
    ],
    "IO": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "IQ": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "IR": [
        "hB",
        "H"
    ],
    "IS": [
        "H"
    ],
    "IT": [
        "H",
        "hB"
    ],
    "JE": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "JM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "JO": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "JP": [
        "H",
        "h",
        "K"
    ],
    "KE": [
        "hB",
        "hb",
        "H",
        "h"
    ],
    "KG": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "KH": [
        "hB",
        "h",
        "H",
        "hb"
    ],
    "KI": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "KM": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "KN": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "KP": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "KR": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "KW": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "KY": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "KZ": [
        "H",
        "hB"
    ],
    "LA": [
        "H",
        "hb",
        "hB",
        "h"
    ],
    "LB": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "LC": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "LI": [
        "H",
        "hB",
        "h"
    ],
    "LK": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "LR": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "LS": [
        "h",
        "H"
    ],
    "LT": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "LU": [
        "H",
        "h",
        "hB"
    ],
    "LV": [
        "H",
        "hB",
        "hb",
        "h"
    ],
    "LY": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "MA": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "MC": [
        "H",
        "hB"
    ],
    "MD": [
        "H",
        "hB"
    ],
    "ME": [
        "H",
        "hB",
        "h"
    ],
    "MF": [
        "H",
        "hB"
    ],
    "MH": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "MK": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "ML": [
        "H"
    ],
    "MM": [
        "hB",
        "hb",
        "H",
        "h"
    ],
    "MN": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "MO": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "MP": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "MQ": [
        "H",
        "hB"
    ],
    "MR": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "MS": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "MW": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "MX": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "MY": [
        "hb",
        "hB",
        "h",
        "H"
    ],
    "MZ": [
        "H",
        "hB"
    ],
    "NA": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "NC": [
        "H",
        "hB"
    ],
    "NE": [
        "H"
    ],
    "NF": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "NG": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "NI": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "NL": [
        "H",
        "hB"
    ],
    "NP": [
        "H",
        "h",
        "hB"
    ],
    "NR": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "NU": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "NZ": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "OM": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "PA": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "PE": [
        "H",
        "hB",
        "h",
        "hb"
    ],
    "PF": [
        "H",
        "h",
        "hB"
    ],
    "PG": [
        "h",
        "H"
    ],
    "PH": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "PK": [
        "h",
        "hB",
        "H"
    ],
    "PM": [
        "H",
        "hB"
    ],
    "PN": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "PR": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "PS": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "PT": [
        "H",
        "hB"
    ],
    "PW": [
        "h",
        "H"
    ],
    "PY": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "QA": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "RE": [
        "H",
        "hB"
    ],
    "RO": [
        "H",
        "hB"
    ],
    "RS": [
        "H",
        "hB",
        "h"
    ],
    "RU": [
        "H"
    ],
    "SA": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "SB": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "SC": [
        "H",
        "h",
        "hB"
    ],
    "SD": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "SE": [
        "H"
    ],
    "SG": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "SH": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "SI": [
        "H",
        "hB"
    ],
    "SJ": [
        "H"
    ],
    "SK": [
        "H"
    ],
    "SL": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "SM": [
        "H",
        "h",
        "hB"
    ],
    "SN": [
        "H",
        "h",
        "hB"
    ],
    "SO": [
        "h",
        "H"
    ],
    "SR": [
        "H",
        "hB"
    ],
    "SS": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "ST": [
        "H",
        "hB"
    ],
    "SV": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "SX": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "SY": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "SZ": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "TA": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "TC": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "TD": [
        "h",
        "H",
        "hB"
    ],
    "TF": [
        "H",
        "h",
        "hB"
    ],
    "TG": [
        "H",
        "hB"
    ],
    "TL": [
        "H",
        "hB",
        "hb",
        "h"
    ],
    "TN": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "TO": [
        "h",
        "H"
    ],
    "TR": [
        "H",
        "hB"
    ],
    "TT": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "TW": [
        "hB",
        "hb",
        "h",
        "H"
    ],
    "TZ": [
        "hB",
        "hb",
        "H",
        "h"
    ],
    "UA": [
        "H",
        "hB",
        "h"
    ],
    "UG": [
        "hB",
        "hb",
        "H",
        "h"
    ],
    "UM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "US": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "UY": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "UZ": [
        "H",
        "hB",
        "h"
    ],
    "VA": [
        "H",
        "h",
        "hB"
    ],
    "VC": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "VE": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "VG": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "VI": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "VU": [
        "h",
        "H"
    ],
    "WF": [
        "H",
        "hB"
    ],
    "WS": [
        "h",
        "H"
    ],
    "XK": [
        "H",
        "hB",
        "h"
    ],
    "YE": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "YT": [
        "H",
        "hB"
    ],
    "ZA": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "ZM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "af-ZA": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "ar-001": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "ca-ES": [
        "H",
        "h",
        "hB"
    ],
    "en-001": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "es-BO": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "es-BR": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "es-EC": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "es-ES": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "es-GQ": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "es-PE": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "fr-CA": [
        "H",
        "h",
        "hB"
    ],
    "gl-ES": [
        "H",
        "h",
        "hB"
    ],
    "gu-IN": [
        "hB",
        "hb",
        "h",
        "H"
    ],
    "hi-IN": [
        "hB",
        "h",
        "H"
    ],
    "it-CH": [
        "H",
        "h",
        "hB"
    ],
    "it-IT": [
        "H",
        "h",
        "hB"
    ],
    "kn-IN": [
        "hB",
        "h",
        "H"
    ],
    "ml-IN": [
        "hB",
        "h",
        "H"
    ],
    "mr-IN": [
        "hB",
        "hb",
        "h",
        "H"
    ],
    "pa-IN": [
        "hB",
        "hb",
        "h",
        "H"
    ],
    "ta-IN": [
        "hB",
        "h",
        "hb",
        "H"
    ],
    "te-IN": [
        "hB",
        "h",
        "H"
    ],
    "zu-ZA": [
        "H",
        "hB",
        "hb",
        "h"
    ]
};


/***/ }),

/***/ 5497:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createNumberElement = exports.createLiteralElement = exports.isDateTimeSkeleton = exports.isNumberSkeleton = exports.isTagElement = exports.isPoundElement = exports.isPluralElement = exports.isSelectElement = exports.isTimeElement = exports.isDateElement = exports.isNumberElement = exports.isArgumentElement = exports.isLiteralElement = exports.SKELETON_TYPE = exports.TYPE = void 0;
var TYPE;
(function (TYPE) {
    /**
     * Raw text
     */
    TYPE[TYPE["literal"] = 0] = "literal";
    /**
     * Variable w/o any format, e.g `var` in `this is a {var}`
     */
    TYPE[TYPE["argument"] = 1] = "argument";
    /**
     * Variable w/ number format
     */
    TYPE[TYPE["number"] = 2] = "number";
    /**
     * Variable w/ date format
     */
    TYPE[TYPE["date"] = 3] = "date";
    /**
     * Variable w/ time format
     */
    TYPE[TYPE["time"] = 4] = "time";
    /**
     * Variable w/ select format
     */
    TYPE[TYPE["select"] = 5] = "select";
    /**
     * Variable w/ plural format
     */
    TYPE[TYPE["plural"] = 6] = "plural";
    /**
     * Only possible within plural argument.
     * This is the `#` symbol that will be substituted with the count.
     */
    TYPE[TYPE["pound"] = 7] = "pound";
    /**
     * XML-like tag
     */
    TYPE[TYPE["tag"] = 8] = "tag";
})(TYPE = exports.TYPE || (exports.TYPE = {}));
var SKELETON_TYPE;
(function (SKELETON_TYPE) {
    SKELETON_TYPE[SKELETON_TYPE["number"] = 0] = "number";
    SKELETON_TYPE[SKELETON_TYPE["dateTime"] = 1] = "dateTime";
})(SKELETON_TYPE = exports.SKELETON_TYPE || (exports.SKELETON_TYPE = {}));
/**
 * Type Guards
 */
function isLiteralElement(el) {
    return el.type === TYPE.literal;
}
exports.isLiteralElement = isLiteralElement;
function isArgumentElement(el) {
    return el.type === TYPE.argument;
}
exports.isArgumentElement = isArgumentElement;
function isNumberElement(el) {
    return el.type === TYPE.number;
}
exports.isNumberElement = isNumberElement;
function isDateElement(el) {
    return el.type === TYPE.date;
}
exports.isDateElement = isDateElement;
function isTimeElement(el) {
    return el.type === TYPE.time;
}
exports.isTimeElement = isTimeElement;
function isSelectElement(el) {
    return el.type === TYPE.select;
}
exports.isSelectElement = isSelectElement;
function isPluralElement(el) {
    return el.type === TYPE.plural;
}
exports.isPluralElement = isPluralElement;
function isPoundElement(el) {
    return el.type === TYPE.pound;
}
exports.isPoundElement = isPoundElement;
function isTagElement(el) {
    return el.type === TYPE.tag;
}
exports.isTagElement = isTagElement;
function isNumberSkeleton(el) {
    return !!(el && typeof el === 'object' && el.type === SKELETON_TYPE.number);
}
exports.isNumberSkeleton = isNumberSkeleton;
function isDateTimeSkeleton(el) {
    return !!(el && typeof el === 'object' && el.type === SKELETON_TYPE.dateTime);
}
exports.isDateTimeSkeleton = isDateTimeSkeleton;
function createLiteralElement(value) {
    return {
        type: TYPE.literal,
        value: value,
    };
}
exports.createLiteralElement = createLiteralElement;
function createNumberElement(value, style) {
    return {
        type: TYPE.number,
        value: value,
        style: style,
    };
}
exports.createNumberElement = createNumberElement;


/***/ }),

/***/ 66683:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseDateTimeSkeleton = void 0;
/**
 * https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * Credit: https://github.com/caridy/intl-datetimeformat-pattern/blob/master/index.js
 * with some tweaks
 */
var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
/**
 * Parse Date time skeleton into Intl.DateTimeFormatOptions
 * Ref: https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * @public
 * @param skeleton skeleton string
 */
function parseDateTimeSkeleton(skeleton) {
    var result = {};
    skeleton.replace(DATE_TIME_REGEX, function (match) {
        var len = match.length;
        switch (match[0]) {
            // Era
            case 'G':
                result.era = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';
                break;
            // Year
            case 'y':
                result.year = len === 2 ? '2-digit' : 'numeric';
                break;
            case 'Y':
            case 'u':
            case 'U':
            case 'r':
                throw new RangeError('`Y/u/U/r` (year) patterns are not supported, use `y` instead');
            // Quarter
            case 'q':
            case 'Q':
                throw new RangeError('`q/Q` (quarter) patterns are not supported');
            // Month
            case 'M':
            case 'L':
                result.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][len - 1];
                break;
            // Week
            case 'w':
            case 'W':
                throw new RangeError('`w/W` (week) patterns are not supported');
            case 'd':
                result.day = ['numeric', '2-digit'][len - 1];
                break;
            case 'D':
            case 'F':
            case 'g':
                throw new RangeError('`D/F/g` (day) patterns are not supported, use `d` instead');
            // Weekday
            case 'E':
                result.weekday = len === 4 ? 'short' : len === 5 ? 'narrow' : 'short';
                break;
            case 'e':
                if (len < 4) {
                    throw new RangeError('`e..eee` (weekday) patterns are not supported');
                }
                result.weekday = ['short', 'long', 'narrow', 'short'][len - 4];
                break;
            case 'c':
                if (len < 4) {
                    throw new RangeError('`c..ccc` (weekday) patterns are not supported');
                }
                result.weekday = ['short', 'long', 'narrow', 'short'][len - 4];
                break;
            // Period
            case 'a': // AM, PM
                result.hour12 = true;
                break;
            case 'b': // am, pm, noon, midnight
            case 'B': // flexible day periods
                throw new RangeError('`b/B` (period) patterns are not supported, use `a` instead');
            // Hour
            case 'h':
                result.hourCycle = 'h12';
                result.hour = ['numeric', '2-digit'][len - 1];
                break;
            case 'H':
                result.hourCycle = 'h23';
                result.hour = ['numeric', '2-digit'][len - 1];
                break;
            case 'K':
                result.hourCycle = 'h11';
                result.hour = ['numeric', '2-digit'][len - 1];
                break;
            case 'k':
                result.hourCycle = 'h24';
                result.hour = ['numeric', '2-digit'][len - 1];
                break;
            case 'j':
            case 'J':
            case 'C':
                throw new RangeError('`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead');
            // Minute
            case 'm':
                result.minute = ['numeric', '2-digit'][len - 1];
                break;
            // Second
            case 's':
                result.second = ['numeric', '2-digit'][len - 1];
                break;
            case 'S':
            case 'A':
                throw new RangeError('`S/A` (second) patterns are not supported, use `s` instead');
            // Zone
            case 'z': // 1..3, 4: specific non-location format
                result.timeZoneName = len < 4 ? 'short' : 'long';
                break;
            case 'Z': // 1..3, 4, 5: The ISO8601 varios formats
            case 'O': // 1, 4: miliseconds in day short, long
            case 'v': // 1, 4: generic non-location format
            case 'V': // 1, 2, 3, 4: time zone ID or city
            case 'X': // 1, 2, 3, 4: The ISO8601 varios formats
            case 'x': // 1, 2, 3, 4: The ISO8601 varios formats
                throw new RangeError('`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead');
        }
        return '';
    });
    return result;
}
exports.parseDateTimeSkeleton = parseDateTimeSkeleton;


/***/ }),

/***/ 9313:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(61915);
tslib_1.__exportStar(__webpack_require__(66683), exports);
tslib_1.__exportStar(__webpack_require__(52383), exports);


/***/ }),

/***/ 52383:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseNumberSkeleton = exports.parseNumberSkeletonFromString = void 0;
var tslib_1 = __webpack_require__(61915);
var regex_generated_1 = __webpack_require__(85491);
function parseNumberSkeletonFromString(skeleton) {
    if (skeleton.length === 0) {
        throw new Error('Number skeleton cannot be empty');
    }
    // Parse the skeleton
    var stringTokens = skeleton
        .split(regex_generated_1.WHITE_SPACE_REGEX)
        .filter(function (x) { return x.length > 0; });
    var tokens = [];
    for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {
        var stringToken = stringTokens_1[_i];
        var stemAndOptions = stringToken.split('/');
        if (stemAndOptions.length === 0) {
            throw new Error('Invalid number skeleton');
        }
        var stem = stemAndOptions[0], options = stemAndOptions.slice(1);
        for (var _a = 0, options_1 = options; _a < options_1.length; _a++) {
            var option = options_1[_a];
            if (option.length === 0) {
                throw new Error('Invalid number skeleton');
            }
        }
        tokens.push({ stem: stem, options: options });
    }
    return tokens;
}
exports.parseNumberSkeletonFromString = parseNumberSkeletonFromString;
function icuUnitToEcma(unit) {
    return unit.replace(/^(.*?)-/, '');
}
var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
function parseSignificantPrecision(str) {
    var result = {};
    if (str[str.length - 1] === 'r') {
        result.roundingPriority = 'morePrecision';
    }
    else if (str[str.length - 1] === 's') {
        result.roundingPriority = 'lessPrecision';
    }
    str.replace(SIGNIFICANT_PRECISION_REGEX, function (_, g1, g2) {
        // @@@ case
        if (typeof g2 !== 'string') {
            result.minimumSignificantDigits = g1.length;
            result.maximumSignificantDigits = g1.length;
        }
        // @@@+ case
        else if (g2 === '+') {
            result.minimumSignificantDigits = g1.length;
        }
        // .### case
        else if (g1[0] === '#') {
            result.maximumSignificantDigits = g1.length;
        }
        // .@@## or .@@@ case
        else {
            result.minimumSignificantDigits = g1.length;
            result.maximumSignificantDigits =
                g1.length + (typeof g2 === 'string' ? g2.length : 0);
        }
        return '';
    });
    return result;
}
function parseSign(str) {
    switch (str) {
        case 'sign-auto':
            return {
                signDisplay: 'auto',
            };
        case 'sign-accounting':
        case '()':
            return {
                currencySign: 'accounting',
            };
        case 'sign-always':
        case '+!':
            return {
                signDisplay: 'always',
            };
        case 'sign-accounting-always':
        case '()!':
            return {
                signDisplay: 'always',
                currencySign: 'accounting',
            };
        case 'sign-except-zero':
        case '+?':
            return {
                signDisplay: 'exceptZero',
            };
        case 'sign-accounting-except-zero':
        case '()?':
            return {
                signDisplay: 'exceptZero',
                currencySign: 'accounting',
            };
        case 'sign-never':
        case '+_':
            return {
                signDisplay: 'never',
            };
    }
}
function parseConciseScientificAndEngineeringStem(stem) {
    // Engineering
    var result;
    if (stem[0] === 'E' && stem[1] === 'E') {
        result = {
            notation: 'engineering',
        };
        stem = stem.slice(2);
    }
    else if (stem[0] === 'E') {
        result = {
            notation: 'scientific',
        };
        stem = stem.slice(1);
    }
    if (result) {
        var signDisplay = stem.slice(0, 2);
        if (signDisplay === '+!') {
            result.signDisplay = 'always';
            stem = stem.slice(2);
        }
        else if (signDisplay === '+?') {
            result.signDisplay = 'exceptZero';
            stem = stem.slice(2);
        }
        if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
            throw new Error('Malformed concise eng/scientific notation');
        }
        result.minimumIntegerDigits = stem.length;
    }
    return result;
}
function parseNotationOptions(opt) {
    var result = {};
    var signOpts = parseSign(opt);
    if (signOpts) {
        return signOpts;
    }
    return result;
}
/**
 * https://github.com/unicode-org/icu/blob/master/docs/userguide/format_parse/numbers/skeletons.md#skeleton-stems-and-options
 */
function parseNumberSkeleton(tokens) {
    var result = {};
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        switch (token.stem) {
            case 'percent':
            case '%':
                result.style = 'percent';
                continue;
            case '%x100':
                result.style = 'percent';
                result.scale = 100;
                continue;
            case 'currency':
                result.style = 'currency';
                result.currency = token.options[0];
                continue;
            case 'group-off':
            case ',_':
                result.useGrouping = false;
                continue;
            case 'precision-integer':
            case '.':
                result.maximumFractionDigits = 0;
                continue;
            case 'measure-unit':
            case 'unit':
                result.style = 'unit';
                result.unit = icuUnitToEcma(token.options[0]);
                continue;
            case 'compact-short':
            case 'K':
                result.notation = 'compact';
                result.compactDisplay = 'short';
                continue;
            case 'compact-long':
            case 'KK':
                result.notation = 'compact';
                result.compactDisplay = 'long';
                continue;
            case 'scientific':
                result = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, result), { notation: 'scientific' }), token.options.reduce(function (all, opt) { return (tslib_1.__assign(tslib_1.__assign({}, all), parseNotationOptions(opt))); }, {}));
                continue;
            case 'engineering':
                result = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, result), { notation: 'engineering' }), token.options.reduce(function (all, opt) { return (tslib_1.__assign(tslib_1.__assign({}, all), parseNotationOptions(opt))); }, {}));
                continue;
            case 'notation-simple':
                result.notation = 'standard';
                continue;
            // https://github.com/unicode-org/icu/blob/master/icu4c/source/i18n/unicode/unumberformatter.h
            case 'unit-width-narrow':
                result.currencyDisplay = 'narrowSymbol';
                result.unitDisplay = 'narrow';
                continue;
            case 'unit-width-short':
                result.currencyDisplay = 'code';
                result.unitDisplay = 'short';
                continue;
            case 'unit-width-full-name':
                result.currencyDisplay = 'name';
                result.unitDisplay = 'long';
                continue;
            case 'unit-width-iso-code':
                result.currencyDisplay = 'symbol';
                continue;
            case 'scale':
                result.scale = parseFloat(token.options[0]);
                continue;
            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width
            case 'integer-width':
                if (token.options.length > 1) {
                    throw new RangeError('integer-width stems only accept a single optional option');
                }
                token.options[0].replace(INTEGER_WIDTH_REGEX, function (_, g1, g2, g3, g4, g5) {
                    if (g1) {
                        result.minimumIntegerDigits = g2.length;
                    }
                    else if (g3 && g4) {
                        throw new Error('We currently do not support maximum integer digits');
                    }
                    else if (g5) {
                        throw new Error('We currently do not support exact integer digits');
                    }
                    return '';
                });
                continue;
        }
        // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width
        if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {
            result.minimumIntegerDigits = token.stem.length;
            continue;
        }
        if (FRACTION_PRECISION_REGEX.test(token.stem)) {
            // Precision
            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#fraction-precision
            // precision-integer case
            if (token.options.length > 1) {
                throw new RangeError('Fraction-precision stems only accept a single optional option');
            }
            token.stem.replace(FRACTION_PRECISION_REGEX, function (_, g1, g2, g3, g4, g5) {
                // .000* case (before ICU67 it was .000+)
                if (g2 === '*') {
                    result.minimumFractionDigits = g1.length;
                }
                // .### case
                else if (g3 && g3[0] === '#') {
                    result.maximumFractionDigits = g3.length;
                }
                // .00## case
                else if (g4 && g5) {
                    result.minimumFractionDigits = g4.length;
                    result.maximumFractionDigits = g4.length + g5.length;
                }
                else {
                    result.minimumFractionDigits = g1.length;
                    result.maximumFractionDigits = g1.length;
                }
                return '';
            });
            var opt = token.options[0];
            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#trailing-zero-display
            if (opt === 'w') {
                result = tslib_1.__assign(tslib_1.__assign({}, result), { trailingZeroDisplay: 'stripIfInteger' });
            }
            else if (opt) {
                result = tslib_1.__assign(tslib_1.__assign({}, result), parseSignificantPrecision(opt));
            }
            continue;
        }
        // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#significant-digits-precision
        if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {
            result = tslib_1.__assign(tslib_1.__assign({}, result), parseSignificantPrecision(token.stem));
            continue;
        }
        var signOpts = parseSign(token.stem);
        if (signOpts) {
            result = tslib_1.__assign(tslib_1.__assign({}, result), signOpts);
        }
        var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);
        if (conciseScientificAndEngineeringOpts) {
            result = tslib_1.__assign(tslib_1.__assign({}, result), conciseScientificAndEngineeringOpts);
        }
    }
    return result;
}
exports.parseNumberSkeleton = parseNumberSkeleton;


/***/ }),

/***/ 85491:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WHITE_SPACE_REGEX = void 0;
// @generated from regex-gen.ts
exports.WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;


/***/ }),

/***/ 50031:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $kgI3C$swchelperscjs_class_private_field_initcjs = __webpack_require__(62789);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "CalendarDate", () => $625ad1e1f4c43bc1$export$99faa760c7908e4f);
$parcel$export(module.exports, "CalendarDateTime", () => $625ad1e1f4c43bc1$export$ca871e8dbb80966f);
$parcel$export(module.exports, "Time", () => $625ad1e1f4c43bc1$export$680ea196effce5f);
$parcel$export(module.exports, "ZonedDateTime", () => $625ad1e1f4c43bc1$export$d3b7288e7994edea);
$parcel$export(module.exports, "GregorianCalendar", () => $af14c9812fdceb33$export$80ee6245ec4f29ec);
$parcel$export(module.exports, "JapaneseCalendar", () => $b0ac0602ef646b2c$export$b746ab2b60cdffbf);
$parcel$export(module.exports, "BuddhistCalendar", () => $561c4ef058278b74$export$42d20a78301dee44);
$parcel$export(module.exports, "TaiwanCalendar", () => $9cc5d3577ec40243$export$65e01080afcb0799);
$parcel$export(module.exports, "PersianCalendar", () => $3c060181fc7249ae$export$37fccdbfd14c5939);
$parcel$export(module.exports, "IndianCalendar", () => $5f1dfa5c67609fe6$export$39f31c639fa15726);
$parcel$export(module.exports, "IslamicCivilCalendar", () => $ecb2c4cc8c9aae25$export$2066795aadd37bfc);
$parcel$export(module.exports, "IslamicTabularCalendar", () => $ecb2c4cc8c9aae25$export$37f0887f2f9d22f7);
$parcel$export(module.exports, "IslamicUmalquraCalendar", () => $ecb2c4cc8c9aae25$export$5baab4758c231076);
$parcel$export(module.exports, "HebrewCalendar", () => $0f5324ee3bdd9396$export$ca405048b8fb5af);
$parcel$export(module.exports, "EthiopicCalendar", () => $4db04d1051af0f2f$export$26ba6eab5e20cd7d);
$parcel$export(module.exports, "EthiopicAmeteAlemCalendar", () => $4db04d1051af0f2f$export$d72e0c37005a4914);
$parcel$export(module.exports, "CopticCalendar", () => $4db04d1051af0f2f$export$fe6243cbe1a4b7c1);
$parcel$export(module.exports, "createCalendar", () => $4922c0a5a69da0ba$export$dd0bbc9b26defe37);
$parcel$export(module.exports, "toCalendarDate", () => $4ae0260a69729f1d$export$93522d1a439f3617);
$parcel$export(module.exports, "toCalendarDateTime", () => $4ae0260a69729f1d$export$b21e0b124e224484);
$parcel$export(module.exports, "toTime", () => $4ae0260a69729f1d$export$d33f79e3ffc3dc83);
$parcel$export(module.exports, "toCalendar", () => $4ae0260a69729f1d$export$b4a036af3fc0b032);
$parcel$export(module.exports, "toZoned", () => $4ae0260a69729f1d$export$84c95a83c799e074);
$parcel$export(module.exports, "toTimeZone", () => $4ae0260a69729f1d$export$538b00033cc11c75);
$parcel$export(module.exports, "toLocalTimeZone", () => $4ae0260a69729f1d$export$d9b67bc93c097491);
$parcel$export(module.exports, "isSameDay", () => $1f0f7ebf1ae6c530$export$ea39ec197993aef0);
$parcel$export(module.exports, "isSameMonth", () => $1f0f7ebf1ae6c530$export$a18c89cbd24170ff);
$parcel$export(module.exports, "isSameYear", () => $1f0f7ebf1ae6c530$export$5841f9eb9773f25f);
$parcel$export(module.exports, "isEqualDay", () => $1f0f7ebf1ae6c530$export$91b62ebf2ba703ee);
$parcel$export(module.exports, "isEqualMonth", () => $1f0f7ebf1ae6c530$export$5a8da0c44a3afdf2);
$parcel$export(module.exports, "isEqualYear", () => $1f0f7ebf1ae6c530$export$ea840f5a6dda8147);
$parcel$export(module.exports, "isToday", () => $1f0f7ebf1ae6c530$export$629b0a497aa65267);
$parcel$export(module.exports, "getDayOfWeek", () => $1f0f7ebf1ae6c530$export$2061056d06d7cdf7);
$parcel$export(module.exports, "now", () => $1f0f7ebf1ae6c530$export$461939dd4422153);
$parcel$export(module.exports, "today", () => $1f0f7ebf1ae6c530$export$d0bdf45af03a6ea3);
$parcel$export(module.exports, "getHoursInDay", () => $1f0f7ebf1ae6c530$export$126c91c941de7e);
$parcel$export(module.exports, "getLocalTimeZone", () => $1f0f7ebf1ae6c530$export$aa8b41735afcabd2);
$parcel$export(module.exports, "startOfMonth", () => $1f0f7ebf1ae6c530$export$a5a3b454ada2268e);
$parcel$export(module.exports, "startOfWeek", () => $1f0f7ebf1ae6c530$export$42c81a444fbfb5d4);
$parcel$export(module.exports, "startOfYear", () => $1f0f7ebf1ae6c530$export$f91e89d3d0406102);
$parcel$export(module.exports, "endOfMonth", () => $1f0f7ebf1ae6c530$export$a2258d9c4118825c);
$parcel$export(module.exports, "endOfWeek", () => $1f0f7ebf1ae6c530$export$ef8b6d9133084f4e);
$parcel$export(module.exports, "endOfYear", () => $1f0f7ebf1ae6c530$export$8b7aa55c66d5569e);
$parcel$export(module.exports, "getMinimumMonthInYear", () => $1f0f7ebf1ae6c530$export$5412ac11713b72ad);
$parcel$export(module.exports, "getMinimumDayInMonth", () => $1f0f7ebf1ae6c530$export$b2f4953d301981d5);
$parcel$export(module.exports, "getWeeksInMonth", () => $1f0f7ebf1ae6c530$export$ccc1b2479e7dd654);
$parcel$export(module.exports, "minDate", () => $1f0f7ebf1ae6c530$export$5c333a116e949cdd);
$parcel$export(module.exports, "maxDate", () => $1f0f7ebf1ae6c530$export$a75f2bff57811055);
$parcel$export(module.exports, "isWeekend", () => $1f0f7ebf1ae6c530$export$618d60ea299da42);
$parcel$export(module.exports, "isWeekday", () => $1f0f7ebf1ae6c530$export$ee9d87258e1d19ed);
$parcel$export(module.exports, "parseDate", () => $4c32e2d98e5a5134$export$6b862160d295c8e);
$parcel$export(module.exports, "parseDateTime", () => $4c32e2d98e5a5134$export$588937bcd60ade55);
$parcel$export(module.exports, "parseTime", () => $4c32e2d98e5a5134$export$c9698ec7f05a07e1);
$parcel$export(module.exports, "parseAbsolute", () => $4c32e2d98e5a5134$export$5adfdab05168c219);
$parcel$export(module.exports, "parseAbsoluteToLocal", () => $4c32e2d98e5a5134$export$8e384432362ed0f0);
$parcel$export(module.exports, "parseZonedDateTime", () => $4c32e2d98e5a5134$export$fd7893f06e92a6a4);
$parcel$export(module.exports, "parseDuration", () => $4c32e2d98e5a5134$export$ecae829bb3747ea6);
$parcel$export(module.exports, "DateFormatter", () => $8f23a04ae90a588b$export$ad991b66133851cf);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from the TC39 Temporal proposal.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $a5090d6430502238$export$842a2cf37af977e1(amount, numerator) {
    return amount - numerator * Math.floor(amount / numerator);
}
function $a5090d6430502238$export$784d13d8ee351f07(date) {
    if (date.era) return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(date.calendar, date.era, date.year, date.month, date.day);
    else return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(date.calendar, date.year, date.month, date.day);
}
function $a5090d6430502238$export$27fa0172ae2644b3(date) {
    if (date.era) return new (0, $625ad1e1f4c43bc1$export$ca871e8dbb80966f)(date.calendar, date.era, date.year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);
    else return new (0, $625ad1e1f4c43bc1$export$ca871e8dbb80966f)(date.calendar, date.year, date.month, date.day, date.hour, date.minute, date.second);
}


const $af14c9812fdceb33$var$EPOCH = 1721426; // 001/01/03 Julian C.E.
function $af14c9812fdceb33$export$f297eb839006d339(era, year, month, day) {
    year = $af14c9812fdceb33$export$c36e0ecb2d4fa69d(era, year);
    let y1 = year - 1;
    let monthOffset = -2;
    if (month <= 2) monthOffset = 0;
    else if ($af14c9812fdceb33$export$553d7fa8e3805fc0(year)) monthOffset = -1;
    return $af14c9812fdceb33$var$EPOCH - 1 + 365 * y1 + Math.floor(y1 / 4) - Math.floor(y1 / 100) + Math.floor(y1 / 400) + Math.floor((367 * month - 362) / 12 + monthOffset + day);
}
function $af14c9812fdceb33$export$553d7fa8e3805fc0(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function $af14c9812fdceb33$export$c36e0ecb2d4fa69d(era, year) {
    return era === "BC" ? 1 - year : year;
}
function $af14c9812fdceb33$export$4475b7e617eb123c(year) {
    let era = "AD";
    if (year <= 0) {
        era = "BC";
        year = 1 - year;
    }
    return [
        era,
        year
    ];
}
const $af14c9812fdceb33$var$daysInMonth = {
    standard: [
        31,
        28,
        31,
        30,
        31,
        30,
        31,
        31,
        30,
        31,
        30,
        31
    ],
    leapyear: [
        31,
        29,
        31,
        30,
        31,
        30,
        31,
        31,
        30,
        31,
        30,
        31
    ]
};
class $af14c9812fdceb33$export$80ee6245ec4f29ec {
    fromJulianDay(jd) {
        let jd0 = jd;
        let depoch = jd0 - $af14c9812fdceb33$var$EPOCH;
        let quadricent = Math.floor(depoch / 146097);
        let dqc = (0, $a5090d6430502238$export$842a2cf37af977e1)(depoch, 146097);
        let cent = Math.floor(dqc / 36524);
        let dcent = (0, $a5090d6430502238$export$842a2cf37af977e1)(dqc, 36524);
        let quad = Math.floor(dcent / 1461);
        let dquad = (0, $a5090d6430502238$export$842a2cf37af977e1)(dcent, 1461);
        let yindex = Math.floor(dquad / 365);
        let extendedYear = quadricent * 400 + cent * 100 + quad * 4 + yindex + (cent !== 4 && yindex !== 4 ? 1 : 0);
        let [era, year] = $af14c9812fdceb33$export$4475b7e617eb123c(extendedYear);
        let yearDay = jd0 - $af14c9812fdceb33$export$f297eb839006d339(era, year, 1, 1);
        let leapAdj = 2;
        if (jd0 < $af14c9812fdceb33$export$f297eb839006d339(era, year, 3, 1)) leapAdj = 0;
        else if ($af14c9812fdceb33$export$553d7fa8e3805fc0(year)) leapAdj = 1;
        let month = Math.floor(((yearDay + leapAdj) * 12 + 373) / 367);
        let day = jd0 - $af14c9812fdceb33$export$f297eb839006d339(era, year, month, 1) + 1;
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(era, year, month, day);
    }
    toJulianDay(date) {
        return $af14c9812fdceb33$export$f297eb839006d339(date.era, date.year, date.month, date.day);
    }
    getDaysInMonth(date) {
        return $af14c9812fdceb33$var$daysInMonth[$af14c9812fdceb33$export$553d7fa8e3805fc0(date.year) ? "leapyear" : "standard"][date.month - 1];
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getMonthsInYear(date) {
        return 12;
    }
    getDaysInYear(date) {
        return $af14c9812fdceb33$export$553d7fa8e3805fc0(date.year) ? 366 : 365;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getYearsInEra(date) {
        return 9999;
    }
    getEras() {
        return [
            "BC",
            "AD"
        ];
    }
    isInverseEra(date) {
        return date.era === "BC";
    }
    balanceDate(date) {
        if (date.year <= 0) {
            date.era = date.era === "BC" ? "AD" : "BC";
            date.year = 1 - date.year;
        }
    }
    constructor(){
        this.identifier = "gregory";
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Data from https://github.com/unicode-cldr/cldr-core/blob/master/supplemental/weekData.json
// Locales starting on Sunday have been removed for compression.
const $4d88eff242b38a9e$export$7a5acbd77d414bd9 = {
    "001": 1,
    AD: 1,
    AE: 6,
    AF: 6,
    AI: 1,
    AL: 1,
    AM: 1,
    AN: 1,
    AR: 1,
    AT: 1,
    AU: 1,
    AX: 1,
    AZ: 1,
    BA: 1,
    BE: 1,
    BG: 1,
    BH: 6,
    BM: 1,
    BN: 1,
    BY: 1,
    CH: 1,
    CL: 1,
    CM: 1,
    CN: 1,
    CR: 1,
    CY: 1,
    CZ: 1,
    DE: 1,
    DJ: 6,
    DK: 1,
    DZ: 6,
    EC: 1,
    EE: 1,
    EG: 6,
    ES: 1,
    FI: 1,
    FJ: 1,
    FO: 1,
    FR: 1,
    GB: 1,
    GE: 1,
    GF: 1,
    GP: 1,
    GR: 1,
    HR: 1,
    HU: 1,
    IE: 1,
    IQ: 6,
    IR: 6,
    IS: 1,
    IT: 1,
    JO: 6,
    KG: 1,
    KW: 6,
    KZ: 1,
    LB: 1,
    LI: 1,
    LK: 1,
    LT: 1,
    LU: 1,
    LV: 1,
    LY: 6,
    MC: 1,
    MD: 1,
    ME: 1,
    MK: 1,
    MN: 1,
    MQ: 1,
    MV: 5,
    MY: 1,
    NL: 1,
    NO: 1,
    NZ: 1,
    OM: 6,
    PL: 1,
    QA: 6,
    RE: 1,
    RO: 1,
    RS: 1,
    RU: 1,
    SD: 6,
    SE: 1,
    SI: 1,
    SK: 1,
    SM: 1,
    SY: 6,
    TJ: 1,
    TM: 1,
    TR: 1,
    UA: 1,
    UY: 1,
    UZ: 1,
    VA: 1,
    VN: 1,
    XK: 1
};


function $1f0f7ebf1ae6c530$export$ea39ec197993aef0(a, b) {
    b = (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)(b, a.calendar);
    return a.era === b.era && a.year === b.year && a.month === b.month && a.day === b.day;
}
function $1f0f7ebf1ae6c530$export$a18c89cbd24170ff(a, b) {
    b = (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)(b, a.calendar);
    // In the Japanese calendar, months can span multiple eras/years, so only compare the first of the month.
    a = $1f0f7ebf1ae6c530$export$a5a3b454ada2268e(a);
    b = $1f0f7ebf1ae6c530$export$a5a3b454ada2268e(b);
    return a.era === b.era && a.year === b.year && a.month === b.month;
}
function $1f0f7ebf1ae6c530$export$5841f9eb9773f25f(a, b) {
    b = (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)(b, a.calendar);
    a = $1f0f7ebf1ae6c530$export$f91e89d3d0406102(a);
    b = $1f0f7ebf1ae6c530$export$f91e89d3d0406102(b);
    return a.era === b.era && a.year === b.year;
}
function $1f0f7ebf1ae6c530$export$91b62ebf2ba703ee(a, b) {
    return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year && a.month === b.month && a.day === b.day;
}
function $1f0f7ebf1ae6c530$export$5a8da0c44a3afdf2(a, b) {
    a = $1f0f7ebf1ae6c530$export$a5a3b454ada2268e(a);
    b = $1f0f7ebf1ae6c530$export$a5a3b454ada2268e(b);
    return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year && a.month === b.month;
}
function $1f0f7ebf1ae6c530$export$ea840f5a6dda8147(a, b) {
    a = $1f0f7ebf1ae6c530$export$f91e89d3d0406102(a);
    b = $1f0f7ebf1ae6c530$export$f91e89d3d0406102(b);
    return a.calendar.identifier === b.calendar.identifier && a.era === b.era && a.year === b.year;
}
function $1f0f7ebf1ae6c530$export$629b0a497aa65267(date, timeZone) {
    return $1f0f7ebf1ae6c530$export$ea39ec197993aef0(date, $1f0f7ebf1ae6c530$export$d0bdf45af03a6ea3(timeZone));
}
function $1f0f7ebf1ae6c530$export$2061056d06d7cdf7(date, locale) {
    let julian = date.calendar.toJulianDay(date);
    // If julian is negative, then julian % 7 will be negative, so we adjust
    // accordingly.  Julian day 0 is Monday.
    let dayOfWeek = Math.ceil(julian + 1 - $1f0f7ebf1ae6c530$var$getWeekStart(locale)) % 7;
    if (dayOfWeek < 0) dayOfWeek += 7;
    return dayOfWeek;
}
function $1f0f7ebf1ae6c530$export$461939dd4422153(timeZone) {
    return (0, $4ae0260a69729f1d$export$1b96692a1ba042ac)(Date.now(), timeZone);
}
function $1f0f7ebf1ae6c530$export$d0bdf45af03a6ea3(timeZone) {
    return (0, $4ae0260a69729f1d$export$93522d1a439f3617)($1f0f7ebf1ae6c530$export$461939dd4422153(timeZone));
}
function $1f0f7ebf1ae6c530$export$68781ddf31c0090f(a, b) {
    return a.calendar.toJulianDay(a) - b.calendar.toJulianDay(b);
}
function $1f0f7ebf1ae6c530$export$c19a80a9721b80f6(a, b) {
    return $1f0f7ebf1ae6c530$var$timeToMs(a) - $1f0f7ebf1ae6c530$var$timeToMs(b);
}
function $1f0f7ebf1ae6c530$var$timeToMs(a) {
    return a.hour * 3600000 + a.minute * 60000 + a.second * 1000 + a.millisecond;
}
function $1f0f7ebf1ae6c530$export$126c91c941de7e(a, timeZone) {
    let ms = (0, $4ae0260a69729f1d$export$5107c82f94518f5c)(a, timeZone);
    let tomorrow = a.add({
        days: 1
    });
    let tomorrowMs = (0, $4ae0260a69729f1d$export$5107c82f94518f5c)(tomorrow, timeZone);
    return (tomorrowMs - ms) / 3600000;
}
let $1f0f7ebf1ae6c530$var$localTimeZone = null;
function $1f0f7ebf1ae6c530$export$aa8b41735afcabd2() {
    // TODO: invalidate this somehow?
    if ($1f0f7ebf1ae6c530$var$localTimeZone == null) $1f0f7ebf1ae6c530$var$localTimeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone;
    return $1f0f7ebf1ae6c530$var$localTimeZone;
}
function $1f0f7ebf1ae6c530$export$a5a3b454ada2268e(date) {
    // Use `subtract` instead of `set` so we don't get constrained in an era.
    return date.subtract({
        days: date.day - 1
    });
}
function $1f0f7ebf1ae6c530$export$a2258d9c4118825c(date) {
    return date.add({
        days: date.calendar.getDaysInMonth(date) - date.day
    });
}
function $1f0f7ebf1ae6c530$export$f91e89d3d0406102(date) {
    return $1f0f7ebf1ae6c530$export$a5a3b454ada2268e(date.subtract({
        months: date.month - 1
    }));
}
function $1f0f7ebf1ae6c530$export$8b7aa55c66d5569e(date) {
    return $1f0f7ebf1ae6c530$export$a2258d9c4118825c(date.add({
        months: date.calendar.getMonthsInYear(date) - date.month
    }));
}
function $1f0f7ebf1ae6c530$export$5412ac11713b72ad(date) {
    if (date.calendar.getMinimumMonthInYear) return date.calendar.getMinimumMonthInYear(date);
    return 1;
}
function $1f0f7ebf1ae6c530$export$b2f4953d301981d5(date) {
    if (date.calendar.getMinimumDayInMonth) return date.calendar.getMinimumDayInMonth(date);
    return 1;
}
function $1f0f7ebf1ae6c530$export$42c81a444fbfb5d4(date, locale) {
    let dayOfWeek = $1f0f7ebf1ae6c530$export$2061056d06d7cdf7(date, locale);
    return date.subtract({
        days: dayOfWeek
    });
}
function $1f0f7ebf1ae6c530$export$ef8b6d9133084f4e(date, locale) {
    return $1f0f7ebf1ae6c530$export$42c81a444fbfb5d4(date, locale).add({
        days: 6
    });
}
const $1f0f7ebf1ae6c530$var$cachedRegions = new Map();
function $1f0f7ebf1ae6c530$var$getRegion(locale) {
    // If the Intl.Locale API is available, use it to get the region for the locale.
    // @ts-ignore
    if (Intl.Locale) {
        // Constructing an Intl.Locale is expensive, so cache the result.
        let region = $1f0f7ebf1ae6c530$var$cachedRegions.get(locale);
        if (!region) {
            // @ts-ignore
            region = new Intl.Locale(locale).maximize().region;
            $1f0f7ebf1ae6c530$var$cachedRegions.set(locale, region);
        }
        return region;
    }
    // If not, just try splitting the string.
    // If the second part of the locale string is 'u',
    // then this is a unicode extension, so ignore it.
    // Otherwise, it should be the region.
    let part = locale.split("-")[1];
    return part === "u" ? null : part;
}
function $1f0f7ebf1ae6c530$var$getWeekStart(locale) {
    // TODO: use Intl.Locale for this once browsers support the weekInfo property
    // https://github.com/tc39/proposal-intl-locale-info
    let region = $1f0f7ebf1ae6c530$var$getRegion(locale);
    return (0, $4d88eff242b38a9e$export$7a5acbd77d414bd9)[region] || 0;
}
function $1f0f7ebf1ae6c530$export$ccc1b2479e7dd654(date, locale) {
    let days = date.calendar.getDaysInMonth(date);
    return Math.ceil(($1f0f7ebf1ae6c530$export$2061056d06d7cdf7($1f0f7ebf1ae6c530$export$a5a3b454ada2268e(date), locale) + days) / 7);
}
function $1f0f7ebf1ae6c530$export$5c333a116e949cdd(a, b) {
    if (a && b) return a.compare(b) <= 0 ? a : b;
    return a || b;
}
function $1f0f7ebf1ae6c530$export$a75f2bff57811055(a, b) {
    if (a && b) return a.compare(b) >= 0 ? a : b;
    return a || b;
}
const $1f0f7ebf1ae6c530$var$WEEKEND_DATA = {
    AF: [
        4,
        5
    ],
    AE: [
        5,
        6
    ],
    BH: [
        5,
        6
    ],
    DZ: [
        5,
        6
    ],
    EG: [
        5,
        6
    ],
    IL: [
        5,
        6
    ],
    IQ: [
        5,
        6
    ],
    IR: [
        5,
        5
    ],
    JO: [
        5,
        6
    ],
    KW: [
        5,
        6
    ],
    LY: [
        5,
        6
    ],
    OM: [
        5,
        6
    ],
    QA: [
        5,
        6
    ],
    SA: [
        5,
        6
    ],
    SD: [
        5,
        6
    ],
    SY: [
        5,
        6
    ],
    YE: [
        5,
        6
    ]
};
function $1f0f7ebf1ae6c530$export$618d60ea299da42(date, locale) {
    let julian = date.calendar.toJulianDay(date);
    // If julian is negative, then julian % 7 will be negative, so we adjust
    // accordingly.  Julian day 0 is Monday.
    let dayOfWeek = Math.ceil(julian + 1) % 7;
    if (dayOfWeek < 0) dayOfWeek += 7;
    let region = $1f0f7ebf1ae6c530$var$getRegion(locale);
    // Use Intl.Locale for this once weekInfo is supported.
    // https://github.com/tc39/proposal-intl-locale-info
    let [start, end] = $1f0f7ebf1ae6c530$var$WEEKEND_DATA[region] || [
        6,
        0
    ];
    return dayOfWeek === start || dayOfWeek === end;
}
function $1f0f7ebf1ae6c530$export$ee9d87258e1d19ed(date, locale) {
    return !$1f0f7ebf1ae6c530$export$618d60ea299da42(date, locale);
}


function $4ae0260a69729f1d$export$bd4fb2bc8bb06fb(date) {
    date = $4ae0260a69729f1d$export$b4a036af3fc0b032(date, new (0, $af14c9812fdceb33$export$80ee6245ec4f29ec)());
    let year = (0, $af14c9812fdceb33$export$c36e0ecb2d4fa69d)(date.era, date.year);
    return $4ae0260a69729f1d$var$epochFromParts(year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);
}
function $4ae0260a69729f1d$var$epochFromParts(year, month, day, hour, minute, second, millisecond) {
    // Note: Date.UTC() interprets one and two-digit years as being in the
    // 20th century, so don't use it
    let date = new Date();
    date.setUTCHours(hour, minute, second, millisecond);
    date.setUTCFullYear(year, month - 1, day);
    return date.getTime();
}
function $4ae0260a69729f1d$export$59c99f3515d3493f(ms, timeZone) {
    // Fast path for UTC.
    if (timeZone === "UTC") return 0;
    // Fast path: for local timezone after 1970, use native Date.
    if (ms > 0 && timeZone === (0, $1f0f7ebf1ae6c530$export$aa8b41735afcabd2)()) return new Date(ms).getTimezoneOffset() * -60000;
    let { year: year , month: month , day: day , hour: hour , minute: minute , second: second  } = $4ae0260a69729f1d$var$getTimeZoneParts(ms, timeZone);
    let utc = $4ae0260a69729f1d$var$epochFromParts(year, month, day, hour, minute, second, 0);
    return utc - Math.floor(ms / 1000) * 1000;
}
const $4ae0260a69729f1d$var$formattersByTimeZone = new Map();
function $4ae0260a69729f1d$var$getTimeZoneParts(ms, timeZone) {
    let formatter = $4ae0260a69729f1d$var$formattersByTimeZone.get(timeZone);
    if (!formatter) {
        formatter = new Intl.DateTimeFormat("en-US", {
            timeZone: timeZone,
            hour12: false,
            era: "short",
            year: "numeric",
            month: "numeric",
            day: "numeric",
            hour: "numeric",
            minute: "numeric",
            second: "numeric"
        });
        $4ae0260a69729f1d$var$formattersByTimeZone.set(timeZone, formatter);
    }
    let parts = formatter.formatToParts(new Date(ms));
    let namedParts = {};
    for (let part of parts)if (part.type !== "literal") namedParts[part.type] = part.value;
    return {
        // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
        year: namedParts.era === "BC" || namedParts.era === "B" ? -namedParts.year + 1 : +namedParts.year,
        month: +namedParts.month,
        day: +namedParts.day,
        hour: namedParts.hour === "24" ? 0 : +namedParts.hour,
        minute: +namedParts.minute,
        second: +namedParts.second
    };
}
const $4ae0260a69729f1d$var$DAYMILLIS = 86400000;
function $4ae0260a69729f1d$export$136f38efe7caf549(date, timeZone) {
    let ms = $4ae0260a69729f1d$export$bd4fb2bc8bb06fb(date);
    let earlier = ms - $4ae0260a69729f1d$export$59c99f3515d3493f(ms - $4ae0260a69729f1d$var$DAYMILLIS, timeZone);
    let later = ms - $4ae0260a69729f1d$export$59c99f3515d3493f(ms + $4ae0260a69729f1d$var$DAYMILLIS, timeZone);
    return $4ae0260a69729f1d$var$getValidWallTimes(date, timeZone, earlier, later);
}
function $4ae0260a69729f1d$var$getValidWallTimes(date, timeZone, earlier, later) {
    let found = earlier === later ? [
        earlier
    ] : [
        earlier,
        later
    ];
    return found.filter((absolute)=>$4ae0260a69729f1d$var$isValidWallTime(date, timeZone, absolute));
}
function $4ae0260a69729f1d$var$isValidWallTime(date, timeZone, absolute) {
    let parts = $4ae0260a69729f1d$var$getTimeZoneParts(absolute, timeZone);
    return date.year === parts.year && date.month === parts.month && date.day === parts.day && date.hour === parts.hour && date.minute === parts.minute && date.second === parts.second;
}
function $4ae0260a69729f1d$export$5107c82f94518f5c(date, timeZone, disambiguation = "compatible") {
    let dateTime = $4ae0260a69729f1d$export$b21e0b124e224484(date);
    // Fast path: if the time zone is UTC, use native Date.
    if (timeZone === "UTC") return $4ae0260a69729f1d$export$bd4fb2bc8bb06fb(dateTime);
    // Fast path: if the time zone is the local timezone and disambiguation is compatible, use native Date.
    if (timeZone === (0, $1f0f7ebf1ae6c530$export$aa8b41735afcabd2)() && disambiguation === "compatible") {
        dateTime = $4ae0260a69729f1d$export$b4a036af3fc0b032(dateTime, new (0, $af14c9812fdceb33$export$80ee6245ec4f29ec)());
        // Don't use Date constructor here because two-digit years are interpreted in the 20th century.
        let date = new Date();
        let year = (0, $af14c9812fdceb33$export$c36e0ecb2d4fa69d)(dateTime.era, dateTime.year);
        date.setFullYear(year, dateTime.month - 1, dateTime.day);
        date.setHours(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);
        return date.getTime();
    }
    let ms = $4ae0260a69729f1d$export$bd4fb2bc8bb06fb(dateTime);
    let offsetBefore = $4ae0260a69729f1d$export$59c99f3515d3493f(ms - $4ae0260a69729f1d$var$DAYMILLIS, timeZone);
    let offsetAfter = $4ae0260a69729f1d$export$59c99f3515d3493f(ms + $4ae0260a69729f1d$var$DAYMILLIS, timeZone);
    let valid = $4ae0260a69729f1d$var$getValidWallTimes(dateTime, timeZone, ms - offsetBefore, ms - offsetAfter);
    if (valid.length === 1) return valid[0];
    if (valid.length > 1) switch(disambiguation){
        // 'compatible' means 'earlier' for "fall back" transitions
        case "compatible":
        case "earlier":
            return valid[0];
        case "later":
            return valid[valid.length - 1];
        case "reject":
            throw new RangeError("Multiple possible absolute times found");
    }
    switch(disambiguation){
        case "earlier":
            return Math.min(ms - offsetBefore, ms - offsetAfter);
        // 'compatible' means 'later' for "spring forward" transitions
        case "compatible":
        case "later":
            return Math.max(ms - offsetBefore, ms - offsetAfter);
        case "reject":
            throw new RangeError("No such absolute time found");
    }
}
function $4ae0260a69729f1d$export$e67a095c620b86fe(dateTime, timeZone, disambiguation = "compatible") {
    return new Date($4ae0260a69729f1d$export$5107c82f94518f5c(dateTime, timeZone, disambiguation));
}
function $4ae0260a69729f1d$export$1b96692a1ba042ac(ms, timeZone) {
    let offset = $4ae0260a69729f1d$export$59c99f3515d3493f(ms, timeZone);
    let date = new Date(ms + offset);
    let year = date.getUTCFullYear();
    let month = date.getUTCMonth() + 1;
    let day = date.getUTCDate();
    let hour = date.getUTCHours();
    let minute = date.getUTCMinutes();
    let second = date.getUTCSeconds();
    let millisecond = date.getUTCMilliseconds();
    return new (0, $625ad1e1f4c43bc1$export$d3b7288e7994edea)(year, month, day, timeZone, offset, hour, minute, second, millisecond);
}
function $4ae0260a69729f1d$export$e57ff100d91bd4b9(date, timeZone) {
    return $4ae0260a69729f1d$export$1b96692a1ba042ac(date.getTime(), timeZone);
}
function $4ae0260a69729f1d$export$d7f92bcd3596b086(date) {
    return $4ae0260a69729f1d$export$e57ff100d91bd4b9(date, (0, $1f0f7ebf1ae6c530$export$aa8b41735afcabd2)());
}
function $4ae0260a69729f1d$export$93522d1a439f3617(dateTime) {
    return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(dateTime.calendar, dateTime.era, dateTime.year, dateTime.month, dateTime.day);
}
function $4ae0260a69729f1d$export$6f4d78149f3f53ac(date) {
    return {
        era: date.era,
        year: date.year,
        month: date.month,
        day: date.day
    };
}
function $4ae0260a69729f1d$export$4d0393e732857be5(date) {
    return {
        hour: date.hour,
        minute: date.minute,
        second: date.second,
        millisecond: date.millisecond
    };
}
function $4ae0260a69729f1d$export$b21e0b124e224484(date, time) {
    let hour = 0, minute = 0, second = 0, millisecond = 0;
    if ("timeZone" in date) ({ hour: hour , minute: minute , second: second , millisecond: millisecond  } = date);
    else if ("hour" in date && !time) return date;
    if (time) ({ hour: hour , minute: minute , second: second , millisecond: millisecond  } = time);
    return new (0, $625ad1e1f4c43bc1$export$ca871e8dbb80966f)(date.calendar, date.era, date.year, date.month, date.day, hour, minute, second, millisecond);
}
function $4ae0260a69729f1d$export$d33f79e3ffc3dc83(dateTime) {
    return new (0, $625ad1e1f4c43bc1$export$680ea196effce5f)(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);
}
function $4ae0260a69729f1d$export$b4a036af3fc0b032(date, calendar) {
    if (date.calendar.identifier === calendar.identifier) return date;
    let calendarDate = calendar.fromJulianDay(date.calendar.toJulianDay(date));
    let copy = date.copy();
    copy.calendar = calendar;
    copy.era = calendarDate.era;
    copy.year = calendarDate.year;
    copy.month = calendarDate.month;
    copy.day = calendarDate.day;
    (0, $5c0571aa5b6fb5da$export$c4e2ecac49351ef2)(copy);
    return copy;
}
function $4ae0260a69729f1d$export$84c95a83c799e074(date, timeZone, disambiguation) {
    if (date instanceof (0, $625ad1e1f4c43bc1$export$d3b7288e7994edea)) {
        if (date.timeZone === timeZone) return date;
        return $4ae0260a69729f1d$export$538b00033cc11c75(date, timeZone);
    }
    let ms = $4ae0260a69729f1d$export$5107c82f94518f5c(date, timeZone, disambiguation);
    return $4ae0260a69729f1d$export$1b96692a1ba042ac(ms, timeZone);
}
function $4ae0260a69729f1d$export$83aac07b4c37b25(date) {
    let ms = $4ae0260a69729f1d$export$bd4fb2bc8bb06fb(date) - date.offset;
    return new Date(ms);
}
function $4ae0260a69729f1d$export$538b00033cc11c75(date, timeZone) {
    let ms = $4ae0260a69729f1d$export$bd4fb2bc8bb06fb(date) - date.offset;
    return $4ae0260a69729f1d$export$b4a036af3fc0b032($4ae0260a69729f1d$export$1b96692a1ba042ac(ms, timeZone), date.calendar);
}
function $4ae0260a69729f1d$export$d9b67bc93c097491(date) {
    return $4ae0260a69729f1d$export$538b00033cc11c75(date, (0, $1f0f7ebf1ae6c530$export$aa8b41735afcabd2)());
}



const $5c0571aa5b6fb5da$var$ONE_HOUR = 3600000;
function $5c0571aa5b6fb5da$export$e16d8520af44a096(date, duration) {
    let mutableDate = date.copy();
    let days = "hour" in mutableDate ? $5c0571aa5b6fb5da$var$addTimeFields(mutableDate, duration) : 0;
    $5c0571aa5b6fb5da$var$addYears(mutableDate, duration.years || 0);
    if (mutableDate.calendar.balanceYearMonth) mutableDate.calendar.balanceYearMonth(mutableDate, date);
    mutableDate.month += duration.months || 0;
    $5c0571aa5b6fb5da$var$balanceYearMonth(mutableDate);
    $5c0571aa5b6fb5da$var$constrainMonthDay(mutableDate);
    mutableDate.day += (duration.weeks || 0) * 7;
    mutableDate.day += duration.days || 0;
    mutableDate.day += days;
    $5c0571aa5b6fb5da$var$balanceDay(mutableDate);
    if (mutableDate.calendar.balanceDate) mutableDate.calendar.balanceDate(mutableDate);
    // Constrain in case adding ended up with a date outside the valid range for the calendar system.
    // The behavior here is slightly different than when constraining in the `set` function in that
    // we adjust smaller fields to their minimum/maximum values rather than constraining each field
    // individually. This matches the general behavior of `add` vs `set` regarding how fields are balanced.
    if (mutableDate.year < 1) {
        mutableDate.year = 1;
        mutableDate.month = 1;
        mutableDate.day = 1;
    }
    let maxYear = mutableDate.calendar.getYearsInEra(mutableDate);
    if (mutableDate.year > maxYear) {
        var _mutableDate_calendar, _mutableDate_calendar_isInverseEra;
        let isInverseEra = (_mutableDate_calendar_isInverseEra = (_mutableDate_calendar = mutableDate.calendar).isInverseEra) === null || _mutableDate_calendar_isInverseEra === void 0 ? void 0 : _mutableDate_calendar_isInverseEra.call(_mutableDate_calendar, mutableDate);
        mutableDate.year = maxYear;
        mutableDate.month = isInverseEra ? 1 : mutableDate.calendar.getMonthsInYear(mutableDate);
        mutableDate.day = isInverseEra ? 1 : mutableDate.calendar.getDaysInMonth(mutableDate);
    }
    if (mutableDate.month < 1) {
        mutableDate.month = 1;
        mutableDate.day = 1;
    }
    let maxMonth = mutableDate.calendar.getMonthsInYear(mutableDate);
    if (mutableDate.month > maxMonth) {
        mutableDate.month = maxMonth;
        mutableDate.day = mutableDate.calendar.getDaysInMonth(mutableDate);
    }
    mutableDate.day = Math.max(1, Math.min(mutableDate.calendar.getDaysInMonth(mutableDate), mutableDate.day));
    return mutableDate;
}
function $5c0571aa5b6fb5da$var$addYears(date, years) {
    var _date_calendar, _date_calendar_isInverseEra;
    if ((_date_calendar_isInverseEra = (_date_calendar = date.calendar).isInverseEra) === null || _date_calendar_isInverseEra === void 0 ? void 0 : _date_calendar_isInverseEra.call(_date_calendar, date)) years = -years;
    date.year += years;
}
function $5c0571aa5b6fb5da$var$balanceYearMonth(date) {
    while(date.month < 1){
        $5c0571aa5b6fb5da$var$addYears(date, -1);
        date.month += date.calendar.getMonthsInYear(date);
    }
    let monthsInYear = 0;
    while(date.month > (monthsInYear = date.calendar.getMonthsInYear(date))){
        date.month -= monthsInYear;
        $5c0571aa5b6fb5da$var$addYears(date, 1);
    }
}
function $5c0571aa5b6fb5da$var$balanceDay(date) {
    while(date.day < 1){
        date.month--;
        $5c0571aa5b6fb5da$var$balanceYearMonth(date);
        date.day += date.calendar.getDaysInMonth(date);
    }
    while(date.day > date.calendar.getDaysInMonth(date)){
        date.day -= date.calendar.getDaysInMonth(date);
        date.month++;
        $5c0571aa5b6fb5da$var$balanceYearMonth(date);
    }
}
function $5c0571aa5b6fb5da$var$constrainMonthDay(date) {
    date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));
    date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));
}
function $5c0571aa5b6fb5da$export$c4e2ecac49351ef2(date) {
    if (date.calendar.constrainDate) date.calendar.constrainDate(date);
    date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));
    $5c0571aa5b6fb5da$var$constrainMonthDay(date);
}
function $5c0571aa5b6fb5da$export$3e2544e88a25bff8(duration) {
    let inverseDuration = {};
    for(let key in duration)if (typeof duration[key] === "number") inverseDuration[key] = -duration[key];
    return inverseDuration;
}
function $5c0571aa5b6fb5da$export$4e2d2ead65e5f7e3(date, duration) {
    return $5c0571aa5b6fb5da$export$e16d8520af44a096(date, $5c0571aa5b6fb5da$export$3e2544e88a25bff8(duration));
}
function $5c0571aa5b6fb5da$export$adaa4cf7ef1b65be(date, fields) {
    let mutableDate = date.copy();
    if (fields.era != null) mutableDate.era = fields.era;
    if (fields.year != null) mutableDate.year = fields.year;
    if (fields.month != null) mutableDate.month = fields.month;
    if (fields.day != null) mutableDate.day = fields.day;
    $5c0571aa5b6fb5da$export$c4e2ecac49351ef2(mutableDate);
    return mutableDate;
}
function $5c0571aa5b6fb5da$export$e5d5e1c1822b6e56(value, fields) {
    let mutableValue = value.copy();
    if (fields.hour != null) mutableValue.hour = fields.hour;
    if (fields.minute != null) mutableValue.minute = fields.minute;
    if (fields.second != null) mutableValue.second = fields.second;
    if (fields.millisecond != null) mutableValue.millisecond = fields.millisecond;
    $5c0571aa5b6fb5da$export$7555de1e070510cb(mutableValue);
    return mutableValue;
}
function $5c0571aa5b6fb5da$var$balanceTime(time) {
    time.second += Math.floor(time.millisecond / 1000);
    time.millisecond = $5c0571aa5b6fb5da$var$nonNegativeMod(time.millisecond, 1000);
    time.minute += Math.floor(time.second / 60);
    time.second = $5c0571aa5b6fb5da$var$nonNegativeMod(time.second, 60);
    time.hour += Math.floor(time.minute / 60);
    time.minute = $5c0571aa5b6fb5da$var$nonNegativeMod(time.minute, 60);
    let days = Math.floor(time.hour / 24);
    time.hour = $5c0571aa5b6fb5da$var$nonNegativeMod(time.hour, 24);
    return days;
}
function $5c0571aa5b6fb5da$export$7555de1e070510cb(time) {
    time.millisecond = Math.max(0, Math.min(time.millisecond, 1000));
    time.second = Math.max(0, Math.min(time.second, 59));
    time.minute = Math.max(0, Math.min(time.minute, 59));
    time.hour = Math.max(0, Math.min(time.hour, 23));
}
function $5c0571aa5b6fb5da$var$nonNegativeMod(a, b) {
    let result = a % b;
    if (result < 0) result += b;
    return result;
}
function $5c0571aa5b6fb5da$var$addTimeFields(time, duration) {
    time.hour += duration.hours || 0;
    time.minute += duration.minutes || 0;
    time.second += duration.seconds || 0;
    time.millisecond += duration.milliseconds || 0;
    return $5c0571aa5b6fb5da$var$balanceTime(time);
}
function $5c0571aa5b6fb5da$export$7ed87b6bc2506470(time, duration) {
    let res = time.copy();
    $5c0571aa5b6fb5da$var$addTimeFields(res, duration);
    return res;
}
function $5c0571aa5b6fb5da$export$fe34d3a381cd7501(time, duration) {
    return $5c0571aa5b6fb5da$export$7ed87b6bc2506470(time, $5c0571aa5b6fb5da$export$3e2544e88a25bff8(duration));
}
function $5c0571aa5b6fb5da$export$d52ced6badfb9a4c(value, field, amount, options) {
    let mutable = value.copy();
    switch(field){
        case "era":
            {
                let eras = value.calendar.getEras();
                let eraIndex = eras.indexOf(value.era);
                if (eraIndex < 0) throw new Error("Invalid era: " + value.era);
                eraIndex = $5c0571aa5b6fb5da$var$cycleValue(eraIndex, amount, 0, eras.length - 1, options === null || options === void 0 ? void 0 : options.round);
                mutable.era = eras[eraIndex];
                // Constrain the year and other fields within the era, so the era doesn't change when we balance below.
                $5c0571aa5b6fb5da$export$c4e2ecac49351ef2(mutable);
                break;
            }
        case "year":
            var _mutable_calendar, _mutable_calendar_isInverseEra;
            if ((_mutable_calendar_isInverseEra = (_mutable_calendar = mutable.calendar).isInverseEra) === null || _mutable_calendar_isInverseEra === void 0 ? void 0 : _mutable_calendar_isInverseEra.call(_mutable_calendar, mutable)) amount = -amount;
            // The year field should not cycle within the era as that can cause weird behavior affecting other fields.
            // We need to also allow values < 1 so that decrementing goes to the previous era. If we get -Infinity back
            // we know we wrapped around after reaching 9999 (the maximum), so set the year back to 1.
            mutable.year = $5c0571aa5b6fb5da$var$cycleValue(value.year, amount, -Infinity, 9999, options === null || options === void 0 ? void 0 : options.round);
            if (mutable.year === -Infinity) mutable.year = 1;
            if (mutable.calendar.balanceYearMonth) mutable.calendar.balanceYearMonth(mutable, value);
            break;
        case "month":
            mutable.month = $5c0571aa5b6fb5da$var$cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options === null || options === void 0 ? void 0 : options.round);
            break;
        case "day":
            mutable.day = $5c0571aa5b6fb5da$var$cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options === null || options === void 0 ? void 0 : options.round);
            break;
        default:
            throw new Error("Unsupported field " + field);
    }
    if (value.calendar.balanceDate) value.calendar.balanceDate(mutable);
    $5c0571aa5b6fb5da$export$c4e2ecac49351ef2(mutable);
    return mutable;
}
function $5c0571aa5b6fb5da$export$dd02b3e0007dfe28(value, field, amount, options) {
    let mutable = value.copy();
    switch(field){
        case "hour":
            {
                let hours = value.hour;
                let min = 0;
                let max = 23;
                if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
                    let isPM = hours >= 12;
                    min = isPM ? 12 : 0;
                    max = isPM ? 23 : 11;
                }
                mutable.hour = $5c0571aa5b6fb5da$var$cycleValue(hours, amount, min, max, options === null || options === void 0 ? void 0 : options.round);
                break;
            }
        case "minute":
            mutable.minute = $5c0571aa5b6fb5da$var$cycleValue(value.minute, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
            break;
        case "second":
            mutable.second = $5c0571aa5b6fb5da$var$cycleValue(value.second, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
            break;
        case "millisecond":
            mutable.millisecond = $5c0571aa5b6fb5da$var$cycleValue(value.millisecond, amount, 0, 999, options === null || options === void 0 ? void 0 : options.round);
            break;
        default:
            throw new Error("Unsupported field " + field);
    }
    return mutable;
}
function $5c0571aa5b6fb5da$var$cycleValue(value, amount, min, max, round = false) {
    if (round) {
        value += Math.sign(amount);
        if (value < min) value = max;
        let div = Math.abs(amount);
        if (amount > 0) value = Math.ceil(value / div) * div;
        else value = Math.floor(value / div) * div;
        if (value > max) value = min;
    } else {
        value += amount;
        if (value < min) value = max - (min - value - 1);
        else if (value > max) value = min + (value - max - 1);
    }
    return value;
}
function $5c0571aa5b6fb5da$export$96b1d28349274637(dateTime, duration) {
    let ms;
    if (duration.years != null && duration.years !== 0 || duration.months != null && duration.months !== 0 || duration.days != null && duration.days !== 0) {
        let res = $5c0571aa5b6fb5da$export$e16d8520af44a096((0, $4ae0260a69729f1d$export$b21e0b124e224484)(dateTime), {
            years: duration.years,
            months: duration.months,
            days: duration.days
        });
        // Changing the date may change the timezone offset, so we need to recompute
        // using the 'compatible' disambiguation.
        ms = (0, $4ae0260a69729f1d$export$5107c82f94518f5c)(res, dateTime.timeZone);
    } else // Otherwise, preserve the offset of the original date.
    ms = (0, $4ae0260a69729f1d$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
    // Perform time manipulation in milliseconds rather than on the original time fields to account for DST.
    // For example, adding one hour during a DST transition may result in the hour field staying the same or
    // skipping an hour. This results in the offset field changing value instead of the specified field.
    ms += duration.milliseconds || 0;
    ms += (duration.seconds || 0) * 1000;
    ms += (duration.minutes || 0) * 60000;
    ms += (duration.hours || 0) * 3600000;
    let res = (0, $4ae0260a69729f1d$export$1b96692a1ba042ac)(ms, dateTime.timeZone);
    return (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)(res, dateTime.calendar);
}
function $5c0571aa5b6fb5da$export$6814caac34ca03c7(dateTime, duration) {
    return $5c0571aa5b6fb5da$export$96b1d28349274637(dateTime, $5c0571aa5b6fb5da$export$3e2544e88a25bff8(duration));
}
function $5c0571aa5b6fb5da$export$9a297d111fc86b79(dateTime, field, amount, options) {
    // For date fields, we want the time to remain consistent and the UTC offset to potentially change to account for DST changes.
    // For time fields, we want the time to change by the amount given. This may result in the hour field staying the same, but the UTC
    // offset changing in the case of a backward DST transition, or skipping an hour in the case of a forward DST transition.
    switch(field){
        case "hour":
            {
                let min = 0;
                let max = 23;
                if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
                    let isPM = dateTime.hour >= 12;
                    min = isPM ? 12 : 0;
                    max = isPM ? 23 : 11;
                }
                // The minimum and maximum hour may be affected by daylight saving time.
                // For example, it might jump forward at midnight, and skip 1am.
                // Or it might end at midnight and repeat the 11pm hour. To handle this, we get
                // the possible absolute times for the min and max, and find the maximum range
                // that is within the current day.
                let plainDateTime = (0, $4ae0260a69729f1d$export$b21e0b124e224484)(dateTime);
                let minDate = (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)($5c0571aa5b6fb5da$export$e5d5e1c1822b6e56(plainDateTime, {
                    hour: min
                }), new (0, $af14c9812fdceb33$export$80ee6245ec4f29ec)());
                let minAbsolute = [
                    (0, $4ae0260a69729f1d$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "earlier"),
                    (0, $4ae0260a69729f1d$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "later")
                ].filter((ms)=>(0, $4ae0260a69729f1d$export$1b96692a1ba042ac)(ms, dateTime.timeZone).day === minDate.day)[0];
                let maxDate = (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)($5c0571aa5b6fb5da$export$e5d5e1c1822b6e56(plainDateTime, {
                    hour: max
                }), new (0, $af14c9812fdceb33$export$80ee6245ec4f29ec)());
                let maxAbsolute = [
                    (0, $4ae0260a69729f1d$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "earlier"),
                    (0, $4ae0260a69729f1d$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "later")
                ].filter((ms)=>(0, $4ae0260a69729f1d$export$1b96692a1ba042ac)(ms, dateTime.timeZone).day === maxDate.day).pop();
                // Since hours may repeat, we need to operate on the absolute time in milliseconds.
                // This is done in hours from the Unix epoch so that cycleValue works correctly,
                // and then converted back to milliseconds.
                let ms = (0, $4ae0260a69729f1d$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
                let hours = Math.floor(ms / $5c0571aa5b6fb5da$var$ONE_HOUR);
                let remainder = ms % $5c0571aa5b6fb5da$var$ONE_HOUR;
                ms = $5c0571aa5b6fb5da$var$cycleValue(hours, amount, Math.floor(minAbsolute / $5c0571aa5b6fb5da$var$ONE_HOUR), Math.floor(maxAbsolute / $5c0571aa5b6fb5da$var$ONE_HOUR), options === null || options === void 0 ? void 0 : options.round) * $5c0571aa5b6fb5da$var$ONE_HOUR + remainder;
                // Now compute the new timezone offset, and convert the absolute time back to local time.
                return (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)((0, $4ae0260a69729f1d$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
            }
        case "minute":
        case "second":
        case "millisecond":
            // @ts-ignore
            return $5c0571aa5b6fb5da$export$dd02b3e0007dfe28(dateTime, field, amount, options);
        case "era":
        case "year":
        case "month":
        case "day":
            {
                let res = $5c0571aa5b6fb5da$export$d52ced6badfb9a4c((0, $4ae0260a69729f1d$export$b21e0b124e224484)(dateTime), field, amount, options);
                let ms = (0, $4ae0260a69729f1d$export$5107c82f94518f5c)(res, dateTime.timeZone);
                return (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)((0, $4ae0260a69729f1d$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
            }
        default:
            throw new Error("Unsupported field " + field);
    }
}
function $5c0571aa5b6fb5da$export$31b5430eb18be4f8(dateTime, fields, disambiguation) {
    // Set the date/time fields, and recompute the UTC offset to account for DST changes.
    // We also need to validate by converting back to a local time in case hours are skipped during forward DST transitions.
    let plainDateTime = (0, $4ae0260a69729f1d$export$b21e0b124e224484)(dateTime);
    let res = $5c0571aa5b6fb5da$export$e5d5e1c1822b6e56($5c0571aa5b6fb5da$export$adaa4cf7ef1b65be(plainDateTime, fields), fields);
    // If the resulting plain date time values are equal, return the original time.
    // We don't want to change the offset when setting the time to the same value.
    if (res.compare(plainDateTime) === 0) return dateTime;
    let ms = (0, $4ae0260a69729f1d$export$5107c82f94518f5c)(res, dateTime.timeZone, disambiguation);
    return (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)((0, $4ae0260a69729f1d$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



const $4c32e2d98e5a5134$var$TIME_RE = /^(\d{2})(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?$/;
const $4c32e2d98e5a5134$var$DATE_RE = /^(\d{4})-(\d{2})-(\d{2})$/;
const $4c32e2d98e5a5134$var$DATE_TIME_RE = /^(\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?$/;
const $4c32e2d98e5a5134$var$ZONED_DATE_TIME_RE = /^(\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:([+-]\d{2})(?::?(\d{2}))?)?\[(.*?)\]$/;
const $4c32e2d98e5a5134$var$ABSOLUTE_RE = /^(\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:(?:([+-]\d{2})(?::?(\d{2}))?)|Z)$/;
const $4c32e2d98e5a5134$var$DATE_TIME_DURATION_RE = /^((?<negative>-)|\+)?P((?<years>\d*)Y)?((?<months>\d*)M)?((?<weeks>\d*)W)?((?<days>\d*)D)?((?<time>T)((?<hours>\d*[.,]?\d{1,9})H)?((?<minutes>\d*[.,]?\d{1,9})M)?((?<seconds>\d*[.,]?\d{1,9})S)?)?$/;
const $4c32e2d98e5a5134$var$requiredDurationTimeGroups = [
    "hours",
    "minutes",
    "seconds"
];
const $4c32e2d98e5a5134$var$requiredDurationGroups = [
    "years",
    "months",
    "weeks",
    "days",
    ...$4c32e2d98e5a5134$var$requiredDurationTimeGroups
];
function $4c32e2d98e5a5134$export$c9698ec7f05a07e1(value) {
    let m = value.match($4c32e2d98e5a5134$var$TIME_RE);
    if (!m) throw new Error("Invalid ISO 8601 time string: " + value);
    return new (0, $625ad1e1f4c43bc1$export$680ea196effce5f)($4c32e2d98e5a5134$var$parseNumber(m[1], 0, 23), m[2] ? $4c32e2d98e5a5134$var$parseNumber(m[2], 0, 59) : 0, m[3] ? $4c32e2d98e5a5134$var$parseNumber(m[3], 0, 59) : 0, m[4] ? $4c32e2d98e5a5134$var$parseNumber(m[4], 0, Infinity) * 1000 : 0);
}
function $4c32e2d98e5a5134$export$6b862160d295c8e(value) {
    let m = value.match($4c32e2d98e5a5134$var$DATE_RE);
    if (!m) throw new Error("Invalid ISO 8601 date string: " + value);
    let date = new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)($4c32e2d98e5a5134$var$parseNumber(m[1], 0, 9999), $4c32e2d98e5a5134$var$parseNumber(m[2], 1, 12), 1);
    date.day = $4c32e2d98e5a5134$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
    return date;
}
function $4c32e2d98e5a5134$export$588937bcd60ade55(value) {
    let m = value.match($4c32e2d98e5a5134$var$DATE_TIME_RE);
    if (!m) throw new Error("Invalid ISO 8601 date time string: " + value);
    let date = new (0, $625ad1e1f4c43bc1$export$ca871e8dbb80966f)($4c32e2d98e5a5134$var$parseNumber(m[1], 1, 9999), $4c32e2d98e5a5134$var$parseNumber(m[2], 1, 12), 1, m[4] ? $4c32e2d98e5a5134$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $4c32e2d98e5a5134$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $4c32e2d98e5a5134$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $4c32e2d98e5a5134$var$parseNumber(m[7], 0, Infinity) * 1000 : 0);
    date.day = $4c32e2d98e5a5134$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
    return date;
}
function $4c32e2d98e5a5134$export$fd7893f06e92a6a4(value, disambiguation) {
    let m = value.match($4c32e2d98e5a5134$var$ZONED_DATE_TIME_RE);
    if (!m) throw new Error("Invalid ISO 8601 date time string: " + value);
    let date = new (0, $625ad1e1f4c43bc1$export$d3b7288e7994edea)($4c32e2d98e5a5134$var$parseNumber(m[1], 1, 9999), $4c32e2d98e5a5134$var$parseNumber(m[2], 1, 12), 1, m[10], 0, m[4] ? $4c32e2d98e5a5134$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $4c32e2d98e5a5134$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $4c32e2d98e5a5134$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $4c32e2d98e5a5134$var$parseNumber(m[7], 0, Infinity) * 1000 : 0);
    date.day = $4c32e2d98e5a5134$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
    let plainDateTime = (0, $4ae0260a69729f1d$export$b21e0b124e224484)(date);
    let ms;
    if (m[8]) {
        var _m_;
        date.offset = $4c32e2d98e5a5134$var$parseNumber(m[8], -23, 23) * 3600000 + $4c32e2d98e5a5134$var$parseNumber((_m_ = m[9]) !== null && _m_ !== void 0 ? _m_ : "0", 0, 59) * 60000;
        ms = (0, $4ae0260a69729f1d$export$bd4fb2bc8bb06fb)(date) - date.offset;
        // Validate offset against parsed date.
        let absolutes = (0, $4ae0260a69729f1d$export$136f38efe7caf549)(plainDateTime, date.timeZone);
        if (!absolutes.includes(ms)) throw new Error(`Offset ${$4c32e2d98e5a5134$var$offsetToString(date.offset)} is invalid for ${$4c32e2d98e5a5134$export$4223de14708adc63(date)} in ${date.timeZone}`);
    } else // Convert to absolute and back to fix invalid times due to DST.
    ms = (0, $4ae0260a69729f1d$export$5107c82f94518f5c)((0, $4ae0260a69729f1d$export$b21e0b124e224484)(plainDateTime), date.timeZone, disambiguation);
    return (0, $4ae0260a69729f1d$export$1b96692a1ba042ac)(ms, date.timeZone);
}
function $4c32e2d98e5a5134$export$5adfdab05168c219(value, timeZone) {
    let m = value.match($4c32e2d98e5a5134$var$ABSOLUTE_RE);
    if (!m) throw new Error("Invalid ISO 8601 date time string: " + value);
    let date = new (0, $625ad1e1f4c43bc1$export$d3b7288e7994edea)($4c32e2d98e5a5134$var$parseNumber(m[1], 1, 9999), $4c32e2d98e5a5134$var$parseNumber(m[2], 1, 12), 1, timeZone, 0, m[4] ? $4c32e2d98e5a5134$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $4c32e2d98e5a5134$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $4c32e2d98e5a5134$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $4c32e2d98e5a5134$var$parseNumber(m[7], 0, Infinity) * 1000 : 0);
    date.day = $4c32e2d98e5a5134$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
    var _m_;
    if (m[8]) date.offset = $4c32e2d98e5a5134$var$parseNumber(m[8], -23, 23) * 3600000 + $4c32e2d98e5a5134$var$parseNumber((_m_ = m[9]) !== null && _m_ !== void 0 ? _m_ : "0", 0, 59) * 60000;
    return (0, $4ae0260a69729f1d$export$538b00033cc11c75)(date, timeZone);
}
function $4c32e2d98e5a5134$export$8e384432362ed0f0(value) {
    return $4c32e2d98e5a5134$export$5adfdab05168c219(value, (0, $1f0f7ebf1ae6c530$export$aa8b41735afcabd2)());
}
function $4c32e2d98e5a5134$var$parseNumber(value, min, max) {
    let val = Number(value);
    if (val < min || val > max) throw new RangeError(`Value out of range: ${min} <= ${val} <= ${max}`);
    return val;
}
function $4c32e2d98e5a5134$export$f59dee82248f5ad4(time) {
    return `${String(time.hour).padStart(2, "0")}:${String(time.minute).padStart(2, "0")}:${String(time.second).padStart(2, "0")}${time.millisecond ? String(time.millisecond / 1000).slice(1) : ""}`;
}
function $4c32e2d98e5a5134$export$60dfd74aa96791bd(date) {
    let gregorianDate = (0, $4ae0260a69729f1d$export$b4a036af3fc0b032)(date, new (0, $af14c9812fdceb33$export$80ee6245ec4f29ec)());
    return `${String(gregorianDate.year).padStart(4, "0")}-${String(gregorianDate.month).padStart(2, "0")}-${String(gregorianDate.day).padStart(2, "0")}`;
}
function $4c32e2d98e5a5134$export$4223de14708adc63(date) {
    // @ts-ignore
    return `${$4c32e2d98e5a5134$export$60dfd74aa96791bd(date)}T${$4c32e2d98e5a5134$export$f59dee82248f5ad4(date)}`;
}
function $4c32e2d98e5a5134$var$offsetToString(offset) {
    let sign = Math.sign(offset) < 0 ? "-" : "+";
    offset = Math.abs(offset);
    let offsetHours = Math.floor(offset / 3600000);
    let offsetMinutes = offset % 3600000 / 60000;
    return `${sign}${String(offsetHours).padStart(2, "0")}:${String(offsetMinutes).padStart(2, "0")}`;
}
function $4c32e2d98e5a5134$export$bf79f1ebf4b18792(date) {
    return `${$4c32e2d98e5a5134$export$4223de14708adc63(date)}${$4c32e2d98e5a5134$var$offsetToString(date.offset)}[${date.timeZone}]`;
}
function $4c32e2d98e5a5134$export$ecae829bb3747ea6(value) {
    var _match_groups, _match_groups1, _match_groups2, _match_groups3, _match_groups4, _match_groups5, _match_groups6, _match_groups7, _match_groups8;
    const match = value.match($4c32e2d98e5a5134$var$DATE_TIME_DURATION_RE);
    if (!match) throw new Error(`Invalid ISO 8601 Duration string: ${value}`);
    const parseDurationGroup = (group, isNegative, min, max)=>{
        if (!group) return 0;
        try {
            const sign = isNegative ? -1 : 1;
            return sign * $4c32e2d98e5a5134$var$parseNumber(group.replace(",", "."), min, max);
        } catch  {
            throw new Error(`Invalid ISO 8601 Duration string: ${value}`);
        }
    };
    const isNegative = !!((_match_groups = match.groups) === null || _match_groups === void 0 ? void 0 : _match_groups.negative);
    const hasRequiredGroups = $4c32e2d98e5a5134$var$requiredDurationGroups.some((group)=>{
        var _match_groups;
        return (_match_groups = match.groups) === null || _match_groups === void 0 ? void 0 : _match_groups[group];
    });
    if (!hasRequiredGroups) throw new Error(`Invalid ISO 8601 Duration string: ${value}`);
    const durationStringIncludesTime = (_match_groups1 = match.groups) === null || _match_groups1 === void 0 ? void 0 : _match_groups1.time;
    if (durationStringIncludesTime) {
        const hasRequiredDurationTimeGroups = $4c32e2d98e5a5134$var$requiredDurationTimeGroups.some((group)=>{
            var _match_groups;
            return (_match_groups = match.groups) === null || _match_groups === void 0 ? void 0 : _match_groups[group];
        });
        if (!hasRequiredDurationTimeGroups) throw new Error(`Invalid ISO 8601 Duration string: ${value}`);
    }
    const duration = {
        years: parseDurationGroup((_match_groups2 = match.groups) === null || _match_groups2 === void 0 ? void 0 : _match_groups2.years, isNegative, 0, 9999),
        months: parseDurationGroup((_match_groups3 = match.groups) === null || _match_groups3 === void 0 ? void 0 : _match_groups3.months, isNegative, 0, 12),
        weeks: parseDurationGroup((_match_groups4 = match.groups) === null || _match_groups4 === void 0 ? void 0 : _match_groups4.weeks, isNegative, 0, Infinity),
        days: parseDurationGroup((_match_groups5 = match.groups) === null || _match_groups5 === void 0 ? void 0 : _match_groups5.days, isNegative, 0, 31),
        hours: parseDurationGroup((_match_groups6 = match.groups) === null || _match_groups6 === void 0 ? void 0 : _match_groups6.hours, isNegative, 0, 23),
        minutes: parseDurationGroup((_match_groups7 = match.groups) === null || _match_groups7 === void 0 ? void 0 : _match_groups7.minutes, isNegative, 0, 59),
        seconds: parseDurationGroup((_match_groups8 = match.groups) === null || _match_groups8 === void 0 ? void 0 : _match_groups8.seconds, isNegative, 0, 59)
    };
    if (duration.hours % 1 !== 0 && (duration.minutes || duration.seconds)) throw new Error(`Invalid ISO 8601 Duration string: ${value} - only the smallest unit can be fractional`);
    if (duration.minutes % 1 !== 0 && duration.seconds) throw new Error(`Invalid ISO 8601 Duration string: ${value} - only the smallest unit can be fractional`);
    return duration;
}




function $625ad1e1f4c43bc1$var$shiftArgs(args) {
    let calendar = typeof args[0] === "object" ? args.shift() : new (0, $af14c9812fdceb33$export$80ee6245ec4f29ec)();
    let era;
    if (typeof args[0] === "string") era = args.shift();
    else {
        let eras = calendar.getEras();
        era = eras[eras.length - 1];
    }
    let year = args.shift();
    let month = args.shift();
    let day = args.shift();
    return [
        calendar,
        era,
        year,
        month,
        day
    ];
}
var // This prevents TypeScript from allowing other types with the same fields to match.
// i.e. a ZonedDateTime should not be be passable to a parameter that expects CalendarDate.
// If that behavior is desired, use the AnyCalendarDate interface instead.
// @ts-ignore
$625ad1e1f4c43bc1$var$_type = /*#__PURE__*/ new WeakMap();
class $625ad1e1f4c43bc1$export$99faa760c7908e4f {
    /** Returns a copy of this date. */ copy() {
        if (this.era) return new $625ad1e1f4c43bc1$export$99faa760c7908e4f(this.calendar, this.era, this.year, this.month, this.day);
        else return new $625ad1e1f4c43bc1$export$99faa760c7908e4f(this.calendar, this.year, this.month, this.day);
    }
    /** Returns a new `CalendarDate` with the given duration added to it. */ add(duration) {
        return (0, $5c0571aa5b6fb5da$export$e16d8520af44a096)(this, duration);
    }
    /** Returns a new `CalendarDate` with the given duration subtracted from it. */ subtract(duration) {
        return (0, $5c0571aa5b6fb5da$export$4e2d2ead65e5f7e3)(this, duration);
    }
    /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields) {
        return (0, $5c0571aa5b6fb5da$export$adaa4cf7ef1b65be)(this, fields);
    }
    /**
   * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
   * When the resulting value reaches the limits of the field, it wraps around.
   */ cycle(field, amount, options) {
        return (0, $5c0571aa5b6fb5da$export$d52ced6badfb9a4c)(this, field, amount, options);
    }
    /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */ toDate(timeZone) {
        return (0, $4ae0260a69729f1d$export$e67a095c620b86fe)(this, timeZone);
    }
    /** Converts the date to an ISO 8601 formatted string. */ toString() {
        return (0, $4c32e2d98e5a5134$export$60dfd74aa96791bd)(this);
    }
    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */ compare(b) {
        return (0, $1f0f7ebf1ae6c530$export$68781ddf31c0090f)(this, b);
    }
    constructor(...args){
        (0, $kgI3C$swchelperscjs_class_private_field_initcjs._)(this, $625ad1e1f4c43bc1$var$_type, {
            writable: true,
            value: void 0
        });
        let [calendar, era, year, month, day] = $625ad1e1f4c43bc1$var$shiftArgs(args);
        this.calendar = calendar;
        this.era = era;
        this.year = year;
        this.month = month;
        this.day = day;
        (0, $5c0571aa5b6fb5da$export$c4e2ecac49351ef2)(this);
    }
}
var // This prevents TypeScript from allowing other types with the same fields to match.
// @ts-ignore
$625ad1e1f4c43bc1$var$_type1 = /*#__PURE__*/ new WeakMap();
class $625ad1e1f4c43bc1$export$680ea196effce5f {
    /** Returns a copy of this time. */ copy() {
        return new $625ad1e1f4c43bc1$export$680ea196effce5f(this.hour, this.minute, this.second, this.millisecond);
    }
    /** Returns a new `Time` with the given duration added to it. */ add(duration) {
        return (0, $5c0571aa5b6fb5da$export$7ed87b6bc2506470)(this, duration);
    }
    /** Returns a new `Time` with the given duration subtracted from it. */ subtract(duration) {
        return (0, $5c0571aa5b6fb5da$export$fe34d3a381cd7501)(this, duration);
    }
    /** Returns a new `Time` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields) {
        return (0, $5c0571aa5b6fb5da$export$e5d5e1c1822b6e56)(this, fields);
    }
    /**
   * Returns a new `Time` with the given field adjusted by a specified amount.
   * When the resulting value reaches the limits of the field, it wraps around.
   */ cycle(field, amount, options) {
        return (0, $5c0571aa5b6fb5da$export$dd02b3e0007dfe28)(this, field, amount, options);
    }
    /** Converts the time to an ISO 8601 formatted string. */ toString() {
        return (0, $4c32e2d98e5a5134$export$f59dee82248f5ad4)(this);
    }
    /** Compares this time with another. A negative result indicates that this time is before the given one, and a positive time indicates that it is after. */ compare(b) {
        return (0, $1f0f7ebf1ae6c530$export$c19a80a9721b80f6)(this, b);
    }
    constructor(hour = 0, minute = 0, second = 0, millisecond = 0){
        (0, $kgI3C$swchelperscjs_class_private_field_initcjs._)(this, $625ad1e1f4c43bc1$var$_type1, {
            writable: true,
            value: void 0
        });
        this.hour = hour;
        this.minute = minute;
        this.second = second;
        this.millisecond = millisecond;
        (0, $5c0571aa5b6fb5da$export$7555de1e070510cb)(this);
    }
}
var // This prevents TypeScript from allowing other types with the same fields to match.
// @ts-ignore
$625ad1e1f4c43bc1$var$_type2 = /*#__PURE__*/ new WeakMap();
class $625ad1e1f4c43bc1$export$ca871e8dbb80966f {
    /** Returns a copy of this date. */ copy() {
        if (this.era) return new $625ad1e1f4c43bc1$export$ca871e8dbb80966f(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
        else return new $625ad1e1f4c43bc1$export$ca871e8dbb80966f(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
    }
    /** Returns a new `CalendarDateTime` with the given duration added to it. */ add(duration) {
        return (0, $5c0571aa5b6fb5da$export$e16d8520af44a096)(this, duration);
    }
    /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */ subtract(duration) {
        return (0, $5c0571aa5b6fb5da$export$4e2d2ead65e5f7e3)(this, duration);
    }
    /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields) {
        return (0, $5c0571aa5b6fb5da$export$adaa4cf7ef1b65be)((0, $5c0571aa5b6fb5da$export$e5d5e1c1822b6e56)(this, fields), fields);
    }
    /**
   * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
   * When the resulting value reaches the limits of the field, it wraps around.
   */ cycle(field, amount, options) {
        switch(field){
            case "era":
            case "year":
            case "month":
            case "day":
                return (0, $5c0571aa5b6fb5da$export$d52ced6badfb9a4c)(this, field, amount, options);
            default:
                return (0, $5c0571aa5b6fb5da$export$dd02b3e0007dfe28)(this, field, amount, options);
        }
    }
    /** Converts the date to a native JavaScript Date object in the given time zone. */ toDate(timeZone, disambiguation) {
        return (0, $4ae0260a69729f1d$export$e67a095c620b86fe)(this, timeZone, disambiguation);
    }
    /** Converts the date to an ISO 8601 formatted string. */ toString() {
        return (0, $4c32e2d98e5a5134$export$4223de14708adc63)(this);
    }
    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */ compare(b) {
        let res = (0, $1f0f7ebf1ae6c530$export$68781ddf31c0090f)(this, b);
        if (res === 0) return (0, $1f0f7ebf1ae6c530$export$c19a80a9721b80f6)(this, (0, $4ae0260a69729f1d$export$b21e0b124e224484)(b));
        return res;
    }
    constructor(...args){
        (0, $kgI3C$swchelperscjs_class_private_field_initcjs._)(this, $625ad1e1f4c43bc1$var$_type2, {
            writable: true,
            value: void 0
        });
        let [calendar, era, year, month, day] = $625ad1e1f4c43bc1$var$shiftArgs(args);
        this.calendar = calendar;
        this.era = era;
        this.year = year;
        this.month = month;
        this.day = day;
        this.hour = args.shift() || 0;
        this.minute = args.shift() || 0;
        this.second = args.shift() || 0;
        this.millisecond = args.shift() || 0;
        (0, $5c0571aa5b6fb5da$export$c4e2ecac49351ef2)(this);
    }
}
var // This prevents TypeScript from allowing other types with the same fields to match.
// @ts-ignore
$625ad1e1f4c43bc1$var$_type3 = /*#__PURE__*/ new WeakMap();
class $625ad1e1f4c43bc1$export$d3b7288e7994edea {
    /** Returns a copy of this date. */ copy() {
        if (this.era) return new $625ad1e1f4c43bc1$export$d3b7288e7994edea(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
        else return new $625ad1e1f4c43bc1$export$d3b7288e7994edea(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
    }
    /** Returns a new `ZonedDateTime` with the given duration added to it. */ add(duration) {
        return (0, $5c0571aa5b6fb5da$export$96b1d28349274637)(this, duration);
    }
    /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */ subtract(duration) {
        return (0, $5c0571aa5b6fb5da$export$6814caac34ca03c7)(this, duration);
    }
    /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */ set(fields, disambiguation) {
        return (0, $5c0571aa5b6fb5da$export$31b5430eb18be4f8)(this, fields, disambiguation);
    }
    /**
   * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
   * When the resulting value reaches the limits of the field, it wraps around.
   */ cycle(field, amount, options) {
        return (0, $5c0571aa5b6fb5da$export$9a297d111fc86b79)(this, field, amount, options);
    }
    /** Converts the date to a native JavaScript Date object. */ toDate() {
        return (0, $4ae0260a69729f1d$export$83aac07b4c37b25)(this);
    }
    /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */ toString() {
        return (0, $4c32e2d98e5a5134$export$bf79f1ebf4b18792)(this);
    }
    /** Converts the date to an ISO 8601 formatted string in UTC. */ toAbsoluteString() {
        return this.toDate().toISOString();
    }
    /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */ compare(b) {
        // TODO: Is this a bad idea??
        return this.toDate().getTime() - (0, $4ae0260a69729f1d$export$84c95a83c799e074)(b, this.timeZone).toDate().getTime();
    }
    constructor(...args){
        (0, $kgI3C$swchelperscjs_class_private_field_initcjs._)(this, $625ad1e1f4c43bc1$var$_type3, {
            writable: true,
            value: void 0
        });
        let [calendar, era, year, month, day] = $625ad1e1f4c43bc1$var$shiftArgs(args);
        let timeZone = args.shift();
        let offset = args.shift();
        this.calendar = calendar;
        this.era = era;
        this.year = year;
        this.month = month;
        this.day = day;
        this.timeZone = timeZone;
        this.offset = offset;
        this.hour = args.shift() || 0;
        this.minute = args.shift() || 0;
        this.second = args.shift() || 0;
        this.millisecond = args.shift() || 0;
        (0, $5c0571aa5b6fb5da$export$c4e2ecac49351ef2)(this);
    }
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from the TC39 Temporal proposal.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.


const $b0ac0602ef646b2c$var$ERA_START_DATES = [
    [
        1868,
        9,
        8
    ],
    [
        1912,
        7,
        30
    ],
    [
        1926,
        12,
        25
    ],
    [
        1989,
        1,
        8
    ],
    [
        2019,
        5,
        1
    ]
];
const $b0ac0602ef646b2c$var$ERA_END_DATES = [
    [
        1912,
        7,
        29
    ],
    [
        1926,
        12,
        24
    ],
    [
        1989,
        1,
        7
    ],
    [
        2019,
        4,
        30
    ]
];
const $b0ac0602ef646b2c$var$ERA_ADDENDS = [
    1867,
    1911,
    1925,
    1988,
    2018
];
const $b0ac0602ef646b2c$var$ERA_NAMES = [
    "meiji",
    "taisho",
    "showa",
    "heisei",
    "reiwa"
];
function $b0ac0602ef646b2c$var$findEraFromGregorianDate(date) {
    const idx = $b0ac0602ef646b2c$var$ERA_START_DATES.findIndex(([year, month, day])=>{
        if (date.year < year) return true;
        if (date.year === year && date.month < month) return true;
        if (date.year === year && date.month === month && date.day < day) return true;
        return false;
    });
    if (idx === -1) return $b0ac0602ef646b2c$var$ERA_START_DATES.length - 1;
    if (idx === 0) return 0;
    return idx - 1;
}
function $b0ac0602ef646b2c$var$toGregorian(date) {
    let eraAddend = $b0ac0602ef646b2c$var$ERA_ADDENDS[$b0ac0602ef646b2c$var$ERA_NAMES.indexOf(date.era)];
    if (!eraAddend) throw new Error("Unknown era: " + date.era);
    return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(date.year + eraAddend, date.month, date.day);
}
class $b0ac0602ef646b2c$export$b746ab2b60cdffbf extends (0, $af14c9812fdceb33$export$80ee6245ec4f29ec) {
    fromJulianDay(jd) {
        let date = super.fromJulianDay(jd);
        let era = $b0ac0602ef646b2c$var$findEraFromGregorianDate(date);
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, $b0ac0602ef646b2c$var$ERA_NAMES[era], date.year - $b0ac0602ef646b2c$var$ERA_ADDENDS[era], date.month, date.day);
    }
    toJulianDay(date) {
        return super.toJulianDay($b0ac0602ef646b2c$var$toGregorian(date));
    }
    balanceDate(date) {
        let gregorianDate = $b0ac0602ef646b2c$var$toGregorian(date);
        let era = $b0ac0602ef646b2c$var$findEraFromGregorianDate(gregorianDate);
        if ($b0ac0602ef646b2c$var$ERA_NAMES[era] !== date.era) {
            date.era = $b0ac0602ef646b2c$var$ERA_NAMES[era];
            date.year = gregorianDate.year - $b0ac0602ef646b2c$var$ERA_ADDENDS[era];
        }
        // Constrain in case we went before the first supported era.
        this.constrainDate(date);
    }
    constrainDate(date) {
        let idx = $b0ac0602ef646b2c$var$ERA_NAMES.indexOf(date.era);
        let end = $b0ac0602ef646b2c$var$ERA_END_DATES[idx];
        if (end != null) {
            let [endYear, endMonth, endDay] = end;
            // Constrain the year to the maximum possible value in the era.
            // Then constrain the month and day fields within that.
            let maxYear = endYear - $b0ac0602ef646b2c$var$ERA_ADDENDS[idx];
            date.year = Math.max(1, Math.min(maxYear, date.year));
            if (date.year === maxYear) {
                date.month = Math.min(endMonth, date.month);
                if (date.month === endMonth) date.day = Math.min(endDay, date.day);
            }
        }
        if (date.year === 1 && idx >= 0) {
            let [, startMonth, startDay] = $b0ac0602ef646b2c$var$ERA_START_DATES[idx];
            date.month = Math.max(startMonth, date.month);
            if (date.month === startMonth) date.day = Math.max(startDay, date.day);
        }
    }
    getEras() {
        return $b0ac0602ef646b2c$var$ERA_NAMES;
    }
    getYearsInEra(date) {
        // Get the number of years in the era, taking into account the date's month and day fields.
        let era = $b0ac0602ef646b2c$var$ERA_NAMES.indexOf(date.era);
        let cur = $b0ac0602ef646b2c$var$ERA_START_DATES[era];
        let next = $b0ac0602ef646b2c$var$ERA_START_DATES[era + 1];
        if (next == null) // 9999 gregorian is the maximum year allowed.
        return 9999 - cur[0] + 1;
        let years = next[0] - cur[0];
        if (date.month < next[1] || date.month === next[1] && date.day < next[2]) years++;
        return years;
    }
    getDaysInMonth(date) {
        return super.getDaysInMonth($b0ac0602ef646b2c$var$toGregorian(date));
    }
    getMinimumMonthInYear(date) {
        let start = $b0ac0602ef646b2c$var$getMinimums(date);
        return start ? start[1] : 1;
    }
    getMinimumDayInMonth(date) {
        let start = $b0ac0602ef646b2c$var$getMinimums(date);
        return start && date.month === start[1] ? start[2] : 1;
    }
    constructor(...args){
        super(...args);
        this.identifier = "japanese";
    }
}
function $b0ac0602ef646b2c$var$getMinimums(date) {
    if (date.year === 1) {
        let idx = $b0ac0602ef646b2c$var$ERA_NAMES.indexOf(date.era);
        return $b0ac0602ef646b2c$var$ERA_START_DATES[idx];
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.


const $561c4ef058278b74$var$BUDDHIST_ERA_START = -543;
class $561c4ef058278b74$export$42d20a78301dee44 extends (0, $af14c9812fdceb33$export$80ee6245ec4f29ec) {
    fromJulianDay(jd) {
        let gregorianDate = super.fromJulianDay(jd);
        let year = (0, $af14c9812fdceb33$export$c36e0ecb2d4fa69d)(gregorianDate.era, gregorianDate.year);
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, year - $561c4ef058278b74$var$BUDDHIST_ERA_START, gregorianDate.month, gregorianDate.day);
    }
    toJulianDay(date) {
        return super.toJulianDay($561c4ef058278b74$var$toGregorian(date));
    }
    getEras() {
        return [
            "BE"
        ];
    }
    getDaysInMonth(date) {
        return super.getDaysInMonth($561c4ef058278b74$var$toGregorian(date));
    }
    balanceDate() {}
    constructor(...args){
        super(...args);
        this.identifier = "buddhist";
    }
}
function $561c4ef058278b74$var$toGregorian(date) {
    let [era, year] = (0, $af14c9812fdceb33$export$4475b7e617eb123c)(date.year + $561c4ef058278b74$var$BUDDHIST_ERA_START);
    return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(era, year, date.month, date.day);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.


const $9cc5d3577ec40243$var$TAIWAN_ERA_START = 1911;
function $9cc5d3577ec40243$var$gregorianYear(date) {
    return date.era === "minguo" ? date.year + $9cc5d3577ec40243$var$TAIWAN_ERA_START : 1 - date.year + $9cc5d3577ec40243$var$TAIWAN_ERA_START;
}
function $9cc5d3577ec40243$var$gregorianToTaiwan(year) {
    let y = year - $9cc5d3577ec40243$var$TAIWAN_ERA_START;
    if (y > 0) return [
        "minguo",
        y
    ];
    else return [
        "before_minguo",
        1 - y
    ];
}
class $9cc5d3577ec40243$export$65e01080afcb0799 extends (0, $af14c9812fdceb33$export$80ee6245ec4f29ec) {
    fromJulianDay(jd) {
        let date = super.fromJulianDay(jd);
        let extendedYear = (0, $af14c9812fdceb33$export$c36e0ecb2d4fa69d)(date.era, date.year);
        let [era, year] = $9cc5d3577ec40243$var$gregorianToTaiwan(extendedYear);
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, era, year, date.month, date.day);
    }
    toJulianDay(date) {
        return super.toJulianDay($9cc5d3577ec40243$var$toGregorian(date));
    }
    getEras() {
        return [
            "before_minguo",
            "minguo"
        ];
    }
    balanceDate(date) {
        let [era, year] = $9cc5d3577ec40243$var$gregorianToTaiwan($9cc5d3577ec40243$var$gregorianYear(date));
        date.era = era;
        date.year = year;
    }
    isInverseEra(date) {
        return date.era === "before_minguo";
    }
    getDaysInMonth(date) {
        return super.getDaysInMonth($9cc5d3577ec40243$var$toGregorian(date));
    }
    getYearsInEra(date) {
        return date.era === "before_minguo" ? 9999 : 9999 - $9cc5d3577ec40243$var$TAIWAN_ERA_START;
    }
    constructor(...args){
        super(...args);
        this.identifier = "roc" // Republic of China
        ;
    }
}
function $9cc5d3577ec40243$var$toGregorian(date) {
    let [era, year] = (0, $af14c9812fdceb33$export$4475b7e617eb123c)($9cc5d3577ec40243$var$gregorianYear(date));
    return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(era, year, date.month, date.day);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.


const $3c060181fc7249ae$var$PERSIAN_EPOCH = 1948321; // 622/03/19 Julian C.E.
function $3c060181fc7249ae$var$isLeapYear(year) {
    let y0 = year > 0 ? year - 474 : year - 473;
    let y1 = (0, $a5090d6430502238$export$842a2cf37af977e1)(y0, 2820) + 474;
    return (0, $a5090d6430502238$export$842a2cf37af977e1)((y1 + 38) * 31, 128) < 31;
}
function $3c060181fc7249ae$var$persianToJulianDay(year, month, day) {
    let y0 = year > 0 ? year - 474 : year - 473;
    let y1 = (0, $a5090d6430502238$export$842a2cf37af977e1)(y0, 2820) + 474;
    let offset = month <= 7 ? 31 * (month - 1) : 30 * (month - 1) + 6;
    return $3c060181fc7249ae$var$PERSIAN_EPOCH - 1 + 1029983 * Math.floor(y0 / 2820) + 365 * (y1 - 1) + Math.floor((31 * y1 - 5) / 128) + offset + day;
}
class $3c060181fc7249ae$export$37fccdbfd14c5939 {
    fromJulianDay(jd) {
        let d0 = jd - $3c060181fc7249ae$var$persianToJulianDay(475, 1, 1);
        let n2820 = Math.floor(d0 / 1029983);
        let d1 = (0, $a5090d6430502238$export$842a2cf37af977e1)(d0, 1029983);
        let y2820 = d1 === 1029982 ? 2820 : Math.floor((128 * d1 + 46878) / 46751);
        let year = 474 + 2820 * n2820 + y2820;
        if (year <= 0) year--;
        let yDay = jd - $3c060181fc7249ae$var$persianToJulianDay(year, 1, 1) + 1;
        let month = yDay <= 186 ? Math.ceil(yDay / 31) : Math.ceil((yDay - 6) / 31);
        let day = jd - $3c060181fc7249ae$var$persianToJulianDay(year, month, 1) + 1;
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, year, month, day);
    }
    toJulianDay(date) {
        return $3c060181fc7249ae$var$persianToJulianDay(date.year, date.month, date.day);
    }
    getMonthsInYear() {
        return 12;
    }
    getDaysInMonth(date) {
        if (date.month <= 6) return 31;
        if (date.month <= 11) return 30;
        return $3c060181fc7249ae$var$isLeapYear(date.year) ? 30 : 29;
    }
    getEras() {
        return [
            "AP"
        ];
    }
    getYearsInEra() {
        // 9378-10-10 persian is 9999-12-31 gregorian.
        // Round down to 9377 to set the maximum full year.
        return 9377;
    }
    constructor(){
        this.identifier = "persian";
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.


// Starts in 78 AD,
const $5f1dfa5c67609fe6$var$INDIAN_ERA_START = 78;
// The Indian year starts 80 days later than the Gregorian year.
const $5f1dfa5c67609fe6$var$INDIAN_YEAR_START = 80;
class $5f1dfa5c67609fe6$export$39f31c639fa15726 extends (0, $af14c9812fdceb33$export$80ee6245ec4f29ec) {
    fromJulianDay(jd) {
        // Gregorian date for Julian day
        let date = super.fromJulianDay(jd);
        // Year in Saka era
        let indianYear = date.year - $5f1dfa5c67609fe6$var$INDIAN_ERA_START;
        // Day number in Gregorian year (starting from 0)
        let yDay = jd - (0, $af14c9812fdceb33$export$f297eb839006d339)(date.era, date.year, 1, 1);
        let leapMonth;
        if (yDay < $5f1dfa5c67609fe6$var$INDIAN_YEAR_START) {
            //  Day is at the end of the preceding Saka year
            indianYear--;
            // Days in leapMonth this year, previous Gregorian year
            leapMonth = (0, $af14c9812fdceb33$export$553d7fa8e3805fc0)(date.year - 1) ? 31 : 30;
            yDay += leapMonth + 155 + 90 + 10;
        } else {
            // Days in leapMonth this year
            leapMonth = (0, $af14c9812fdceb33$export$553d7fa8e3805fc0)(date.year) ? 31 : 30;
            yDay -= $5f1dfa5c67609fe6$var$INDIAN_YEAR_START;
        }
        let indianMonth;
        let indianDay;
        if (yDay < leapMonth) {
            indianMonth = 1;
            indianDay = yDay + 1;
        } else {
            let mDay = yDay - leapMonth;
            if (mDay < 155) {
                indianMonth = Math.floor(mDay / 31) + 2;
                indianDay = mDay % 31 + 1;
            } else {
                mDay -= 155;
                indianMonth = Math.floor(mDay / 30) + 7;
                indianDay = mDay % 30 + 1;
            }
        }
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, indianYear, indianMonth, indianDay);
    }
    toJulianDay(date) {
        let extendedYear = date.year + $5f1dfa5c67609fe6$var$INDIAN_ERA_START;
        let [era, year] = (0, $af14c9812fdceb33$export$4475b7e617eb123c)(extendedYear);
        let leapMonth;
        let jd;
        if ((0, $af14c9812fdceb33$export$553d7fa8e3805fc0)(year)) {
            leapMonth = 31;
            jd = (0, $af14c9812fdceb33$export$f297eb839006d339)(era, year, 3, 21);
        } else {
            leapMonth = 30;
            jd = (0, $af14c9812fdceb33$export$f297eb839006d339)(era, year, 3, 22);
        }
        if (date.month === 1) return jd + date.day - 1;
        jd += leapMonth + Math.min(date.month - 2, 5) * 31;
        if (date.month >= 8) jd += (date.month - 7) * 30;
        jd += date.day - 1;
        return jd;
    }
    getDaysInMonth(date) {
        if (date.month === 1 && (0, $af14c9812fdceb33$export$553d7fa8e3805fc0)(date.year + $5f1dfa5c67609fe6$var$INDIAN_ERA_START)) return 31;
        if (date.month >= 2 && date.month <= 6) return 31;
        return 30;
    }
    getYearsInEra() {
        // 9999-12-31 gregorian is 9920-10-10 indian.
        // Round down to 9919 for the last full year.
        return 9919;
    }
    getEras() {
        return [
            "saka"
        ];
    }
    balanceDate() {}
    constructor(...args){
        super(...args);
        this.identifier = "indian";
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.

const $ecb2c4cc8c9aae25$var$CIVIL_EPOC = 1948440; // CE 622 July 16 Friday (Julian calendar) / CE 622 July 19 (Gregorian calendar)
const $ecb2c4cc8c9aae25$var$ASTRONOMICAL_EPOC = 1948439; // CE 622 July 15 Thursday (Julian calendar)
const $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START = 1300;
const $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_END = 1600;
const $ecb2c4cc8c9aae25$var$UMALQURA_START_DAYS = 460322;
function $ecb2c4cc8c9aae25$var$islamicToJulianDay(epoch, year, month, day) {
    return day + Math.ceil(29.5 * (month - 1)) + (year - 1) * 354 + Math.floor((3 + 11 * year) / 30) + epoch - 1;
}
function $ecb2c4cc8c9aae25$var$julianDayToIslamic(calendar, epoch, jd) {
    let year = Math.floor((30 * (jd - epoch) + 10646) / 10631);
    let month = Math.min(12, Math.ceil((jd - (29 + $ecb2c4cc8c9aae25$var$islamicToJulianDay(epoch, year, 1, 1))) / 29.5) + 1);
    let day = jd - $ecb2c4cc8c9aae25$var$islamicToJulianDay(epoch, year, month, 1) + 1;
    return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(calendar, year, month, day);
}
function $ecb2c4cc8c9aae25$var$isLeapYear(year) {
    return (14 + 11 * year) % 30 < 11;
}
class $ecb2c4cc8c9aae25$export$2066795aadd37bfc {
    fromJulianDay(jd) {
        return $ecb2c4cc8c9aae25$var$julianDayToIslamic(this, $ecb2c4cc8c9aae25$var$CIVIL_EPOC, jd);
    }
    toJulianDay(date) {
        return $ecb2c4cc8c9aae25$var$islamicToJulianDay($ecb2c4cc8c9aae25$var$CIVIL_EPOC, date.year, date.month, date.day);
    }
    getDaysInMonth(date) {
        let length = 29 + date.month % 2;
        if (date.month === 12 && $ecb2c4cc8c9aae25$var$isLeapYear(date.year)) length++;
        return length;
    }
    getMonthsInYear() {
        return 12;
    }
    getDaysInYear(date) {
        return $ecb2c4cc8c9aae25$var$isLeapYear(date.year) ? 355 : 354;
    }
    getYearsInEra() {
        // 9999 gregorian
        return 9665;
    }
    getEras() {
        return [
            "AH"
        ];
    }
    constructor(){
        this.identifier = "islamic-civil";
    }
}
class $ecb2c4cc8c9aae25$export$37f0887f2f9d22f7 extends $ecb2c4cc8c9aae25$export$2066795aadd37bfc {
    fromJulianDay(jd) {
        return $ecb2c4cc8c9aae25$var$julianDayToIslamic(this, $ecb2c4cc8c9aae25$var$ASTRONOMICAL_EPOC, jd);
    }
    toJulianDay(date) {
        return $ecb2c4cc8c9aae25$var$islamicToJulianDay($ecb2c4cc8c9aae25$var$ASTRONOMICAL_EPOC, date.year, date.month, date.day);
    }
    constructor(...args){
        super(...args);
        this.identifier = "islamic-tbla";
    }
}
// Generated by scripts/generate-umalqura.js
const $ecb2c4cc8c9aae25$var$UMALQURA_DATA = "qgpUDckO1AbqBmwDrQpVBakGkgepC9QF2gpcBS0NlQZKB1QLagutBa4ETwoXBYsGpQbVCtYCWwmdBE0KJg2VDawFtgm6AlsKKwWVCsoG6Qr0AnYJtgJWCcoKpAvSC9kF3AJtCU0FpQpSC6ULtAW2CVcFlwJLBaMGUgdlC2oFqworBZUMSg2lDcoF1gpXCasESwmlClILagt1BXYCtwhbBFUFqQW0BdoJ3QRuAjYJqgpUDbIN1QXaAlsJqwRVCkkLZAtxC7QFtQpVCiUNkg7JDtQG6QprCasEkwpJDaQNsg25CroEWworBZUKKgtVC1wFvQQ9Ah0JlQpKC1oLbQW2AjsJmwRVBqkGVAdqC2wFrQpVBSkLkgupC9QF2gpaBasKlQVJB2QHqgu1BbYCVgpNDiULUgtqC60FrgIvCZcESwalBqwG1gpdBZ0ETQoWDZUNqgW1BdoCWwmtBJUFygbkBuoK9QS2AlYJqgpUC9IL2QXqAm0JrQSVCkoLpQuyBbUJ1gSXCkcFkwZJB1ULagVrCisFiwpGDaMNygXWCtsEawJLCaUKUgtpC3UFdgG3CFsCKwVlBbQF2gntBG0BtgimClINqQ3UBdoKWwmrBFMGKQdiB6kLsgW1ClUFJQuSDckO0gbpCmsFqwRVCikNVA2qDbUJugQ7CpsETQqqCtUK2gJdCV4ELgqaDFUNsga5BroEXQotBZUKUguoC7QLuQXaAloJSgukDdEO6AZqC20FNQWVBkoNqA3UDdoGWwWdAisGFQtKC5ULqgWuCi4JjwwnBZUGqgbWCl0FnQI=";
let $ecb2c4cc8c9aae25$var$UMALQURA_MONTHLENGTH;
let $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START_TABLE;
function $ecb2c4cc8c9aae25$var$umalquraYearStart(year) {
    return $ecb2c4cc8c9aae25$var$UMALQURA_START_DAYS + $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START_TABLE[year - $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START];
}
function $ecb2c4cc8c9aae25$var$umalquraMonthLength(year, month) {
    let idx = year - $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START;
    let mask = 0x01 << 11 - (month - 1);
    if (($ecb2c4cc8c9aae25$var$UMALQURA_MONTHLENGTH[idx] & mask) === 0) return 29;
    else return 30;
}
function $ecb2c4cc8c9aae25$var$umalquraMonthStart(year, month) {
    let day = $ecb2c4cc8c9aae25$var$umalquraYearStart(year);
    for(let i = 1; i < month; i++)day += $ecb2c4cc8c9aae25$var$umalquraMonthLength(year, i);
    return day;
}
function $ecb2c4cc8c9aae25$var$umalquraYearLength(year) {
    return $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START_TABLE[year + 1 - $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START] - $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START_TABLE[year - $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START];
}
class $ecb2c4cc8c9aae25$export$5baab4758c231076 extends $ecb2c4cc8c9aae25$export$2066795aadd37bfc {
    fromJulianDay(jd) {
        let days = jd - $ecb2c4cc8c9aae25$var$CIVIL_EPOC;
        let startDays = $ecb2c4cc8c9aae25$var$umalquraYearStart($ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START);
        let endDays = $ecb2c4cc8c9aae25$var$umalquraYearStart($ecb2c4cc8c9aae25$var$UMALQURA_YEAR_END);
        if (days < startDays || days > endDays) return super.fromJulianDay(jd);
        else {
            let y = $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START - 1;
            let m = 1;
            let d = 1;
            while(d > 0){
                y++;
                d = days - $ecb2c4cc8c9aae25$var$umalquraYearStart(y) + 1;
                let yearLength = $ecb2c4cc8c9aae25$var$umalquraYearLength(y);
                if (d === yearLength) {
                    m = 12;
                    break;
                } else if (d < yearLength) {
                    let monthLength = $ecb2c4cc8c9aae25$var$umalquraMonthLength(y, m);
                    m = 1;
                    while(d > monthLength){
                        d -= monthLength;
                        m++;
                        monthLength = $ecb2c4cc8c9aae25$var$umalquraMonthLength(y, m);
                    }
                    break;
                }
            }
            return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, y, m, days - $ecb2c4cc8c9aae25$var$umalquraMonthStart(y, m) + 1);
        }
    }
    toJulianDay(date) {
        if (date.year < $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START || date.year > $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_END) return super.toJulianDay(date);
        return $ecb2c4cc8c9aae25$var$CIVIL_EPOC + $ecb2c4cc8c9aae25$var$umalquraMonthStart(date.year, date.month) + (date.day - 1);
    }
    getDaysInMonth(date) {
        if (date.year < $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START || date.year > $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_END) return super.getDaysInMonth(date);
        return $ecb2c4cc8c9aae25$var$umalquraMonthLength(date.year, date.month);
    }
    getDaysInYear(date) {
        if (date.year < $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START || date.year > $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_END) return super.getDaysInYear(date);
        return $ecb2c4cc8c9aae25$var$umalquraYearLength(date.year);
    }
    constructor(){
        super();
        this.identifier = "islamic-umalqura";
        if (!$ecb2c4cc8c9aae25$var$UMALQURA_MONTHLENGTH) $ecb2c4cc8c9aae25$var$UMALQURA_MONTHLENGTH = new Uint16Array(Uint8Array.from(atob($ecb2c4cc8c9aae25$var$UMALQURA_DATA), (c)=>c.charCodeAt(0)).buffer);
        if (!$ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START_TABLE) {
            $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START_TABLE = new Uint32Array($ecb2c4cc8c9aae25$var$UMALQURA_YEAR_END - $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START + 1);
            let yearStart = 0;
            for(let year = $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START; year <= $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_END; year++){
                $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START_TABLE[year - $ecb2c4cc8c9aae25$var$UMALQURA_YEAR_START] = yearStart;
                for(let i = 1; i <= 12; i++)yearStart += $ecb2c4cc8c9aae25$var$umalquraMonthLength(year, i);
            }
        }
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.


const $0f5324ee3bdd9396$var$HEBREW_EPOCH = 347997;
// Hebrew date calculations are performed in terms of days, hours, and
// "parts" (or halakim), which are 1/1080 of an hour, or 3 1/3 seconds.
const $0f5324ee3bdd9396$var$HOUR_PARTS = 1080;
const $0f5324ee3bdd9396$var$DAY_PARTS = 24 * $0f5324ee3bdd9396$var$HOUR_PARTS;
// An approximate value for the length of a lunar month.
// It is used to calculate the approximate year and month of a given
// absolute date.
const $0f5324ee3bdd9396$var$MONTH_DAYS = 29;
const $0f5324ee3bdd9396$var$MONTH_FRACT = 12 * $0f5324ee3bdd9396$var$HOUR_PARTS + 793;
const $0f5324ee3bdd9396$var$MONTH_PARTS = $0f5324ee3bdd9396$var$MONTH_DAYS * $0f5324ee3bdd9396$var$DAY_PARTS + $0f5324ee3bdd9396$var$MONTH_FRACT;
function $0f5324ee3bdd9396$var$isLeapYear(year) {
    return (0, $a5090d6430502238$export$842a2cf37af977e1)(year * 7 + 1, 19) < 7;
}
// Test for delay of start of new year and to avoid
// Sunday, Wednesday, and Friday as start of the new year.
function $0f5324ee3bdd9396$var$hebrewDelay1(year) {
    let months = Math.floor((235 * year - 234) / 19);
    let parts = 12084 + 13753 * months;
    let day = months * 29 + Math.floor(parts / 25920);
    if ((0, $a5090d6430502238$export$842a2cf37af977e1)(3 * (day + 1), 7) < 3) day += 1;
    return day;
}
// Check for delay in start of new year due to length of adjacent years
function $0f5324ee3bdd9396$var$hebrewDelay2(year) {
    let last = $0f5324ee3bdd9396$var$hebrewDelay1(year - 1);
    let present = $0f5324ee3bdd9396$var$hebrewDelay1(year);
    let next = $0f5324ee3bdd9396$var$hebrewDelay1(year + 1);
    if (next - present === 356) return 2;
    if (present - last === 382) return 1;
    return 0;
}
function $0f5324ee3bdd9396$var$startOfYear(year) {
    return $0f5324ee3bdd9396$var$hebrewDelay1(year) + $0f5324ee3bdd9396$var$hebrewDelay2(year);
}
function $0f5324ee3bdd9396$var$getDaysInYear(year) {
    return $0f5324ee3bdd9396$var$startOfYear(year + 1) - $0f5324ee3bdd9396$var$startOfYear(year);
}
function $0f5324ee3bdd9396$var$getYearType(year) {
    let yearLength = $0f5324ee3bdd9396$var$getDaysInYear(year);
    if (yearLength > 380) yearLength -= 30; // Subtract length of leap month.
    switch(yearLength){
        case 353:
            return 0; // deficient
        case 354:
            return 1; // normal
        case 355:
            return 2; // complete
    }
}
function $0f5324ee3bdd9396$var$getDaysInMonth(year, month) {
    // Normalize month numbers from 1 - 13, even on non-leap years
    if (month >= 6 && !$0f5324ee3bdd9396$var$isLeapYear(year)) month++;
    // First of all, dispose of fixed-length 29 day months
    if (month === 4 || month === 7 || month === 9 || month === 11 || month === 13) return 29;
    let yearType = $0f5324ee3bdd9396$var$getYearType(year);
    // If it's Heshvan, days depend on length of year
    if (month === 2) return yearType === 2 ? 30 : 29;
    // Similarly, Kislev varies with the length of year
    if (month === 3) return yearType === 0 ? 29 : 30;
    // Adar I only exists in leap years
    if (month === 6) return $0f5324ee3bdd9396$var$isLeapYear(year) ? 30 : 0;
    return 30;
}
class $0f5324ee3bdd9396$export$ca405048b8fb5af {
    fromJulianDay(jd) {
        let d = jd - $0f5324ee3bdd9396$var$HEBREW_EPOCH;
        let m = d * $0f5324ee3bdd9396$var$DAY_PARTS / $0f5324ee3bdd9396$var$MONTH_PARTS; // Months (approx)
        let year = Math.floor((19 * m + 234) / 235) + 1; // Years (approx)
        let ys = $0f5324ee3bdd9396$var$startOfYear(year); // 1st day of year
        let dayOfYear = Math.floor(d - ys);
        // Because of the postponement rules, it's possible to guess wrong.  Fix it.
        while(dayOfYear < 1){
            year--;
            ys = $0f5324ee3bdd9396$var$startOfYear(year);
            dayOfYear = Math.floor(d - ys);
        }
        // Now figure out which month we're in, and the date within that month
        let month = 1;
        let monthStart = 0;
        while(monthStart < dayOfYear){
            monthStart += $0f5324ee3bdd9396$var$getDaysInMonth(year, month);
            month++;
        }
        month--;
        monthStart -= $0f5324ee3bdd9396$var$getDaysInMonth(year, month);
        let day = dayOfYear - monthStart;
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, year, month, day);
    }
    toJulianDay(date) {
        let jd = $0f5324ee3bdd9396$var$startOfYear(date.year);
        for(let month = 1; month < date.month; month++)jd += $0f5324ee3bdd9396$var$getDaysInMonth(date.year, month);
        return jd + date.day + $0f5324ee3bdd9396$var$HEBREW_EPOCH;
    }
    getDaysInMonth(date) {
        return $0f5324ee3bdd9396$var$getDaysInMonth(date.year, date.month);
    }
    getMonthsInYear(date) {
        return $0f5324ee3bdd9396$var$isLeapYear(date.year) ? 13 : 12;
    }
    getDaysInYear(date) {
        return $0f5324ee3bdd9396$var$getDaysInYear(date.year);
    }
    getYearsInEra() {
        // 6239 gregorian
        return 9999;
    }
    getEras() {
        return [
            "AM"
        ];
    }
    balanceYearMonth(date, previousDate) {
        // Keep date in the same month when switching between leap years and non leap years
        if (previousDate.year !== date.year) {
            if ($0f5324ee3bdd9396$var$isLeapYear(previousDate.year) && !$0f5324ee3bdd9396$var$isLeapYear(date.year) && previousDate.month > 6) date.month--;
            else if (!$0f5324ee3bdd9396$var$isLeapYear(previousDate.year) && $0f5324ee3bdd9396$var$isLeapYear(date.year) && previousDate.month > 6) date.month++;
        }
    }
    constructor(){
        this.identifier = "hebrew";
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from ICU.
// Original licensing can be found in the NOTICE file in the root directory of this source tree.

const $4db04d1051af0f2f$var$ETHIOPIC_EPOCH = 1723856;
const $4db04d1051af0f2f$var$COPTIC_EPOCH = 1824665;
// The delta between Amete Alem 1 and Amete Mihret 1
// AA 5501 = AM 1
const $4db04d1051af0f2f$var$AMETE_MIHRET_DELTA = 5500;
function $4db04d1051af0f2f$var$ceToJulianDay(epoch, year, month, day) {
    return epoch // difference from Julian epoch to 1,1,1
     + 365 * year // number of days from years
     + Math.floor(year / 4) // extra day of leap year
     + 30 * (month - 1 // number of days from months (1 based)
    ) + day - 1 // number of days for present month (1 based)
    ;
}
function $4db04d1051af0f2f$var$julianDayToCE(epoch, jd) {
    let year = Math.floor(4 * (jd - epoch) / 1461);
    let month = 1 + Math.floor((jd - $4db04d1051af0f2f$var$ceToJulianDay(epoch, year, 1, 1)) / 30);
    let day = jd + 1 - $4db04d1051af0f2f$var$ceToJulianDay(epoch, year, month, 1);
    return [
        year,
        month,
        day
    ];
}
function $4db04d1051af0f2f$var$getLeapDay(year) {
    return Math.floor(year % 4 / 3);
}
function $4db04d1051af0f2f$var$getDaysInMonth(year, month) {
    // The Ethiopian and Coptic calendars have 13 months, 12 of 30 days each and
    // an intercalary month at the end of the year of 5 or 6 days, depending whether
    // the year is a leap year or not. The Leap Year follows the same rules as the
    // Julian Calendar so that the extra month always has six days in the year before
    // a Julian Leap Year.
    if (month % 13 !== 0) // not intercalary month
    return 30;
    else // intercalary month 5 days + possible leap day
    return $4db04d1051af0f2f$var$getLeapDay(year) + 5;
}
class $4db04d1051af0f2f$export$26ba6eab5e20cd7d {
    fromJulianDay(jd) {
        let [year, month, day] = $4db04d1051af0f2f$var$julianDayToCE($4db04d1051af0f2f$var$ETHIOPIC_EPOCH, jd);
        let era = "AM";
        if (year <= 0) {
            era = "AA";
            year += $4db04d1051af0f2f$var$AMETE_MIHRET_DELTA;
        }
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, era, year, month, day);
    }
    toJulianDay(date) {
        let year = date.year;
        if (date.era === "AA") year -= $4db04d1051af0f2f$var$AMETE_MIHRET_DELTA;
        return $4db04d1051af0f2f$var$ceToJulianDay($4db04d1051af0f2f$var$ETHIOPIC_EPOCH, year, date.month, date.day);
    }
    getDaysInMonth(date) {
        return $4db04d1051af0f2f$var$getDaysInMonth(date.year, date.month);
    }
    getMonthsInYear() {
        return 13;
    }
    getDaysInYear(date) {
        return 365 + $4db04d1051af0f2f$var$getLeapDay(date.year);
    }
    getYearsInEra(date) {
        // 9999-12-31 gregorian is 9992-20-02 ethiopic.
        // Round down to 9991 for the last full year.
        // AA 9999-01-01 ethiopic is 4506-09-30 gregorian.
        return date.era === "AA" ? 9999 : 9991;
    }
    getEras() {
        return [
            "AA",
            "AM"
        ];
    }
    constructor(){
        this.identifier = "ethiopic";
    }
}
class $4db04d1051af0f2f$export$d72e0c37005a4914 extends $4db04d1051af0f2f$export$26ba6eab5e20cd7d {
    fromJulianDay(jd) {
        let [year, month, day] = $4db04d1051af0f2f$var$julianDayToCE($4db04d1051af0f2f$var$ETHIOPIC_EPOCH, jd);
        year += $4db04d1051af0f2f$var$AMETE_MIHRET_DELTA;
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, "AA", year, month, day);
    }
    getEras() {
        return [
            "AA"
        ];
    }
    getYearsInEra() {
        // 9999-13-04 ethioaa is the maximum date, which is equivalent to 4506-09-29 gregorian.
        return 9999;
    }
    constructor(...args){
        super(...args);
        this.identifier = "ethioaa" // also known as 'ethiopic-amete-alem' in ICU
        ;
    }
}
class $4db04d1051af0f2f$export$fe6243cbe1a4b7c1 extends $4db04d1051af0f2f$export$26ba6eab5e20cd7d {
    fromJulianDay(jd) {
        let [year, month, day] = $4db04d1051af0f2f$var$julianDayToCE($4db04d1051af0f2f$var$COPTIC_EPOCH, jd);
        let era = "CE";
        if (year <= 0) {
            era = "BCE";
            year = 1 - year;
        }
        return new (0, $625ad1e1f4c43bc1$export$99faa760c7908e4f)(this, era, year, month, day);
    }
    toJulianDay(date) {
        let year = date.year;
        if (date.era === "BCE") year = 1 - year;
        return $4db04d1051af0f2f$var$ceToJulianDay($4db04d1051af0f2f$var$COPTIC_EPOCH, year, date.month, date.day);
    }
    getDaysInMonth(date) {
        let year = date.year;
        if (date.era === "BCE") year = 1 - year;
        return $4db04d1051af0f2f$var$getDaysInMonth(year, date.month);
    }
    isInverseEra(date) {
        return date.era === "BCE";
    }
    balanceDate(date) {
        if (date.year <= 0) {
            date.era = date.era === "BCE" ? "CE" : "BCE";
            date.year = 1 - date.year;
        }
    }
    getEras() {
        return [
            "BCE",
            "CE"
        ];
    }
    getYearsInEra(date) {
        // 9999-12-30 gregorian is 9716-02-20 coptic.
        // Round down to 9715 for the last full year.
        // BCE 9999-01-01 coptic is BC 9716-06-15 gregorian.
        return date.era === "BCE" ? 9999 : 9715;
    }
    constructor(...args){
        super(...args);
        this.identifier = "coptic";
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 








function $4922c0a5a69da0ba$export$dd0bbc9b26defe37(name) {
    switch(name){
        case "buddhist":
            return new (0, $561c4ef058278b74$export$42d20a78301dee44)();
        case "ethiopic":
            return new (0, $4db04d1051af0f2f$export$26ba6eab5e20cd7d)();
        case "ethioaa":
            return new (0, $4db04d1051af0f2f$export$d72e0c37005a4914)();
        case "coptic":
            return new (0, $4db04d1051af0f2f$export$fe6243cbe1a4b7c1)();
        case "hebrew":
            return new (0, $0f5324ee3bdd9396$export$ca405048b8fb5af)();
        case "indian":
            return new (0, $5f1dfa5c67609fe6$export$39f31c639fa15726)();
        case "islamic-civil":
            return new (0, $ecb2c4cc8c9aae25$export$2066795aadd37bfc)();
        case "islamic-tbla":
            return new (0, $ecb2c4cc8c9aae25$export$37f0887f2f9d22f7)();
        case "islamic-umalqura":
            return new (0, $ecb2c4cc8c9aae25$export$5baab4758c231076)();
        case "japanese":
            return new (0, $b0ac0602ef646b2c$export$b746ab2b60cdffbf)();
        case "persian":
            return new (0, $3c060181fc7249ae$export$37fccdbfd14c5939)();
        case "roc":
            return new (0, $9cc5d3577ec40243$export$65e01080afcb0799)();
        case "gregory":
        default:
            return new (0, $af14c9812fdceb33$export$80ee6245ec4f29ec)();
    }
}





/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ let $8f23a04ae90a588b$var$formatterCache = new Map();
class $8f23a04ae90a588b$export$ad991b66133851cf {
    /** Formats a date as a string according to the locale and format options passed to the constructor. */ format(value) {
        return this.formatter.format(value);
    }
    /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */ formatToParts(value) {
        return this.formatter.formatToParts(value);
    }
    /** Formats a date range as a string. */ formatRange(start, end) {
        // @ts-ignore
        if (typeof this.formatter.formatRange === "function") // @ts-ignore
        return this.formatter.formatRange(start, end);
        if (end < start) throw new RangeError("End date must be >= start date");
        // Very basic fallback for old browsers.
        return `${this.formatter.format(start)} – ${this.formatter.format(end)}`;
    }
    /** Formats a date range as an array of parts. */ formatRangeToParts(start, end) {
        // @ts-ignore
        if (typeof this.formatter.formatRangeToParts === "function") // @ts-ignore
        return this.formatter.formatRangeToParts(start, end);
        if (end < start) throw new RangeError("End date must be >= start date");
        let startParts = this.formatter.formatToParts(start);
        let endParts = this.formatter.formatToParts(end);
        return [
            ...startParts.map((p)=>({
                    ...p,
                    source: "startRange"
                })),
            {
                type: "literal",
                value: " – ",
                source: "shared"
            },
            ...endParts.map((p)=>({
                    ...p,
                    source: "endRange"
                }))
        ];
    }
    /** Returns the resolved formatting options based on the values passed to the constructor. */ resolvedOptions() {
        let resolvedOptions = this.formatter.resolvedOptions();
        if ($8f23a04ae90a588b$var$hasBuggyResolvedHourCycle()) {
            if (!this.resolvedHourCycle) this.resolvedHourCycle = $8f23a04ae90a588b$var$getResolvedHourCycle(resolvedOptions.locale, this.options);
            resolvedOptions.hourCycle = this.resolvedHourCycle;
            resolvedOptions.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12";
        }
        // Safari uses a different name for the Ethiopic (Amete Alem) calendar.
        // https://bugs.webkit.org/show_bug.cgi?id=241564
        if (resolvedOptions.calendar === "ethiopic-amete-alem") resolvedOptions.calendar = "ethioaa";
        return resolvedOptions;
    }
    constructor(locale, options = {}){
        this.formatter = $8f23a04ae90a588b$var$getCachedDateFormatter(locale, options);
        this.options = options;
    }
}
// There are multiple bugs involving the hour12 and hourCycle options in various browser engines.
//   - Chrome [1] (and the ECMA 402 spec [2]) resolve hour12: false in English and other locales to h24 (24:00 - 23:59)
//     rather than h23 (00:00 - 23:59). Same can happen with hour12: true in French, which Chrome resolves to h11 (00:00 - 11:59)
//     rather than h12 (12:00 - 11:59).
//   - WebKit returns an incorrect hourCycle resolved option in the French locale due to incorrect parsing of 'h' literal
//     in the resolved pattern. It also formats incorrectly when specifying the hourCycle option for the same reason. [3]
// [1] https://bugs.chromium.org/p/chromium/issues/detail?id=1045791
// [2] https://github.com/tc39/ecma402/issues/402
// [3] https://bugs.webkit.org/show_bug.cgi?id=229313
// https://github.com/unicode-org/cldr/blob/018b55eff7ceb389c7e3fc44e2f657eae3b10b38/common/supplemental/supplementalData.xml#L4774-L4802
const $8f23a04ae90a588b$var$hour12Preferences = {
    true: {
        // Only Japanese uses the h11 style for 12 hour time. All others use h12.
        ja: "h11"
    },
    false: {
    }
};
function $8f23a04ae90a588b$var$getCachedDateFormatter(locale, options = {}) {
    // Work around buggy hour12 behavior in Chrome / ECMA 402 spec by using hourCycle instead.
    // Only apply the workaround if the issue is detected, because the hourCycle option is buggy in Safari.
    if (typeof options.hour12 === "boolean" && $8f23a04ae90a588b$var$hasBuggyHour12Behavior()) {
        options = {
            ...options
        };
        let pref = $8f23a04ae90a588b$var$hour12Preferences[String(options.hour12)][locale.split("-")[0]];
        let defaultHourCycle = options.hour12 ? "h12" : "h23";
        options.hourCycle = pref !== null && pref !== void 0 ? pref : defaultHourCycle;
        delete options.hour12;
    }
    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : "");
    if ($8f23a04ae90a588b$var$formatterCache.has(cacheKey)) return $8f23a04ae90a588b$var$formatterCache.get(cacheKey);
    let numberFormatter = new Intl.DateTimeFormat(locale, options);
    $8f23a04ae90a588b$var$formatterCache.set(cacheKey, numberFormatter);
    return numberFormatter;
}
let $8f23a04ae90a588b$var$_hasBuggyHour12Behavior = null;
function $8f23a04ae90a588b$var$hasBuggyHour12Behavior() {
    if ($8f23a04ae90a588b$var$_hasBuggyHour12Behavior == null) $8f23a04ae90a588b$var$_hasBuggyHour12Behavior = new Intl.DateTimeFormat("en-US", {
        hour: "numeric",
        hour12: false
    }).format(new Date(2020, 2, 3, 0)) === "24";
    return $8f23a04ae90a588b$var$_hasBuggyHour12Behavior;
}
let $8f23a04ae90a588b$var$_hasBuggyResolvedHourCycle = null;
function $8f23a04ae90a588b$var$hasBuggyResolvedHourCycle() {
    if ($8f23a04ae90a588b$var$_hasBuggyResolvedHourCycle == null) $8f23a04ae90a588b$var$_hasBuggyResolvedHourCycle = new Intl.DateTimeFormat("fr", {
        hour: "numeric",
        hour12: false
    }).resolvedOptions().hourCycle === "h12";
    return $8f23a04ae90a588b$var$_hasBuggyResolvedHourCycle;
}
function $8f23a04ae90a588b$var$getResolvedHourCycle(locale, options) {
    if (!options.timeStyle && !options.hour) return undefined;
    // Work around buggy results in resolved hourCycle and hour12 options in WebKit.
    // Format the minimum possible hour and maximum possible hour in a day and parse the results.
    locale = locale.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, "");
    locale += (locale.includes("-u-") ? "" : "-u") + "-nu-latn";
    let formatter = $8f23a04ae90a588b$var$getCachedDateFormatter(locale, {
        ...options,
        timeZone: undefined // use local timezone
    });
    let min = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 0)).find((p)=>p.type === "hour").value, 10);
    let max = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 23)).find((p)=>p.type === "hour").value, 10);
    if (min === 0 && max === 23) return "h23";
    if (min === 24 && max === 23) return "h24";
    if (min === 0 && max === 11) return "h11";
    if (min === 12 && max === 11) return "h12";
    throw new Error("Unexpected hour cycle result");
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 81020:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $g9nQA$intlmessageformat = __webpack_require__(34559);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "MessageDictionary", () => $9a5a7b8408290694$export$64839e615120df17);
$parcel$export(module.exports, "MessageFormatter", () => $7a31ee9993c13f0b$export$526ebc05ff964723);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ class $9a5a7b8408290694$export$64839e615120df17 {
    getStringForLocale(key, locale) {
        let strings = this.messages[locale];
        if (!strings) {
            strings = $9a5a7b8408290694$var$getStringsForLocale(locale, this.messages, this.defaultLocale);
            this.messages[locale] = strings;
        }
        let string = strings[key];
        if (!string) throw new Error(`Could not find intl message ${key} in ${locale} locale`);
        return string;
    }
    constructor(messages, defaultLocale = "en-US"){
        // Clone messages so we don't modify the original object.
        this.messages = {
            ...messages
        };
        this.defaultLocale = defaultLocale;
    }
}
function $9a5a7b8408290694$var$getStringsForLocale(locale, strings, defaultLocale = "en-US") {
    // If there is an exact match, use it.
    if (strings[locale]) return strings[locale];
    // Attempt to find the closest match by language.
    // For example, if the locale is fr-CA (French Canadian), but there is only
    // an fr-FR (France) set of strings, use that.
    // This could be replaced with Intl.LocaleMatcher once it is supported.
    // https://github.com/tc39/proposal-intl-localematcher
    let language = $9a5a7b8408290694$var$getLanguage(locale);
    if (strings[language]) return strings[language];
    for(let key in strings){
        if (key.startsWith(language + "-")) return strings[key];
    }
    // Nothing close, use english.
    return strings[defaultLocale];
}
function $9a5a7b8408290694$var$getLanguage(locale) {
    // @ts-ignore
    if (Intl.Locale) // @ts-ignore
    return new Intl.Locale(locale).language;
    return locale.split("-")[0];
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
class $7a31ee9993c13f0b$export$526ebc05ff964723 {
    format(key, variables) {
        let message = this.cache[key];
        if (!message) {
            let msg = this.messages.getStringForLocale(key, this.locale);
            if (!msg) throw new Error(`Could not find intl message ${key} in ${this.locale} locale`);
            message = new (0, ($parcel$interopDefault($g9nQA$intlmessageformat)))(msg, this.locale);
            this.cache[key] = message;
        }
        let varCopy;
        if (variables) varCopy = Object.keys(variables).reduce((acc, key)=>{
            acc[key] = variables[key] == null ? false : variables[key];
            return acc;
        }, {});
        return message.format(varCopy);
    }
    constructor(locale, messages){
        this.locale = locale;
        this.messages = messages;
        this.cache = {};
    }
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 8483:
/***/ ((module) => {

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "NumberFormatter", () => $0c1d5654b62fc485$export$cc77c4ff7e8673c5);
$parcel$export(module.exports, "NumberParser", () => $d68f3f4c684426c6$export$cd11ab140839f11d);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ let $0c1d5654b62fc485$var$formatterCache = new Map();
let $0c1d5654b62fc485$var$supportsSignDisplay = false;
try {
    // @ts-ignore
    $0c1d5654b62fc485$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
        signDisplay: "exceptZero"
    }).resolvedOptions().signDisplay === "exceptZero";
// eslint-disable-next-line no-empty
} catch (e) {}
let $0c1d5654b62fc485$var$supportsUnit = false;
try {
    // @ts-ignore
    $0c1d5654b62fc485$var$supportsUnit = new Intl.NumberFormat("de-DE", {
        style: "unit",
        unit: "degree"
    }).resolvedOptions().style === "unit";
// eslint-disable-next-line no-empty
} catch (e) {}
// Polyfill for units since Safari doesn't support them yet. See https://bugs.webkit.org/show_bug.cgi?id=215438.
// Currently only polyfilling the unit degree in narrow format for ColorSlider in our supported locales.
// Values were determined by switching to each locale manually in Chrome.
const $0c1d5654b62fc485$var$UNITS = {
    degree: {
        narrow: {
            default: "\xb0",
            "ja-JP": " 度",
            "zh-TW": "度",
            "sl-SI": " \xb0"
        }
    }
};
class $0c1d5654b62fc485$export$cc77c4ff7e8673c5 {
    /** Formats a number value as a string, according to the locale and options provided to the constructor. */ format(value) {
        let res = "";
        if (!$0c1d5654b62fc485$var$supportsSignDisplay && this.options.signDisplay != null) res = $0c1d5654b62fc485$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);
        else res = this.numberFormatter.format(value);
        if (this.options.style === "unit" && !$0c1d5654b62fc485$var$supportsUnit) {
            var _UNITS_unit;
            let { unit: unit , unitDisplay: unitDisplay = "short" , locale: locale  } = this.resolvedOptions();
            let values = (_UNITS_unit = $0c1d5654b62fc485$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
            res += values[locale] || values.default;
        }
        return res;
    }
    /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */ formatToParts(value) {
        // TODO: implement signDisplay for formatToParts
        // @ts-ignore
        return this.numberFormatter.formatToParts(value);
    }
    /** Formats a number range as a string. */ formatRange(start, end) {
        // @ts-ignore
        if (typeof this.numberFormatter.formatRange === "function") // @ts-ignore
        return this.numberFormatter.formatRange(start, end);
        if (end < start) throw new RangeError("End date must be >= start date");
        // Very basic fallback for old browsers.
        return `${this.format(start)} – ${this.format(end)}`;
    }
    /** Formats a number range as an array of parts. */ formatRangeToParts(start, end) {
        // @ts-ignore
        if (typeof this.numberFormatter.formatRangeToParts === "function") // @ts-ignore
        return this.numberFormatter.formatRangeToParts(start, end);
        if (end < start) throw new RangeError("End date must be >= start date");
        let startParts = this.numberFormatter.formatToParts(start);
        let endParts = this.numberFormatter.formatToParts(end);
        return [
            ...startParts.map((p)=>({
                    ...p,
                    source: "startRange"
                })),
            {
                type: "literal",
                value: " – ",
                source: "shared"
            },
            ...endParts.map((p)=>({
                    ...p,
                    source: "endRange"
                }))
        ];
    }
    /** Returns the resolved formatting options based on the values passed to the constructor. */ resolvedOptions() {
        let options = this.numberFormatter.resolvedOptions();
        if (!$0c1d5654b62fc485$var$supportsSignDisplay && this.options.signDisplay != null) options = {
            ...options,
            signDisplay: this.options.signDisplay
        };
        if (!$0c1d5654b62fc485$var$supportsUnit && this.options.style === "unit") options = {
            ...options,
            style: "unit",
            unit: this.options.unit,
            unitDisplay: this.options.unitDisplay
        };
        return options;
    }
    constructor(locale, options = {}){
        this.numberFormatter = $0c1d5654b62fc485$var$getCachedNumberFormatter(locale, options);
        this.options = options;
    }
}
function $0c1d5654b62fc485$var$getCachedNumberFormatter(locale, options = {}) {
    let { numberingSystem: numberingSystem  } = options;
    if (numberingSystem && locale.indexOf("-u-nu-") === -1) locale = `${locale}-u-nu-${numberingSystem}`;
    if (options.style === "unit" && !$0c1d5654b62fc485$var$supportsUnit) {
        var _UNITS_unit;
        let { unit: unit , unitDisplay: unitDisplay = "short"  } = options;
        if (!unit) throw new Error('unit option must be provided with style: "unit"');
        if (!((_UNITS_unit = $0c1d5654b62fc485$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
        options = {
            ...options,
            style: "decimal"
        };
    }
    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : "");
    if ($0c1d5654b62fc485$var$formatterCache.has(cacheKey)) return $0c1d5654b62fc485$var$formatterCache.get(cacheKey);
    let numberFormatter = new Intl.NumberFormat(locale, options);
    $0c1d5654b62fc485$var$formatterCache.set(cacheKey, numberFormatter);
    return numberFormatter;
}
function $0c1d5654b62fc485$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
    if (signDisplay === "auto") return numberFormat.format(num);
    else if (signDisplay === "never") return numberFormat.format(Math.abs(num));
    else {
        let needsPositiveSign = false;
        if (signDisplay === "always") needsPositiveSign = num > 0 || Object.is(num, 0);
        else if (signDisplay === "exceptZero") {
            if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);
            else needsPositiveSign = num > 0;
        }
        if (needsPositiveSign) {
            let negative = numberFormat.format(-num);
            let noSign = numberFormat.format(num);
            // ignore RTL/LTR marker character
            let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
            if ([
                ...minus
            ].length !== 1) console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
            let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
            return positive;
        } else return numberFormat.format(num);
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ const $d68f3f4c684426c6$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
const $d68f3f4c684426c6$var$NUMBERING_SYSTEMS = [
    "latn",
    "arab",
    "hanidec"
];
class $d68f3f4c684426c6$export$cd11ab140839f11d {
    /**
   * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
   */ parse(value) {
        return $d68f3f4c684426c6$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
    }
    /**
   * Returns whether the given string could potentially be a valid number. This should be used to
   * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
   * of the minus/plus sign characters can be checked.
   */ isValidPartialNumber(value, minValue, maxValue) {
        return $d68f3f4c684426c6$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);
    }
    /**
   * Returns a numbering system for which the given string is valid in the current locale.
   * If no numbering system could be detected, the default numbering system for the current
   * locale is returned.
   */ getNumberingSystem(value) {
        return $d68f3f4c684426c6$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
    }
    constructor(locale, options = {}){
        this.locale = locale;
        this.options = options;
    }
}
const $d68f3f4c684426c6$var$numberParserCache = new Map();
function $d68f3f4c684426c6$var$getNumberParserImpl(locale, options, value) {
    // First try the default numbering system for the provided locale
    let defaultParser = $d68f3f4c684426c6$var$getCachedNumberParser(locale, options);
    // If that doesn't match, and the locale doesn't include a hard coded numbering system,
    // try each of the other supported numbering systems until we find one that matches.
    if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value)) {
        for (let numberingSystem of $d68f3f4c684426c6$var$NUMBERING_SYSTEMS)if (numberingSystem !== defaultParser.options.numberingSystem) {
            let parser = $d68f3f4c684426c6$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options);
            if (parser.isValidPartialNumber(value)) return parser;
        }
    }
    return defaultParser;
}
function $d68f3f4c684426c6$var$getCachedNumberParser(locale, options) {
    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : "");
    let parser = $d68f3f4c684426c6$var$numberParserCache.get(cacheKey);
    if (!parser) {
        parser = new $d68f3f4c684426c6$var$NumberParserImpl(locale, options);
        $d68f3f4c684426c6$var$numberParserCache.set(cacheKey, parser);
    }
    return parser;
}
// The actual number parser implementation. Instances of this class are cached
// based on the locale, options, and detected numbering system.
class $d68f3f4c684426c6$var$NumberParserImpl {
    parse(value) {
        // to parse the number, we need to remove anything that isn't actually part of the number, for example we want '-10.40' not '-10.40 USD'
        let fullySanitizedValue = this.sanitize(value);
        // Remove group characters, and replace decimal points and numerals with ASCII values.
        fullySanitizedValue = $d68f3f4c684426c6$var$replaceAll(fullySanitizedValue, this.symbols.group, "").replace(this.symbols.decimal, ".").replace(this.symbols.minusSign, "-").replace(this.symbols.numeral, this.symbols.index);
        let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
        if (isNaN(newValue)) return NaN;
        // accounting will always be stripped to a positive number, so if it's accounting and has a () around everything, then we need to make it negative again
        if (this.options.currencySign === "accounting" && $d68f3f4c684426c6$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
        // when reading the number, if it's a percent, then it should be interpreted as being divided by 100
        if (this.options.style === "percent") {
            newValue /= 100;
            var _this_options_maximumFractionDigits;
            // after dividing to get the percent value, javascript may get .0210999999 instead of .0211, so fix the number of fraction digits
            newValue = +newValue.toFixed(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2);
        }
        return newValue;
    }
    sanitize(value) {
        // Remove literals and whitespace, which are allowed anywhere in the string
        value = value.replace(this.symbols.literals, "");
        // Replace the ASCII minus sign with the minus sign used in the current locale
        // so that both are allowed in case the user's keyboard doesn't have the locale's minus sign.
        value = value.replace("-", this.symbols.minusSign);
        // In arab numeral system, their decimal character is 1643, but most keyboards don't type that
        // instead they use the , (44) character or apparently the (1548) character.
        if (this.options.numberingSystem === "arab") {
            value = value.replace(",", this.symbols.decimal);
            value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
            value = $d68f3f4c684426c6$var$replaceAll(value, ".", this.symbols.group);
        }
        // fr-FR group character is char code 8239, but that's not a key on the french keyboard,
        // so allow 'period' as a group char and replace it with a space
        if (this.options.locale === "fr-FR") value = $d68f3f4c684426c6$var$replaceAll(value, ".", String.fromCharCode(8239));
        return value;
    }
    isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {
        value = this.sanitize(value);
        // Remove minus or plus sign, which must be at the start of the string.
        if (value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);
        else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);
        // Numbers cannot start with a group separator
        if (value.startsWith(this.symbols.group)) return false;
        // Remove numerals, groups, and decimals
        value = $d68f3f4c684426c6$var$replaceAll(value, this.symbols.group, "").replace(this.symbols.numeral, "").replace(this.symbols.decimal, "");
        // The number is valid if there are no remaining characters
        return value.length === 0;
    }
    constructor(locale, options = {}){
        this.formatter = new Intl.NumberFormat(locale, options);
        this.options = this.formatter.resolvedOptions();
        this.symbols = $d68f3f4c684426c6$var$getSymbols(this.formatter, this.options, options);
    }
}
const $d68f3f4c684426c6$var$nonLiteralParts = new Set([
    "decimal",
    "fraction",
    "integer",
    "minusSign",
    "plusSign",
    "group"
]);
function $d68f3f4c684426c6$var$getSymbols(formatter, intlOptions, originalOptions) {
    var _allParts_find, _posAllParts_find, _allParts_find1, _allParts_find2;
    // Note: some locale's don't add a group symbol until there is a ten thousands place
    let allParts = formatter.formatToParts(-10000.111);
    let posAllParts = formatter.formatToParts(10000.111);
    let singularParts = formatter.formatToParts(1);
    var _allParts_find_value;
    let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p)=>p.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
    let plusSign = (_posAllParts_find = posAllParts.find((p)=>p.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
    // Safari does not support the signDisplay option, but our number parser polyfills it.
    // If no plus sign was returned, but the original options contained signDisplay, default to the '+' character.
    // @ts-ignore
    if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always")) plusSign = "+";
    let decimal = (_allParts_find1 = allParts.find((p)=>p.type === "decimal")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
    let group = (_allParts_find2 = allParts.find((p)=>p.type === "group")) === null || _allParts_find2 === void 0 ? void 0 : _allParts_find2.value;
    // this set is also for a regex, it's all literals that might be in the string we want to eventually parse that
    // don't contribute to the numerical value
    let pluralLiterals = allParts.filter((p)=>!$d68f3f4c684426c6$var$nonLiteralParts.has(p.type)).map((p)=>$d68f3f4c684426c6$var$escapeRegex(p.value));
    let singularLiterals = singularParts.filter((p)=>!$d68f3f4c684426c6$var$nonLiteralParts.has(p.type)).map((p)=>$d68f3f4c684426c6$var$escapeRegex(p.value));
    let sortedLiterals = [
        ...new Set([
            ...singularLiterals,
            ...pluralLiterals
        ])
    ].sort((a, b)=>b.length - a.length);
    let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
    // These are for replacing non-latn characters with the latn equivalent
    let numerals = [
        ...new Intl.NumberFormat(intlOptions.locale, {
            useGrouping: false
        }).format(9876543210)
    ].reverse();
    let indexes = new Map(numerals.map((d, i)=>[
            d,
            i
        ]));
    let numeral = new RegExp(`[${numerals.join("")}]`, "g");
    let index = (d)=>String(indexes.get(d));
    return {
        minusSign: minusSign,
        plusSign: plusSign,
        decimal: decimal,
        group: group,
        literals: literals,
        numeral: numeral,
        index: index
    };
}
function $d68f3f4c684426c6$var$replaceAll(str, find, replace) {
    // @ts-ignore
    if (str.replaceAll) // @ts-ignore
    return str.replaceAll(find, replace);
    return str.split(find).join(replace);
}
function $d68f3f4c684426c6$var$escapeRegex(string) {
    return string.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 36058:
/***/ ((module) => {

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "LocalizedStringDictionary", () => $f80be5fd4d03dda9$export$c17fa47878dc55b6);
$parcel$export(module.exports, "LocalizedStringFormatter", () => $3e95fbf3429967d1$export$2f817fcdc4b89ae0);
/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ class $f80be5fd4d03dda9$export$c17fa47878dc55b6 {
    /** Returns a localized string for the given key and locale. */ getStringForLocale(key, locale) {
        let strings = this.strings[locale];
        if (!strings) {
            strings = $f80be5fd4d03dda9$var$getStringsForLocale(locale, this.strings, this.defaultLocale);
            this.strings[locale] = strings;
        }
        let string = strings[key];
        if (!string) throw new Error(`Could not find intl message ${key} in ${locale} locale`);
        return string;
    }
    constructor(messages, defaultLocale = "en-US"){
        // Clone messages so we don't modify the original object.
        this.strings = {
            ...messages
        };
        this.defaultLocale = defaultLocale;
    }
}
function $f80be5fd4d03dda9$var$getStringsForLocale(locale, strings, defaultLocale = "en-US") {
    // If there is an exact match, use it.
    if (strings[locale]) return strings[locale];
    // Attempt to find the closest match by language.
    // For example, if the locale is fr-CA (French Canadian), but there is only
    // an fr-FR (France) set of strings, use that.
    // This could be replaced with Intl.LocaleMatcher once it is supported.
    // https://github.com/tc39/proposal-intl-localematcher
    let language = $f80be5fd4d03dda9$var$getLanguage(locale);
    if (strings[language]) return strings[language];
    for(let key in strings){
        if (key.startsWith(language + "-")) return strings[key];
    }
    // Nothing close, use english.
    return strings[defaultLocale];
}
function $f80be5fd4d03dda9$var$getLanguage(locale) {
    // @ts-ignore
    if (Intl.Locale) // @ts-ignore
    return new Intl.Locale(locale).language;
    return locale.split("-")[0];
}


/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ const $3e95fbf3429967d1$var$pluralRulesCache = new Map();
const $3e95fbf3429967d1$var$numberFormatCache = new Map();
class $3e95fbf3429967d1$export$2f817fcdc4b89ae0 {
    /** Formats a localized string for the given key with the provided variables. */ format(key, variables) {
        let message = this.strings.getStringForLocale(key, this.locale);
        return typeof message === "function" ? message(variables, this) : message;
    }
    plural(count, options, type = "cardinal") {
        let opt = options["=" + count];
        if (opt) return typeof opt === "function" ? opt() : opt;
        let key = this.locale + ":" + type;
        let pluralRules = $3e95fbf3429967d1$var$pluralRulesCache.get(key);
        if (!pluralRules) {
            pluralRules = new Intl.PluralRules(this.locale, {
                type: type
            });
            $3e95fbf3429967d1$var$pluralRulesCache.set(key, pluralRules);
        }
        let selected = pluralRules.select(count);
        opt = options[selected] || options.other;
        return typeof opt === "function" ? opt() : opt;
    }
    number(value) {
        let numberFormat = $3e95fbf3429967d1$var$numberFormatCache.get(this.locale);
        if (!numberFormat) {
            numberFormat = new Intl.NumberFormat(this.locale);
            $3e95fbf3429967d1$var$numberFormatCache.set(this.locale, numberFormat);
        }
        return numberFormat.format(value);
    }
    select(options, value) {
        let opt = options[value] || options.other;
        return typeof opt === "function" ? opt() : opt;
    }
    constructor(locale, strings){
        this.locale = locale;
        this.strings = strings;
    }
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 77929:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.AvatarGroup=void 0;var r=e(__webpack_require__(18038)),t=__webpack_require__(73726),a=__webpack_require__(81595),u=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=o(r);if(t&&t.has(e))return t.get(e);var a={},u=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in e)if("default"!==n&&Object.prototype.hasOwnProperty.call(e,n)){var i=u?Object.getOwnPropertyDescriptor(e,n):null;i&&(i.get||i.set)?Object.defineProperty(a,n,i):a[n]=e[n]}a.default=e,t&&t.set(e,a);return a}(__webpack_require__(84382)),n=__webpack_require__(56786);function o(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(o=function(e){return e?t:r})(e)}const i=r.default.forwardRef(((e,r)=>{const{count:a,children:o,...i}=e,s=(0,t.useDOMRef)(r);return(0,n.jsxs)(u.default,{ref:s,...i,children:[o,a&&(0,n.jsxs)(u.StyledAvatarGroupCount,{className:"nextui-avatar-group-count",children:["+",a]})]})}));exports.AvatarGroup=i,a.__DEV__&&(i.displayName="NextUI.AvatarGroup"),i.toString=()=>".nextui-avatar-group";var s=i;exports["default"]=s;

/***/ }),

/***/ 84382:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var t=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledAvatarGroupCount=exports.StyledAvatarGroup=void 0;var e=__webpack_require__(88194),a=t(__webpack_require__(25355));const r=(0,e.styled)("span",{fontSize:"$xs",display:"inline-flex",alignItems:"center",marginLeft:"$3",color:"$text"});exports.StyledAvatarGroupCount=r;const o=(0,e.styled)("div",{dflex:"center",height:"auto",width:"max-content","@motion":{transition:"none"},[`& ${a.default}`]:{marginLeft:"-$space$5",transition:"$default",".only-text-avatar":{boxShadow:"$xs"}},".only-text-avatar":{boxShadow:"$xs"},variants:{animated:{true:{[`& ${a.default}:hover`]:{transform:"translate(-$space$5)"}}}},defaultVariants:{animated:!0}});exports.StyledAvatarGroup=o;var n=o;exports["default"]=n;

/***/ }),

/***/ 47454:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.Avatar=void 0;var t=__webpack_require__(94135),r=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=l(t);if(r&&r.has(e))return r.get(e);var a={},s=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in e)if("default"!==n&&Object.prototype.hasOwnProperty.call(e,n)){var u=s?Object.getOwnPropertyDescriptor(e,n):null;u&&(u.get||u.set)?Object.defineProperty(a,n,u):a[n]=e[n]}a.default=e,r&&r.set(e,a);return a}(__webpack_require__(18038)),a=__webpack_require__(77335),s=__webpack_require__(73726),n=__webpack_require__(81595),u=e(__webpack_require__(62358)),i=e(__webpack_require__(25355)),o=__webpack_require__(56786);function l(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(l=function(e){return e?r:t})(e)}const c=e=>(null==e?void 0:e.length)<=4?e:null==e?void 0:e.slice(0,3),f=r.default.forwardRef(((e,n)=>{const{as:l,src:f,css:p,text:d,icon:v,alt:x,className:m,imgRef:y,...b}=e,g=(0,s.useDOMRef)(n),j=!f,[q,O]=(0,r.useState)(!1),M=(0,s.useDOMRef)(y),{isFocusVisible:N,focusProps:_}=(0,t.useFocusRing)();(0,r.useEffect)((()=>{var e;(null==M||null==(e=M.current)?void 0:e.complete)&&O(!0)}),[]);const h=(0,r.useMemo)((()=>!q&&f?"loading":"ready"),[f,q]),P=(0,r.useMemo)((()=>{if("button"===l)return{appearance:"none",outline:"none",border:"none",cursor:"pointer"}}),[l]);return(0,o.jsxs)(i.default,{ref:g,as:l,...(0,a.mergeProps)(b,_),className:(0,u.default)({"only-text-avatar":j},m),css:{...P,...p},"data-state":h,isFocusVisible:N,children:[(0,o.jsx)("span",{className:"nextui-avatar-bg"}),!j&&(0,o.jsx)("img",{ref:M,alt:x,className:(0,u.default)("nextui-avatar-img",`nextui-avatar--${h}`,{"nextui-avatar-ready":q}),"data-state":h,src:f,onLoad:()=>O(!0)}),j&&!v&&d&&(0,o.jsx)("span",{className:"nextui-avatar-text",children:c(d)}),v&&(0,o.jsx)("span",{className:"nextui-avatar-icon",children:v})]})}));exports.Avatar=f,n.__DEV__&&(f.displayName="NextUI.Avatar"),f.toString=()=>".nextui-avatar";var p=f;exports["default"]=p;

/***/ }),

/***/ 25355:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=exports.StyledAvatar=void 0;var a=__webpack_require__(88194),t=__webpack_require__(74042);const e=(0,a.styled)("span",{dflex:"center",position:"relative",zIndex:"$1",boxSizing:"border-box",overflow:"hidden",verticalAlign:"top",cursor:"auto",transition:"transform 250ms ease 0ms, box-shadow 0.25s ease 0s",".nextui-avatar-bg":{position:"absolute",top:0,left:0,right:0,bottom:0,zIndex:"$2",transition:"$avatar",size:"100%"},".nextui-avatar-img":{opacity:0,zIndex:"$3",display:"flex",bg:"$background",transition:"transform 250ms ease 0ms, opacity 200ms ease-in 0ms",width:"100%",height:"100%",objectFit:"cover"},'&[data-state="ready"] .nextui-avatar-img':{opacity:1},".nextui-avatar-icon":{display:"flex",position:"absolute",left:"50%",top:"50%",ta:"center",zIndex:"$2",transform:"translate(-50%, -50%)",whiteSpace:"nowrap",us:"none"},".nextui-avatar-text":{position:"absolute",zIndex:"$2",left:"50%",top:"50%",ta:"center",color:"$text",fontWeight:"$medium",transform:"translate(-50%, -50%) scale(0.65)",whiteSpace:"nowrap",us:"none"},"@motion":{transition:"none",".nextui-avatar-bg, .nextui-avatar-img":{transition:"none"}},variants:{color:{default:{".nextui-avatar-bg":{bg:"$accents2"}},primary:{".nextui-avatar-bg":{bg:"$primary"}},secondary:{".nextui-avatar-bg":{bg:"$secondary"}},success:{".nextui-avatar-bg":{bg:"$success"}},warning:{".nextui-avatar-bg":{bg:"$warning"}},error:{".nextui-avatar-bg":{bg:"$error"}},gradient:{".nextui-avatar-bg":{bg:"$gradient"}}},textColor:{default:{".nextui-avatar-text":{color:"$text"}},white:{".nextui-avatar-text":{color:"$white"}},primary:{".nextui-avatar-text":{color:"$primary"}},secondary:{".nextui-avatar-text":{color:"$secondary"}},success:{".nextui-avatar-text":{color:"$success"}},warning:{".nextui-avatar-text":{color:"$warning"}},error:{".nextui-avatar-text":{color:"$error"}}},size:{xs:{$$avatarXs:"$space$9",sizeMin:"$$avatarXs",".nextui-avatar-text":{fontSize:"$sm"}},sm:{$$avatarSm:"$space$11",sizeMin:"$$avatarSm",".nextui-avatar-text":{fontSize:"$md"}},md:{$$avatarMd:"$space$14",sizeMin:"$$avatarMd",".nextui-avatar-text":{fontSize:"$lg"}},lg:{$$avatarLg:"$space$16",sizeMin:"$$avatarLg",".nextui-avatar-text":{fontSize:"$xl"}},xl:{$$avatarXl:"$space$18",sizeMin:"$$avatarXl",".nextui-avatar-text":{fontSize:"$2xl"}}},borderWeight:{light:{".nextui-avatar-img":{borderWidth:"$light"}},normal:{".nextui-avatar-img":{borderWidth:"$normal"}},bold:{".nextui-avatar-img":{borderWidth:"$normal"}},extrabold:{".nextui-avatar-img":{borderWidth:"$normal"}},black:{".nextui-avatar-img":{borderWidth:"$normal"}}},bordered:{true:{".nextui-avatar-img":{borderStyle:"solid",borderColor:"$background"}}},stacked:{true:{ml:"-$5"}},pointer:{true:{cursor:"pointer","&:hover .nextui-avatar-bg":{boxShadow:"inset 0 0 40px 0 rgb(0 0 0 / 14%)"}}},rounded:{true:{borderRadius:"$rounded",".nextui-avatar-img":{borderRadius:"$rounded"}}},squared:{true:{borderRadius:"$squared",".nextui-avatar-img":{borderRadius:"$squared"}}},zoomed:{true:{"&:hover .nextui-avatar-img":{transform:"scale(1.125)"}}}},compoundVariants:[{bordered:!0,borderWeight:"light",css:{padding:"calc($1/2)"}},{bordered:!0,borderWeight:"normal",css:{padding:"$1"}},{bordered:!0,borderWeight:"bold",css:{padding:"calc($2/1.5)"}},{bordered:!0,borderWeight:"extrabold",css:{padding:"$2"}},{bordered:!0,borderWeight:"black",css:{padding:"calc($3/1.5)"}},{rounded:!0,squared:!0,css:{borderRadius:"$squared",".nextui-avatar-img":{borderRadius:"$squared"}}},{bordered:!0,pointer:!0,css:{"&:hover:not(.only-text-avatar) .nextui-avatar-bg":{opacity:"0.7"}}}],defaultVariants:{size:"md",rounded:!0,color:"default",textColor:"default",borderWeight:"normal"}},t.cssFocusVisible);exports.StyledAvatar=e;var r=e;exports["default"]=r;

/***/ }),

/***/ 21013:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var r=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledAvatarGroupCount=exports.StyledAvatarGroup=exports.StyledAvatar=void 0;var e=r(__webpack_require__(47454)),t=r(__webpack_require__(77929)),a=__webpack_require__(25355);exports.StyledAvatar=a.StyledAvatar;var u=__webpack_require__(84382);exports.StyledAvatarGroup=u.StyledAvatarGroup,exports.StyledAvatarGroupCount=u.StyledAvatarGroupCount,e.default.Group=t.default;var o=e.default;exports["default"]=o;

/***/ }),

/***/ 8926:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=d(__webpack_require__(18038)),r=e(__webpack_require__(25457)),a=e(__webpack_require__(91863)),n=e(__webpack_require__(32821)),i=e(__webpack_require__(62358)),l=d(__webpack_require__(60690)),u=__webpack_require__(81595),s=__webpack_require__(17488),o=__webpack_require__(56786);function c(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(c=function(e){return e?r:t})(e)}function d(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=c(t);if(r&&r.has(e))return r.get(e);var a={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if("default"!==i&&Object.prototype.hasOwnProperty.call(e,i)){var l=n?Object.getOwnPropertyDescriptor(e,i):null;l&&(l.get||l.set)?Object.defineProperty(a,i,l):a[i]=e[i]}return a.default=e,r&&r.set(e,a),a}const p="nextui-backdrop",f=t.default.memo((({children:e,onClick:r,onKeyPress:u,visible:c,maxWidth:d,blur:f,animated:b,opacity:m,preventDefault:y,className:x,css:k,...v})=>{const[,h,j]=(0,n.default)(!1),q=e=>{j.current||r&&r(e)},M=(0,t.useCallback)((e=>{e.stopPropagation()}),[]),O=()=>{if(!j.current)return;const e=setTimeout((()=>{h(!1),clearTimeout(e)}),0)},{bindings:$}=(0,l.default)((e=>{u&&u(e)}),[l.KeyCode.Escape,l.KeyCode.Space],{disableGlobalEvent:!0,preventDefault:y}),g=(0,t.useMemo)((()=>c?"open":"closed"),[c]),w=(0,t.useMemo)((()=>(0,o.jsxs)(s.StyledBackdrop,{"aria-hidden":!0,className:(0,i.default)(p,`${p}--${g}`,x),css:{$$backdropOpacity:m,...k},"data-state":g,role:"button",tabIndex:-1,onClick:q,onMouseUp:O,...$,...v,children:[(0,o.jsx)(s.StyledBackdropLayer,{animated:b,blur:f,className:(0,i.default)(`${p}-layer`,f?`${p}-layer-blur`:`${p}-layer-default`)}),(0,o.jsx)(s.StyledBackdropContent,{animated:b,className:`${p}-content`,css:{maxWidth:d},onClick:M,onMouseDown:()=>h(!0),children:e})]})),[e]);return(0,o.jsx)(o.Fragment,{children:b?(0,o.jsx)(a.default,{clearTime:150,enterTime:20,leaveTime:20,name:`${p}-wrapper`,visible:c,children:w}):c?w:null})}));u.__DEV__&&(f.displayName="NextUI.Backdrop"),f.toString=()=>".nextui-backdrop";var b=(0,r.default)(f,{onClick:()=>{},visible:!1,blur:!1,animated:!0,preventDefault:!0,opacity:.5,className:""});exports["default"]=b,module.exports=exports.default;

/***/ }),

/***/ 17488:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledBackdropLayer=exports.StyledBackdropContent=exports.StyledBackdrop=void 0;var e=__webpack_require__(88194);const a=(0,e.keyframes)({"0%":{opacity:0},"60%":{opacity:.75},"100%":{opacity:1}}),t=(0,e.keyframes)({"0%":{opacity:0}}),i=(0,e.keyframes)({"0%":{backdropFilter:"saturate(0%) blur(0)"}}),r=(0,e.styled)("div",{position:"relative",display:"inline-block",zIndex:"$max",outline:"none",width:"100%",margin:"$9 auto",verticalAlign:"middle","@sm":{width:"90%",maxWidth:"90%"},variants:{animated:{true:{"&":{animationName:a,animationDuration:"200ms",animationTimingFunction:"ease-in",animationDirection:"normal"}},false:{transition:"none"}}}});exports.StyledBackdropContent=r;const n=(0,e.styled)("div",{position:"fixed",top:0,left:0,right:0,bottom:0,size:"100%",pe:"none",zIndex:"$max","@motion":{transition:"none"},variants:{blur:{true:{bg:"$black",opacity:"$$backdropOpacity","@supports ((-webkit-backdrop-filter: none) or (backdrop-filter: none))":{opacity:1,backdropFilter:"saturate(180%) blur(20px)",animationName:`${i}, ${t}`,bg:"rgba(0, 0, 0, 0.1)"}},false:{bg:"$black",opacity:"$$backdropOpacity",animationName:`${t}`,animationDuration:"0.2s",animationTimingFunction:"cubic-bezier(0.4, 0, 0.2, 1)"}},animated:{true:{animationName:`${t}`,animationDuration:"0.2s",animationTimingFunction:"cubic-bezier(0.4, 0, 0.2, 1)"},false:{transition:"none"}}}});exports.StyledBackdropLayer=n;const o=(0,e.styled)("div",{position:"fixed",top:0,left:0,right:0,bottom:0,overflow:"auto",zIndex:"$max",WebkitOverflowScrolling:"touch",boxSizing:"border-box",textAlign:"center","&:before":{content:"",display:"inline-block",width:0,height:"100%",verticalAlign:"middle"},".nextui-backdrop-wrapper-enter .nextui-backdrop-layer-default":{opacity:0},".nextui-backdrop-wrapper-enter-active .nextui-backdrop-layer-default":{opacity:"$$backdropOpacity"},".nextui-backdrop-wrapper-leave .nextui-backdrop-layer-default":{opacity:"$$backdropOpacity"},".nextui-backdrop-wrapper-leave-active .nextui-backdrop-layer-default":{opacity:0},".nextui-backdrop-wrapper-enter .nextui-backdrop-layer-blur":{bg:"rgba(0, 0, 0, 0.1)"},".nextui-backdrop-wrapper-enter-active .nextui-backdrop-layer-blur":{bg:"rgba(0, 0, 0, 0.4)"},".nextui-backdrop-wrapper-leave .nextui-backdrop-layer-blur":{bg:"rgba(0, 0, 0, 0.4)"},".nextui-backdrop-wrapper-leave-active .nextui-backdrop-layer-blur":{bg:"rgba(0, 0, 0, 0.1)"},variants:{fullScreen:{true:{display:"inline-flex",overflow:"hidden",[`& ${r}`]:{width:"100vw",maxWidth:"100vw",height:"100vh",margin:0},[`& ${n}`]:{display:"none"}}}},defaultVariants:{fullScreen:!1}});exports.StyledBackdrop=o;

/***/ }),

/***/ 41222:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledBackdropLayer=exports.StyledBackdropContent=exports.StyledBackdrop=void 0;var r=e(__webpack_require__(8926)),t=__webpack_require__(17488);exports.StyledBackdropContent=t.StyledBackdropContent,exports.StyledBackdropLayer=t.StyledBackdropLayer,exports.StyledBackdrop=t.StyledBackdrop;var o=r.default;exports["default"]=o;

/***/ }),

/***/ 86753:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.pointAnimation=exports.appearanceOutTopRight=exports.appearanceOutTopLeft=exports.appearanceOutBottomRight=exports.appearanceOutBottomLeft=exports.appearanceInTopRight=exports.appearanceInTopLeft=exports.appearanceInBottomRight=exports.appearanceInBottomLeft=void 0;var a=__webpack_require__(88194);const t=(0,a.keyframes)({"0%":{opacity:1},"50%":{opacity:"0.4",transform:"scale(0.5)"},"100%":{opacity:1}});exports.pointAnimation=t;const e=(0,a.keyframes)({"0%":{opacity:0,transform:"scale(0.2) translate(50%, -50%)"},"60%":{opacity:.75,transform:"scale(1.2) translate(50%, -50%)"},"100%":{opacity:1,transform:"scale(1) translate(50%, -50%)"}});exports.appearanceInTopRight=e;const r=(0,a.keyframes)({"0%":{opacity:1,transform:"scale(1) translate(50%, -50%)"},"100%":{opacity:0,transform:"scale(0.2) translate(50%, -50%)"}});exports.appearanceOutTopRight=r;const o=(0,a.keyframes)({"0%":{opacity:0,transform:"scale(0.2) translate(-50%, -50%)"},"60%":{opacity:.75,transform:"scale(1.2) translate(-50%, -50%)"},"100%":{opacity:1,transform:"scale(1) translate(-50%, -50%)"}});exports.appearanceInTopLeft=o;const s=(0,a.keyframes)({"0%":{opacity:1,transform:"scale(1) translate(-50%, -50%)"},"100%":{opacity:0,transform:"scale(0.2) translate(-50%, -50%)"}});exports.appearanceOutTopLeft=s;const p=(0,a.keyframes)({"0%":{opacity:0,transform:"scale(0.2) translate(50%, 50%)"},"60%":{opacity:.75,transform:"scale(1.2) translate(50%, 50%)"},"100%":{opacity:1,transform:"scale(1) translate(50%, 50%)"}});exports.appearanceInBottomRight=p;const n=(0,a.keyframes)({"0%":{opacity:1,transform:"scale(1) translate(50%, 50%)"},"100%":{opacity:0,transform:"scale(0.2) translate(50%, 50%)"}});exports.appearanceOutBottomRight=n;const c=(0,a.keyframes)({"0%":{opacity:0,transform:"scale(0.2) translate(-50%, 50%)"},"60%":{opacity:.75,transform:"scale(1.2) translate(-50%, 50%)"},"100%":{opacity:1,transform:"scale(1) translate(-50%, 50%)"}});exports.appearanceInBottomLeft=c;const l=(0,a.keyframes)({"0%":{opacity:1,transform:"scale(1) translate(-50%, 50%)"},"100%":{opacity:0,transform:"scale(0.2) translate(-50%, 50%)"}});exports.appearanceOutBottomLeft=l;

/***/ }),

/***/ 39930:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var a=o(t);if(a&&a.has(e))return a.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if("default"!==i&&Object.prototype.hasOwnProperty.call(e,i)){var s=n?Object.getOwnPropertyDescriptor(e,i):null;s&&(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}r.default=e,a&&a.set(e,r);return r}(__webpack_require__(18038)),a=__webpack_require__(93795),r=e(__webpack_require__(62358)),n=__webpack_require__(73726),i=__webpack_require__(81595),s=__webpack_require__(93099),l=__webpack_require__(56786);function o(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,a=new WeakMap;return(o=function(e){return e?a:t})(e)}const u=(0,a.forwardRef)(((e,a)=>{const{css:i,children:o,content:u,isInvisible:d=!1,disableOutline:f,placement:p="top-right",variant:c="default",verticalOffset:b,horizontalOffset:g,disableAnimation:m=!1,className:x,...y}=e,O=(0,n.useDOMRef)(a),v=void 0!==u&&!!o,h=t.useMemo((()=>{var e;return v&&u&&"points"!==c&&"dot"!==c?1===(null==(e=String(u))?void 0:e.length):!(!o||"string"!=typeof o)&&1===o.length}),[v,o,c,u]),j=t.useMemo((()=>"dot"===c?null:"points"===c?(0,l.jsxs)(s.StyledBadgePoints,{className:"nextui-badge-points",children:[(0,l.jsx)("span",{className:"nextui-badge-point","data-testid":"badge-point"}),(0,l.jsx)("span",{className:"nextui-badge-point","data-testid":"badge-point"}),(0,l.jsx)("span",{className:"nextui-badge-point","data-testid":"badge-point"})]}):v?u:o),[c,h,v,u,o]),$=t.useMemo((()=>{const e="number"==typeof g,t="number"==typeof b;return b&&g?{$$badgePlacementHOffset:e?`${g}px`:g,$$badgePlacementVOffset:t?`${b}px`:b,...i}:b?{$$badgePlacementVOffset:t?`${b}px`:b,...i}:g?{$$badgePlacementHOffset:e?`${g}px`:g,...i}:i}),[b,g,i]);return(0,l.jsxs)(s.StyledBadgeRoot,{ref:O,className:(0,r.default)("nextui-badge-root",x),children:[v&&o,(0,l.jsx)(s.StyledBadge,{asChild:v,className:(0,r.default)("nextui-badge",{"nextui-badge--is-invisible":d}),css:$,disableAnimation:m||!v,disableOutline:"bordered"===c||f,isOneChar:h,placement:p,variant:c,...y,children:j})]})}));i.__DEV__&&(u.displayName="NextUI.Badge"),u.toString=()=>".nextui-badge";var d=u;exports["default"]=d,module.exports=exports.default;

/***/ }),

/***/ 93099:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledBadgeRoot=exports.StyledBadgePoints=exports.StyledBadge=void 0;var e=__webpack_require__(88194),a=__webpack_require__(86753);const o=(0,e.styled)("span",{d:"inline-flex",flexShrink:0,verticalAlign:"middle",position:"relative",overflow:"visible"});exports.StyledBadgeRoot=o;const r=(0,e.styled)("span",{$$badgePlacementHOffset:"0%",$$badgePlacementVOffset:"0%",lineHeight:1,display:"flex",flexFlow:"row wrap",placeContent:"center",alignItems:"center",boxSizing:"border-box",whiteSpace:"nowrap",bg:"$$badgeBackgroundColor",color:"$$badgeTextColor",fontWeight:"$bold",fontSize:"$$badgeFontSize",p:"$$badgeVPadding $$badgeHPadding","@motion":{animation:"none",transition:"none","&.nextui-badge--is-invisible":{animation:"none",transition:"none"}},variants:{size:{xs:{$$badgeVPadding:"$space$2",$$badgeHPadding:"$space$2",$$badgeFontSize:"0.65rem"},sm:{$$badgeVPadding:"$space$2",$$badgeHPadding:"$space$3",$$badgeFontSize:"0.73rem"},md:{$$badgeVPadding:"$space$3",$$badgeHPadding:"$space$4",$$badgeFontSize:"$fontSizes$xs"},lg:{$$badgeVPadding:"$space$4",$$badgeHPadding:"$space$5",$$badgeFontSize:"$fontSizes$base"},xl:{$$badgeVPadding:"$space$5",$$badgeHPadding:"$space$6",$$badgeFontSize:"$fontSizes$xl"}},shape:{circle:{},rectangle:{}},asChild:{true:{zIndex:"$2",position:"absolute",lineHeight:1.5}},isOneChar:{true:{}},color:{default:{$$badgeBackgroundColor:"$colors$neutral",$$badgeTextColor:"$colors$neutralSolidContrast",$$badgeShadowColor:"$colors$neutralShadow"},primary:{$$badgeBackgroundColor:"$colors$primary",$$badgeTextColor:"$colors$primarySolidContrast",$$badgeShadowColor:"$colors$primaryShadow"},secondary:{$$badgeBackgroundColor:"$colors$secondary",$$badgeTextColor:"$colors$secondarySolidContrast",$$badgeShadowColor:"$colors$secondaryShadow"},success:{$$badgeBackgroundColor:"$colors$success",$$badgeTextColor:"$colors$successSolidContrast",$$badgeShadowColor:"$colors$successShadow"},warning:{$$badgeBackgroundColor:"$colors$warning",$$badgeTextColor:"$colors$warningSolidContrast",$$badgeShadowColor:"$colors$warningShadow"},error:{$$badgeBackgroundColor:"$colors$error",$$badgeTextColor:"$colors$errorSolidContrast",$$badgeShadowColor:"$colors$errorShadow"}},enableShadow:{true:{boxShadow:"0 2px 10px 0 $$badgeShadowColor"}},isSquared:{true:{borderRadius:"calc($$badgeFontSize * 0.45)"},false:{borderRadius:"$pill"}},placement:{"top-right":{animation:`${a.appearanceInTopRight} 0.25s ease-out`,"&.nextui-badge--is-invisible":{opacity:0,animation:`${a.appearanceOutTopRight} 0.2s ease-in`}},"top-left":{animation:`${a.appearanceInTopLeft} 0.25s ease-out`,"&.nextui-badge--is-invisible":{opacity:0,animation:`${a.appearanceOutTopLeft} 0.2s ease-in`}},"bottom-right":{animation:`${a.appearanceInBottomRight} 0.25s ease-out`,"&.nextui-badge--is-invisible":{opacity:0,animation:`${a.appearanceOutBottomRight} 0.2s ease-in`}},"bottom-left":{animation:`${a.appearanceInBottomLeft} 0.25s ease-out`,"&.nextui-badge--is-invisible":{opacity:0,animation:`${a.appearanceOutBottomLeft} 0.2s ease-in`}}},variant:{default:{},flat:{},dot:{p:0,dflex:"center",minSize:"$$badgeFontSize",boxSizing:"border-box"},points:{p:"calc($$badgeFontSize * 0.4)",boxSizing:"border-box",$$badgePlacementHOffset:"calc($$badgeFontSize * 0.8)"},bordered:{$$badgeBackgroundColor:"$colors$background",bg:"$background",bw:"$$badgeBorderWeight",borderStyle:"solid",borderColor:"$$badgeTextColor"}},borderWeight:{light:{$$badgeBorderWeight:"$borderWeights$light"},normal:{$$badgeBorderWeight:"$borderWeights$normal"},bold:{$$badgeBorderWeight:"$borderWeights$bold"},extrabold:{$$badgeBorderWeight:"$borderWeights$extrabold"},black:{$$badgeBorderWeight:"$borderWeights$black"}},disableOutline:{true:{border:"2px solid transparent"},false:{border:"2px solid $colors$background"}},disableAnimation:{true:{animation:"none",transition:"none","&.nextui-badge--is-invisible":{animation:"none",transition:"none"}}}},compoundVariants:[{variant:"flat",color:"default",css:{$$badgeBackgroundColor:"$colors$neutralLight",$$badgeTextColor:"$colors$neutralLightContrast"}},{variant:"flat",color:"primary",css:{$$badgeBackgroundColor:"$colors$primaryLight",$$badgeTextColor:"$colors$primaryLightContrast"}},{variant:"flat",color:"secondary",css:{$$badgeBackgroundColor:"$colors$secondaryLight",$$badgeTextColor:"$colors$secondaryLightContrast"}},{variant:"flat",color:"success",css:{$$badgeBackgroundColor:"$colors$successLight",$$badgeTextColor:"$colors$successLightContrast"}},{variant:"flat",color:"warning",css:{$$badgeBackgroundColor:"$colors$warningLight",$$badgeTextColor:"$colors$warningLightContrast"}},{variant:"flat",color:"error",css:{$$badgeBackgroundColor:"$colors$errorLight",$$badgeTextColor:"$colors$errorLightContrast"}},{variant:"bordered",color:"default",css:{$$badgeTextColor:"$colors$neutral"}},{variant:"bordered",color:"primary",css:{$$badgeTextColor:"$colors$primary"}},{variant:"bordered",color:"secondary",css:{$$badgeTextColor:"$colors$secondary"}},{variant:"bordered",color:"success",css:{$$badgeTextColor:"$colors$success"}},{variant:"bordered",color:"warning",css:{$$badgeTextColor:"$colors$warning"}},{variant:"bordered",color:"error",css:{$$badgeTextColor:"$colors$error"}},{asChild:!0,shape:"rectangle",placement:"top-right",css:{top:"calc(5% + $$badgePlacementVOffset)",right:"calc(5% + $$badgePlacementHOffset)",transform:"scale(1) translate(50%, -50%)",transformOrigin:"100% 0%"}},{asChild:!0,shape:"rectangle",placement:"top-left",css:{top:"calc(5% + $$badgePlacementVOffset)",left:"calc(5% + $$badgePlacementHOffset)",transform:"scale(1) translate(-50%, -50%)",transformOrigin:"0% 0%"}},{asChild:!0,shape:"rectangle",placement:"bottom-right",css:{bottom:"calc(5% + $$badgePlacementVOffset)",right:"calc(5% + $$badgePlacementHOffset)",transform:"scale(1) translate(50%, 50%)",transformOrigin:"100% 100%"}},{asChild:!0,shape:"rectangle",placement:"bottom-left",css:{bottom:"calc(5% + $$badgePlacementVOffset)",left:"calc(5% + $$badgePlacementHOffset)",transform:"scale(1) translate(-50%, 50%)",transformOrigin:"0% 100%"}},{asChild:!0,shape:"circle",placement:"top-right",css:{top:"calc(15% + $$badgePlacementVOffset)",right:"calc(15% + $$badgePlacementHOffset)",transform:"scale(1) translate(50%, -50%)",transformOrigin:"100% 0%"}},{asChild:!0,shape:"circle",placement:"top-left",css:{top:"calc(15% + $$badgePlacementVOffset)",left:"calc(15% + $$badgePlacementHOffset)",transform:"scale(1) translate(-50%, -50%)",transformOrigin:"0% 0%"}},{asChild:!0,shape:"circle",placement:"bottom-right",css:{bottom:"calc(15% + $$badgePlacementVOffset)",right:"calc(15% + $$badgePlacementHOffset)",transform:"scale(1) translate(50%, 50%)",transformOrigin:"100% 100%"}},{asChild:!0,shape:"circle",placement:"bottom-left",css:{bottom:"calc(15% + $$badgePlacementVOffset)",left:"calc(15% + $$badgePlacementHOffset)",transform:"scale(1) translate(-50%, 50%)",transformOrigin:"0% 100%"}},{variant:"dot",shape:"rectangle",css:{$$badgePlacementHOffset:"calc($$badgeFontSize * 0.2)",$$badgePlacementVOffset:"calc($$badgeFontSize * 0.1)"}},{isOneChar:!0,asChild:!0,css:{p:0,size:"calc($$badgeFontSize + $$badgeHPadding)"}},{isOneChar:!1,asChild:!0,css:{$$badgeVPadding:"0px",$$badgeHPadding:"$space$2"}},{isOneChar:!1,asChild:!0,size:"md",css:{$$badgeHPadding:"$space$3"}},{isOneChar:!1,asChild:!0,size:"lg",css:{$$badgeHPadding:"$space$4"}},{isOneChar:!1,asChild:!0,size:"xl",css:{$$badgeHPadding:"$space$5"}},{disableOutline:!0,variant:"bordered",css:{borderColor:"$$badgeTextColor"}}],defaultVariants:{size:"md",color:"default",variant:"default",borderWeight:"normal",placement:"top-right",shape:"rectangle",enableShadow:!1,disableOutline:!1,isSquared:!1}});exports.StyledBadge=r;const t=(0,e.styled)("div",{position:"relative",dflex:"center","& .nextui-badge-point":{size:"calc($$badgeFontSize * 0.3)",background:"$$badgeTextColor",margin:"0 2px",borderRadius:"$pill","&:nth-child(1)":{animation:`${a.pointAnimation} 1.2s ease infinite`},"&:nth-child(2)":{animation:`${a.pointAnimation} 1.2s ease infinite 0.4s`},"&:nth-child(3)":{animation:`${a.pointAnimation} 1.2s ease infinite 0.8s`}}});exports.StyledBadgePoints=t;

/***/ }),

/***/ 81034:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledBadgeRoot=exports.StyledBadgePoints=exports.StyledBadge=void 0;var t=e(__webpack_require__(39930)),d=__webpack_require__(93099);exports.StyledBadgeRoot=d.StyledBadgeRoot,exports.StyledBadge=d.StyledBadge,exports.StyledBadgePoints=d.StyledBadgePoints;var r=t.default;exports["default"]=r;

/***/ }),

/***/ 33210:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var t=__webpack_require__(27574);exports.__esModule=!0,exports.useButtonGroupContext=exports.ButtonGroupContext=void 0;var e=t(__webpack_require__(18038));const o={isButtonGroup:!1,disabled:!1},r=e.default.createContext(o);exports.ButtonGroupContext=r;exports.useButtonGroupContext=()=>e.default.useContext(r);

/***/ }),

/***/ 33253:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=i(r);if(t&&t.has(e))return t.get(e);var o={},u=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in e)if("default"!==n&&Object.prototype.hasOwnProperty.call(e,n)){var a=u?Object.getOwnPropertyDescriptor(e,n):null;a&&(a.get||a.set)?Object.defineProperty(o,n,a):o[n]=e[n]}o.default=e,t&&t.set(e,o);return o}(__webpack_require__(18038)),t=e(__webpack_require__(25457)),o=__webpack_require__(33210),u=e(__webpack_require__(42554)),n=__webpack_require__(56786);function i(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(i=function(e){return e?t:r})(e)}const a=e=>{const{disabled:t,size:i,color:a,bordered:d,ghost:l,light:s,flat:p,shadow:f,auto:c,animated:b,rounded:g,ripple:h,borderWeight:v,children:x,...m}=e,y=(0,r.useMemo)((()=>({disabled:t,size:i,color:a,bordered:d,light:s,ghost:l,flat:p,shadow:f,auto:c,borderWeight:v,animated:b,rounded:g,ripple:h,isButtonGroup:!0})),[t,b,i,h,a,d,s,l,p,v]);return(0,n.jsx)(o.ButtonGroupContext.Provider,{value:y,children:(0,n.jsx)(u.default,{bordered:d||l,gradient:"gradient"===e.color,size:i,...m,children:x})})};a.toString=()=>".nextui-button-group";const d=r.default.memo(a);var l=(0,t.default)(d,{borderWeight:"normal",size:"md",color:"default"});exports["default"]=l,module.exports=exports.default;

/***/ }),

/***/ 42554:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var t=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledButtonGroup=void 0;var r=__webpack_require__(88194),e=t(__webpack_require__(77583));const l=(0,r.styled)("div",{display:"inline-flex",margin:"$3",backgroundColor:"transparent",height:"min-content",[`& ${e.default}`]:{".nextui-button-text":{top:0}},variants:{vertical:{true:{fd:"column",[`& ${e.default}`]:{"&:not(:first-child)":{btlr:0,btrr:0},"&:not(:last-child)":{bblr:0,bbrr:0}}},false:{fd:"row",[`& ${e.default}`]:{"&:not(:first-child)":{btlr:0,bblr:0},"&:not(:last-child)":{btrr:0,bbrr:0}}}},size:{xs:{br:"$xs"},sm:{br:"$sm"},md:{br:"$md"},lg:{br:"$base"},xl:{br:"$xl"}},rounded:{true:{br:"$pill"}},bordered:{true:{bg:"transparent"}},gradient:{true:{pl:0}}},defaultVariants:{vertical:!1},compoundVariants:[{bordered:!0,vertical:!0,css:{[`& ${e.default}`]:{"&:not(:last-child)":{borderBottom:"none",paddingBottom:"0"}}}},{bordered:!0,vertical:!1,css:{[`& ${e.default}`]:{"&:not(:first-child)":{borderLeft:"none"}}}},{bordered:!0,vertical:!1,gradient:!0,css:{[`& ${e.default}`]:{"&:not(:last-child)&:not(:first-child)":{pl:0},"&:last-child":{pl:0}}}}]});exports.StyledButtonGroup=l;var d=l;exports["default"]=d;

/***/ }),

/***/ 48410:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var t=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledButtonIcon=void 0;var e=t(__webpack_require__(18038)),i=__webpack_require__(88194),s=t(__webpack_require__(25457)),n=t(__webpack_require__(62358)),r=__webpack_require__(56786);const o=(0,i.styled)("span",{dflex:"center",position:"absolute",left:"$$buttonPadding",right:"auto",top:"50%",transform:"translateY(-50%)",color:"inherit",zIndex:"$1","& svg":{background:"transparent"},variants:{isAuto:{true:{position:"relative",transform:"none",top:"0%"}},isRight:{true:{right:"$$buttonPadding",left:"auto"}},isSingle:{true:{position:"static",transform:"none"}},isGradientButtonBorder:{true:{}}},compoundVariants:[{isAuto:!0,isRight:!0,isSingle:!1,css:{order:2,ml:"calc($$buttonPadding / 2)",right:"0%",left:"0%"}},{isAuto:!0,isRight:!1,isSingle:!1,css:{order:0,mr:"calc($$buttonPadding / 2)",right:"0%",left:"0%"}},{isSingle:!0,isRight:!1,css:{ml:0}},{isSingle:!0,isRight:!0,css:{mr:0}},{isSingle:!0,isRight:!1,isGradientButtonBorder:!0,css:{mr:"calc($$buttonPadding / 2)"}}]});exports.StyledButtonIcon=o;const u=({children:t,className:e,css:i,...s})=>(0,r.jsx)(o,{className:(0,n.default)("nextui-button-icon",{"nextui-button-icon-right":s.isRight,"nextui-button-icon-single":s.isSingle},e),css:i,...s,children:t});u.toString=()=>".nextui-button-icon";const a=e.default.memo(u);var l=(0,s.default)(a,{className:""});exports["default"]=l;

/***/ }),

/***/ 59257:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=m(t);if(r&&r.has(e))return r.get(e);var s={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in e)if("default"!==o&&Object.prototype.hasOwnProperty.call(e,o)){var n=i?Object.getOwnPropertyDescriptor(e,o):null;n&&(n.get||n.set)?Object.defineProperty(s,o,n):s[o]=e[o]}s.default=e,r&&r.set(e,s);return s}(__webpack_require__(18038)),r=__webpack_require__(94135),s=__webpack_require__(20662),i=__webpack_require__(34353),o=__webpack_require__(77335),n=__webpack_require__(10084),u=e(__webpack_require__(24192)),a=e(__webpack_require__(62358)),l=e(__webpack_require__(19964)),d=e(__webpack_require__(25457)),c=__webpack_require__(73726),p=__webpack_require__(81595),f=__webpack_require__(93795),b=__webpack_require__(57891),h=__webpack_require__(33210),g=e(__webpack_require__(48410)),x=e(__webpack_require__(77583)),P=__webpack_require__(56786);function m(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(m=function(e){return e?r:t})(e)}const q=(0,f.forwardRef)(((e,d)=>{const{as:f,css:m,iconLeftCss:q,iconRightCss:v,onClick:y,onPress:w,onPressStart:j,onPressEnd:C,onPressChange:_,onPressUp:O,...B}=e,D=(0,h.useButtonGroupContext)(),F=(0,b.filterPropsWithGroup)(B,D),M=(0,b.getCssColors)(F),{flat:N,children:R,disabled:k,animated:W,light:S,ripple:E,bordered:G,auto:U,borderWeight:V,icon:H,iconRight:T,ghost:A,autoFocus:L,className:I,...$}=F,z=e=>{W&&E&&J.current&&re(e)},J=(0,c.useDOMRef)(d),{buttonProps:K,isPressed:Q}=(0,s.useButton)({...B,isDisabled:k,elementType:f,onPress:e=>{"keyboard"===e.pointerType||"virtual"===e.pointerType?z(e):"undefined"!=typeof window&&window.event&&z(window.event),y&&(y(e),console.warn("onClick is deprecated, please use onPress")),null==w||w(e)},onPressStart:j,onPressEnd:C,onPressChange:_,onPressUp:O},J),{hoverProps:X,isHovered:Y}=(0,i.useHover)({isDisabled:k}),{isFocused:Z,isFocusVisible:ee,focusProps:te}=(0,r.useFocusRing)({autoFocus:L}),{onClick:re,...se}=(0,l.default)(!1,J);p.__DEV__&&"gradient"===F.color&&(N||S)&&(0,n.warn)("Using the gradient color on flat and light buttons will have no effect.");const ie=H||T,oe=0===t.default.Children.count(R),ne=Boolean(T),ue=(0,t.useMemo)((()=>Q?"pressed":Y?"hovered":k?"disabled":"ready"),[k,Y,Q]),ae=(0,t.useMemo)((()=>ne?v:q),[ne,v,q]);return(0,P.jsxs)(x.default,{ref:J,animated:W,as:f,auto:U,borderWeight:V,bordered:G||A,className:(0,a.default)("nextui-button",`nextui-button--${ue}`,I),css:{...m,...M},"data-state":ue,flat:N,ghost:A,isChildLess:oe,isFocusVisible:ee&&!k,isHovered:Y||A&&Z,isPressed:Q,light:S,...(0,o.mergeProps)(K,te,X,$),children:[0===t.default.Children.count(R)?(0,P.jsx)(g.default,{isSingle:!0,css:ae,isAuto:U,isGradientButtonBorder:"gradient"===e.color&&(G||A),isRight:ne,children:ie}):ie?(0,P.jsxs)(P.Fragment,{children:[(0,P.jsx)(g.default,{css:ae,isAuto:U,isGradientButtonBorder:"gradient"===e.color&&(G||A),isRight:ne,isSingle:!1,children:ie}),(0,P.jsx)("div",{className:(0,a.default)("nextui-button-text",{"nextui-button-text-right":ne,"nextui-button-text-left":!ne}),children:R})]}):(0,P.jsx)("span",{className:"nextui-button-text",children:R}),(0,P.jsx)(u.default,{className:"nextui-button-drip",color:"white",...se})]})}));p.__DEV__&&(q.displayName="NextUI.Button"),q.toString=()=>".nextui-button";var v=(0,d.default)(q,{ghost:!1,bordered:!1,ripple:!0,animated:!0,disabled:!1,autoFocus:!1,auto:!1,className:"",type:"button"});exports["default"]=v,module.exports=exports.default;

/***/ }),

/***/ 77583:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=exports.StyledButton=void 0;var r=__webpack_require__(88194),o=__webpack_require__(74042),i=__webpack_require__(24192);const t=(0,r.styled)("button",{$$buttonBorderRadius:"$radii$md",$$buttonPressedScale:.97,dflex:"center",appearance:"none",boxSizing:"border-box",fontWeight:"$medium",us:"none",lineHeight:"$sm",ta:"center",whiteSpace:"nowrap",transition:"$button",position:"relative",overflow:"hidden",border:"none",cursor:"pointer",pe:"auto",p:0,br:"$$buttonBorderRadius","@motion":{transition:"none"},".nextui-button-text":{dflex:"center",zIndex:"$2","p, pre, div":{margin:0}},[`& ${i.StyledDrip}`]:{zIndex:"$1",".nextui-drip-filler":{opacity:.25,fill:"$accents2"}},variants:{bordered:{true:{bg:"transparent",borderStyle:"solid",color:"$text"}},ghost:{true:{}},color:{default:{bg:"$primary",color:"$primarySolidContrast"},primary:{bg:"$primary",color:"$primarySolidContrast"},secondary:{bg:"$secondary",color:"$secondarySolidContrast"},success:{bg:"$success",color:"$successSolidContrast"},warning:{bg:"$warning",color:"$warningSolidContrast"},error:{bg:"$error",color:"$errorSolidContrast"},gradient:{bg:"$gradient",color:"$primarySolidContrast"}},size:{xs:{$$buttonPadding:"$space$3",$$buttonBorderRadius:"$radii$xs",$$buttonHeight:"$space$10",px:"$3",height:"$$buttonHeight",lh:"$space$10",width:"auto",minWidth:"$20",fontSize:"$xs"},sm:{$$buttonPadding:"$space$5",$$buttonBorderRadius:"$radii$sm",$$buttonHeight:"$space$12",px:"$5",height:"$$buttonHeight",lh:"$space$14",width:"auto",minWidth:"$36",fontSize:"$sm"},md:{$$buttonPadding:"$space$7",$$buttonBorderRadius:"$radii$md",$$buttonHeight:"$space$14",px:"$7",height:"$$buttonHeight",lh:"$space$14",width:"auto",minWidth:"$48",fontSize:"$sm"},lg:{$$buttonPadding:"$space$9",$$buttonBorderRadius:"$radii$base",$$buttonHeight:"$space$16",px:"$9",height:"$$buttonHeight",lh:"$space$15",width:"auto",minWidth:"$60",fontSize:"$md"},xl:{$$buttonPadding:"$space$10",$$buttonBorderRadius:"$radii$xl",$$buttonHeight:"$space$18",px:"$10",height:"$$buttonHeight",lh:"$space$17",width:"auto",minWidth:"$72",fontSize:"$lg"}},borderWeight:{light:{bw:"$light",$$buttonBorderWeight:"$borderWeights$light"},normal:{bw:"$normal",$$buttonBorderWeight:"$borderWeights$normal"},bold:{bw:"$bold",$$buttonBorderWeight:"$borderWeights$bold"},extrabold:{bw:"$extrabold",$$buttonBorderWeight:"$borderWeights$extrabold"},black:{bw:"$black",$$buttonBorderWeight:"$borderWeights$black"}},flat:{true:{color:"$text"}},light:{true:{bg:"transparent",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{opacity:.8,fill:"$accents2"}}}},shadow:{true:{bs:"$sm"}},animated:{false:{transition:"none"}},auto:{true:{width:"auto",minWidth:"min-content"}},rounded:{true:{$$buttonBorderRadius:"$radii$pill"}},isPressed:{true:{}},isHovered:{true:{}},isChildLess:{true:{p:0,width:"$$buttonHeight",height:"$$buttonHeight"}},isFocusVisible:{true:{},false:{}}},compoundVariants:[{isPressed:!0,animated:!0,css:{transform:"scale($$buttonPressedScale)"}},{auto:!0,isChildLess:!1,size:"xs",css:{px:"$5",minWidth:"min-content"}},{auto:!0,isChildLess:!1,size:"sm",css:{px:"$8",minWidth:"min-content"}},{auto:!0,isChildLess:!1,size:"md",css:{px:"$9",minWidth:"min-content"}},{auto:!0,isChildLess:!1,size:"lg",css:{px:"$10",minWidth:"min-content"}},{auto:!0,isChildLess:!1,size:"xl",css:{px:"$11",minWidth:"min-content"}},{shadow:!0,isFocusVisible:!1,color:"default",css:{normalShadow:"$primaryShadow"}},{shadow:!0,isFocusVisible:!1,color:"primary",css:{normalShadow:"$primaryShadow"}},{shadow:!0,isFocusVisible:!1,color:"secondary",css:{normalShadow:"$secondaryShadow"}},{shadow:!0,isFocusVisible:!1,color:"warning",css:{normalShadow:"$warningShadow"}},{shadow:!0,isFocusVisible:!1,color:"success",css:{normalShadow:"$successShadow"}},{shadow:!0,isFocusVisible:!1,color:"error",css:{normalShadow:"$errorShadow"}},{shadow:!0,isFocusVisible:!1,color:"gradient",css:{normalShadow:"$primaryShadow"}},{light:!0,color:"default",css:{bg:"transparent",color:"$text",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{opacity:.8,fill:"$primaryLightActive"}}}},{light:!0,color:"primary",css:{bg:"transparent",color:"$primary",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{opacity:.8,fill:"$primaryLightActive"}}}},{light:!0,color:"secondary",css:{bg:"transparent",color:"$secondary",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{opacity:.8,fill:"$secondaryLightActive"}}}},{light:!0,color:"warning",css:{bg:"transparent",color:"$warning",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{opacity:.8,fill:"$warningLightActive"}}}},{light:!0,color:"success",css:{bg:"transparent",color:"$success",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{opacity:.8,fill:"$successLightActive"}}}},{light:!0,color:"error",css:{bg:"transparent",color:"$error",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{opacity:.8,fill:"$errorLightActive"}}}},{bordered:!0,color:"default",css:{bg:"transparent",borderColor:"$primary",color:"$primary",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{fill:"$primary"}}}},{bordered:!0,color:"primary",css:{bg:"transparent",borderColor:"$primary",color:"$primary",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{fill:"$primary"}}}},{bordered:!0,color:"secondary",css:{bg:"transparent",borderColor:"$secondary",color:"$secondary",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{fill:"$secondary"}}}},{bordered:!0,color:"success",css:{bg:"transparent",borderColor:"$success",color:"$success",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{fill:"$success"}}}},{bordered:!0,color:"warning",css:{bg:"transparent",borderColor:"$warning",color:"$warning",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{fill:"$warning"}}}},{bordered:!0,color:"error",css:{bg:"transparent",borderColor:"$error",color:"$error",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{fill:"$error"}}}},{bordered:!0,color:"gradient",css:{bg:"transparent",color:"$text",padding:"$$buttonBorderWeight",bgClip:"content-box, border-box",borderColor:"$primary",backgroundImage:"linear-gradient($background, $background), $gradient",border:"none",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{fill:"$secondary"}}}},{ghost:!0,isHovered:!0,color:"default",css:{bg:"$primary",color:"$primarySolidContrast"}},{ghost:!0,isHovered:!0,color:"primary",css:{bg:"$primary",color:"$primarySolidContrast"}},{ghost:!0,isHovered:!0,color:"secondary",css:{bg:"$secondary",color:"$secondarySolidContrast"}},{ghost:!0,isHovered:!0,color:"success",css:{bg:"$success",color:"$successSolidContrast"}},{ghost:!0,isHovered:!0,color:"warning",css:{bg:"$warning",color:"$warningSolidContrast"}},{ghost:!0,isHovered:!0,color:"error",css:{bg:"$error",color:"$errorSolidContrast"}},{ghost:!0,color:"gradient",isHovered:!0,css:{bg:"$gradient",color:"$white"}},{flat:!0,color:"default",css:{bg:"$primaryLight",color:"$primaryLightContrast",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{opacity:.4,fill:"$primary"}}}},{flat:!0,color:"primary",css:{bg:"$primaryLight",color:"$primaryLightContrast",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{opacity:.4,fill:"$primary"}}}},{flat:!0,color:"secondary",css:{bg:"$secondaryLight",color:"$secondaryLightContrast",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{opacity:.4,fill:"$secondary"}}}},{flat:!0,color:"success",css:{bg:"$successLight",color:"$successLightContrast",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{opacity:.4,fill:"$success"}}}},{flat:!0,color:"warning",css:{bg:"$warningLight",color:"$warningLightContrast",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{opacity:.4,fill:"$warning"}}}},{flat:!0,color:"error",css:{bg:"$errorLight",color:"$errorLightContrast",[`& ${i.StyledDrip}`]:{".nextui-drip-filler":{opacity:.4,fill:"$error"}}}},{flat:!0,isHovered:!0,color:"default",css:{bg:"$primaryLightHover"}},{flat:!0,isHovered:!0,color:"primary",css:{bg:"$primaryLightHover"}},{flat:!0,isHovered:!0,color:"secondary",css:{bg:"$secondaryLightHover"}},{flat:!0,isHovered:!0,color:"success",css:{bg:"$successLightHover"}},{flat:!0,isHovered:!0,color:"warning",css:{bg:"$warningLightHover"}},{flat:!0,isHovered:!0,color:"error",css:{bg:"$errorLightHover"}},{flat:!0,isPressed:!0,color:"default",css:{bg:"$primaryLightActive"}},{flat:!0,isPressed:!0,color:"primary",css:{bg:"$primaryLightActive"}},{flat:!0,isPressed:!0,color:"secondary",css:{bg:"$secondaryLightActive"}},{flat:!0,isPressed:!0,color:"success",css:{bg:"$successLightActive"}},{flat:!0,isPressed:!0,color:"warning",css:{bg:"$warningLightActive"}},{flat:!0,isPressed:!0,color:"error",css:{bg:"$errorLightActive"}},{auto:!0,color:"gradient",bordered:!0,css:{".nextui-button-text":{px:"$$buttonPadding"},".nextui-button-icon":{ml:"$$buttonPadding"},".nextui-button-icon-right":{mr:"$$buttonPadding"},".nextui-button-text-left":{pl:0},".nextui-button-text-right":{pr:0}}},{rounded:!0,size:"xs",css:{br:"$pill"}},{rounded:!0,size:"sm",css:{br:"$pill"}},{rounded:!0,size:"md",css:{br:"$pill"}},{rounded:!0,size:"lg",css:{br:"$pill"}},{rounded:!0,size:"xl",css:{br:"$pill"}}],defaultVariants:{color:"default",borderWeight:"normal",animated:!0,size:"md"}},o.cssFocusVisible);exports.StyledButton=t;var e=t;exports["default"]=e;

/***/ }),

/***/ 73831:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var t=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledButtonIcon=exports.StyledButtonGroup=exports.StyledButton=void 0;var e=t(__webpack_require__(59257)),o=t(__webpack_require__(33253)),r=__webpack_require__(77583);exports.StyledButton=r.StyledButton;var u=__webpack_require__(42554);exports.StyledButtonGroup=u.StyledButtonGroup;var l=__webpack_require__(48410);exports.StyledButtonIcon=l.StyledButtonIcon,e.default.Group=o.default;var n=e.default;exports["default"]=n;

/***/ }),

/***/ 57891:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.getCssColors=exports.filterPropsWithGroup=void 0;exports.filterPropsWithGroup=(e,o)=>{var r,t,n,l,d,a,s,i,g,u,b;return o.isButtonGroup?{...e,auto:!0,shadow:!1,bordered:null!=(r=o.bordered)?r:e.bordered,borderWeight:null!=(t=o.borderWeight)?t:e.borderWeight,ghost:null!=(n=o.ghost)?n:e.ghost,ripple:null!=(l=o.ripple)?l:e.ripple,flat:null!=(d=o.flat)?d:e.flat,animated:null!=(a=o.animated)?a:e.animated,rounded:null!=(s=o.rounded)?s:e.rounded,light:null!=(i=o.light)?i:e.light,size:null!=(g=o.size)?g:e.size,color:null!=(u=o.color)?u:e.color,disabled:null!=(b=o.disabled)?b:e.disabled}:e};exports.getCssColors=e=>{if(!e.disabled)return e.auto&&"gradient"===e.color&&(e.bordered||e.ghost)?{px:"$$buttonBorderWeight",py:"$$buttonBorderWeight"}:{};const o={bg:"$accents1",color:"$accents7",transform:"none",boxShadow:"none",pe:"none"};return e.bordered||e.flat||e.ghost||e.light?"gradient"===e.color&&(e.bordered||e.ghost)?{color:"$accents4",backgroundImage:"linear-gradient($background, $background), linear-gradient($accents2, $accents2)",transform:"none",boxShadow:"none",pe:"none",pl:"$$buttonBorderWeight",pr:"$$buttonBorderWeight"}:e.bordered||e.ghost||e.light?{...o,bg:"transparent",borderColor:"$accents4"}:e.flat?{...o,bg:"$accents1"}:void 0:o};

/***/ }),

/***/ 96243:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(18038)),s=e(__webpack_require__(24192)),i=__webpack_require__(81595),a=__webpack_require__(73685),t=__webpack_require__(18920),d=__webpack_require__(56786);const u=r.default.forwardRef((({...e},r)=>{const{as:i,css:u,children:l,...o}=e,{cardRef:n,variant:c,isFocusVisible:b,isPressable:p,isPressed:f,disableAnimation:x,disableRipple:q,borderWeight:v,isHovered:g,getCardProps:m,dripBindings:_}=(0,a.useCard)({...o,ref:r});return(0,d.jsxs)(t.StyledCard,{ref:n,as:i,borderWeight:v,css:u,disableAnimation:x,isFocusVisible:b,isHovered:g,isPressable:p,isPressed:f,role:p?"button":"region",tabIndex:p?0:-1,variant:c,...m(),children:[p&&!x&&!q&&(0,d.jsx)(s.default,{..._}),l]})}));i.__DEV__&&(u.displayName="NextUI.Card"),u.toString=()=>".nextui-card";var l=u;exports["default"]=l,module.exports=exports.default;

/***/ }),

/***/ 18920:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledCardHeader=exports.StyledCardFooter=exports.StyledCardBody=exports.StyledCard=void 0;var o=__webpack_require__(88194),r=__webpack_require__(24192),e=__webpack_require__(74042);const d=(0,o.styled)("div",{d:"flex",w:"100%",h:"auto",flex:"1 1 auto",fd:"column",jc:"inherit",ai:"inherit",ac:"inherit",py:"$lg",px:"$sm",oy:"auto",position:"relative",ta:"left"});exports.StyledCardBody=d;const t=(0,o.styled)("div",{$$cardColor:"$colors$backgroundContrast",$$cardTextColor:"$colors$text",m:0,p:0,br:"$lg",bg:"$$cardColor",color:"$$cardTextColor",position:"relative",display:"flex",overflow:"hidden",fd:"column",width:"100%",height:"auto",boxSizing:"border-box","@motion":{transition:"none"},".nextui-image":{width:"100%"},[`& ${r.StyledDrip}`]:{zIndex:"$1",".nextui-drip-filler":{opacity:.25,fill:"$accents6"}},variants:{variant:{flat:{bg:"$accents0"},shadow:{dropShadow:"$lg","@safari":{boxShadow:"$lg",dropShadow:"none"},"@-moz-document url-prefix()":{boxShadow:"$lg",dropShadow:"none"}},bordered:{borderStyle:"solid",borderColor:"$border"}},borderWeight:{light:{bw:"$light"},normal:{bw:"$normal"},bold:{bw:"$bold"},extrabold:{bw:"$extrabold"},black:{bw:"$black"}},disableAnimation:{true:{transition:"none"},false:{transition:"$card"}},isPressable:{true:{cursor:"pointer",us:"none",WebkitTapHighlightColor:"transparent"}},isPressed:{true:{}},isHovered:{true:{dropShadow:"$lg","@safari":{boxShadow:"$lg",dropShadow:"none"},"@-moz-document url-prefix()":{boxShadow:"$lg",dropShadow:"none"}}}},compoundVariants:[{isPressed:!0,disableAnimation:!1,css:{transform:"scale(0.97)"}},{isHovered:!0,disableAnimation:!1,css:{transform:"translateY(-2px)"}},{isHovered:!0,variant:"shadow",css:{dropShadow:"$xl","@safari":{boxShadow:"$xl",dropShadow:"none"},"@-moz-document url-prefix()":{boxShadow:"$xl",dropShadow:"none"}}}]},e.cssNoBlurriness,e.cssFocusVisible);exports.StyledCard=t;const a=(0,o.styled)("div",{w:"100%",display:"flex",flexShrink:0,zIndex:"$1",jc:"flex-start",ai:"center",overflow:"hidden",color:"inherit",p:"$sm"});exports.StyledCardHeader=a;const i=(0,o.styled)("div",{w:"100%",h:"auto",p:"$sm",d:"flex",ai:"center",overflow:"hidden",color:"inherit",bblr:"$lg",bbrr:"$lg",variants:{isBlurred:{true:{bf:"saturate(180%) blur(10px)",bg:"$$cardColor"}}}});exports.StyledCardFooter=i;

/***/ }),

/***/ 1853:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledCardHeader=exports.StyledCardFooter=exports.StyledCardBody=exports.StyledCard=void 0;var d=e(__webpack_require__(6361)),r=e(__webpack_require__(5136)),t=e(__webpack_require__(96243)),a=__webpack_require__(18920);exports.StyledCard=a.StyledCard,exports.StyledCardHeader=a.StyledCardHeader,exports.StyledCardFooter=a.StyledCardFooter,exports.StyledCardBody=a.StyledCardBody,t.default.Header=a.StyledCardHeader,t.default.Body=a.StyledCardBody,t.default.Footer=a.StyledCardFooter,t.default.Image=d.default,t.default.Divider=r.default;var l=t.default;exports["default"]=l;

/***/ }),

/***/ 73685:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports.useCard=void 0;var r=__webpack_require__(18038),s=__webpack_require__(94135),i=__webpack_require__(77335),o=__webpack_require__(34353),a=e(__webpack_require__(19964)),l=__webpack_require__(73726);exports.useCard=e=>{const{ref:u,disableAnimation:t=!1,disableRipple:n=!1,variant:d="shadow",isHoverable:c=!1,borderWeight:p="light",isPressable:b=!1,onClick:P,onPress:v,autoFocus:q,allowTextSelectionOnPress:C=!0,...f}=e,g=(0,l.useDOMRef)(u),{onClick:h,...k}=(0,a.default)(!1,g),R=e=>{t||n||!g.current||h(e)},{isPressed:m,pressProps:x}=(0,o.usePress)({isDisabled:!b,onPress:e=>{"keyboard"!==e.pointerType&&"virtual"!==e.pointerType||(R(e),null==P||P(e)),null==v||v(e)},allowTextSelectionOnPress:C,...f}),{hoverProps:D,isHovered:F}=(0,o.useHover)({isDisabled:!c,...f}),{isFocusVisible:H,focusProps:T}=(0,s.useFocusRing)({autoFocus:q});x.onClick=e=>{b&&(R(e),null==P||P(e))};const w=(0,r.useCallback)(((e={})=>({...(0,i.mergeProps)(b?{...x,...T}:{},c?D:{},f,e)})),[b,c,x,T,D,f]);return{cardRef:g,variant:d,borderWeight:p,isPressable:b,isHovered:F,isPressed:m,disableAnimation:t,disableRipple:n,dripBindings:k,onDripClickHandler:h,isFocusVisible:H,getCardProps:w}};

/***/ }),

/***/ 12913:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.useCheckboxGroupContext=exports.CheckboxGroupProvider=void 0;var e=__webpack_require__(19938);const[o,t]=(0,e.createContext)({name:"CheckboxGroupContext",strict:!1});exports.useCheckboxGroupContext=t,exports.CheckboxGroupProvider=o;

/***/ }),

/***/ 17598:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(18038)),s=e(__webpack_require__(62358)),o=__webpack_require__(73726),t=__webpack_require__(81595),u=__webpack_require__(12913),i=__webpack_require__(6101),l=__webpack_require__(72201),a=__webpack_require__(56786);const c=r.default.forwardRef(((e,r)=>{const{children:t,className:c,as:x,label:n,...p}=e,{css:b,...d}=(0,i.useCheckboxGroup)({...p,label:n}),h=(0,o.useDOMRef)(r);return(0,a.jsxs)(l.StyledCheckboxGroup,{ref:h,...d.groupProps,as:x,className:(0,s.default)("nextui-checkbox-group",c),css:b,isDisabled:d.groupState.isDisabled,size:d.size,children:[n&&(0,a.jsx)("label",{className:"nextui-checkbox-group-label",...d.labelProps,children:n}),(0,a.jsx)(l.StyledCheckboxGroupContainer,{className:"nextui-checkbox-group-items",isRow:"horizontal"===d.orientation,role:"presentation",children:(0,a.jsx)(u.CheckboxGroupProvider,{value:d,children:t})})]})}));t.__DEV__&&(c.displayName="NextUI.CheckboxGroup"),c.toString=()=>".nextui-checkbox-group";var x=c;exports["default"]=x,module.exports=exports.default;

/***/ }),

/***/ 52957:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var i=function(e,i){if(!i&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var s=h(i);if(s&&s.has(e))return s.get(e);var r={},c=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var t in e)if("default"!==t&&Object.prototype.hasOwnProperty.call(e,t)){var a=c?Object.getOwnPropertyDescriptor(e,t):null;a&&(a.get||a.set)?Object.defineProperty(r,t,a):r[t]=e[t]}r.default=e,s&&s.set(e,r);return r}(__webpack_require__(18038)),s=__webpack_require__(77335),r=__webpack_require__(94135),c=__webpack_require__(34353),t=__webpack_require__(20198),a=e(__webpack_require__(62358)),n=__webpack_require__(81595),o=__webpack_require__(73726),l=__webpack_require__(72384),d=__webpack_require__(72201),u=__webpack_require__(56786);function h(e){if("function"!=typeof WeakMap)return null;var i=new WeakMap,s=new WeakMap;return(h=function(e){return e?s:i})(e)}const b=i.default.forwardRef(((e,n)=>{const{className:h,as:b,css:x,children:k,label:p,...f}=e,{size:m,color:y,labelColor:C,isRounded:j,lineThrough:v,disableAnimation:q,isIndeterminate:P,inputRef:N,inputProps:g,containerCss:D}=(0,l.useCheckbox)({...f,children:null!=k?k:p}),I=(0,o.useFocusableRef)(n,N),{hoverProps:O,isHovered:S}=(0,c.useHover)({isDisabled:g.disabled}),{pressProps:A}=(0,c.usePress)({isDisabled:g.disabled}),{focusProps:M,isFocusVisible:_}=(0,r.useFocusRing)({autoFocus:g.autoFocus}),F=(0,i.useMemo)((()=>S?"hovered":P&&g.checked?"mixed":g.checked?"checked":"unchecked"),[S,P,g.checked]);return(0,u.jsxs)(d.StyledCheckboxLabel,{ref:I,...(0,s.mergeProps)(O,A,(0,s.filterDOMProps)(f,{labelable:!0})),as:b,className:(0,a.default)("nextui-checkbox-label",`nextui-checkbox--${F}`,h),css:x,disableAnimation:q,isDisabled:g.disabled,size:m,children:[(0,u.jsxs)(d.StyledCheckboxContainer,{className:"nextui-checkbox-container",color:y,css:D,disableAnimation:q,isDisabled:g.disabled,isFocusVisible:_,isHovered:S,isRounded:j,...M,children:[(0,u.jsx)(t.VisuallyHidden,{children:(0,u.jsx)("input",{ref:N,className:"nextui-checkbox-input",...(0,s.mergeProps)(g,M)})}),(0,u.jsx)(d.StyledCheckboxMask,{className:"nextui-checkbox-mask",disableAnimation:q,isChecked:g.checked,isIndeterminate:P,children:(0,u.jsxs)(d.StyledIconCheck,{className:"nextui-icon-check",disableAnimation:q,isChecked:g.checked,isIndeterminate:P,size:m,children:[(0,u.jsx)(d.StyledIconCheckFirstLine,{className:"nextui-icon-check-line1",disableAnimation:q,isChecked:g.checked,isIndeterminate:P}),(0,u.jsx)(d.StyledIconCheckSecondLine,{className:"nextui-icon-check-line2",disableAnimation:q,isChecked:g.checked,isIndeterminate:P})]})})]}),(k||p)&&(0,u.jsx)(d.StyledCheckboxText,{className:"nextui-checkbox-text",color:C,disableAnimation:q,isChecked:g.checked,isDisabled:g.disabled,lineThrough:v,children:k||p})]})}));n.__DEV__&&(b.displayName="NextUI.Checkbox"),b.toString=()=>".nextui-checkbox";var x=b;exports["default"]=x,module.exports=exports.default;

/***/ }),

/***/ 72201:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledIconCheckSecondLine=exports.StyledIconCheckFirstLine=exports.StyledIconCheck=exports.StyledCheckboxText=exports.StyledCheckboxMask=exports.StyledCheckboxLabel=exports.StyledCheckboxGroupContainer=exports.StyledCheckboxGroup=exports.StyledCheckboxContainer=void 0;var e=__webpack_require__(88194),o=__webpack_require__(74042);const t=(0,e.styled)("label",{$$checkboxBorderColor:"$colors$border",$$checkboxBorderRadius:"$radii$squared",d:"inline-flex",jc:"flex-start",ai:"center",position:"relative",w:"auto",cursor:"pointer",zIndex:"$1",opacity:1,transition:"opacity 0.25s ease","@motion":{transition:"none"},variants:{size:{xs:{$$checkboxSize:"$space$7"},sm:{$$checkboxSize:"$space$8"},md:{$$checkboxSize:"$space$9"},lg:{$$checkboxSize:"$space$10"},xl:{$$checkboxSize:"$space$11"}},isDisabled:{true:{opacity:.75,cursor:"not-allowed"}},disableAnimation:{true:{transition:"none"}}},defaultVariants:{size:"md"}});exports.StyledCheckboxLabel=t;const r=(0,e.styled)("div",{content:"",background:"transparent",position:"absolute",width:"8px",height:"1px",br:"5px",zIndex:"$1",bottom:"0px","&:after":{content:"",position:"absolute",left:"0px",width:"0%",height:"2px",background:"$white",br:"5px 0px 0px 5px"},"@motion":{"&:after":{transition:"none"}},variants:{isIndeterminate:{true:{display:"none"}},isChecked:{true:{"&:after":{width:"100%",transition:"width 0.25s ease 0.1s"}}},disableAnimation:{true:{"&:after":{transition:"none"}}}},compoundVariants:[{isChecked:!0,disableAnimation:!0,css:{"&:after":{transition:"none"}}}]});exports.StyledIconCheckFirstLine=r;const i=(0,e.styled)("div",{content:"",position:"absolute",h:"13px",br:"5px",bottom:"0",right:"0",zIndex:"$1",background:"transparent",width:"2px","&:after":{content:"",position:"absolute",width:"2px",height:"0%",background:"$white",left:"0px",bottom:"0px",br:"5px 5px 0px 0px"},"@motion":{"&:after":{transition:"none"}},variants:{isIndeterminate:{true:{display:"none"}},isChecked:{true:{"&:after":{height:"100%",transition:"height 0.2s ease 0.3s"}}},disableAnimation:{true:{"&:after":{transition:"none"}}}},compoundVariants:[{isChecked:!0,disableAnimation:!0,css:{"&:after":{transition:"none"}}}]});exports.StyledIconCheckSecondLine=i;const n=(0,e.styled)("i",{size:"$$checkboxSize",dflex:"center",br:"inherit",opacity:0,zIndex:"$2",transition:"transform 0.35s ease","&:after":{content:"",opacity:0,position:"relative",width:"10px",height:"2px",br:"1px",background:"$white",display:"block"},"@motion":{transition:"none","&:after":{transition:"none"}},variants:{isIndeterminate:{true:{opacity:1,transform:"rotate(0deg)",width:"auto",height:"auto",margin:"0px","&:after":{opacity:1}},false:{width:"8px",height:"14px",display:"block",position:"relative",marginTop:"-4px"}},size:{xs:{marginTop:"-2px",transform:"rotate(45deg) scale(0.5)"},sm:{marginTop:"-2px",transform:"rotate(45deg) scale(0.5)"},md:{transform:"rotate(45deg) scale(0.8)"},lg:{transform:"rotate(45deg)"},xl:{transform:"rotate(45deg)"}},isChecked:{true:{opacity:1}},disableAnimation:{true:{transition:"none","&:after":{transition:"none"}}}},compoundVariants:[{isIndeterminate:!0,size:"xs",css:{scale:"0.5"}},{isIndeterminate:!0,size:"sm",css:{scale:"0.5"}},{isIndeterminate:!0,size:"md",css:{scale:"0.8"}},{isIndeterminate:!0,size:"lg",css:{transform:"none"}},{isIndeterminate:!0,size:"lg",css:{transform:"none"}}]});exports.StyledIconCheck=n;const s=(0,e.styled)("div",{$$checkboxMaskTransition:"transform 0.25s ease 0s, opacity 0.25s ease 0s, background 0.25s ease 0s, border-color 0.25s ease 0s",size:"100%",position:"absolute",pe:"none",boxSizing:"border-box",dflex:"center",zIndex:"-$1",br:"inherit",color:"$$checkboxBorderColor","&:before":{content:"",position:"absolute",top:"0px",left:"0px",size:"100%",br:"inherit",transition:"$$checkboxMaskTransition",zIndex:"-$1",border:"$borderWeights$normal solid currentColor",boxSizing:"border-box"},"&:after":{content:"",position:"absolute",top:"0px",left:"0px",size:"100%",bg:"$$checkboxColor",scale:.5,br:"inherit",opacity:0,transition:"$$checkboxMaskTransition",zIndex:"-$1"},"@motion":{"&:before":{transition:"none"},"&:after":{transition:"none"}},variants:{isChecked:{true:{"&:before":{opacity:0,scale:1.2},"&:after":{opacity:1,scale:1}}},isIndeterminate:{true:{"&:before":{opacity:0,scale:1.2},"&:after":{opacity:1,scale:1}}},disableAnimation:{true:{"&:before":{transition:"none"},"&:after":{transition:"none"}}}}});exports.StyledCheckboxMask=s;const a=(0,e.styled)("span",{position:"relative",dflex:"center",color:"$text",opacity:1,pl:"calc($$checkboxSize * 0.57)",ln:"$$checkboxSize",fontSize:"$$checkboxSize",us:"none",transition:"opacity 0.25s ease 0s","@motion":{transition:"none","&:before":{transition:"none"}},variants:{color:{default:{color:"$text"},primary:{color:"$primary"},secondary:{color:"$secondary"},success:{color:"$success"},warning:{color:"$warning"},error:{color:"$error"}},lineThrough:{true:{"&:before":{content:"",position:"absolute",width:"0px",height:"2px",background:"$text",transition:"width 0.25s ease 0s"}}},isChecked:{true:{"&:before":{opacity:.8}}},isDisabled:{true:{color:"$accents5"}},disableAnimation:{true:{transition:"none","&:before":{transition:"none"}}}},compoundVariants:[{lineThrough:!0,isChecked:!0,css:{opacity:.6,"&:before":{w:"calc(100% - 10px)"}}}]});exports.StyledCheckboxText=a;const c=(0,e.styled)("div",{br:"$$checkboxBorderRadius",position:"relative",sizeMin:"$$checkboxSize",transition:"box-shadow 0.25s ease",zIndex:"$1",".nextui-checkbox-input":{position:"absolute",width:"100%",height:"100%",top:"0px",left:"0px",margin:"0px",padding:"0px",opacity:0,zIndex:"$1",cursor:"pointer","&:disabled":{cursor:"not-allowed"}},"@motion":{transition:"none"},variants:{color:{default:{$$checkboxColor:"$colors$primary",$$checkboxColorHover:"$colors$primarySolidHover"},primary:{$$checkboxColor:"$colors$primary",$$checkboxColorHover:"$colors$primarySolidHover"},secondary:{$$checkboxColor:"$colors$secondary",$$checkboxColorHover:"$colors$secondarySolidHover"},success:{$$checkboxColor:"$colors$success",$$checkboxColorHover:"$colors$successSolidHover"},warning:{$$checkboxColor:"$colors$warning",$$checkboxColorHover:"$colors$warningSolidHover"},error:{$$checkboxColor:"$colors$error",$$checkboxColorHover:"$colors$errorSolidHover"},gradient:{$$checkboxColor:"$colors$gradient",$$checkboxColorHover:"$colors$gradient"}},isRounded:{true:{$$checkboxBorderRadius:"$radii$pill"}},isDisabled:{true:{opacity:.4,cursor:"not-allowed"}},disableAnimation:{true:{transition:"none"}},isHovered:{true:{[`& ${s}:before`]:{bg:"$$checkboxBorderColor",border:"2px solid transparent"},[`& ${s}:after`]:{bg:"$$checkboxColorHover"}}}},defaultVariants:{color:"default"}},o.cssFocusVisible);exports.StyledCheckboxContainer=c;const l=(0,e.styled)("div",{display:"flex",flexDirection:"column","& .nextui-checkbox-group-label":{d:"block",fontWeight:"$normal",fontSize:"calc($$checkboxSize * 0.8)",color:"$accents7",mb:"$3"},variants:{size:{xs:{$$checkboxSize:"$space$7"},sm:{$$checkboxSize:"$space$8"},md:{$$checkboxSize:"$space$9"},lg:{$$checkboxSize:"$space$10"},xl:{$$checkboxSize:"$space$11"}},isDisabled:{true:{"& .nextui-checkbox-group-label":{color:"$accents5"}}}}});exports.StyledCheckboxGroup=l;const d=(0,e.styled)("div",{display:"flex",flexDirection:"column",variants:{isRow:{true:{flexDirection:"row",mt:0,[`& ${t}`]:{mr:"$$checkboxSize"}},false:{mr:0,flexDirection:"column",[`& ${t}:not(:first-child)`]:{mt:"$$checkboxSize"}}}},defaultVariants:{isRow:!1}});exports.StyledCheckboxGroupContainer=d;

/***/ }),

/***/ 32140:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledIconCheckSecondLine=exports.StyledIconCheckFirstLine=exports.StyledIconCheck=exports.StyledCheckboxText=exports.StyledCheckboxMask=exports.StyledCheckboxLabel=exports.StyledCheckboxGroup=exports.StyledCheckboxContainer=void 0;var t=e(__webpack_require__(52957)),o=e(__webpack_require__(17598)),r=__webpack_require__(72201);exports.StyledCheckboxLabel=r.StyledCheckboxLabel,exports.StyledCheckboxContainer=r.StyledCheckboxContainer,exports.StyledIconCheckFirstLine=r.StyledIconCheckFirstLine,exports.StyledIconCheckSecondLine=r.StyledIconCheckSecondLine,exports.StyledIconCheck=r.StyledIconCheck,exports.StyledCheckboxMask=r.StyledCheckboxMask,exports.StyledCheckboxText=r.StyledCheckboxText,exports.StyledCheckboxGroup=r.StyledCheckboxGroup,t.default.Group=o.default;var c=t.default;exports["default"]=c;

/***/ }),

/***/ 6101:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.useCheckboxGroup=void 0;var e=__webpack_require__(29422),o=__webpack_require__(48289);exports.useCheckboxGroup=(r={})=>{const{size:s="md",color:t="default",labelColor:a="default",orientation:l="vertical",css:u,...c}=r,p=(0,o.useCheckboxGroupState)(c),{labelProps:i,groupProps:b}=(0,e.useCheckboxGroup)(c,p);return{css:u,size:s,orientation:l,color:t,labelColor:a,groupState:p,labelProps:i,groupProps:b}};

/***/ }),

/***/ 72384:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.useCheckbox=void 0;var e=__webpack_require__(18038),o=__webpack_require__(841),l=__webpack_require__(29422),t=__webpack_require__(81595),i=__webpack_require__(12913);exports.useCheckbox=r=>{var u,n,s;const a=(0,i.useCheckboxGroupContext)(),{size:d=(null!=(u=null==a?void 0:a.size)?u:"md"),color:c=(null!=(n=null==a?void 0:a.color)?n:"default"),labelColor:b=(null!=(s=null==a?void 0:a.labelColor)?s:"default"),lineThrough:h,isRounded:x=!1,disableAnimation:p=!1,isIndeterminate:C=!1,containerCss:v,...f}=r;if(a&&t.__DEV__){const e="The Checkbox.Group is being used, `%s` will be ignored. Use the `%s` of the Checkbox.Group instead.";"isSelected"in f&&console.warn(e,"isSelected","value"),"defaultSelected"in f&&console.warn(e,"defaultSelected","defaultValue")}const g=(0,e.useRef)(null),k=(0,e.useMemo)((()=>{var e,o;return{...f,isIndeterminate:C,value:null!=(e=f.value)?e:"",isRequired:null!=(o=f.isRequired)&&o}}),[C,f]),{inputProps:m}=a?(0,l.useCheckboxGroupItem)({...k,validationState:f.validationState},a.groupState,g):(0,l.useCheckbox)(k,(0,o.useToggleState)(k),g);return{size:d,color:c,labelColor:b,isRounded:x,lineThrough:h,disableAnimation:p,isIndeterminate:C,inputRef:g,inputProps:m,containerCss:v}};

/***/ }),

/***/ 50591:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(18038)),t=e(__webpack_require__(25457)),l=__webpack_require__(49590),d=__webpack_require__(56786);const o=({block:e,children:r,...t})=>e?(0,d.jsx)(l.StyledPre,{...t,children:(0,d.jsx)(l.StyledCode,{children:r})}):(0,d.jsx)(l.StyledCode,{...t,children:r});o.toString=()=>".nextui-code";const u=r.default.memo(o);var i=(0,t.default)(u,{block:!1});exports["default"]=i,module.exports=exports.default;

/***/ }),

/***/ 49590:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledPre=exports.StyledCode=void 0;var e=__webpack_require__(88194);const t=(0,e.styled)("code",{});exports.StyledCode=t;const o=(0,e.styled)("pre",{width:"initial",mw:"100"});exports.StyledPre=o;

/***/ }),

/***/ 58420:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledPre=exports.StyledCode=void 0;var r=e(__webpack_require__(50591)),t=__webpack_require__(49590);exports.StyledPre=t.StyledPre,exports.StyledCode=t.StyledCode;var d=r.default;exports["default"]=d;

/***/ }),

/***/ 67685:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=e(__webpack_require__(18038)),r=e(__webpack_require__(25457)),s=e(__webpack_require__(71388)),u=__webpack_require__(56786);const i=({children:e,span:t,offset:r,css:i,...l})=>(0,u.jsx)(s.default,{css:{width:100/12*t+"%",marginLeft:100/12*r+"%",...i},...l,children:e});i.toString=()=>".nextui-column";const l=t.default.memo(i);var a=(0,r.default)(l,{span:12,offset:0});exports["default"]=a,module.exports=exports.default;

/***/ }),

/***/ 71388:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=exports.StyledCol=void 0;const e=(0,(__webpack_require__(88194).styled))("div",{float:"left",boxSizing:"border-box",pl:"calc($$rowGap / 2)",pr:"calc($$rowGap / 2)"});exports.StyledCol=e;var o=e;exports["default"]=o;

/***/ }),

/***/ 19316:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledCol=void 0;var r=e(__webpack_require__(67685)),l=__webpack_require__(71388);exports.StyledCol=l.StyledCol;var t=r.default;exports["default"]=t;

/***/ }),

/***/ 91153:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports.useCollapseContext=exports.CollapseContext=void 0;var t=e(__webpack_require__(18038));const o={values:[]},r=t.default.createContext(o);exports.CollapseContext=r;exports.useCollapseContext=()=>t.default.useContext(r);

/***/ }),

/***/ 85008:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=s(r);if(t&&t.has(e))return t.get(e);var u={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if("default"!==i&&Object.prototype.hasOwnProperty.call(e,i)){var o=n?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(u,i,o):u[i]=e[i]}u.default=e,t&&t.set(e,u);return u}(__webpack_require__(18038)),t=e(__webpack_require__(25457)),u=e(__webpack_require__(32821)),n=__webpack_require__(72625),i=__webpack_require__(91153),o=__webpack_require__(38518),l=e(__webpack_require__(42078)),a=__webpack_require__(56786);function s(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(s=function(e){return e?t:r})(e)}const c=({children:e,accordion:t,animated:s,divider:c,onChange:d,...f})=>{const[p,v,x]=(0,u.default)([]),y=(e,r)=>{const u=x.current.find((r=>r===e));if(d&&d(e,r),t)return v(r?[e]:[]);if(r){if(u)return;return v([...x.current,e])}v(x.current.filter((r=>r!==e)))},j=(0,r.useMemo)((()=>({values:p,updateValues:y,divider:c,animated:s})),[p.join(",")]),q=(0,r.useMemo)((()=>(0,n.setChildrenIndex)(e,[l.default])),[e]);return(0,a.jsx)(i.CollapseContext.Provider,{value:j,children:(0,a.jsx)(o.StyledCollapseGroup,{...f,children:q})})};c.toString=()=>".nextui-collapse-group";var d=(0,t.default)(c,{accordion:!0});exports["default"]=d,module.exports=exports.default;

/***/ }),

/***/ 17734:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(18038)),t=__webpack_require__(38518),o=__webpack_require__(56786);const l=({...e})=>(0,o.jsx)(t.StyledCollapseIcon,{className:"nextui-collapse-icon",fill:"none",focusable:"false",height:"20",role:"presentation",viewBox:"0 0 24 24",width:"20",xmlns:"http://www.w3.org/2000/svg",...e,children:(0,o.jsx)("path",{d:"M15.5 19l-7-7 7-7",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:1.5})});l.toString=()=>".nextui-collapse-icon";var s=r.default.memo(l);exports["default"]=s,module.exports=exports.default;

/***/ }),

/***/ 42078:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=x(__webpack_require__(18038)),r=__webpack_require__(94135),a=__webpack_require__(77335),i=__webpack_require__(10084),l=e(__webpack_require__(32821)),s=e(__webpack_require__(96075)),n=x(__webpack_require__(60690)),d=e(__webpack_require__(62358)),o=e(__webpack_require__(25457)),u=__webpack_require__(91153),c=__webpack_require__(38518),f=e(__webpack_require__(17734)),p=__webpack_require__(56786);function b(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(b=function(e){return e?r:t})(e)}function x(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=b(t);if(r&&r.has(e))return r.get(e);var a={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var l in e)if("default"!==l&&Object.prototype.hasOwnProperty.call(e,l)){var s=i?Object.getOwnPropertyDescriptor(e,l):null;s&&(s.get||s.set)?Object.defineProperty(a,l,s):a[l]=e[l]}return a.default=e,r&&r.set(e,a),a}const v="nextui-collapse",h=({children:e,title:o,subtitle:b,expanded:x,shadow:h,className:m,divider:j,arrowIcon:w,showArrow:y,disabled:q,onChange:g,bordered:C,contentLeft:N,preventDefault:$,animated:M,borderWeight:O,index:D,...E})=>{const[I,P,k]=(0,l.default)(x),{values:S,divider:V,animated:W,updateValues:_}=(0,u.useCollapseContext)(),{isFocusVisible:F,focusProps:A}=(0,r.useFocusRing)();o||(0,i.warn)('"title" is required.',"Collapse"),(0,t.useEffect)((()=>{I!==x&&P(x)}),[x]),(0,t.useEffect)((()=>{if(!S.length)return;const e=!!S.find((e=>e===D));P(e)}),[S.join(",")]);const K=(0,a.useId)(),R=(0,a.useId)(),G=(0,t.useMemo)((()=>y?w||(0,p.jsx)(f.default,{}):null),[w,y]),L=void 0===V?j:V,z=(0,t.useMemo)((()=>void 0===W?M:W),[W,M]),B=e=>{if(q)return;const t=!k.current;P(t),_&&_(D,t),g&&g(e,D,t)},{bindings:H}=(0,n.default)((e=>{B(e)}),[n.KeyCode.Enter,n.KeyCode.Space],{disableGlobalEvent:!0,preventDefault:$}),J=(0,t.useMemo)((()=>I?"open":"closed"),[I]);return(0,p.jsxs)(c.StyledCollapse,{animated:z,borderWeight:O,bordered:C,className:(0,d.default)(m,v,`${v}--${J}`),"data-state":J,divider:L,shadow:h,tabIndex:-1,visible:I,...E,children:[(0,p.jsx)(c.StyledCollapseView,{"aria-controls":R,"aria-disabled":q,"aria-expanded":I,className:`${v}-view`,"data-state":J,disabled:q,id:K,isFocusVisible:F,role:"button",tabIndex:q?-1:0,onClick:B,...A,...H,children:(0,p.jsxs)("div",{className:(0,d.default)(`${v}-title-container`),children:[N&&(0,p.jsx)("div",{className:`${v}-title-content-left`,children:N}),(0,p.jsxs)("div",{className:`${v}-title-content`,children:[t.default.isValidElement(o)?o:(0,p.jsx)("h3",{className:`${v}-title`,children:o}),b&&(0,p.jsx)("div",{className:`${v}-subtitle`,children:b})]}),(0,p.jsx)("div",{className:`${v}-title-content-right`,children:G})]})}),(0,p.jsx)(s.default,{animated:z,isExpanded:I,children:(0,p.jsx)(c.StyledCollapseContent,{"aria-labelledby":K,className:`${v}-content`,id:R,role:"region",tabIndex:-1,children:e})})]})};h.toString=()=>".nextui-collapse";var m=(0,o.default)(h,{shadow:!1,divider:!0,bordered:!1,showArrow:!0,animated:!0,disabled:!1,preventDefault:!0,expanded:!1});exports["default"]=m,module.exports=exports.default;

/***/ }),

/***/ 38518:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledCollapseView=exports.StyledCollapseIcon=exports.StyledCollapseGroup=exports.StyledCollapseContent=exports.StyledCollapse=void 0;var e=__webpack_require__(88194),t=__webpack_require__(74042);const o=(0,e.styled)("div",{transition:"$default",".nextui-collapse-title-content":{w:"100%","h1,h2,h3,h4,h5,h6,p,span,b":{margin:0}},".nextui-collapse-title-container":{d:"flex",jc:"space-between",ai:"center"},".nextui-collapse-title":{color:"$foreground"},".nextui-collapse-subtitle":{color:"$accents7",margin:0,"*":{margin:0}},".nextui-collapse-title-content-left":{mr:"$sm"},".nextui-collapse-title-content-left, .nextui-collapse-title-content-right":{d:"flex",ai:"center"},"@motion":{transition:"none",".nextui-collapse-title-content-right ":{svg:{transition:"none"}}},variants:{shadow:{true:{border:"none",boxShadow:"$md",br:"$lg",p:"0 $lg",bg:"$backgroundContrast"}},borderWeight:{light:{$$collapseBorderWidth:"$borderWeights$light"},normal:{$$collapseBorderWidth:"$borderWeights$normal"},bold:{$$collapseBorderWidth:"$borderWeights$bold"},extrabold:{$$collapseBorderWidth:"$borderWeights$extrabold"},black:{$$collapseBorderWidth:"$borderWeights$black"}},divider:{true:{borderTop:"$$collapseBorderWidth solid $border",borderBottom:"$$collapseBorderWidth solid $border"}},bordered:{true:{br:"$lg",p:"0 $lg",border:"$$collapseBorderWidth solid $border"}},animated:{true:{".nextui-collapse-title-content-right ":{svg:{transition:"transform 200ms ease"}}},false:{transition:"none"}},visible:{true:{".nextui-collapse-title-content-right ":{svg:{transform:"rotateZ(-90deg)"}}},false:{".nextui-collapse-title-content-right":{svg:{transform:"rotateZ(0deg)"}}}}},defaultVariants:{borderWeight:"light"}},t.sharedFocus);exports.StyledCollapse=o;const r=(0,e.styled)("div",{w:"100%",d:"block",ta:"left",bg:"transparent",border:"none",cursor:"pointer",outline:"none",padding:"$lg 0",variants:{disabled:{true:{cursor:"not-allowed",".nextui-collapse-title, .nextui-collapse-subtitle":{opacity:.5}}}}},t.cssFocusVisible);exports.StyledCollapseView=r;const l=(0,e.styled)("div",{fontSize:"$base",lineHeight:"$lg",pb:"$lg","*:first-child":{mt:0},"*:last-child":{mb:0}});exports.StyledCollapseContent=l;const d=(0,e.styled)("svg",{path:{stroke:"$accents7"}});exports.StyledCollapseIcon=d;const s=(0,e.styled)("div",{width:"auto",padding:"0 $sm","div + div":{borderTop:"none"},[`& ${o}:first-child`]:{borderTop:"none"},[`& ${o}:last-child`]:{borderBottom:"none"},variants:{borderWeight:{light:{$$collapseGroupBorderWidth:"$borderWeights$light"},normal:{$$collapseGroupBorderWidth:"$borderWeights$normal"},bold:{$$collapseGroupBorderWidth:"$borderWeights$bold"},extrabold:{$$collapseGroupBorderWidth:"$borderWeights$extrabold"},black:{$$collapseGroupBorderWidth:"$borderWeights$black"}},shadow:{true:{br:"$lg",border:"none",boxShadow:"$md",p:"0 $lg",bg:"$backgroundContrast"}},bordered:{true:{br:"$lg",p:"0 $lg",border:"$$collapseGroupBorderWidth solid $border"}},splitted:{true:{[`& ${o}`]:{br:"$lg",border:"none",bg:"$backgroundContrast",boxShadow:"$md",p:"0 $lg",margin:"$md 0"}}}},defaultVariants:{borderWeight:"light",shadow:!1,bordered:!1,splitted:!1}});exports.StyledCollapseGroup=s;

/***/ }),

/***/ 82166:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledCollapseView=exports.StyledCollapseIcon=exports.StyledCollapseGroup=exports.StyledCollapseContent=exports.StyledCollapse=void 0;var l=e(__webpack_require__(42078)),o=e(__webpack_require__(85008)),t=__webpack_require__(38518);exports.StyledCollapse=t.StyledCollapse,exports.StyledCollapseView=t.StyledCollapseView,exports.StyledCollapseContent=t.StyledCollapseContent,exports.StyledCollapseIcon=t.StyledCollapseIcon,exports.StyledCollapseGroup=t.StyledCollapseGroup,l.default.Group=o.default;var p=l.default;exports["default"]=p;

/***/ }),

/***/ 38503:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=i(t);if(r&&r.has(e))return r.get(e);var n={},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if("default"!==s&&Object.prototype.hasOwnProperty.call(e,s)){var o=a?Object.getOwnPropertyDescriptor(e,s):null;o&&(o.get||o.set)?Object.defineProperty(n,s,o):n[s]=e[s]}n.default=e,r&&r.set(e,n);return n}(__webpack_require__(18038)),r=__webpack_require__(73726),n=e(__webpack_require__(67006)),a=__webpack_require__(56786);function i(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(i=function(e){return e?r:t})(e)}const s=t.default.forwardRef(((e,i)=>{const{xs:s,sm:o,md:l,lg:u,xl:p,wrap:f,gap:d,as:c,display:x,justify:m,direction:y,alignItems:b,alignContent:g,children:v,responsive:$,fluid:j,css:k,...w}=e,O=(0,r.useDOMRef)(i),M=(0,t.useMemo)((()=>`calc(${d} * $space$sm)`),[d]);return(0,a.jsx)(n.default,{ref:O,as:c,css:{px:M,maxWidth:s?"$breakpoints$xs":o?"$breakpoints$sm":l?"$breakpoints$md":u?"$breakpoints$lg":p?"$breakpoints$xl":"",alignItems:b,alignContent:g,flexWrap:f,display:x,justifyContent:m,flexDirection:y,...k},fluid:j,responsive:$,...w,children:v})}));s.displayName="NextUI.Container",s.toString=()=>".nextui-container",s.defaultProps={gap:2,xs:!1,sm:!1,md:!1,lg:!1,xl:!1,responsive:!0,fluid:!1,wrap:"wrap",as:"div",display:"block"};var o=t.default.memo(s);exports["default"]=o,module.exports=exports.default;

/***/ }),

/***/ 67006:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=exports.StyledContainer=void 0;const t=(0,(__webpack_require__(88194).styled))("div",{w:"100%",mr:"auto",ml:"auto",variants:{fluid:{true:{maxWidth:"100%"}},responsive:{true:{"@xs":{maxWidth:"$breakpoints$xs"},"@sm":{maxWidth:"$breakpoints$sm"},"@md":{maxWidth:"$breakpoints$md"},"@lg":{maxWidth:"$breakpoints$lg"},"@xl":{maxWidth:"$breakpoints$xl"}}}},defaultVariants:{fluid:!1,responsive:!0}});exports.StyledContainer=t;var e=t;exports["default"]=e;

/***/ }),

/***/ 21213:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledContainer=void 0;var r=e(__webpack_require__(38503)),t=__webpack_require__(67006);exports.StyledContainer=t.StyledContainer;var a=r.default;exports["default"]=a;

/***/ }),

/***/ 2805:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=e(__webpack_require__(18038)),i=__webpack_require__(88194),o=__webpack_require__(56786);const n=(0,i.globalCss)({"*, *:before, *:after":{boxSizing:"border-box",textRendering:"geometricPrecision",WebkitTapHighlightColor:"transparent"},html:{fontSize:"$base"},body:{margin:0,padding:0,minHeight:"100%",position:"relative",overflowX:"hidden",WebkitFontSmoothing:"antialiased",MozOsxFontSmoothing:"grayscale",textRendering:"optimizeLegibility",fontSize:"$base",lineHeight:"$md",fontFamily:"$sans"},"html, body":{backgroundColor:"$background",color:"$text"},"p, small":{color:"inherit",letterSpacing:"$tighter",fontWeight:"$normal",fontFamily:"$sans"},p:{fontSize:"$base",lineHeight:"$lg"},small:{margin:0,lineHeight:"$xs",fontSize:"$xs"},b:{fontWeight:"$semibold"},span:{fontSize:"inherit",color:"inherit",fontWeight:"inherit"},img:{maxWidth:"100%"},a:{cursor:"pointer",fontSize:"inherit",WebkitTouchCallout:"none",WebkitTapHighlightColor:"rgba(0, 0, 0, 0)",WebkitBoxAlign:"center",alignItems:"center",color:"$link",textDecoration:"none"},"a:hover":{textDecoration:"none"},"ul,ol":{padding:0,listStyleType:"none",margin:"$sm $sm $sm $lg",color:"$foreground"},ol:{listStyleType:"decimal"},li:{marginBottom:"$5",fontSize:"$base",lineHeight:"$lg"},"h1,h2,h3,h4,h5,h6":{color:"inherit",margin:"0 0 $5 0"},h1:{letterSpacing:"$tighter",fontSize:"$5xl",lineHeight:"$md",fontWeight:"$bold"},h2:{letterSpacing:"$tighter",fontSize:"$4xl",fontWeight:"$semibold"},h3:{letterSpacing:"$tighter",fontSize:"$2xl",fontWeight:"$semibold"},h4:{letterSpacing:"$tighter",fontSize:"$xl",fontWeight:"$semibold"},h5:{letterSpacing:"$tight",fontSize:"$md",fontWeight:"$semibold"},h6:{letterSpacing:"$tight",fontSize:"$sm",fontWeight:"$semibold"},"button, input, select,textarea":{fontFamily:"inherit",fontSize:"inherit",lineHeight:"inherit",color:"inherit",margin:0},"button:focus, input:focus, select:focus, textarea:focus":{outline:"none"},code:{color:"$code",padding:"$1 $2",borderRadius:"$xs",bg:"$codeLight",fontFamily:"$mono",fontSize:"$sm",whiteSpace:"pre-wrap",transition:"opacity 0.25s ease 0s"},"code:hover":{opacity:.8},pre:{overflow:"auto",whiteSpace:"pre",textAlign:"left",fontSize:"$sm",borderRadius:"$lg",padding:"$md $lg",margin:"$lg 0",fontFamily:"$mono",lineHeight:"$md",webkitOverflowScrolling:"touch"},"pre code":{color:"$foreground",fontSize:"$sm",lineHeight:"$sm",whiteSpace:"pre"},"pre code:before,pre code:after":{display:"none"},"pre p":{margin:0},"pre::-webkit-scrollbar":{display:"none",width:0,height:0,background:"transparent"},hr:{background:"$border",borderColor:"transparent",borderWidth:"0px",borderStyle:"none",height:"1px"},details:{backgroundColor:"$accents1",border:"none"},"details:focus, details:hover, details:active":{outline:"none"},summary:{cursor:"pointer",userSelect:"none",listStyle:"none",outline:"none"},"summary::-webkit-details-marker, summary::before":{display:"none"},"summary::-moz-list-bullet":{fontSize:0},"summary:focus, summary:hover, summary:active":{outline:"none",listStyle:"none"},"::selection":{backgroundColor:"$selection"},blockquote:{padding:"$md $lg",color:"$accents7",backgroundColor:"$accents0",borderRadius:"$lg",margin:"$10 0"},"blockquote *:first-child":{marginTop:0},"blockquote *:last-child":{marginBottom:0},kbd:{width:"fit-content",textAlign:"center",display:"inline-block",color:"$accents8",bg:"$accents0",border:"1px solid $border",boxShadow:"0 0 1px 0 rgb(0 0 0 / 14%)",fontFamily:"$sans",borderRadius:"5px",padding:"$1 $3",mx:"$1",lineHeight:"$sm",fontSize:"$sm"},"kbd + kbd":{ml:"$2"},"dl, dd, hr, figure, p":{margin:0}}),r=({children:e})=>(n(),(0,o.jsx)(t.default.Fragment,{children:e})),l=t.default.memo(r);l.flush=()=>(0,o.jsx)("style",{dangerouslySetInnerHTML:{__html:(0,i.getCssText)()},id:"stitches"});var a=l;exports["default"]=a,module.exports=exports.default;

/***/ }),

/***/ 94754:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(2805));exports["default"]=r.default,module.exports=exports.default;

/***/ }),

/***/ 57441:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=o(t);if(r&&r.has(e))return r.get(e);var i={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if("default"!==a&&Object.prototype.hasOwnProperty.call(e,a)){var u=n?Object.getOwnPropertyDescriptor(e,a):null;u&&(u.get||u.set)?Object.defineProperty(i,a,u):i[a]=e[a]}i.default=e,r&&r.set(e,i);return i}(__webpack_require__(18038)),r=e(__webpack_require__(25457)),i=__webpack_require__(72844),n=__webpack_require__(94077),a=__webpack_require__(56786);function o(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(o=function(e){return e?r:t})(e)}const u=({height:e,x:r,y:o,align:u,children:l,textColor:s,css:f,...c})=>{const d=(0,t.useMemo)((()=>{if(u&&"center"!==u)return"left"===u||"start"===u?{transform:"translateY(-50%)",left:"7%"}:{transform:"translateY(-50%)",left:"auto",right:"7%"}}),[u]),p=o?(0,i.getMargin)(o/2):0,g=r?(0,i.getMargin)(r/2):0;return(0,a.jsx)(n.StyledDivider,{css:{margin:`${p} ${g}`,height:`calc(${e} * 1px)`,...f},role:"separator",...c,children:l&&(0,a.jsx)(n.StyledDividerText,{className:"nextui-divider-text",color:s,css:{...d},children:l})})};u.toString=()=>".nextui-divider";const l=t.default.memo(u);var s=(0,r.default)(l,{x:0,y:0,height:1,align:"center"});exports["default"]=s,module.exports=exports.default;

/***/ }),

/***/ 94077:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledDividerText=exports.StyledDivider=void 0;var r=__webpack_require__(88194);const e=(0,r.styled)("div",{width:"100%",maxWidth:"100%",position:"relative",variants:{color:{default:{bg:"$border"},primary:{bg:"$primary"},secondary:{bg:"$secondary"},success:{bg:"$success"},warning:{bg:"$warning"},error:{bg:"$error"}}},defaultVariants:{color:"default"}});exports.StyledDivider=e;const o=(0,r.styled)("span",{position:"absolute",left:"50%",top:"50%",minHeight:"100%",display:"inline-flex",jc:"center",ai:"center",transform:"translate(-50%, -50%)",padding:"0 $lg",fontSize:"$base",fontWeight:"bold",textTransform:"capitalize",backgroundColor:"$background",zIndex:"$1",variants:{color:{default:{color:"$text"},primary:{color:"$primary"},secondary:{color:"$secondary"},success:{color:"$success"},warning:{color:"$warning"},error:{color:"$error"}}}});exports.StyledDividerText=o;

/***/ }),

/***/ 5136:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledDividerText=exports.StyledDivider=void 0;var r=e(__webpack_require__(57441)),i=__webpack_require__(94077);exports.StyledDivider=i.StyledDivider,exports.StyledDividerText=i.StyledDividerText;var t=r.default;exports["default"]=t;

/***/ }),

/***/ 47250:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;const e=(__webpack_require__(92775).Item);e.toString=()=>".nextui-dropdown-item-base";var t=e;exports["default"]=t,module.exports=exports.default;

/***/ }),

/***/ 11561:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=l(t);if(r&&r.has(e))return r.get(e);var n={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if("default"!==i&&Object.prototype.hasOwnProperty.call(e,i)){var u=o?Object.getOwnPropertyDescriptor(e,i):null;u&&(u.get||u.set)?Object.defineProperty(n,i,u):n[i]=e[i]}n.default=e,r&&r.set(e,n);return n}(__webpack_require__(18038)),r=__webpack_require__(80345),n=__webpack_require__(73726),o=__webpack_require__(81595),i=e(__webpack_require__(62358)),u=e(__webpack_require__(96266)),a=__webpack_require__(45146),s=e(__webpack_require__(67143)),d=__webpack_require__(56786);function l(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(l=function(e){return e?r:t})(e)}const c=t.default.forwardRef(((e,o)=>{const{css:l,children:c,className:f,iconRight:p,iconRightCss:x,auto:b=!0,animated:g,...m}=e,{disableAnimation:w}=(0,a.useDropdownContext)(),h=(0,n.useDOMRef)(o),q=(0,t.useMemo)((()=>p||(0,d.jsx)(s.default,{fill:"currentColor",size:14})),[p]),j=(0,t.useMemo)((()=>g||!w),[g,w]);return(0,d.jsx)(u.default,{css:{"& .nextui-button-icon-right, & .nextui-button-text-right":{pointerEvents:"none"},...l},children:(0,d.jsx)(r.Button,{ref:h,animated:j,auto:b,className:(0,i.default)("nextui-dropdown-button",f),iconRight:q,iconRightCss:{mt:"$1",...x},...m,children:c})})}));o.__DEV__&&(c.displayName="NextUI.DropdownButton"),c.toString=()=>".nextui-dropdown-button";var f=c;exports["default"]=f,module.exports=exports.default;

/***/ }),

/***/ 45146:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.useDropdownContext=exports.DropdownProvider=void 0;var o=__webpack_require__(19938);const[e,r]=(0,o.createContext)({name:"DropdownContext",errorMessage:"useDropdownContext: `context` is undefined. Seems you forgot to wrap all popover components within `<Dropdown />`"});exports.useDropdownContext=r,exports.DropdownProvider=e;

/***/ }),

/***/ 67143:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;e(__webpack_require__(18038));var r=__webpack_require__(81595),t=__webpack_require__(56786);const i=({fill:e,size:r,height:i,width:o,...s})=>(0,t.jsx)("svg",{fill:"none",height:r||i||24,viewBox:"0 0 24 24",width:r||o||24,xmlns:"http://www.w3.org/2000/svg",...s,children:(0,t.jsx)("path",{d:"M17.9188 8.17969H11.6888H6.07877C5.11877 8.17969 4.63877 9.33969 5.31877 10.0197L10.4988 15.1997C11.3288 16.0297 12.6788 16.0297 13.5088 15.1997L15.4788 13.2297L18.6888 10.0197C19.3588 9.33969 18.8788 8.17969 17.9188 8.17969Z",fill:e})});r.__DEV__&&(i.displayName="NextUI.DropdownIcon"),i.toString=()=>".nextui-dropdown-icon";var o=i;exports["default"]=o,module.exports=exports.default;

/***/ }),

/***/ 62378:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var o=u(r);if(o&&o.has(e))return o.get(e);var s={},t=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if("default"!==i&&Object.prototype.hasOwnProperty.call(e,i)){var n=t?Object.getOwnPropertyDescriptor(e,i):null;n&&(n.get||n.set)?Object.defineProperty(s,i,n):s[i]=e[i]}s.default=e,o&&o.set(e,s);return s}(__webpack_require__(18038)),o=__webpack_require__(77335),s=__webpack_require__(94135),t=__webpack_require__(34353),i=__webpack_require__(72928),n=e(__webpack_require__(99389)),a=e(__webpack_require__(62358)),d=__webpack_require__(81595),l=__webpack_require__(45146),p=__webpack_require__(65600),c=__webpack_require__(56786);function u(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,o=new WeakMap;return(u=function(e){return e?o:r})(e)}const m=({as:e,css:d,item:u,state:m,color:f,icon:w,command:h,description:x,textColor:b,variant:y,autoFocus:D,isVirtualized:v,withDivider:P,dividerWeight:S,showFullDescription:g,className:j,onAction:M})=>{const{onClose:q,closeOnSelect:I,disableAnimation:C,borderWeight:O}=(0,l.useDropdownContext)(),{rendered:N,key:k}=u,F=m.selectionManager.isSelected(k),W=m.selectionManager.focusedKey===u.key,_=m.disabledKeys.has(k),V=(0,r.useRef)(null),{pressProps:A,isPressed:H}=(0,t.usePress)({ref:V,isDisabled:_}),{isFocusVisible:K,focusProps:R}=(0,s.useFocusRing)({autoFocus:D}),{hoverProps:z,isHovered:E}=(0,t.useHover)({isDisabled:_}),U="none"!==m.selectionManager.selectionMode&&!_,{menuItemProps:$,labelProps:B,descriptionProps:G,keyboardShortcutProps:J}=(0,i.useMenuItem)({key:k,onClose:q,isSelected:F,isDisabled:_,"aria-label":u["aria-label"],closeOnSelect:I,isVirtualized:v,onAction:M},m,V),L=(0,r.useMemo)((()=>E?"hovered":F?"selected":H?"pressed":_?"disabled":"ready"),[F,_,E,H]),Q=(0,r.useMemo)((()=>u.props.textColor?u.props.textColor:u.props.color&&"default"===b?u.props.color:b),[b,u.props.color,u.props.textColor]),T=(0,r.useMemo)((()=>x||u.props.description),[x,u.props.description]),X=(0,r.useMemo)((()=>h||u.props.command),[h,u.props.command]),Y=(0,r.useMemo)((()=>w||u.props.icon),[w,u.props.icon]);return(0,c.jsxs)(p.StyledDropdownItem,{ref:V,...(0,o.mergeProps)($,z,A,R),as:u.props.as||e,className:(0,a.default)("nextui-dropdown-item",{"is-disabled":_,"is-selected":F,"is-selectable":U,"is-hovered":E,"is-focused":W,"is-pressed":H},j,u.props.className),color:u.props.color||f,css:{...(0,o.mergeProps)(d,u.props.css)},"data-state":L,disableAnimation:C,dividerWeight:S||u.props.dividerWeight||O,isDisabled:_,isFocusVisible:K,isFocused:W,isHovered:E,isPressed:H,isSelectable:U,isSelected:F,shouldShowOutline:K&&"shadow"===y,showFullDescription:g||u.props.showFullDescription,textColor:Q,variant:u.props.variant||y,withDescription:!!T,withDivider:P||u.props.withDivider,children:[Y&&(0,c.jsx)(p.StyledDropdownItemIconWrapper,{className:"nextui-dropdown-item-icon-wrapper",children:Y}),T?(0,c.jsxs)(p.StyledDropdownItemContentWrapper,{children:[(0,c.jsx)(p.StyledDropdownItemContent,{className:"nextui-dropdown-item-content",...B,children:N}),(0,c.jsx)(p.StyledDropdownItemDescription,{className:"nextui-dropdown-item-description",hasCommand:!!X,hasIcon:!!Y,...G,children:T})]}):(0,c.jsx)(p.StyledDropdownItemContent,{className:"nextui-dropdown-item-content",...B,children:N}),X&&(0,c.jsx)(p.StyledDropdownItemKbd,{className:"nextui-dropdown-item-command",...J,children:X}),F&&(0,c.jsx)(n.default,{css:{ml:"$4"}})]})};d.__DEV__&&(m.displayName="NextUI.DropdownItem"),m.toString=()=>".nextui-dropdown-item";var f=m;exports["default"]=f,module.exports=exports.default;

/***/ }),

/***/ 19942:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(18038)),t=__webpack_require__(72928),o=__webpack_require__(62051),n=__webpack_require__(77335),u=e(__webpack_require__(42354)),s=__webpack_require__(73726),a=e(__webpack_require__(62358)),i=__webpack_require__(81595),l=__webpack_require__(45146),d=e(__webpack_require__(28557)),c=e(__webpack_require__(62378)),p=__webpack_require__(65600),x=__webpack_require__(56786);const f=r.default.forwardRef(((e,r)=>{const{as:i,css:f,color:m="default",textColor:q="default",variant:w="flat",containerCss:v,...y}=e,C=(0,l.useDropdownContext)(),D={...(0,n.mergeProps)(C,y)},_=(0,s.useDOMRef)(r),j=(0,o.useTreeState)(D),{menuProps:M}=(0,t.useMenu)(D,j,_);return(0,s.useSyncRef)(C,_),(0,x.jsx)(u.default.Content,{css:v,children:(0,x.jsx)(p.StyledDropdownMenu,{ref:_,as:i,className:(0,a.default)("nextui-dropdown-menu",e.className),css:f,...M,children:[...j.collection].map((e=>{if("section"===e.type)return(0,x.jsx)(d.default,{color:m,item:e,state:j,textColor:q,variant:w,onAction:D.onAction},e.key);let r=(0,x.jsx)(c.default,{color:m,item:e,state:j,textColor:q,variant:w,onAction:D.onAction},e.key);return e.wrapper&&(r=e.wrapper(r)),r}))})})}));i.__DEV__&&(f.displayName="NextUI.DropdownMenu"),f.toString=()=>".nextui-dropdown-menu";var m=f;exports["default"]=m,module.exports=exports.default;

/***/ }),

/***/ 28557:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=__webpack_require__(72928),t=__webpack_require__(77335),o=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=u(r);if(t&&t.has(e))return t.get(e);var o={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in e)if("default"!==n&&Object.prototype.hasOwnProperty.call(e,n)){var a=i?Object.getOwnPropertyDescriptor(e,n):null;a&&(a.get||a.set)?Object.defineProperty(o,n,a):o[n]=e[n]}o.default=e,t&&t.set(e,o);return o}(__webpack_require__(18038)),i=e(__webpack_require__(62358)),n=e(__webpack_require__(5136)),a=__webpack_require__(81595),s=__webpack_require__(65600),l=e(__webpack_require__(62378)),d=__webpack_require__(56786);function u(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(u=function(e){return e?t:r})(e)}const p=e=>{var a,u;const{item:p,state:c,css:f,as:x,color:w,textColor:m,variant:y,withDivider:v=!0,className:j,onAction:g}=e,{itemProps:h,headingProps:q,groupProps:b}=(0,r.useMenuSection)({heading:p.rendered,"aria-label":p["aria-label"]});return(0,d.jsxs)(o.Fragment,{children:[p.key!==c.collection.getFirstKey()&&v&&(0,d.jsx)(n.default,{as:"li",className:"nextui-dropdown-section-divider",css:{my:"$2"}}),(0,d.jsxs)(s.StyledDropdownSectionWrapper,{...h,className:"nextui-dropdown-section-wrapper",children:[p.rendered&&(0,d.jsx)(s.StyledDropdownSectionTitle,{...q,className:"nextui-dropdown-section-title",children:p.rendered}),(0,d.jsx)(s.StyledDropdownSection,{...b,as:(null==(a=p.props)?void 0:a.as)||x,className:(0,i.default)("nextui-dropdown-section",j),css:{...(0,t.mergeProps)(f,null==(u=p.props)?void 0:u.css)},children:[...p.childNodes].map((e=>{let r=(0,d.jsx)(l.default,{color:w,item:e,state:c,textColor:m,variant:y,onAction:g},e.key);return e.wrapper&&(r=e.wrapper(r)),r}))})]})]})};a.__DEV__&&(p.displayName="NextUI.DropdownSection"),p.toString=()=>".nextui-dropdown-section";var c=p;exports["default"]=c,module.exports=exports.default;

/***/ }),

/***/ 96266:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(18038)),t=e(__webpack_require__(42354)),o=__webpack_require__(81595),i=__webpack_require__(45146),u=__webpack_require__(56786);const d=r.default.forwardRef(((e,r)=>{const{children:o,...d}=e,{getMenuTriggerProps:n}=(0,i.useDropdownContext)();return(0,u.jsx)(t.default.Trigger,{...n(d),children:o})}));o.__DEV__&&(d.displayName="NextUI.DropdownTrigger"),d.toString=()=>".nextui-dropdown-trigger";var n=d;exports["default"]=n,module.exports=exports.default;

/***/ }),

/***/ 60428:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(18038)),o=e(__webpack_require__(42354)),t=__webpack_require__(81595),i=__webpack_require__(45146),n=__webpack_require__(17240),s=__webpack_require__(56786);const d=e=>{const{children:t,...d}=e,u=(0,n.useDropdown)(d),[l,a]=r.default.Children.toArray(t);return(0,s.jsx)(i.DropdownProvider,{value:u,children:(0,s.jsxs)(o.default,{ref:u.menuPopoverRef,...u.popoverProps,borderWeight:u.borderWeight,disableAnimation:u.disableAnimation,isOpen:u.state.isOpen,scrollRef:u.menuRef,triggerRef:u.menuTriggerRef,onClose:u.onClose,children:[l,a]})})};t.__DEV__&&(d.displayName="NextUI.Dropdown"),d.toString=()=>".nextui-dropdown";var u=d;exports["default"]=u,module.exports=exports.default;

/***/ }),

/***/ 65600:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledDropdownSectionWrapper=exports.StyledDropdownSectionTitle=exports.StyledDropdownSection=exports.StyledDropdownMenu=exports.StyledDropdownItemKbd=exports.StyledDropdownItemIconWrapper=exports.StyledDropdownItemDescription=exports.StyledDropdownItemContentWrapper=exports.StyledDropdownItemContent=exports.StyledDropdownItem=void 0;var o=__webpack_require__(88194),r=__webpack_require__(74042);const e=(0,o.styled)("ul",{$$dropdownItemHeight:"$space$13",$$dropdownMenuPadding:"$space$4",$$dropdownMenuWidth:"250px",$$dropdownMenuMinWidth:"250px",listStyle:"none",position:"relative",maxWidth:"$$dropdownMenuWidth",minWidth:"$$dropdownMenuMinWidth",width:"100%",p:"$$dropdownMenuPadding",m:0,outline:"none"});exports.StyledDropdownMenu=e;const t=(0,o.styled)("span",{dflex:"center",flexShrink:0,mr:"$4"});exports.StyledDropdownItemIconWrapper=t;const d=(0,o.styled)("kbd",{opacity:.8,ml:"$4",mr:0,dflex:"center",color:"$$dropdownItemKeyboardColor",fontSize:"$xs",fontFamily:"$sans",boxShadow:"none",bg:"transparent",transition:"border 0.12s ease 0s"});exports.StyledDropdownItemKbd=d;const n=(0,o.styled)("div",{d:"flex",flex:"1 1 0%",flexDirection:"column",alignItems:"flex-start",lineHeight:1.2});exports.StyledDropdownItemContentWrapper=n;const $=(0,o.styled)("span",{flex:"1 1 0%"});exports.StyledDropdownItemContent=$;const s=(0,o.styled)("span",{fontSize:"$xs",color:"$$dropdownItemDescriptionColor",truncateText:"calc($$dropdownMenuWidth * 0.9)",transition:"color 0.12s ease 0s",variants:{hasIcon:{true:{truncateText:"calc($$dropdownMenuWidth * 0.7)"}},hasCommand:{true:{truncateText:"calc($$dropdownMenuWidth * 0.7)"}}},compoundVariants:[{hasIcon:!0,hasCommand:!0,css:{truncateText:"calc($$dropdownMenuWidth * 0.6)"}}]});exports.StyledDropdownItemDescription=s;const l=(0,o.styled)("li",{$$dropdownItemPressedScale:.97,$$dropdownItemTextColor:"$colors$text",$$dropdownItemBorderRadius:"$radii$sm",$$dropdownItemKeyboardColor:"$colors$accents8",$$dropdownItemDescriptionColor:"$colors$accents8",dflex:"center",outline:"none",cursor:"pointer",justifyContent:"space-between",bg:"transparent",position:"relative",height:"$$dropdownItemHeight",px:"$6",br:"$$dropdownItemBorderRadius",color:"$$dropdownItemTextColor",mb:0,transition:"$dropdownItem",transform:"translateZ(0)",backfaceVisibility:"hidden",$$dropdownItemShadow:"$colors$primaryShadow","@motion":{transition:"none",[`& ${d}`]:{transition:"none"},[`& ${s}`]:{transition:"none"}},variants:{color:{default:{$$dropdownItemHoverBackground:"$colors$neutralLight",$$dropdownItemHoverTextColor:"$colors$neutralLightContrast",$$dropdownItemActiveBackground:"$colors$neutralLightActive",$$dropdownItemSolidHoverBackground:"$colors$neutral",$$dropdownItemSolidHoverTextColor:"$colors$neutralSolidContrast",$$dropdownItemShadow:"$colors$neutralShadow",$$dropdownItemHoverBorderColor:"$colors$neutralBorder"},primary:{$$dropdownItemHoverBackground:"$colors$primaryLight",$$dropdownItemHoverTextColor:"$colors$primaryLightContrast",$$dropdownItemActiveBackground:"$colors$primaryLightActive",$$dropdownItemSolidHoverBackground:"$colors$primary",$$dropdownItemSolidHoverTextColor:"$colors$primarySolidContrast",$$dropdownItemShadow:"$colors$primaryShadow",$$dropdownItemHoverBorderColor:"$colors$primaryBorder"},secondary:{$$dropdownItemHoverBackground:"$colors$secondaryLight",$$dropdownItemHoverTextColor:"$colors$secondaryLightContrast",$$dropdownItemActiveBackground:"$colors$secondaryLightActive",$$dropdownItemSolidHoverBackground:"$colors$secondary",$$dropdownItemSolidHoverTextColor:"$colors$secondarySolidContrast",$$dropdownItemShadow:"$colors$secondaryShadow",$$dropdownItemHoverBorderColor:"$colors$secondaryBorder"},success:{$$dropdownItemHoverBackground:"$colors$successLight",$$dropdownItemHoverTextColor:"$colors$successLightContrast",$$dropdownItemActiveBackground:"$colors$successLightActive",$$dropdownItemSolidHoverBackground:"$colors$success",$$dropdownItemSolidHoverTextColor:"$colors$successSolidContrast",$$dropdownItemShadow:"$colors$successShadow",$$dropdownItemHoverBorderColor:"$colors$successBorder"},warning:{$$dropdownItemHoverBackground:"$colors$warningLight",$$dropdownItemHoverTextColor:"$colors$warningLightContrast",$$dropdownItemActiveBackground:"$colors$warningLightActive",$$dropdownItemSolidHoverBackground:"$colors$warning",$$dropdownItemSolidHoverTextColor:"$colors$warningSolidContrast",$$dropdownItemShadow:"$colors$warningShadow",$$dropdownItemHoverBorderColor:"$colors$warningBorder"},error:{$$dropdownItemHoverBackground:"$colors$errorLight",$$dropdownItemHoverTextColor:"$colors$errorLightContrast",$$dropdownItemActiveBackground:"$colors$errorLightActive",$$dropdownItemSolidHoverBackground:"$colors$error",$$dropdownItemSolidHoverTextColor:"$colors$errorSolidContrast",$$dropdownItemShadow:"$colors$errorShadow",$$dropdownItemHoverBorderColor:"$colors$errorBorder"}},textColor:{default:{},primary:{$$dropdownItemTextColor:"$colors$primaryLightContrast",$$dropdownItemHoverTextColor:"$colors$primaryLightContrast"},secondary:{$$dropdownItemTextColor:"$colors$secondaryLightContrast",$$dropdownItemHoverTextColor:"$colors$secondaryLightContrast"},success:{$$dropdownItemTextColor:"$colors$successLightContrast",$$dropdownItemHoverTextColor:"$colors$successLightContrast"},warning:{$$dropdownItemTextColor:"$colors$warningLightContrast",$$dropdownItemHoverTextColor:"$colors$warningLightContrast"},error:{$$dropdownItemTextColor:"$colors$errorLightContrast",$$dropdownItemHoverTextColor:"$colors$errorLightContrast"}},variant:{flat:{true:{}},light:{true:{}},solid:{true:{}},shadow:{true:{}}},isPressed:{true:{bg:"$$dropdownItemActiveBackground"}},isFocused:{true:{bg:"$$dropdownItemHoverBackground",color:"$$dropdownItemHoverTextColor",zIndex:"$1",[`& ${d}`]:{color:"$$dropdownItemHoverTextColor",borderColor:"$$dropdownItemHoverBorderColor"},[`& ${s}`]:{color:"currentColor"}}},isHovered:{true:{bg:"$$dropdownItemHoverBackground",color:"$$dropdownItemHoverTextColor",[`& ${d}`]:{color:"$$dropdownItemHoverTextColor",borderColor:"$$dropdownItemHoverBorderColor"},[`& ${s}`]:{color:"currentColor"}}},shouldShowOutline:{true:{outline:"solid 2px $$dropdownItemActiveBackground"}},isSelected:{true:{}},isSelectable:{true:{}},isDisabled:{true:{color:"$accents5",cursor:"default"}},withDescription:{true:{height:"calc($$dropdownItemHeight * 1.2)"}},withDivider:{true:{mt:"$6","&:before":{content:'""',position:"absolute",top:"-$3",left:"-$$dropdownMenuPadding",right:"-$$dropdownMenuPadding",height:"$$dropdownItemBorderWeight",bg:"$border"}}},dividerWeight:{light:{$$dropdownItemBorderWeight:"$borderWeights$light"},normal:{$$dropdownItemBorderWeight:"$borderWeights$normal"},bold:{$$dropdownItemBorderWeight:"$borderWeights$bold"},extrabold:{$$dropdownItemBorderWeight:"$borderWeights$extrabold"},black:{$$dropdownItemBorderWeight:"$borderWeights$black"}},showFullDescription:{true:{[`& ${s}`]:{mt:"$2",overflow:"visible",textOverflow:"visible",whiteSpace:"normal"}}},disableAnimation:{true:{transition:"none",[`& ${d}`]:{transition:"none"},[`& ${s}`]:{transition:"none"}}}},compoundVariants:[{isPressed:!0,disableAnimation:!1,css:{transform:"scale($$dropdownItemPressedScale)"}},{isHovered:!0,variant:"light",css:{bg:"transparent"}},{isFocused:!0,variant:"light",css:{bg:"transparent"}},{isHovered:!0,variant:"solid",css:{bg:"$$dropdownItemSolidHoverBackground",color:"$$dropdownItemSolidHoverTextColor",[`& ${d}`]:{color:"$$dropdownItemSolidHoverTextColor"}}},{isFocused:!0,variant:"solid",css:{bg:"$$dropdownItemSolidHoverBackground",color:"$$dropdownItemSolidHoverTextColor",[`& ${d}`]:{color:"$$dropdownItemSolidHoverTextColor"}}},{isHovered:!0,variant:"shadow",css:{bg:"$$dropdownItemSolidHoverBackground",color:"$$dropdownItemSolidHoverTextColor",boxShadow:"0 3px 10px 0 $$dropdownItemShadow",[`& ${d}`]:{color:"$$dropdownItemSolidHoverTextColor"}}},{isFocused:!0,variant:"shadow",css:{bg:"$$dropdownItemSolidHoverBackground",color:"$$dropdownItemSolidHoverTextColor",boxShadow:"0 3px 10px 0 $$dropdownItemShadow",[`& ${d}`]:{color:"$$dropdownItemSolidHoverTextColor"}}},{variant:"flat",color:"default",css:{$$dropdownItemHoverTextColor:"$colors$foreground"}}],defaultVariants:{color:"default",textColor:"default",dividerWeight:"light",variant:"flat"}},r.cssFocusVisible);exports.StyledDropdownItem=l;const i=(0,o.styled)("li",{mb:0});exports.StyledDropdownSectionWrapper=i;const c=(0,o.styled)("ul",{m:0,p:0,listStyle:"none"});exports.StyledDropdownSection=c;const a=(0,o.styled)("span",{fontWeight:"$medium",fontSize:"$xs",padding:"0 $4",color:"$accents8"});exports.StyledDropdownSectionTitle=a;

/***/ }),

/***/ 19371:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledDropdownSectionWrapper=exports.StyledDropdownSectionTitle=exports.StyledDropdownSection=exports.StyledDropdownMenu=exports.StyledDropdownItemKbd=exports.StyledDropdownItemIconWrapper=exports.StyledDropdownItemDescription=exports.StyledDropdownItemContentWrapper=exports.StyledDropdownItemContent=exports.StyledDropdownItem=void 0;var t=__webpack_require__(92775),o=e(__webpack_require__(47250)),r=e(__webpack_require__(96266)),d=e(__webpack_require__(19942)),p=e(__webpack_require__(11561)),n=e(__webpack_require__(60428)),l=__webpack_require__(65600);exports.StyledDropdownMenu=l.StyledDropdownMenu,exports.StyledDropdownItem=l.StyledDropdownItem,exports.StyledDropdownItemIconWrapper=l.StyledDropdownItemIconWrapper,exports.StyledDropdownItemKbd=l.StyledDropdownItemKbd,exports.StyledDropdownItemContentWrapper=l.StyledDropdownItemContentWrapper,exports.StyledDropdownItemContent=l.StyledDropdownItemContent,exports.StyledDropdownItemDescription=l.StyledDropdownItemDescription,exports.StyledDropdownSectionWrapper=l.StyledDropdownSectionWrapper,exports.StyledDropdownSection=l.StyledDropdownSection,exports.StyledDropdownSectionTitle=l.StyledDropdownSectionTitle,n.default.Trigger=r.default,n.default.Button=p.default,n.default.Menu=d.default,n.default.Section=t.Section,n.default.Item=o.default;var S=n.default;exports["default"]=S;

/***/ }),

/***/ 17240:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.useDropdown=function(t={}){const{triggerRef:a,type:u="menu",trigger:o="press",isDisabled:l=!1,borderWeight:g,closeOnSelect:p,disableAnimation:c=!1,disableTriggerPressedAnimation:d=!1,isOpen:f,defaultOpen:m,onOpenChange:b,...P}=t,C=(0,e.useRef)(null),O=a||C,R=(0,e.useRef)(null),T=(0,e.useRef)(null),h=(0,n.useMenuTriggerState)({...t,isOpen:f,defaultOpen:m,onOpenChange:b}),{menuTriggerProps:y,menuProps:q}=(0,s.useMenuTrigger)({type:u,trigger:o,isDisabled:l},h,O),A=(0,e.useCallback)((()=>{h.close(),null==P.onClose||P.onClose()}),[h.close,P.onClose]),M=(0,e.useCallback)(((e={},s=null)=>{const{css:n,...t}=null!=a&&a.current?(0,r.mergeProps)(y,e):(0,r.mergeProps)(e,y);return{ref:(0,i.mergeRefs)(C,s),css:d?n:{'&[aria-haspopup="true"]&[aria-expanded="true"]':{opacity:.7,backfaceVisibility:"hidden",transform:"translateZ(0) scale(0.97)"},...n},...t}}),[C,a,y,d]);return{...q,popoverProps:P,state:h,ref:R,onClose:A,autoFocus:h.focusStrategy||!0,disableAnimation:c,disableTriggerPressedAnimation:d,menuRef:R,borderWeight:g,menuPopoverRef:T,menuTriggerRef:O,closeOnSelect:p,getMenuTriggerProps:M}};var e=__webpack_require__(18038),r=__webpack_require__(77335),s=__webpack_require__(72928),n=__webpack_require__(66409),i=__webpack_require__(45728);

/***/ }),

/***/ 35746:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=u(r);if(t&&t.has(e))return t.get(e);var a={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in e)if("default"!==n&&Object.prototype.hasOwnProperty.call(e,n)){var l=i?Object.getOwnPropertyDescriptor(e,n):null;l&&(l.get||l.set)?Object.defineProperty(a,n,l):a[n]=e[n]}a.default=e,t&&t.set(e,a);return a}(__webpack_require__(18038)),t=e(__webpack_require__(62358)),a=e(__webpack_require__(25457)),i=e(__webpack_require__(53125)),n=__webpack_require__(56786);function u(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(u=function(e){return e?t:r})(e)}const l=r.default.forwardRef((({gap:e,wrap:a,css:u,children:l,className:o,...s},c)=>{const p=(0,r.useMemo)((()=>`calc(${e} * $space$3)`),[e]);return(0,n.jsx)(i.default,{ref:c,className:(0,t.default)("nextui-grid-container",o),css:{$$gridGapUnit:p,display:"flex",flexWrap:a,boxSizing:"border-box",margin:"calc(-1 * $$gridGapUnit)",width:"calc(100% + $$gridGapUnit * 2)",...u},...s,children:l})}));l.displayName="NextUI.GridContainer",l.toString=()=>".nextui-grid-container";var o=(0,a.default)(l,{gap:0,wrap:"wrap",className:""});exports["default"]=o,module.exports=exports.default;

/***/ }),

/***/ 53125:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=l(t);if(r&&r.has(e))return r.get(e);var i={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if("default"!==s&&Object.prototype.hasOwnProperty.call(e,s)){var a=n?Object.getOwnPropertyDescriptor(e,s):null;a&&(a.get||a.set)?Object.defineProperty(i,s,a):i[s]=e[s]}i.default=e,r&&r.set(e,i);return i}(__webpack_require__(18038)),r=e(__webpack_require__(62358)),i=e(__webpack_require__(25457)),n=__webpack_require__(65656),s=__webpack_require__(56786);function l(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(l=function(e){return e?r:t})(e)}const a=e=>{const t=0===e?"none":"inherit";if("number"==typeof e){const r=100/12*e,i=r>100?"100%":r<0?"0":`${r}%`;return{flexGrow:0,display:t,maxWidth:i,flexBasis:i}}return{flexGrow:1,display:t,maxWidth:"100%",flexBasis:"0"}},u=t.default.forwardRef((({xs:e,sm:i,md:l,lg:u,xl:o,css:f,justify:d,direction:c,alignItems:x,alignContent:m,children:p,className:y,...g},j)=>{const b=(0,t.useMemo)((()=>{const t={xs:e,sm:i,md:l,lg:u,xl:o};return Object.keys(t).reduce(((e,r)=>void 0!==t[r]&&!1!==t[r]?`${e} ${r}`:e),"").trim()}),[e,i,l,u,o]);return(0,s.jsx)(n.StyledGridItem,{ref:j,className:(0,r.default)("nextui-grid-item",b,y),css:{alignItems:x,alignContent:m,justifyContent:d,flexDirection:c,"&.xs":{...a(e)},"@xsMax":{"&.xs":{...a(e)}},"@sm":{"&.sm":{...a(i)}},"@md":{"&.md":{...a(l)}},"@lg":{"&.lg":{...a(u)}},"@xl":{"&.xl":{...a(o)}},...f},...g,children:p})}));u.displayName="NextUI.GridItem",u.toString=()=>".nextui-grid-item";var o=(0,i.default)(u,{xs:!1,sm:!1,md:!1,lg:!1,xl:!1,className:""});exports["default"]=o,module.exports=exports.default;

/***/ }),

/***/ 17945:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(18038)),t=e(__webpack_require__(53125)),i=__webpack_require__(56786);const u=r.default.forwardRef((({children:e,css:r,...u},a)=>(0,i.jsx)(t.default,{ref:a,css:r,...u,children:e})));u.displayName="NextUI.Grid",u.toString=()=>".nextui-grid";var a=u;exports["default"]=a,module.exports=exports.default;

/***/ }),

/***/ 65656:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledGridItem=exports.StyledGridContainer=void 0;var e=__webpack_require__(88194);const t=(0,e.styled)("div",{});exports.StyledGridContainer=t;const d=(0,e.styled)("div",{margin:0,boxSizing:"border-box",padding:"$$gridGapUnit"});exports.StyledGridItem=d;

/***/ }),

/***/ 64027:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledGridItem=exports.StyledGridContainer=void 0;var r=e(__webpack_require__(17945)),t=e(__webpack_require__(35746)),d=__webpack_require__(65656);exports.StyledGridContainer=d.StyledGridContainer,exports.StyledGridItem=d.StyledGridItem,r.default.Container=t.default;var i=r.default;exports["default"]=i;

/***/ }),

/***/ 39691:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.Image=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=f(t);if(r&&r.has(e))return r.get(e);var a={},u=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if("default"!==s&&Object.prototype.hasOwnProperty.call(e,s)){var i=u?Object.getOwnPropertyDescriptor(e,s):null;i&&(i.get||i.set)?Object.defineProperty(a,s,i):a[s]=e[s]}a.default=e,r&&r.set(e,a);return a}(__webpack_require__(18038)),r=e(__webpack_require__(57539)),a=e(__webpack_require__(32821)),u=e(__webpack_require__(31650)),s=__webpack_require__(73726),i=__webpack_require__(81595),o=e(__webpack_require__(62358)),n=__webpack_require__(56553),l=e(__webpack_require__(93381)),c=__webpack_require__(56786);function f(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(f=function(e){return e?r:t})(e)}const d=t.default.forwardRef(((e,i)=>{const{src:f,width:d,height:p,showSkeleton:m=!0,className:g,maxDelay:h=3e3,autoResize:y=!1,objectFit:x="scale-down",containerCss:w,css:b,...j}=e,q=(0,s.useDOMRef)(i),[v,O]=(0,t.useState)(!0),[M,_]=(0,t.useState)(m),{w:D,h:I}=(0,t.useMemo)((()=>({w:d?"number"==typeof d?`${d}px`:d:"auto",h:p?"number"==typeof p?`${p}px`:p:"auto"})),[d,p]),[S,k,N]=(0,a.default)(I),[P,E]=(0,r.default)(q),R=m&&!!d&&!!p;(0,t.useEffect)((()=>{q.current&&q.current.complete&&(O(!1),_(!1))})),(0,t.useEffect)((()=>{const e=setTimeout((()=>{R&&_(!1),clearTimeout(e)}),h);return()=>clearTimeout(e)}),[v]),(0,t.useEffect)((()=>{if(!y)return;const e=0===P.width,t="auto"===N.current;!e&&d&&p&&(P.width<d?!t&&k("auto"):t&&k(I))}),[P,d]),(0,u.default)((()=>{y&&E()}));const T=(0,t.useMemo)((()=>v?"loading":"ready"),[v]);return(0,c.jsxs)(n.StyledImageContainer,{className:(0,o.default)("nextui-image-container",`nextui-image--${T}`,g),css:{width:D,height:S,...w},"data-state":T,ready:!v||M,children:[M&&(0,c.jsx)(l.default,{opacity:1}),(0,c.jsx)(n.StyledImage,{ref:q,alt:e.alt||"",className:"nextui-image",css:{objectFit:x,...b},"data-state":T,height:p,src:f,width:d,onLoad:()=>{O(!1)},...j})]})}));exports.Image=d,i.__DEV__&&(d.displayName="NextUI.Image"),d.toString=()=>".nextui-image";var p=t.default.memo(d);exports["default"]=p;

/***/ }),

/***/ 93381:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=e(__webpack_require__(18038)),s=e(__webpack_require__(25457)),a=e(__webpack_require__(62358)),r=__webpack_require__(81595),i=__webpack_require__(56553),l=__webpack_require__(56786);const u=t.default.memo((({opacity:e,css:t,className:s,...r})=>(0,l.jsx)(i.StyledImageSkeleton,{className:(0,a.default)("nextui-image-skeleton",s),css:{opacity:e,...t},...r})));r.__DEV__&&(u.displayName="NextUI.ImageSkeleton"),u.toString=()=>".nextui-image-skeleton";var o=(0,s.default)(u,{opacity:.5,className:""});exports["default"]=o,module.exports=exports.default;

/***/ }),

/***/ 56553:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledImageSkeleton=exports.StyledImageContainer=exports.StyledImage=void 0;var e=__webpack_require__(88194);const t=(0,e.keyframes)({"0%":{backgroundPosition:"200% 0"},to:{backgroundPosition:"-200% 0"}}),o=(0,e.styled)("div",{opacity:0,margin:"0 auto",position:"relative",overflow:"hidden",maxWidth:"100%",transition:"transform 250ms ease 0ms, opacity 200ms ease-in 0ms","@motion":{transition:"none"},variants:{ready:{true:{opacity:1},false:{opacity:0}}}});exports.StyledImageContainer=o;const i=(0,e.styled)("img",{size:"100%",display:"block"});exports.StyledImage=i;const s=(0,e.styled)("div",{position:"absolute",top:0,left:0,right:0,bottom:0,size:"100%",borderRadius:"inherit",backgroundImage:"linear-gradient(270deg, $colors$accents1, $colors$accents2, $colors$accents2, $colors$accents1)",backgroundSize:"400% 100%",animation:`${t} 5s ease-in-out infinite`,transition:"opacity 300ms ease-out"});exports.StyledImageSkeleton=s;

/***/ }),

/***/ 6361:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledImageSkeleton=exports.StyledImageContainer=exports.StyledImage=void 0;var t=e(__webpack_require__(39691)),r=__webpack_require__(56553);exports.StyledImageContainer=r.StyledImageContainer,exports.StyledImage=r.StyledImage,exports.StyledImageSkeleton=r.StyledImageSkeleton;var a=t.default;exports["default"]=a;

/***/ }),

/***/ 80345:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0;var r={useCurrentState:!0,useRealShape:!0,useResize:!0,useTheme:!0,usePortal:!0,useSSR:!0,useBodyScroll:!0,useClickAway:!0,useClipboard:!0,useClickAnywhere:!0,useInput:!0,useKeyboard:!0,usePagination:!0,useScrollPosition:!0,useIntersectionObserver:!0,useDrip:!0,Drip:!0,CssBaseline:!0,NextUIProvider:!0,Avatar:!0,Button:!0,Card:!0,Checkbox:!0,Code:!0,Col:!0,Collapse:!0,Container:!0,Divider:!0,Grid:!0,Image:!0,Spacer:!0,Snippet:!0,Row:!0,Link:!0,Loading:!0,Radio:!0,Text:!0,Switch:!0,Backdrop:!0,User:!0,Progress:!0,Modal:!0,useModal:!0,Pagination:!0,Tooltip:!0,Input:!0,Textarea:!0,Table:!0,Popover:!0,Dropdown:!0,Badge:!0,Navbar:!0,KeyMod:!0,KeyCode:!0,useAsyncList:!0,useCollator:!0,changeTheme:!0,getDocumentTheme:!0,getTokenValue:!0,styled:!0,css:!0,theme:!0,defaultTheme:!0,createTheme:!0,getCssText:!0,globalCss:!0,keyframes:!0,config:!0,stitchesConfig:!0};exports.useTheme=exports.useScrollPosition=exports.useSSR=exports.useResize=exports.useRealShape=exports.usePortal=exports.usePagination=exports.useModal=exports.useKeyboard=exports.useIntersectionObserver=exports.useInput=exports.useDrip=exports.useCurrentState=exports.useCollator=exports.useClipboard=exports.useClickAway=exports.useClickAnywhere=exports.useBodyScroll=exports.useAsyncList=exports.theme=exports.styled=exports.stitchesConfig=exports.keyframes=exports.globalCss=exports.getTokenValue=exports.getDocumentTheme=exports.getCssText=exports.defaultTheme=exports.css=exports.createTheme=exports.config=exports.changeTheme=exports.User=exports.Tooltip=exports.Textarea=exports.Text=exports.Table=exports.Switch=exports.Spacer=exports.Snippet=exports.Row=exports.Radio=exports.Progress=exports.Popover=exports.Pagination=exports.NextUIProvider=exports.Navbar=exports.Modal=exports.Loading=exports.Link=exports.KeyMod=exports.KeyCode=exports.Input=exports.Image=exports.Grid=exports.Dropdown=exports.Drip=exports.Divider=exports.CssBaseline=exports.Container=exports.Collapse=exports.Col=exports.Code=exports.Checkbox=exports.Card=exports.Button=exports.Badge=exports.Backdrop=exports.Avatar=void 0;var t=__webpack_require__(65654);Object.keys(t).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===t[e]||(exports[e]=t[e]))}));var o=e(__webpack_require__(32821));exports.useCurrentState=o.default;var s=e(__webpack_require__(57539));exports.useRealShape=s.default;var a=e(__webpack_require__(31650));exports.useResize=a.default;var p=e(__webpack_require__(47902));exports.useTheme=p.default;var u=e(__webpack_require__(79090));exports.usePortal=u.default;var l=e(__webpack_require__(90658));exports.useSSR=l.default;var i=e(__webpack_require__(66551));exports.useBodyScroll=i.default;var n=e(__webpack_require__(69152));exports.useClickAway=n.default;var c=e(__webpack_require__(12458));exports.useClipboard=c.default;var x=e(__webpack_require__(31709));exports.useClickAnywhere=x.default;var d=e(__webpack_require__(46960));exports.useInput=d.default;var f=e(__webpack_require__(60690));exports.useKeyboard=f.default;var y=e(__webpack_require__(60704));exports.usePagination=y.default;var h=e(__webpack_require__(93517));exports.useScrollPosition=h.default;var O=e(__webpack_require__(20027));exports.useIntersectionObserver=O.default;var b=e(__webpack_require__(19964));exports.useDrip=b.default;var v=e(__webpack_require__(24192));exports.Drip=v.default;var j=__webpack_require__(88957);exports.KeyMod=j.KeyMod,exports.KeyCode=j.KeyCode;var _=e(__webpack_require__(94754));exports.CssBaseline=_.default;var k=__webpack_require__(23385);exports.useAsyncList=k.useAsyncList;var q=__webpack_require__(2211);exports.useCollator=q.useCollator;var P=e(__webpack_require__(62356));exports.NextUIProvider=P.default;var w=__webpack_require__(89026);exports.changeTheme=w.changeTheme,exports.getDocumentTheme=w.getDocumentTheme,exports.getTokenValue=w.getTokenValue;var g=__webpack_require__(88194);exports.styled=g.styled,exports.css=g.css,exports.theme=g.theme,exports.createTheme=g.createTheme,exports.getCssText=g.getCssText,exports.globalCss=g.globalCss,exports.keyframes=g.keyframes,exports.config=g.config,exports.stitchesConfig=g.config,exports.defaultTheme=g.theme;var C=__webpack_require__(74042);Object.keys(C).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===C[e]||(exports[e]=C[e]))}));var M=__webpack_require__(16701);Object.keys(M).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===M[e]||(exports[e]=M[e]))}));var m=ie(__webpack_require__(21013));exports.Avatar=m.default,Object.keys(m).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===m[e]||(exports[e]=m[e]))}));var T=ie(__webpack_require__(73831));exports.Button=T.default,Object.keys(T).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===T[e]||(exports[e]=T[e]))}));var E=ie(__webpack_require__(1853));exports.Card=E.default,Object.keys(E).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===E[e]||(exports[e]=E[e]))}));var S=ie(__webpack_require__(32140));exports.Checkbox=S.default,Object.keys(S).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===S[e]||(exports[e]=S[e]))}));var D=ie(__webpack_require__(58420));exports.Code=D.default,Object.keys(D).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===D[e]||(exports[e]=D[e]))}));var R=ie(__webpack_require__(19316));exports.Col=R.default,Object.keys(R).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===R[e]||(exports[e]=R[e]))}));var B=ie(__webpack_require__(82166));exports.Collapse=B.default,Object.keys(B).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===B[e]||(exports[e]=B[e]))}));var I=ie(__webpack_require__(21213));exports.Container=I.default,Object.keys(I).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===I[e]||(exports[e]=I[e]))}));var A=ie(__webpack_require__(5136));exports.Divider=A.default,Object.keys(A).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===A[e]||(exports[e]=A[e]))}));var K=ie(__webpack_require__(64027));exports.Grid=K.default,Object.keys(K).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===K[e]||(exports[e]=K[e]))}));var L=ie(__webpack_require__(6361));exports.Image=L.default,Object.keys(L).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===L[e]||(exports[e]=L[e]))}));var N=ie(__webpack_require__(73441));exports.Spacer=N.default,Object.keys(N).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===N[e]||(exports[e]=N[e]))}));var U=ie(__webpack_require__(76541));exports.Snippet=U.default,Object.keys(U).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===U[e]||(exports[e]=U[e]))}));var z=ie(__webpack_require__(17235));exports.Row=z.default,Object.keys(z).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===z[e]||(exports[e]=z[e]))}));var V=ie(__webpack_require__(74222));exports.Link=V.default,Object.keys(V).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===V[e]||(exports[e]=V[e]))}));var G=ie(__webpack_require__(37103));exports.Loading=G.default,Object.keys(G).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===G[e]||(exports[e]=G[e]))}));var W=ie(__webpack_require__(96025));exports.Radio=W.default,Object.keys(W).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===W[e]||(exports[e]=W[e]))}));var F=ie(__webpack_require__(2387));exports.Text=F.default,Object.keys(F).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===F[e]||(exports[e]=F[e]))}));var H=ie(__webpack_require__(39003));exports.Switch=H.default,Object.keys(H).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===H[e]||(exports[e]=H[e]))}));var J=ie(__webpack_require__(41222));exports.Backdrop=J.default,Object.keys(J).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===J[e]||(exports[e]=J[e]))}));var Q=ie(__webpack_require__(96956));exports.User=Q.default,Object.keys(Q).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===Q[e]||(exports[e]=Q[e]))}));var X=ie(__webpack_require__(37598));exports.Progress=X.default,Object.keys(X).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===X[e]||(exports[e]=X[e]))}));var Y=ie(__webpack_require__(99253));exports.Modal=Y.default,Object.keys(Y).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===Y[e]||(exports[e]=Y[e]))}));var Z=e(__webpack_require__(17175));exports.useModal=Z.default;var $=ie(__webpack_require__(19818));exports.Pagination=$.default,Object.keys($).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===$[e]||(exports[e]=$[e]))}));var ee=ie(__webpack_require__(52089));exports.Tooltip=ee.default,Object.keys(ee).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===ee[e]||(exports[e]=ee[e]))}));var re=ie(__webpack_require__(9492));exports.Input=re.default,Object.keys(re).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===re[e]||(exports[e]=re[e]))}));var te=e(__webpack_require__(59770));exports.Textarea=te.default;var oe=ie(__webpack_require__(71698));exports.Table=oe.default,Object.keys(oe).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===oe[e]||(exports[e]=oe[e]))}));var se=ie(__webpack_require__(42354));exports.Popover=se.default,Object.keys(se).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===se[e]||(exports[e]=se[e]))}));var ae=ie(__webpack_require__(19371));exports.Dropdown=ae.default,Object.keys(ae).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===ae[e]||(exports[e]=ae[e]))}));var pe=ie(__webpack_require__(81034));exports.Badge=pe.default,Object.keys(pe).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===pe[e]||(exports[e]=pe[e]))}));var ue=ie(__webpack_require__(57884));function le(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(le=function(e){return e?t:r})(e)}function ie(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=le(r);if(t&&t.has(e))return t.get(e);var o={},s=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if("default"!==a&&Object.prototype.hasOwnProperty.call(e,a)){var p=s?Object.getOwnPropertyDescriptor(e,a):null;p&&(p.get||p.set)?Object.defineProperty(o,a,p):o[a]=e[a]}return o.default=e,t&&t.set(e,o),o}exports.Navbar=ue.default,Object.keys(ue).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(r,e)||e in exports&&exports[e]===ue[e]||(exports[e]=ue[e]))}));

/***/ }),

/***/ 9492:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledInputWrapper=exports.StyledInputPlaceholder=exports.StyledInputMainContainer=exports.StyledInputLabel=exports.StyledInputContent=exports.StyledInputContainer=exports.StyledInputClearButton=exports.StyledInputBlockLabel=exports.StyledInput=exports.StyledHelperTextContainer=exports.StyledHelperText=void 0;var t=e(__webpack_require__(58561)),p=e(__webpack_require__(72645)),r=__webpack_require__(14418);exports.StyledInputMainContainer=r.StyledInputMainContainer,exports.StyledInputContainer=r.StyledInputContainer,exports.StyledInputWrapper=r.StyledInputWrapper,exports.StyledHelperTextContainer=r.StyledHelperTextContainer,exports.StyledHelperText=r.StyledHelperText,exports.StyledInputPlaceholder=r.StyledInputPlaceholder,exports.StyledInputBlockLabel=r.StyledInputBlockLabel,exports.StyledInputLabel=r.StyledInputLabel,exports.StyledInputContent=r.StyledInputContent,exports.StyledInputClearButton=r.StyledInputClearButton,exports.StyledInput=r.StyledInput,t.default.Password=p.default;var l=t.default;exports["default"]=l;

/***/ }),

/***/ 72645:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=l(t);if(r&&r.has(e))return r.get(e);var n={},u=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if("default"!==i&&Object.prototype.hasOwnProperty.call(e,i)){var o=u?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(n,i,o):n[i]=e[i]}n.default=e,r&&r.set(e,n);return n}(__webpack_require__(18038)),r=e(__webpack_require__(25457)),n=e(__webpack_require__(62358)),u=__webpack_require__(81595),i=__webpack_require__(19941),o=e(__webpack_require__(19122)),s=e(__webpack_require__(58561)),a=__webpack_require__(56786);function l(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(l=function(e){return e?r:t})(e)}const p={...i.defaultProps,hideToggle:!1,visibleIcon:(0,a.jsx)(o.default,{visible:!0}),hiddenIcon:(0,a.jsx)(o.default,{visible:!1})},d=t.default.forwardRef((({hideToggle:e,visibleIcon:r,hiddenIcon:u,children:i,...o},l)=>{const p=(0,t.useRef)(null),[d,f]=(0,t.useState)(!1);(0,t.useImperativeHandle)(l,(()=>p.current));const c=()=>{f((e=>!e))},v=(0,t.useMemo)((()=>({...o,ref:p,className:(0,n.default)("nextui-input-password",o.className),contentClickable:!0,onContentClick:c,type:d?"text":"password"})),[o,c,d,p]),x=(0,t.useMemo)((()=>e?null:d?r:u),[e,d,r,u]);return(0,a.jsx)(s.default,{contentRight:x,...v,children:i})}));u.__DEV__&&(d.displayName="NextUI.InputPassword"),d.toString=()=>".nextui-input-password";var f=(0,r.default)(d,p);exports["default"]=f,module.exports=exports.default;

/***/ }),

/***/ 19941:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.defaultProps=void 0;exports.defaultProps={disabled:!1,bordered:!1,readOnly:!1,clearable:!1,rounded:!1,animated:!0,underlined:!1,shadow:!0,fullWidth:!1,contentClickable:!1,contentRightStyling:!0,contentLeftStyling:!0,required:!1,width:"initial",size:"md",color:"default",helperColor:"default",status:"default",borderWeight:"normal",autoComplete:"off",className:"",placeholder:"",initialValue:""};

/***/ }),

/***/ 58561:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var a=p(t);if(a&&a.has(e))return a.get(e);var r={},l=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in e)if("default"!==n&&Object.prototype.hasOwnProperty.call(e,n)){var i=l?Object.getOwnPropertyDescriptor(e,n):null;i&&(i.get||i.set)?Object.defineProperty(r,n,i):r[n]=e[n]}r.default=e,a&&a.set(e,r);return r}(__webpack_require__(18038)),a=__webpack_require__(26894),r=__webpack_require__(94135),l=e(__webpack_require__(47902)),n=__webpack_require__(10084),i=e(__webpack_require__(77162)),o=e(__webpack_require__(62358)),s=__webpack_require__(81595),d=__webpack_require__(14418),u=__webpack_require__(19941),c=__webpack_require__(56786);function p(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,a=new WeakMap;return(p=function(e){return e?a:t})(e)}const f="nextui-input",h=t.default.forwardRef((({as:e="input",label:u,labelPlaceholder:p,labelLeft:h,labelRight:b,size:m,helperText:y,color:x,helperColor:$,status:g,contentLeft:C,contentRight:v,contentClickable:w,contentLeftStyling:S,contentRightStyling:j,onContentClick:I,initialValue:k,onChange:q,readOnly:N,value:P,onClearClick:M,clearable:O,shadow:R,animated:D,required:L,width:F,className:T,onBlur:W,onFocus:_,autoComplete:V,placeholder:B,fullWidth:E,borderWeight:H,disabled:U,bordered:z,underlined:A,rounded:G,css:J,...K},Q)=>{const X=(0,t.useRef)(null);(0,t.useImperativeHandle)(Q,(()=>X.current));const[Y,Z]=(0,t.useState)(k),[ee,te]=(0,t.useState)(!1),{isDark:ae}=(0,l.default)(),re=(0,t.useMemo)((()=>void 0!==P),[P]),le=(0,t.useMemo)((()=>u||p),[u,p]),ne=(0,t.useMemo)((()=>p?"":B),[B,p]),ie=(0,t.useMemo)((()=>E?"100%":F||"initial"),[E,F]);A&&s.__DEV__&&(z&&(0,n.warn)("Using underlined and bordered at the same time will have no effect."),G&&(0,n.warn)("Using underlined and rounded at the same time will have no effect."));const oe=(e,t)=>{U||I&&I(e,t)};(0,t.useEffect)((()=>{re&&Z(P)}),[re,P]);const se=(0,t.useMemo)((()=>"textarea"===e),[e]),de={...K,...re?{value:P}:{defaultValue:k}},{isFocusVisible:ue,focusProps:ce}=(0,r.useFocusRing)(),{labelProps:pe,fieldProps:fe}=(0,a.useLabel)({...de,label:le}),he=(0,t.useMemo)((()=>ee?"hover":U?"disabled":N?"read-only":Y?"with-value":"normal"),[ee,U,N,Y]);return(0,c.jsxs)(d.StyledInputMainContainer,{borderWeight:H,className:(0,o.default)(`${f}-main-container`,`${f}-main-container--${he}`),color:x,css:{width:ie,...J},"data-state":he,disabled:U,helperColor:$,rounded:G,size:m,status:g,children:[le&&(0,c.jsx)(d.StyledInputBlockLabel,{animated:D,asPlaceholder:!!p,bordered:z,className:`${f}-block-label`,focused:ee,hasContentLeft:!!C,htmlFor:"htmlFor"in pe?pe.htmlFor:"",id:pe.id,isTextarea:se,rounded:G,underlined:A,withValue:!!Y,children:le}),(0,c.jsx)(d.StyledInputContainer,{animated:D,className:(0,o.default)(`${f}-container`,`${f}-container--${he}`,{[`${f}-container--input`]:!se,[`${f}-container--textarea`]:se,[`${f}-container--read-only`]:N},T),focused:ee,isReadOnly:N,isTextarea:se,underlined:A,children:(0,c.jsxs)(d.StyledInputWrapper,{animated:D,as:le?"div":"label",bordered:z,className:(0,o.default)(`${f}-wrapper`,`${f}-wrapper--${he}`,{[`${f}-wrapper--bordered`]:z,[`${f}-wrapper--underlined`]:A,[`${f}-wrapper--shadow`]:R}),disabled:U,focused:ee,isReadOnly:N,isTextarea:se,shadow:R,underlined:A,children:[!le&&B&&(0,c.jsx)(d.StyledInputPlaceholder,{className:`${f}-placeholder`,children:B}),h&&(0,c.jsx)(d.StyledInputLabel,{bordered:z,className:`${f}-label--left`,isDark:ae,isDefaultStatus:"default"===g,underlined:A,children:h}),C&&(0,c.jsx)(d.StyledInputContent,{applyStyles:S,className:(0,o.default)(`${f}-content`,`${f}-content--left`),clickable:w,onClick:e=>oe("left",e),children:C}),(0,c.jsx)(d.StyledInput,{ref:X,"aria-multiline":se,"aria-placeholder":ne,"aria-readonly":N,"aria-required":L,as:e,autoComplete:V,bordered:z,className:(0,o.default)({[`${f}`]:!se,[`${f}-textarea`]:se,[`${f}-disabled`]:U,[`${f}-rounded`]:G,[`${f}-${f}-right-content`]:v,[`${f}-left-content`]:C}),"data-state":he,disabled:U,focused:ee,hasLeftContent:!!C,hasRightContent:!!v,isTextarea:se,placeholder:ne,readOnly:N,required:L,type:"text",onBlur:e=>{te(!1),W&&W(e)},onChange:e=>{U||N||(re||Z(e.target.value),q&&q(e))},onFocus:e=>{te(!0),_&&_(e)},...de,...fe}),O&&(0,c.jsx)(d.StyledInputClearButton,{animated:D,"aria-label":"clear",className:`${f}-clear-button`,disabled:U||N,hasContentRight:!!v,lang:"en",type:"button",underlined:A,visible:Boolean(Y),onClick:e=>{if(e.preventDefault(),e.stopPropagation(),e.nativeEvent.stopImmediatePropagation(),re||Z(""),M&&M(e),!X.current)return;const t=((e,t)=>({...t,target:e,currentTarget:e}))(X.current,e);t.target.value="",q&&q(t),X.current.focus()},...ce,children:(0,c.jsx)(d.StyledInputClearButtonIconWrapper,{isFocusVisible:ue,children:(0,c.jsx)(i.default,{fill:"currentColor"})})}),v&&(0,c.jsx)(d.StyledInputContent,{applyStyles:j,className:(0,o.default)(`${f}-content`,`${f}-content--right`),clickable:w,onClick:e=>oe("right",e),children:v}),b&&(0,c.jsx)(d.StyledInputLabel,{bordered:z,className:`${f}-label--right`,isDark:ae,isDefaultStatus:"default"===g,isRight:!0,underlined:A,children:b})]})}),(0,c.jsx)(d.StyledHelperTextContainer,{className:`${f}-helper-text-container`,withValue:!!y,children:y&&(0,c.jsx)(d.StyledHelperText,{className:`${f}-helper-text`,children:y})})]})}));h.displayName="NextUI.Input",h.defaultProps=u.defaultProps,h.toString=()=>".nextui-input";var b=h;exports["default"]=b,module.exports=exports.default;

/***/ }),

/***/ 14418:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledInputWrapper=exports.StyledInputPlaceholder=exports.StyledInputMainContainer=exports.StyledInputLabel=exports.StyledInputContent=exports.StyledInputContainer=exports.StyledInputClearButtonIconWrapper=exports.StyledInputClearButton=exports.StyledInputBlockLabel=exports.StyledInput=exports.StyledHelperTextContainer=exports.StyledHelperText=void 0;var e=__webpack_require__(88194),o=__webpack_require__(74042);const t=(0,e.styled)("div",{$$inputColor:"$colors$accents0",$$inputTextColor:"$colors$text",$$inputPlaceholderColor:"$colors$accents6",$$inputShadow:"$shadows$sm",$$inputBorderColor:"$colors$border",$$inputHoverBorderColor:"$colors$foreground",$$inputLabelColor:"$$inputHoverBorderColor",display:"inline-flex",flexDirection:"column",justifyContent:"center",position:"relative",boxSizing:"border-box",WebkitBoxAlign:"center",variants:{color:{default:{},primary:{$$inputHoverBorderColor:"$colors$primary",$$inputLabelColor:"$colors$primary"},secondary:{$$inputHoverBorderColor:"$colors$secondary",$$inputLabelColor:"$colors$secondary"},success:{$$inputHoverBorderColor:"$colors$success",$$inputLabelColor:"$colors$success"},warning:{$$inputHoverBorderColor:"$colors$warning",$$inputLabelColor:"$colors$warning"},error:{$$inputHoverBorderColor:"$colors$error",$$inputLabelColor:"$colors$error"}},status:{default:{},primary:{$$inputColor:"$colors$primaryLight",$$inputPlaceholderColor:"$colors$primaryLightContrast",$$inputTextColor:"$colors$primaryLightContrast",$$inputLabelColor:"$$inputTextColor",$$inputHoverBorderColor:"$colors$primary"},secondary:{$$inputColor:"$colors$secondaryLight",$$inputPlaceholderColor:"$colors$secondaryLightContrast",$$inputTextColor:"$colors$secondaryLightContrast",$$inputLabelColor:"$$inputTextColor",$$inputHoverBorderColor:"$colors$secondary"},success:{$$inputColor:"$colors$successLight",$$inputPlaceholderColor:"$colors$successLightContrast",$$inputTextColor:"$colors$successLightContrast",$$inputLabelColor:"$$inputTextColor",$$inputHoverBorderColor:"$colors$success"},warning:{$$inputColor:"$colors$warningLight",$$inputPlaceholderColor:"$colors$warningLightContrast",$$inputTextColor:"$colors$warningLightContrast",$$inputLabelColor:"$$inputTextColor",$$inputHoverBorderColor:"$colors$warning"},error:{$$inputColor:"$colors$errorLight",$$inputPlaceholderColor:"$colors$errorLightContrast",$$inputTextColor:"$colors$errorLightContrast",$$inputLabelColor:"$$inputTextColor",$$inputHoverBorderColor:"$colors$error"}},helperColor:{default:{$$inputHelperColor:"$colors$text"},primary:{$$inputHelperColor:"$colors$primary"},secondary:{$$inputHelperColor:"$colors$secondary"},success:{$$inputHelperColor:"$colors$success"},warning:{$$inputHelperColor:"$colors$warning"},error:{$$inputHelperColor:"$colors$error"}},borderWeight:{light:{$$inputBorderWeight:"$borderWeights$light"},normal:{$$inputBorderWeight:"$borderWeights$normal"},bold:{$$inputBorderWeight:"$borderWeights$bold"},extrabold:{$$inputBorderWeight:"$borderWeights$extrabold"},black:{$$inputBorderWeight:"$borderWeights$black"}},size:{xs:{$$inputBorderRadius:"$space$3",$$inputFontSize:"$fontSizes$xs",$$inputHeightRatio:"1.2",br:"$$inputBorderRadius"},sm:{$$inputBorderRadius:"$space$4",$$inputFontSize:"$fontSizes$xs",$$inputHeightRatio:"1.6",br:"$$inputBorderRadius"},md:{$$inputBorderRadius:"$space$6",$$inputFontSize:"$fontSizes$sm",$$inputHeightRatio:"2",br:"$$inputBorderRadius"},lg:{$$inputBorderRadius:"$space$7",$$inputFontSize:"$fontSizes$md",$$inputHeightRatio:"2.2",br:"$$inputBorderRadius"},xl:{$$inputBorderRadius:"$space$8",$$inputFontSize:"$fontSizes$lg",$$inputHeightRatio:"2.6",br:"$$inputBorderRadius"}},rounded:{true:{$$inputBorderRadius:"$radii$pill"}},disabled:{true:{$$inputColor:"$colors$accents1",$$inputTextColor:"$colors$accents7",$$inputPlaceholderColor:"$colors$accents7",$$inputShadow:"$shadows$sm"}}}});exports.StyledInputMainContainer=t;const r={WebkitTextFillColor:"$$inputTextColor",WebkitBackgroundClip:"text !important",caretColor:"$$inputTextColor"},n=(0,e.styled)("div",{width:"100%",br:"$$inputBorderRadius",input:{"&:-webkit-autofill":{...r,"&:hover":r,"&:focus":r,"&:active":r}},"@motion":{transition:"none"},variants:{isTextarea:{false:{display:"inline-flex",alignItems:"center",height:"calc($$inputHeightRatio * $9)"}},focused:{true:{}},isReadOnly:{false:{}},underlined:{true:{}},animated:{true:{transition:"$default"},false:{transition:"none"}}},compoundVariants:[{isReadOnly:!1,underlined:!0,css:{transform:"none"}},{focused:!0,animated:!0,isReadOnly:!1,underlined:!1,css:{transform:"translateY(-$space$1)"}}]});exports.StyledInputContainer=n;const i=(0,e.styled)("input",{padding:0,fontSize:"$$inputFontSize",bg:"transparent",border:"none",color:"$$inputTextColor",br:0,outline:"none",size:"100%",minWidth:0,WebkitAppearance:"none","::placeholder":{color:"$$inputPlaceholderColor",transition:"opacity 0.25s ease 0s",MozTransition:"opacity 0.25s ease 0s",MsTransition:"opacity 0.25s ease 0s",WebkitTransition:"opacity 0.25s ease 0s"},"@motion":{transition:"none","&::placeholder":{transition:"none"}},"&:disabled":{pe:"none",color:"$accents4",cursor:"not-allowed"},variants:{isTextarea:{true:{boxShadow:"none",display:"block",size:"100%",resize:"none",border:"none",outline:"none"}},focused:{true:{"&::placeholder":{opacity:0,transition:"opacity 0.25s ease 0s"}}},bordered:{true:{padding:"0 $3"}},rounded:{true:{padding:"0 $3"}},animated:{false:{transition:"none","::placeholder":{transition:"none"}}},hasLeftContent:{true:{ml:0}},hasRightContent:{true:{mr:0}}}});exports.StyledInput=i;const s=(0,e.styled)("div",{flex:1,position:"relative",br:"$$inputBorderRadius",bg:"$$inputColor",display:"inline-flex",verticalAlign:"middle",alignItems:"center",userSelect:"none","@motion":{transition:"none","&:before":{transition:"none"},"&:after":{transition:"none"}},variants:{focused:{true:{}},isReadOnly:{true:{}},bordered:{true:{bg:"transparent",border:"none",boxShadow:"0 0 0 $$inputBorderWeight $$inputBorderColor",transition:"box-shadow 0.25s ease"}},shadow:{true:{transition:"$default"}},disabled:{true:{cursor:"not-allowed"}},underlined:{true:{bg:"transparent",[`& ${i}`]:{margin:"$2 $3"},"&:before":{content:"",position:"absolute",zIndex:"$2",width:0,bottom:0,height:"$1",left:"50%",transform:"translate(-50%)",background:"$$inputHoverBorderColor",transition:"width 0.25s ease"},"&:after":{content:"",position:"absolute",zIndex:"$1",bottom:0,width:"100%",height:"$$inputBorderWeight",bg:"$$inputBorderColor"}},false:{[`& ${i}`]:{margin:"$2 $5"}}},animated:{false:{transition:"none","&:before":{transition:"none"},"&:after":{transition:"none"}}},isTextarea:{true:{boxSizing:"border-box",width:"100%",maxWidth:"100%",height:"auto"},false:{height:"100%"}}},compoundVariants:[{bordered:!0,underlined:!0,css:{boxShadow:"0 0 0 0px $$inputBorderColor"}},{focused:!0,underlined:!0,css:{"&:before":{width:"100%"}}},{focused:!0,shadow:!0,isReadOnly:!1,underlined:!1,css:{boxShadow:"$$inputShadow"}},{focused:!0,bordered:!0,isReadOnly:!1,underlined:!1,css:{boxShadow:"0 0 0 $$inputBorderWeight $$inputHoverBorderColor"}},{bordered:!0,isReadOnly:!1,underlined:!1,css:{"&:hover":{boxShadow:"0 0 0 $$inputBorderWeight $$inputHoverBorderColor"}}},{isTextarea:!0,underlined:!1,css:{[`& ${i}`]:{margin:"$xs $sm"}}}]});exports.StyledInputWrapper=s;const a=(0,e.styled)("div",{position:"absolute",opacity:0,bottom:"calc($$inputHeightRatio * -$space$5)","@motion":{transition:"none"},variants:{animated:{true:{transition:"opacity 0.25s ease"},false:{transition:"none"}},withValue:{true:{opacity:1}}}});exports.StyledHelperTextContainer=a;const l=(0,e.styled)("p",{margin:"$1 0 0 $5",fontSize:"$space$5",color:"$$inputHelperColor"});exports.StyledHelperText=l;const $=(0,e.styled)("span",{},o.sharedVisuallyHidden);exports.StyledInputPlaceholder=$;const d=(0,e.styled)("label",{d:"block",fontWeight:"$normal",color:"$$inputLabelColor",p:"0 0 0 $2",mb:"$3",fs:"$$inputFontSize",lh:"$md",WebkitTouchCallout:"none",WebkitUserSelect:"none",KhtmlUserSelect:"none",MozUserSelect:"none",MsUserSelect:"none",us:"none","> *:first-child":{marginTop:0},"> *:last-child":{mb:0},"@motion":{transition:"none"},variants:{rounded:{true:{padding:"0 0 0 $3"}},asPlaceholder:{true:{position:"absolute",padding:0,zIndex:"$1",left:"$space$6",top:"20%",mb:0,cursor:"text",color:"$$inputPlaceholderColor",transition:"left 0.25s ease 0s, color 0.25s ease 0s, top 0.25s ease 0s"}},animated:{false:{transition:"none"}},focused:{true:{color:"$$inputHoverBorderColor"}},underlined:{true:{}},withValue:{true:{}},isTextarea:{true:{}},bordered:{true:{}},hasContentLeft:{true:{}}},compoundVariants:[{underlined:!0,asPlaceholder:!0,css:{left:"$space$2"}},{asPlaceholder:!0,focused:!0,underlined:!1,isTextarea:!1,css:{top:"-72%",left:"$2",cursor:"inherit"}},{asPlaceholder:!0,focused:!0,underlined:!0,isTextarea:!1,css:{top:"-72%",left:"0px",cursor:"inherit"}},{asPlaceholder:!0,withValue:!0,underlined:!1,isTextarea:!1,css:{color:"$$inputTextColor",top:"-72%",left:"$2",cursor:"inherit"}},{asPlaceholder:!0,withValue:!0,underlined:!0,isTextarea:!1,css:{color:"$$inputTextColor",top:"-72%",left:"0px",cursor:"inherit"}},{asPlaceholder:!0,isTextarea:!0,css:{top:"$5"}},{asPlaceholder:!0,hasContentLeft:!0,css:{left:"calc($space$6 + $$inputHeightRatio * $space$7)"}},{asPlaceholder:!0,isTextarea:!0,focused:!0,css:{top:"calc(-$space$10 - $space$3)",left:"$2"}},{asPlaceholder:!0,isTextarea:!0,withValue:!0,css:{top:"-$11"}},{asPlaceholder:!0,focused:!0,isTextarea:!0,bordered:!0,css:{top:"-$12"}}],defaultVariants:{asPlaceholder:!1}});exports.StyledInputBlockLabel=d;const u=(0,e.styled)("span",{position:"relative",display:"inline-flex",width:"initial",height:"100%",fontWeight:"$medium",ai:"center",pe:"none",margin:0,padding:"0 $sm",color:"$$inputPlaceholderColor",fontSize:"$$inputFontSize",lineHeight:"$xs",variants:{isRight:{true:{btrr:"$$inputBorderRadius",bbrr:"$$inputBorderRadius"},false:{btlr:"$$inputBorderRadius",bblr:"$$inputBorderRadius"}},isDark:{true:{}},isDefaultStatus:{true:{}},underlined:{true:{bg:"transparent"}},bordered:{true:{"&:after":{display:"none"},"&:before":{display:"none"}}}},compoundVariants:[{isRight:!0,underlined:!0,css:{borderLeftColor:"$$inputPlaceholderColor",borderLeftStyle:"solid",marginLeft:"$2",borderLeftWidth:"calc($$inputBorderWeight / 2)",height:"40%"}},{isRight:!1,underlined:!0,css:{borderRightColor:"$$inputPlaceholderColor",borderRightStyle:"solid",marginRight:"$2",borderRightWidth:"calc($$inputBorderWeight / 1)",height:"40%"}},{isDefaultStatus:!0,bordered:!1,underlined:!1,css:{bg:"$accents2"}},{isDefaultStatus:!0,bordered:!1,underlined:!1,isDark:!0,css:{color:"$accents6"}},{isDefaultStatus:!1,bordered:!0,underlined:!1,css:{bg:"$$inputColor"}},{bordered:!0,isRight:!0,css:{peddingRight:"$sm",paddingLeft:0}},{bordered:!0,isRight:!1,css:{peddingLeft:"$sm",paddingRight:0}}],defaultVariants:{isRight:!1}});exports.StyledInputLabel=u;const p=(0,e.styled)("span",{variants:{applyStyles:{true:{display:"flex",boxSizing:"content-box",width:"calc($$inputHeightRatio * $space$4)",height:"100%",alignItems:"center",verticalAlign:"center",margin:0,padding:"0 calc($$inputHeightRatio * $3)",color:"$$inputTextColor",lineHeight:"$xs",position:"relative",cursor:"default",pe:"none"}},clickable:{true:{cursor:"pointer",pe:"auto"}}}});exports.StyledInputContent=p;const c=(0,e.styled)("button",{position:"absolute",right:0,margin:0,d:"inline-flex",ai:"center",border:"none",bg:"transparent",width:"auto",height:"auto",cursor:"pointer",boxSizing:"border-box",transition:"color 250ms ease 0s, transform 250ms ease 0s, opacity 250ms ease 0s",color:"$$inputPlaceholderColor",visibility:"hidden",transform:"translateX(20%)",opacity:0,"&:hover":{opacity:.85},svg:{color:"currentColor",size:"calc($space$5 * $$inputHeightRatio)"},"@motion":{transition:"none"},variants:{visible:{true:{visibility:"visible",transform:"translateX(0)",opacity:1}},underlined:{true:{padding:"0 $1"}},animated:{false:{transition:"none"}},hasContentRight:{true:{padding:0,position:"relative",transform:"translateX(30%)"}},disabled:{true:{cursor:"not-allowed","&:hover":{color:"$accents3"}}}}});exports.StyledInputClearButton=c;const h=(0,e.styled)("span",{display:"flex",br:"100%"},o.cssFocusVisible);exports.StyledInputClearButtonIconWrapper=h;

/***/ }),

/***/ 19122:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(18038)),t=__webpack_require__(56786);const s=({visible:e})=>(0,t.jsx)("svg",{className:"nextui-input-password-icon",fill:"none",height:"16",shapeRendering:"geometricPrecision",stroke:"currentColor",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"1.5",style:{color:"currentColor"},viewBox:"0 0 24 24",width:"16",children:e?(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)("path",{d:"M17.94 17.94A10.07 10.07 0 0112 20c-7 0-11-8-11-8a18.45 18.45 0 015.06-5.94M9.9 4.24A9.12 9.12 0 0112 4c7 0 11 8 11 8a18.5 18.5 0 01-2.16 3.19m-6.72-1.07a3 3 0 11-4.24-4.24"}),(0,t.jsx)("path",{d:"M1 1l22 22"})]}):(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)("path",{d:"M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"}),(0,t.jsx)("circle",{cx:"12",cy:"12",r:"3"})]})});var o=r.default.memo(s);exports["default"]=o,module.exports=exports.default;

/***/ }),

/***/ 70834:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.LinkIcon=void 0;var r=e(__webpack_require__(18038)),i=__webpack_require__(98494),t=__webpack_require__(56786);const n=()=>(0,t.jsxs)(i.StyledLinkIcon,{className:"nextui-link-icon",fill:"none",height:"1em",shapeRendering:"geometricPrecision",stroke:"currentColor",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"1.5",viewBox:"0 0 24 24",width:"1em",children:[(0,t.jsx)("path",{d:"M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"}),(0,t.jsx)("path",{d:"M15 3h6v6"}),(0,t.jsx)("path",{d:"M10 14L21 3"})]});exports.LinkIcon=n,n.toString=()=>".nextui-link-icon";var o=r.default.memo(n);exports["default"]=o;

/***/ }),

/***/ 74222:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledLinkIcon=exports.StyledLink=void 0;var r=e(__webpack_require__(13040)),t=__webpack_require__(98494);exports.StyledLink=t.StyledLink,exports.StyledLinkIcon=t.StyledLinkIcon;var l=r.default;exports["default"]=l;

/***/ }),

/***/ 13040:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=p(r);if(t&&t.has(e))return t.get(e);var i={},s=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&Object.prototype.hasOwnProperty.call(e,u)){var o=s?Object.getOwnPropertyDescriptor(e,u):null;o&&(o.get||o.set)?Object.defineProperty(i,u,o):i[u]=e[u]}i.default=e,t&&t.set(e,i);return i}(__webpack_require__(18038)),t=__webpack_require__(38415),i=__webpack_require__(77335),s=__webpack_require__(94135),u=__webpack_require__(93795),o=__webpack_require__(73726),a=e(__webpack_require__(62358)),n=__webpack_require__(81595),l=e(__webpack_require__(70834)),c=e(__webpack_require__(98494)),f=__webpack_require__(56786);function p(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(p=function(e){return e?t:r})(e)}const d=(0,u.forwardRef)(((e,u)=>{const{children:n,isExternal:p=!1,as:d,css:x,color:k="default",autoFocus:q,className:y,...g}=e,m=(0,o.useDOMRef)(u),{linkProps:b}=(0,t.useLink)({...g,elementType:d},m),{isFocusVisible:h,focusProps:j}=(0,s.useFocusRing)({autoFocus:q}),v=(0,r.useMemo)((()=>{let e=`$colors$${k}Light`;switch(k){case"inherit":case"text":e="$colors$textLight";break;case"default":e="$colors$linkLight"}return{...x,$$linkBackgroundColor:e}}),[x,k]);return(0,f.jsx)(c.default,{ref:m,as:d,className:(0,a.default)("nextui-link",y),color:k,css:v,isFocusVisible:h,...(0,i.mergeProps)(b,j,g),children:(0,f.jsxs)(f.Fragment,{children:[n,p&&(0,f.jsx)(l.default,{})]})})}));n.__DEV__&&(d.displayName="NextUI.Link"),d.toString=()=>".nextui-link";var x=d;exports["default"]=x,module.exports=exports.default;

/***/ }),

/***/ 98494:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=exports.StyledLinkIcon=exports.StyledLink=void 0;var o=__webpack_require__(88194),e=__webpack_require__(74042);const r=(0,o.styled)("svg",{ml:"$1",as:"center",display:"flex",color:"currentColor"});exports.StyledLinkIcon=r;const n=(0,o.styled)("a",{$$linkColor:"$colors$link",display:"inline-flex",alignItems:"center",lineHeight:"inherit",textDecoration:"none",width:"$fit",backgroundColor:"transparent",backgroundImage:"inherit",backgroundClip:"inherit",WebkitTextFillColor:"inherit",color:"$$linkColor",outline:"none",maxW:"$max","&:hover":{opacity:.8},"@motion":{transition:"none"},variants:{color:{inherit:{$$linkColor:"inherit"},default:{$$linkColor:"$colors$link"},text:{$$linkColor:"$colors$text"},primary:{$$linkColor:"$colors$primary"},secondary:{$$linkColor:"$colors$secondary"},success:{$$linkColor:"$colors$success"},warning:{$$linkColor:"$colors$warning"},error:{$$linkColor:"$colors$error"}},underline:{true:{"&:hover, &:active, &:focus":{textDecoration:"underline"}}},block:{true:{padding:"$2 $4",borderRadius:"$base","&:hover":{backgroundColor:"$$linkBackgroundColor"}}},animated:{true:{transition:"opacity 0.25s ease 0s, box-shadow 0.25s ease 0s"}}},compoundVariants:[{block:!0,animated:!0,css:{transition:"opacity 0.25s ease 0s, box-shadow 0.25s ease 0s, background 0.25s ease 0s","@motion":{transition:"none"}}}],defaultVariants:{color:"default",animated:!0}},e.cssFocusVisible);exports.StyledLink=n;var i=n;exports["default"]=i;

/***/ }),

/***/ 37103:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledSpinnerSpan=exports.StyledSpinnerContainer=exports.StyledSpinner=exports.StyledLoadingLabel=exports.StyledLoadingContainer=exports.StyledLoading=exports.Spinner=void 0;var n=e(__webpack_require__(33363)),r=__webpack_require__(14994);exports.StyledLoadingContainer=r.StyledLoadingContainer,exports.StyledSpinnerContainer=r.StyledSpinnerContainer,exports.StyledSpinner=r.StyledSpinner,exports.StyledSpinnerSpan=r.StyledSpinnerSpan,exports.StyledLoading=r.StyledLoading,exports.StyledLoadingLabel=r.StyledLoadingLabel;var t=e(__webpack_require__(39326));exports.Spinner=t.default;var i=n.default;exports["default"]=i;

/***/ }),

/***/ 33363:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=s(t);if(r&&r.has(e))return r.get(e);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if("default"!==a&&Object.prototype.hasOwnProperty.call(e,a)){var l=i?Object.getOwnPropertyDescriptor(e,a):null;l&&(l.get||l.set)?Object.defineProperty(n,a,l):n[a]=e[a]}n.default=e,r&&r.set(e,n);return n}(__webpack_require__(18038)),r=e(__webpack_require__(25457)),n=__webpack_require__(14994),i=e(__webpack_require__(39326)),a=__webpack_require__(56786);function s(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(s=function(e){return e?r:t})(e)}const l=({children:e,size:r,gradientBackground:s,loadingCss:l,type:u,...o})=>{const d=e?"":"Loading",c=(0,t.useMemo)((()=>{if("gradient"===u)return{"._2":{bg:s}}}),[u]);return(0,a.jsx)(n.StyledLoadingContainer,{...o,children:"spinner"===u?(0,a.jsx)(i.default,{size:r,children:e}):(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.StyledLoading,{"aria-label":d,className:`nextui-loading nextui-loading-${u}`,css:{...l,...c},size:r,type:u,children:[(0,a.jsx)("i",{className:"_1"}),(0,a.jsx)("i",{className:"_2"}),(0,a.jsx)("i",{className:"_3"})]}),e&&(0,a.jsx)(n.StyledLoadingLabel,{className:"nextui-loading-label",size:r,children:e})]})})};l.toString=()=>".nextui-loading";const u=t.default.memo(l);var o=(0,r.default)(u,{size:"md",type:"default"});exports["default"]=o,module.exports=exports.default;

/***/ }),

/***/ 14994:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledSpinnerSpan=exports.StyledSpinnerContainer=exports.StyledSpinner=exports.StyledLoadingLabel=exports.StyledLoadingContainer=exports.StyledLoading=void 0;var o=__webpack_require__(88194);const e=(0,o.keyframes)({"0%":{opacity:"0.2"},"20%":{opacity:1},"100%":{opacity:"0.2"}}),i=(0,o.keyframes)({"0%":{transform:"rotate(0deg)"},"100%":{transform:"rotate(360deg)"}}),a=(0,o.keyframes)({"0%":{transform:"translate(0px, 0px)"},"50%":{transform:"translate(0, calc(-$$loadingSize * 1.4))"},"100%":{transform:"translate(0px, 0px)"}}),n=(0,o.keyframes)({"0%":{opacity:1},"100%":{opacity:.15}}),t=(0,o.styled)("div",{d:"inline-flex",fd:"column",ai:"center",position:"relative",variants:{color:{currentColor:{$$loadingColor:"currentColor"},white:{$$loadingColor:"$colors$white"},default:{$$loadingColor:"$colors$primary"},primary:{$$loadingColor:"$colors$primary"},secondary:{$$loadingColor:"$colors$secondary"},success:{$$loadingColor:"$colors$success"},warning:{$$loadingColor:"$colors$warning"},error:{$$loadingColor:"$colors$error"}},textColor:{white:{$$loadingTextColor:"$colors$white"},default:{$$loadingTextColor:"$colors$text"},primary:{$$loadingTextColor:"$colors$primary"},secondary:{$$loadingTextColor:"$colors$secondary"},success:{$$loadingTextColor:"$colors$success"},warning:{$$loadingTextColor:"$colors$warning"},error:{$$loadingTextColor:"$colors$error"}}},defaultVariants:{color:"default",textColor:"default"}});exports.StyledLoadingContainer=t;const r=(0,o.styled)("div",{size:"100%",position:"relative",left:"50%",top:"50%"});exports.StyledSpinnerContainer=r;const s=(0,o.styled)("div",{d:"flex",fd:"column",jc:"center",ai:"center",position:"relative",variants:{size:{xs:{size:"$6"},sm:{size:"$8"},md:{size:"$9"},lg:{size:"$11"},xl:{size:"$12"}}}});exports.StyledSpinner=s;const l=(0,o.styled)("span",{bg:"$$loadingColor",position:"absolute",top:"-3.9%",width:"24%",height:"8%",left:"-10%",br:"$lg",animation:`${n} 1.2s linear 0s infinite normal none running`,"&:nth-child(1)":{animationDelay:"-1.2s",transform:"rotate(0deg) translate(146%)"},"&:nth-child(2)":{animationDelay:"-1.1s",transform:"rotate(30deg) translate(146%)"},"&:nth-child(3)":{animationDelay:"-1s",transform:"rotate(60deg) translate(146%)"},"&:nth-child(4)":{animationDelay:"-0.9s",transform:"rotate(90deg) translate(146%)"},"&:nth-child(5)":{animationDelay:"-0.8s",transform:"rotate(120deg) translate(146%)"},"&:nth-child(6)":{animationDelay:"-0.7s",transform:"rotate(150deg) translate(146%)"},"&:nth-child(7)":{animationDelay:"-0.6s",transform:"rotate(180deg) translate(146%)"},"&:nth-child(8)":{animationDelay:"-0.5s",transform:"rotate(210deg) translate(146%)"},"&:nth-child(9)":{animationDelay:"-0.4s",transform:"rotate(240deg) translate(146%)"},"&:nth-child(10)":{animationDelay:"-0.3s",transform:"rotate(270deg) translate(146%)"},"&:nth-child(11)":{animationDelay:"-0.2s",transform:"rotate(300deg) translate(146%)"},"&:nth-child(12)":{animationDelay:"-0.1s",transform:"rotate(330deg) translate(146%)"}});exports.StyledSpinnerSpan=l;const $=(0,o.styled)("span",{position:"absolute",top:0,left:0,right:0,bottom:0,size:"100%",dflex:"center",bgColor:"transparent",us:"none",variants:{size:{xs:{$$loadingSize:"$space$8",$$loadingBorder:"$space$1"},sm:{$$loadingSize:"$space$10",$$loadingBorder:"$space$1"},md:{$$loadingSize:"$space$12",$$loadingBorder:"calc($space$1 * 1.5)"},lg:{$$loadingSize:"$space$15",$$loadingBorder:"$space$2"},xl:{$$loadingSize:"$space$18",$$loadingBorder:"$space$3"}},type:{default:{d:"flex",br:"$rounded",position:"relative",size:"$$loadingSize",i:{top:"0px",size:"100%",position:"absolute",br:"inherit"},"._1":{border:"$$loadingBorder solid $$loadingColor",borderTop:"$$loadingBorder solid transparent",borderLeft:"$$loadingBorder solid transparent",borderRight:"$$loadingBorder solid transparent",animation:`${i} 0.8s ease infinite`},"._2":{border:"$$loadingBorder dotted $$loadingColor",borderTop:"$$loadingBorder solid transparent",borderLeft:"$$loadingBorder solid transparent",borderRight:"$$loadingBorder solid transparent",animation:`${i} 0.8s linear infinite`,opacity:.5},"._3":{display:"none"}},points:{d:"flex",position:"relative",transform:"translate(0, calc($$loadingSize * 0.6))",i:{size:"$$loadingSize",margin:"0 3px",bg:"$$loadingColor"},"._1":{br:"$rounded",animation:`${a} 0.75s ease infinite`},"._2":{br:"$rounded",animation:`${a} 0.75s ease infinite 0.25s`},"._3":{br:"$rounded",animation:`${a} 0.75s ease infinite 0.5s`}},"points-opacity":{d:"flex",position:"relative",i:{display:"inline-block",size:"$$loadingSize",br:"$rounded",bg:"$$loadingColor",margin:"0 1px",animation:`${e} 1.4s infinite both`},"._2":{animationDelay:"0.2s"},"._3":{animationDelay:"0.4s"}},spinner:{},gradient:{display:"flex",position:"relative",size:"$$loadingSize","._1":{position:"absolute",size:"100%",border:"0px",animation:`${i} 1s linear infinite`,top:"0px",br:"$rounded",bg:"linear-gradient(0deg, $background 33%,$$loadingColor 100%)"},"._2":{top:"2px",position:"absolute",size:"calc(100% - 4px)",border:"0px",bg:"$background",br:"$rounded"},"._3":{display:"none"}}}},compoundVariants:[{size:"xs",type:"points-opacity",css:{$$loadingSize:"$space$1"}},{size:"sm",type:"points-opacity",css:{$$loadingSize:"$space$2"}},{size:"md",type:"points-opacity",css:{$$loadingSize:"$space$3"}},{size:"lg",type:"points-opacity",css:{$$loadingSize:"$space$4"}},{size:"xl",type:"points-opacity",css:{$$loadingSize:"$space$5"}},{size:"xs",type:"points",css:{$$loadingSize:"$space$1"}},{size:"sm",type:"points",css:{$$loadingSize:"$space$2"}},{size:"md",type:"points",css:{$$loadingSize:"$space$3"}},{size:"lg",type:"points",css:{$$loadingSize:"$space$4"}},{size:"xl",type:"points",css:{$$loadingSize:"$space$5"}}],defaultVariants:{type:"default"}});exports.StyledLoading=$;const d=(0,o.styled)("label",{mt:"$1",color:"$$loadingTextColor",fontSize:"$$loadingSize","*":{margin:0},variants:{size:{xs:{fontSize:"$space$5",marginTop:"$2"},sm:{fontSize:"$space$6",marginTop:"$3"},md:{fontSize:"$base",marginTop:"$4"},lg:{fontSize:"$space$10",marginTop:"$4"},xl:{fontSize:"$space$11",marginTop:"$5"}}}});exports.StyledLoadingLabel=d;

/***/ }),

/***/ 39326:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;e(__webpack_require__(18038));var r=e(__webpack_require__(62358)),i=__webpack_require__(14994),n=__webpack_require__(56786);const t=({children:e,size:t,color:l,textColor:s,className:a,...o})=>{const u=Array.isArray(e)?(null==e?void 0:e.length)>1&&void 0!==e[0]:void 0!==e,d=e&&u?"":"Loading";return(0,n.jsxs)(i.StyledSpinner,{className:(0,r.default)("nextui-spinner",a),color:l,size:t,...o,children:[(0,n.jsx)(i.StyledSpinnerContainer,{"aria-label":d,className:"nextui-spinner-container",children:[...new Array(12)].map(((e,r)=>(0,n.jsx)(i.StyledSpinnerSpan,{},`nextui-spinner-${r}`)))}),e&&(0,n.jsx)(i.StyledLoadingLabel,{color:s,size:t,children:e})]})};t.toString=()=>".nextui-spinner";var l=t;exports["default"]=l,module.exports=exports.default;

/***/ }),

/***/ 99253:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledModalHideTab=exports.StyledModalHeader=exports.StyledModalFooter=exports.StyledModalCloseButton=exports.StyledModalBody=exports.StyledModal=void 0;var d=e(__webpack_require__(29976)),o=e(__webpack_require__(25157)),l=e(__webpack_require__(37350)),t=e(__webpack_require__(66825)),a=__webpack_require__(13902);exports.StyledModalHideTab=a.StyledModalHideTab,exports.StyledModalCloseButton=a.StyledModalCloseButton,exports.StyledModalHeader=a.StyledModalHeader,exports.StyledModalBody=a.StyledModalBody,exports.StyledModalFooter=a.StyledModalFooter,exports.StyledModal=a.StyledModal,d.default.Header=o.default,d.default.Body=l.default,d.default.Footer=t.default;var r=d.default;exports["default"]=r;

/***/ }),

/***/ 37350:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=i(t);if(r&&r.has(e))return r.get(e);var a={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in e)if("default"!==n&&Object.prototype.hasOwnProperty.call(e,n)){var u=o?Object.getOwnPropertyDescriptor(e,n):null;u&&(u.get||u.set)?Object.defineProperty(a,n,u):a[n]=e[n]}a.default=e,r&&r.set(e,a);return a}(__webpack_require__(18038)),r=e(__webpack_require__(25457)),a=e(__webpack_require__(62358)),o=__webpack_require__(79398),n=__webpack_require__(13902),u=__webpack_require__(56786);function i(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(i=function(e){return e?r:t})(e)}const l="nextui-modal-body",d=({className:e,children:r,autoMargin:i,...d})=>{const{autoMargin:s,noPadding:f}=(0,t.useContext)(o.ModalContext),c=(0,t.useMemo)((()=>void 0!==s?s:i),[i,s]);return(0,u.jsx)(n.StyledModalBody,{autoMargin:c,className:(0,a.default)(l,{[`${l}-auto-margin`]:c,[`${l}-no-padding`]:f},e),noPadding:f,...d,children:r})};d.toString=()=>".nextui-modal-body";const s=t.default.memo(d);var f=(0,r.default)(s,{className:"",autoMargin:!0});exports["default"]=f,module.exports=exports.default;

/***/ }),

/***/ 14821:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=e(__webpack_require__(18038)),o=e(__webpack_require__(77162)),l=__webpack_require__(13902),r=__webpack_require__(56786);const a=({onClick:e,...t})=>(0,r.jsx)(l.StyledModalCloseButton,{"aria-label":"Close",className:"nextui-modal-close-icon",type:"button",onClick:t=>{t.preventDefault(),t.stopPropagation(),t.nativeEvent.stopImmediatePropagation(),e&&e(t)},...t,children:(0,r.jsx)(o.default,{plain:!0,"aria-hidden":!0,className:"nextui-modal-close-icon-svg",fill:"currentColor",size:18})});a.toString=()=>".nextui-modal-close-icon";var i=t.default.memo(a);exports["default"]=i,module.exports=exports.default;

/***/ }),

/***/ 79398:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports.useModalContext=exports.ModalContext=void 0;var t=e(__webpack_require__(18038));const o={},r=t.default.createContext(o);exports.ModalContext=r;exports.useModalContext=()=>t.default.useContext(r);

/***/ }),

/***/ 66825:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=i(t);if(r&&r.has(e))return r.get(e);var o={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if("default"!==a&&Object.prototype.hasOwnProperty.call(e,a)){var u=n?Object.getOwnPropertyDescriptor(e,a):null;u&&(u.get||u.set)?Object.defineProperty(o,a,u):o[a]=e[a]}o.default=e,r&&r.set(e,o);return o}(__webpack_require__(18038)),r=e(__webpack_require__(25457)),o=e(__webpack_require__(62358)),n=__webpack_require__(13902),a=__webpack_require__(79398),u=__webpack_require__(56786);function i(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(i=function(e){return e?r:t})(e)}const l="nextui-modal-footer",s=({children:e,className:r,justify:i,autoMargin:s,css:d,...f})=>{const{autoMargin:c,noPadding:p}=(0,t.useContext)(a.ModalContext),m=(0,t.useMemo)((()=>void 0!==c?c:s),[s,c]);return(0,u.jsx)(n.StyledModalFooter,{autoMargin:m,className:(0,o.default)(l,{[`${l}-auto-margin`]:m,[`${l}-no-padding`]:p},r),css:{justifyContent:i,...d},noPadding:p,...f,children:e})};s.toString=()=>".nextui-modal-footer";const d=t.default.memo(s);var f=(0,r.default)(d,{className:"",justify:"flex-end",autoMargin:!0});exports["default"]=f,module.exports=exports.default;

/***/ }),

/***/ 25157:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=i(t);if(r&&r.has(e))return r.get(e);var a={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in e)if("default"!==o&&Object.prototype.hasOwnProperty.call(e,o)){var u=n?Object.getOwnPropertyDescriptor(e,o):null;u&&(u.get||u.set)?Object.defineProperty(a,o,u):a[o]=e[o]}a.default=e,r&&r.set(e,a);return a}(__webpack_require__(18038)),r=e(__webpack_require__(25457)),a=e(__webpack_require__(62358)),n=__webpack_require__(13902),o=__webpack_require__(79398),u=__webpack_require__(56786);function i(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(i=function(e){return e?r:t})(e)}const l="nextui-modal-header",s=({children:e,className:r,justify:i,autoMargin:s,css:d,...f})=>{const{autoMargin:c,noPadding:p}=(0,t.useContext)(o.ModalContext),m=(0,t.useMemo)((()=>void 0!==c?c:s),[s,c]);return(0,u.jsx)(n.StyledModalHeader,{autoMargin:m,className:(0,a.default)(l,{[`${l}-auto-margin`]:m,[`${l}-no-padding`]:p},r),css:{justifyContent:i,...d},noPadding:p,...f,children:e})};s.toString=()=>".nextui-modal-header";const d=t.default.memo(s);var f=(0,r.default)(d,{className:"",justify:"center",autoMargin:!0});exports["default"]=f,module.exports=exports.default;

/***/ }),

/***/ 24532:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=c(t);if(r&&r.has(e))return r.get(e);var n={},u=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var l in e)if("default"!==l&&Object.prototype.hasOwnProperty.call(e,l)){var o=u?Object.getOwnPropertyDescriptor(e,l):null;o&&(o.get||o.set)?Object.defineProperty(n,l,o):n[l]=e[l]}n.default=e,r&&r.set(e,n);return n}(__webpack_require__(18038)),r=e(__webpack_require__(25457)),n=e(__webpack_require__(91863)),u=__webpack_require__(72625),l=__webpack_require__(60690),o=e(__webpack_require__(62358)),a=e(__webpack_require__(14821)),s=__webpack_require__(13902),i=__webpack_require__(56786);function c(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(c=function(e){return e?r:t})(e)}const d="nextui-modal",f=({className:e,children:r,visible:c,fullScreen:f,closeButton:m,rebound:b,animated:p,onCloseButtonClick:x,scroll:y,...h})=>{const v=(0,t.useRef)(null),j=(0,t.useRef)(null),q=(0,t.useRef)(null),[w,M]=(0,t.useState)(!1);(0,t.useEffect)((()=>{const e=setTimeout((()=>{M(!0),clearTimeout(e)}),300);return()=>clearTimeout(e)}),[]),(0,t.useEffect)((()=>{if(!c)return;const e=document.activeElement;(0,u.isChildElement)(v.current,e)||j.current&&j.current.focus()}),[c]);const T=e=>{const t=e.keyCode===l.KeyCode.Tab;if(!c||!t)return;const r=document.activeElement;e.shiftKey?r===j.current&&q.current&&q.current.focus():r===q.current&&j.current&&j.current.focus()},$=()=>{x&&x()},O=(0,t.useMemo)((()=>c?"open":"closed"),[c]),g=(0,t.useMemo)((()=>(0,i.jsxs)(s.StyledModal,{ref:v,"aria-modal":c,className:(0,o.default)(d,`${d}--${O}`,{[`${d}-fullscreen`]:f,[`${d}-with-close-button`]:m,[`${d}-rebound`]:b,[`${d}-rendered`]:w},e),closeButton:m,"data-state":O,fullScreen:f,role:"dialog",scroll:y,tabIndex:-1,...h,onKeyDown:T,children:[(0,i.jsx)(s.StyledModalHideTab,{ref:j,"aria-hidden":"true",className:`${d}-hide-tab`,role:"button",tabIndex:0}),m&&(0,i.jsx)(a.default,{onClick:$}),r,(0,i.jsx)(s.StyledModalHideTab,{ref:q,"aria-hidden":"true",className:`${d}-hide-tab`,role:"button",tabIndex:0})]})),[b,r]);return(0,i.jsx)(i.Fragment,{children:p?(0,i.jsx)(n.default,{clearTime:300,enterTime:20,leaveTime:20,name:`${d}-wrapper`,visible:c,children:g}):c?g:null})};f.toString=()=>".nextui-modal-wrapper";var m=(0,r.default)(f,{className:"",visible:!1,rebound:!1});exports["default"]=m,module.exports=exports.default;

/***/ }),

/***/ 29976:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=p(__webpack_require__(18038)),t=__webpack_require__(98704),a=e(__webpack_require__(79090)),l=e(__webpack_require__(41222)),n=e(__webpack_require__(66551)),o=e(__webpack_require__(32821)),u=p(__webpack_require__(60690)),i=__webpack_require__(81595),s=e(__webpack_require__(24532)),d=__webpack_require__(79398),c=__webpack_require__(56786);function f(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(f=function(e){return e?t:r})(e)}function p(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=f(r);if(t&&t.has(e))return t.get(e);var a={},l=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in e)if("default"!==n&&Object.prototype.hasOwnProperty.call(e,n)){var o=l?Object.getOwnPropertyDescriptor(e,n):null;o&&(o.get||o.set)?Object.defineProperty(a,n,o):a[n]=e[n]}return a.default=e,t&&t.set(e,a),a}const b=({children:e,onClose:i,onOpen:f,open:p,autoMargin:b,width:m,className:v,preventClose:x,blur:y,animated:q,fullScreen:g,noPadding:P,...h})=>{const j=(0,a.default)("modal"),[,M]=(0,n.default)(null,{scrollLayer:!0}),[O,w,C]=(0,o.default)(!1),[_,k]=(0,r.useState)(!1),S=()=>{i&&i(),w(!1),M(!1)};(0,r.useEffect)((()=>{void 0!==p&&(p&&f&&f(),!p&&C.current&&i&&i(),w(p),M(p))}),[p]);const D=()=>{k(!0);const e=setTimeout((()=>{k(!1),clearTimeout(e)}),300)},{bindings:N}=(0,u.default)((()=>{x?D():S()}),u.KeyCode.Escape,{disableGlobalEvent:!0,preventDefault:!0}),E=(0,r.useMemo)((()=>({close:S,autoMargin:b,noPadding:P})),[]);return j?(0,t.createPortal)((0,c.jsx)(d.ModalContext.Provider,{value:E,children:(0,c.jsx)(l.default,{animated:q,blur:y,fullScreen:g,maxWidth:m,visible:O,onClick:()=>{x?D():S()},...N,children:(0,c.jsx)(s.default,{animated:q,className:v,fullScreen:g,rebound:_,visible:O,onCloseButtonClick:S,...h,children:e})})}),j):null};i.__DEV__&&(b.displayName="NextUI.Modal"),b.toString=()=>".nextui-modal",b.defaultProps={width:"400px",className:"",preventClose:!1,fullScreen:!1,closeButton:!1,animated:!0,blur:!1,scroll:!1,noPadding:!1};var m=b;exports["default"]=m,module.exports=exports.default;

/***/ }),

/***/ 13902:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledModalHideTab=exports.StyledModalHeader=exports.StyledModalFooter=exports.StyledModalCloseButton=exports.StyledModalBody=exports.StyledModal=void 0;var e=__webpack_require__(88194),o=__webpack_require__(31675),t=__webpack_require__(74042);const i=(0,e.styled)("div",{outline:"none",overflow:"hidden",width:0,height:0,opacity:0});exports.StyledModalHideTab=i;const n=(0,e.styled)("button",{position:"absolute",background:"transparent",border:"none",zIndex:"$1",top:"$space$3",right:"$space$2",margin:0,d:"inline-flex",ai:"center",height:"auto",cursor:"pointer",boxSizing:"border-box",transition:"$default",padding:"calc($space$sm * 0.5)",color:"$accents4",br:"$space$5",svg:{color:"currentColor"},"&:hover":{svg:{opacity:.8}},variants:{disabled:{true:{cursor:"not-allowed"}}}},t.sharedFocus);exports.StyledModalCloseButton=n;const a=(0,e.styled)("div",{display:"flex",flexShrink:0,ai:"center",ov:"hidden",color:"inherit",padding:"$sm $10",fs:"$xs",variants:{noPadding:{true:{padding:0}},autoMargin:{true:{"> *:first-child":{mt:0},"> *:last-child":{mb:0}}}}});exports.StyledModalHeader=a;const r=(0,e.styled)("div",{display:"flex",flexDirection:"column",flex:"1 1 auto",padding:"$sm $10",oy:"auto",position:"relative",ta:"left",variants:{noPadding:{true:{flex:1,padding:0}},autoMargin:{true:{"> *:first-child":{mt:0},"> *":{mb:"$8"},"> *:last-child":{mb:0}}}}});exports.StyledModalBody=r;const d=(0,e.styled)("div",{d:"flex",flexWrap:"wrap",flexShrink:0,overflow:"hidden",color:"inherit",ai:"center",fs:"$xs",padding:"$sm $lg",variants:{noPadding:{true:{padding:0}},autoMargin:{true:{"> *":{m:"$2"}}}}});exports.StyledModalFooter=d;const l=(0,e.styled)("section",{maxWidth:"100%",verticalAlign:"middle",overflow:"hidden",height:"fit-content(20em)",maxHeight:"inherit",display:"flex",outline:"none",flexDirection:"column",position:"relative",boxSizing:"border-box",color:"$foreground",br:"$lg",boxShadow:"$lg",bg:"$backgroundContrast",animationFillMode:"forwards","@motion":{transition:"none"},"&.nextui-modal-wrapper-enter:not(.nextui-modal-rendered)":{animationName:o.appearanceIn,animationDuration:"200ms",animationTimingFunction:"ease-in",animationDirection:"normal"},"&.nextui-modal-wrapper-leave":{animationName:o.appearanceOut,animationDuration:"50ms",animationTimingFunction:"ease-out"},variants:{fullScreen:{true:{size:"100%",maxHeight:"100%"},false:{"&.nextui-modal-rebound":{animationDuration:"250ms",animationName:o.reboundAnimation,animationTimingFunction:"ease",animationFillMode:"forwards"}}},scroll:{true:{maxHeight:"calc(100vh - 200px)"}},closeButton:{true:{paddingTop:"$lg",[`& ${n}`]:{svg:{size:"$10"}}}}},compoundVariants:[{scroll:!0,fullScreen:!0,css:{maxHeight:"100%"}}]});exports.StyledModal=l;

/***/ }),

/***/ 17175:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(32821));var t=(e=!1)=>{const[t,s,u]=(0,r.default)(e);return{visible:t,setVisible:s,currentRef:u,bindings:{open:t,onClose:()=>s(!1)}}};exports["default"]=t,module.exports=exports.default;

/***/ }),

/***/ 57884:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledNavbarToggleIconContainer=exports.StyledNavbarToggle=exports.StyledNavbarItem=exports.StyledNavbarContent=exports.StyledNavbarContainer=exports.StyledNavbarCollapseWrapper=exports.StyledNavbarCollapseItem=exports.StyledNavbarCollapse=exports.StyledNavbarBrand=exports.StyledNavbar=exports.StyledBaseNavbarList=exports.StyledBaseNavbarItem=void 0;var a=e(__webpack_require__(82988)),t=e(__webpack_require__(7411)),r=e(__webpack_require__(27209)),l=e(__webpack_require__(89796)),o=e(__webpack_require__(96632)),d=e(__webpack_require__(61969)),s=e(__webpack_require__(92985)),v=e(__webpack_require__(19525)),b=__webpack_require__(89296);exports.StyledBaseNavbarItem=b.StyledBaseNavbarItem,exports.StyledBaseNavbarList=b.StyledBaseNavbarList,exports.StyledNavbarCollapseItem=b.StyledNavbarCollapseItem,exports.StyledNavbarCollapseWrapper=b.StyledNavbarCollapseWrapper,exports.StyledNavbarCollapse=b.StyledNavbarCollapse,exports.StyledNavbarToggleIconContainer=b.StyledNavbarToggleIconContainer,exports.StyledNavbarToggle=b.StyledNavbarToggle,exports.StyledNavbarBrand=b.StyledNavbarBrand,exports.StyledNavbarItem=b.StyledNavbarItem,exports.StyledNavbarContent=b.StyledNavbarContent,exports.StyledNavbarContainer=b.StyledNavbarContainer,exports.StyledNavbar=b.StyledNavbar,v.default.Brand=a.default,v.default.Content=t.default,v.default.Item=r.default,v.default.Link=l.default,v.default.Toggle=o.default,v.default.Collapse=d.default,v.default.CollapseItem=s.default;var p=v.default;exports["default"]=p;

/***/ }),

/***/ 82988:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;e(__webpack_require__(18038));var r=__webpack_require__(93795),a=__webpack_require__(73726),t=e(__webpack_require__(62358)),s=__webpack_require__(81595),u=__webpack_require__(89296),i=__webpack_require__(56786);const l=(0,r.forwardRef)(((e,r)=>{const s=(0,a.useDOMRef)(r),{children:l,className:n,...d}=e;return(0,i.jsx)(u.StyledNavbarBrand,{ref:s,className:(0,t.default)("nextui-navbar-brand",n),...d,children:l})}));s.__DEV__&&(l.displayName="NextUI.NavbarBrand"),l.toString=()=>".nextui-navbar-brand";var n=l;exports["default"]=n,module.exports=exports.default;

/***/ }),

/***/ 27452:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.useNavbarCollapseContext=exports.NavbarCollapseProvider=void 0;var e=__webpack_require__(19938);const[o,t]=(0,e.createContext)({strict:!1,name:"NavbarCollapseContext"});exports.useNavbarCollapseContext=t,exports.NavbarCollapseProvider=o;

/***/ }),

/***/ 92985:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=p(t);if(r&&r.has(e))return r.get(e);var i={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if("default"!==a&&Object.prototype.hasOwnProperty.call(e,a)){var l=n?Object.getOwnPropertyDescriptor(e,a):null;l&&(l.get||l.set)?Object.defineProperty(i,a,l):i[a]=e[a]}i.default=e,r&&r.set(e,i);return i}(__webpack_require__(18038)),r=__webpack_require__(93795),i=__webpack_require__(73726),n=e(__webpack_require__(62358)),a=e(__webpack_require__(20027)),l=__webpack_require__(81595),s=__webpack_require__(67219),o=__webpack_require__(27452),u=__webpack_require__(89296),c=__webpack_require__(56786);function p(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(p=function(e){return e?r:t})(e)}const m=(0,r.forwardRef)(((e,r)=>{var l;const{children:p,className:m,transitionDelay:f,transitionTime:d,transitionMatrix:v,disableAnimation:x,style:b,css:y,...M}=e,O=(0,s.useNavbarContext)(),q=(0,o.useNavbarCollapseContext)(),D=(0,i.useDOMRef)(r),{isVisible:T,setEntry:C}=(0,a.default)(D,{root:null==O||null==(l=O.parentRef)?void 0:l.current,freezeOnceVisible:O.isCollapseOpen});(0,t.useEffect)((()=>{!O.isCollapseOpen&&T&&C(null)}),[T,O.isCollapseOpen]);const I=(0,t.useMemo)((()=>{var e;return null!=q&&q.items?null==(e=q.items)?void 0:e.findIndex((e=>{var t;return(null==e||null==(t=e.props)?void 0:t.children)===p})):-1}),[null==q?void 0:q.items]),h=(0,t.useMemo)((()=>{var e,t,r;return{transitionDelay:null!=(e=null!=f?f:null==q?void 0:q.transitionDelay)?e:0,transitionTime:null!=(t=null!=d?d:null==q?void 0:q.transitionTime)?t:0,transitionMatrix:null!=(r=null!=v?v:null==q?void 0:q.transitionMatrix)?r:{in:"matrix(1, 0, 0, 1, 0, 0)",out:"matrix(0.97, 0, 0, 1, 0, 20)"}}}),[f,d,v,q.transitionMatrix,q.transitionDelay,q.transitionTime]),j=(0,t.useMemo)((()=>q.items&&I>-1?I/q.items.length*.5*1e3+h.transitionDelay:.1),[I,h.transitionDelay,null==q?void 0:q.items]),N=(0,t.useMemo)((()=>{const e=T&&!q.hasScrolled?j:0;return{"--nextui--collapseItemOpacity":T?1:0,"--nextui--collapseItemTransform":T?h.transitionMatrix.in:h.transitionMatrix.out,"--netxui--collapseItemTransition":!x&&O.isCollapseOpen?`opacity ${h.transitionTime}ms cubic-bezier(0.5, 0, 0, 1) ${e}ms, transform ${h.transitionTime}ms cubic-bezier(0.5, 0, 0, 1) ${e}ms`:"none"}}),[I,T,x,j,h.transitionMatrix,h.transitionTime,O.isCollapseOpen,q.hasScrolled]);return(0,c.jsx)(u.StyledNavbarCollapseItem,{ref:D,className:(0,n.default)("nextui-navbar-collapse-item",m),css:{opacity:"var(--nextui--collapseItemOpacity)",transition:"var(--netxui--collapseItemTransition)",transform:"var(--nextui--collapseItemTransform)",...y},disableAnimation:x,style:{...b,...N},...M,children:p})}));l.__DEV__&&(m.displayName="NextUI.NavbarCollapseItem"),m.toString=()=>".nextui-navbar-collapse-item";var f=m;exports["default"]=f,module.exports=exports.default;

/***/ }),

/***/ 61969:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;e(__webpack_require__(18038));var r=__webpack_require__(93795),a=e(__webpack_require__(62358)),s=__webpack_require__(81595),l=__webpack_require__(27452),t=__webpack_require__(67599),i=__webpack_require__(89296),o=__webpack_require__(56786);const u=(0,r.forwardRef)(((e,r)=>{const s=(0,t.useNavbarCollapse)({ref:r,...e});return(0,o.jsx)(l.NavbarCollapseProvider,{value:s,children:(0,o.jsx)(i.StyledNavbarCollapse,{className:(0,a.default)("nextui-navbar-collapse",s.className),css:s.collpaseCss,isOpen:s.isOpen,...s.otherProps,children:(0,o.jsx)(i.StyledNavbarCollapseWrapper,{ref:s.domRef,className:"nextui-navbar-collapse-wrapper",children:s.children})})})}));s.__DEV__&&(u.displayName="NextUI.NavbarCollapse"),u.toString=()=>".nextui-navbar-collapse";var p=u;exports["default"]=p,module.exports=exports.default;

/***/ }),

/***/ 7548:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.useNavbarContentContext=exports.NavbarContentProvider=void 0;var t=__webpack_require__(19938);const[e,o]=(0,t.createContext)({strict:!1,name:"NavbarContentContext"});exports.useNavbarContentContext=o,exports.NavbarContentProvider=e;

/***/ }),

/***/ 7411:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;e(__webpack_require__(18038));var r=__webpack_require__(93795),t=__webpack_require__(73726),i=e(__webpack_require__(62358)),s=__webpack_require__(81595),a=__webpack_require__(45728),l=__webpack_require__(7548),n=__webpack_require__(89296),o=__webpack_require__(47259),u=__webpack_require__(56786);const h=(0,r.forwardRef)(((e,r)=>{const{children:s,...h}=e,g=(0,o.useNavbarContent)(h),c=(0,t.useDOMRef)(r);return(0,u.jsx)(l.NavbarContentProvider,{value:g,children:(0,u.jsxs)(n.StyledNavbarContent,{ref:(0,a.mergeRefs)(g.wrapperRef,c),className:(0,i.default)("nextui-navbar-content",g.className),css:{gap:g.gap,...g.css},enableCursorHighlight:g.enableCursorHighlight,style:g.style,onMouseLeave:g.resetHighlight,...g.otherProps,children:[g.enableCursorHighlight&&(0,u.jsx)(n.StyledCursorHighlight,{ref:g.cursorHighlightRef,className:"nextui-navbar-cursor-highlight",color:g.activeColor,css:g.cursorHighlightCss,isHighlightSolidVariant:g.isHighlightSolidVariant,isHighlightVariant:g.isHighlightVariant,isRounded:g.isRounded}),s]})})}));s.__DEV__&&(h.displayName="NextUI.NavbarContent"),h.toString=()=>".nextui-navbar-content";var g=h;exports["default"]=g,module.exports=exports.default;

/***/ }),

/***/ 67219:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.useNavbarContext=exports.NavbarProvider=void 0;var e=__webpack_require__(19938);const[t,r]=(0,e.createContext)({strict:!0,name:"NavbarContext",errorMessage:"useNavbarContext: `context` is undefined. Seems you forgot to wrap all navbar components within `<Navbar />`"});exports.useNavbarContext=r,exports.NavbarProvider=t;

/***/ }),

/***/ 27209:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=v(r);if(t&&t.has(e))return t.get(e);var i={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var l in e)if("default"!==l&&Object.prototype.hasOwnProperty.call(e,l)){var o=n?Object.getOwnPropertyDescriptor(e,l):null;o&&(o.get||o.set)?Object.defineProperty(i,l,o):i[l]=e[l]}i.default=e,t&&t.set(e,i);return i}(__webpack_require__(18038)),t=__webpack_require__(34353),i=__webpack_require__(77335),n=__webpack_require__(93795),l=__webpack_require__(73726),o=__webpack_require__(36828),u=e(__webpack_require__(62358)),a=__webpack_require__(80345),s=__webpack_require__(81595),d=__webpack_require__(7548),c=__webpack_require__(89296),h=__webpack_require__(56786);function v(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(v=function(e){return e?t:r})(e)}const g=(0,n.forwardRef)(((e,n)=>{var s;const{id:v,css:g,children:p,variant:f,activeColor:b,isActive:m,underlineHeight:x,onMouseEnter:$,onMouseLeave:H,isDisabled:y,className:C,...I}=e,q=(0,d.useNavbarContentContext)(),M=(0,l.useDOMRef)(n),j=f||(null==q?void 0:q.variant),O=null==j?void 0:j.toString(),P=null==O.includes?void 0:O.includes("highlight"),_=null==O.includes?void 0:O.includes("highlight-solid"),{hoverProps:D,isHovered:N}=(0,t.useHover)({isDisabled:y}),w=(0,i.useId)(v);(0,r.useEffect)((()=>{M.current&&q&&null!=q&&q.enableCursorHighlight&&m&&P&&q.updateActiveItem(null==M?void 0:M.current)}),[M,P,m]);const E=(0,r.useMemo)((()=>{var e;return!!q&&(null==(e=q.highlightedItem)?void 0:e.id)===w}),[w,q]),W=(0,r.useMemo)((()=>{var e;return!(E||null==q||!q.enableCursorHighlight||!_||w!==(null==q||null==(e=q.activeItem)?void 0:e.id))}),[q,w,E,_]),A=(0,r.useMemo)((()=>{const e=[],r="string"==typeof p,t=null==O.includes?void 0:O.includes("highlight-solid");q||e.push({$$navbarContentItemGap:"$space$8"}),P&&(e.push({dflex:"center",height:"$$navbarItemMaxHeight"}),r?e.push({px:"calc($$navbarContentItemHorizontalPadding * 0.5)"}):e.push({"*:first-child":{size:"100%",px:"calc($$navbarContentItemHorizontalPadding * 0.5)"}})),P&&null!=O.includes&&O.includes("rounded")&&!q.enableCursorHighlight&&e.push({"&:before":{borderRadius:"$pill"}}),q.enableCursorHighlight&&e.push({"&:before":{display:"none"}}),m&&!P&&e.push({$$navbarItemFontWeight:"$fontWeights$semibold"}),N&&q.enableCursorHighlight&&(P&&e.push({color:"$$navbarItemHighlightTextColor"}),t&&e.push({color:"$$navbarItemHighlightSolidTextColor"})),W&&e.push({color:"$$navbarItemActiveColor"});return{...(0,o.arrayToObject)(e),...g}}),[p,g,q,O,W,m,N,P]),R="string"==typeof p?(0,h.jsx)(a.Text,{children:p}):r.default.Children.only(p),S=r.default.cloneElement(R,{id:(null==(s=R.props)?void 0:s.id)||w,onMouseEnter:e=>{var r;if(null==q||!q.repositionHighlight)return void(null==$||$(e));(null==(r=e.target)?void 0:r.id)===w&&q.repositionHighlight(e,null==M?void 0:M.current),null==$||$(e)},onMouseLeave:e=>{null!=q&&q.resetHighlight&&q.enableCursorHighlight&&P?(q.resetHighlight(),null==H||H(e)):null==H||H(e)}});return(0,h.jsx)(c.StyledNavbarItem,{ref:M,activeColor:b||(null==q?void 0:q.activeColor),className:(0,u.default)("nextui-navbar-item",C),css:A,id:w,isActive:m,underlineHeight:x||(null==q?void 0:q.underlineHeight),variant:j,...(0,i.mergeProps)(D,I),children:S})}));s.__DEV__&&(g.displayName="NextUI.NavbarItem"),g.toString=()=>".nextui-navbar-item";var p=g;exports["default"]=p,module.exports=exports.default;

/***/ }),

/***/ 89796:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=l(r);if(t&&t.has(e))return t.get(e);var i={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if("default"!==a&&Object.prototype.hasOwnProperty.call(e,a)){var s=n?Object.getOwnPropertyDescriptor(e,a):null;s&&(s.get||s.set)?Object.defineProperty(i,a,s):i[a]=e[a]}i.default=e,t&&t.set(e,i);return i}(__webpack_require__(18038)),t=__webpack_require__(93795),i=__webpack_require__(73726),n=e(__webpack_require__(62358)),a=__webpack_require__(81595),s=__webpack_require__(80345),o=e(__webpack_require__(27209)),u=__webpack_require__(56786);function l(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(l=function(e){return e?t:r})(e)}const c=(0,t.forwardRef)(((e,t)=>{const a=(0,i.useDOMRef)(t),{css:l,children:c,isActive:f,color:d,activeColor:p,underlineHeight:v,itemCss:h,itemClassName:b,isDisabled:m,hideIn:x,showIn:y,variant:q,className:j,...w}=e,O=(0,r.useMemo)((()=>d||null!=l&&l.$$linkColor?{...l}:{color:"inherit",height:"100%",width:"fit-content",...l}),[d,l]);return(0,u.jsx)(o.default,{activeColor:p,className:b,css:h,hideIn:x,isActive:f,isDisabled:m,showIn:y,underlineHeight:v,variant:q,children:(0,u.jsx)(s.Link,{ref:a,className:(0,n.default)("nextui-navbar-link",j),color:d,css:O,...w,children:c})})}));a.__DEV__&&(c.displayName="NextUI.NavbarLink"),c.toString=()=>".nextui-navbar-link";var f=c;exports["default"]=f,module.exports=exports.default;

/***/ }),

/***/ 55749:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;e(__webpack_require__(18038));var a=__webpack_require__(81595),r=e(__webpack_require__(62358)),t=__webpack_require__(89296),s=__webpack_require__(56786);const i=e=>{const{isExpanded:a=!1,className:i,...n}=e;return(0,s.jsxs)(t.StyledNavbarToggleIconContainer,{"aria-hidden":!0,className:(0,r.default)("nextui-navbar-toggle-icon",i),isExpanded:a,tabIndex:-1,...n,children:[(0,s.jsx)("span",{className:"line top"}),(0,s.jsx)("span",{className:"line bottom"})]})};a.__DEV__&&(i.displayName="NextUI.NavbarToggleIcon"),i.toString=()=>".nextui-navbar-toggle-icon";var n=i;exports["default"]=n,module.exports=exports.default;

/***/ }),

/***/ 96632:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=b(r);if(t&&t.has(e))return t.get(e);var s={},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&Object.prototype.hasOwnProperty.call(e,u)){var o=a?Object.getOwnPropertyDescriptor(e,u):null;o&&(o.get||o.set)?Object.defineProperty(s,u,o):s[u]=e[u]}s.default=e,t&&t.set(e,s);return s}(__webpack_require__(18038)),t=__webpack_require__(20662),s=__webpack_require__(841),a=__webpack_require__(94135),u=__webpack_require__(77335),o=__webpack_require__(93795),i=__webpack_require__(73726),n=e(__webpack_require__(66551)),l=e(__webpack_require__(62358)),c=__webpack_require__(81595),f=__webpack_require__(67219),p=__webpack_require__(89296),d=e(__webpack_require__(55749)),g=__webpack_require__(56786);function b(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(b=function(e){return e?t:r})(e)}const v=(0,o.forwardRef)(((e,o)=>{const{children:c,className:b,autoFocus:v,onChange:q,as:y,css:x,...m}=e,{parentRef:O,setIsCollapseOpen:P}=(0,f.useNavbarContext)(),[,j]=(0,n.default)(O,{scrollLayer:!0}),_=(0,i.useDOMRef)(o),h=(0,s.useToggleState)({...e,onChange:e=>{P(e),null==q||q(e),j(e)}}),{buttonProps:M,isPressed:N}=(0,t.useToggleButton)(e,h,_),{isFocusVisible:w,focusProps:D}=(0,a.useFocusRing)({autoFocus:v}),F=(0,r.useMemo)((()=>c||(0,g.jsx)(d.default,{isExpanded:h.isSelected})),[c,h.isSelected]);return(0,g.jsx)(p.StyledNavbarToggle,{ref:_,as:y,className:(0,l.default)("nextui-navbar-toggle",b),css:x,isFocusVisible:w,isPressed:N,...(0,u.mergeProps)(M,D,m),children:F})}));c.__DEV__&&(v.displayName="NextUI.NavbarToggle"),v.toString=()=>".nextui-navbar-toggle";var q=v;exports["default"]=q,module.exports=exports.default;

/***/ }),

/***/ 19525:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;e(__webpack_require__(18038));var r=__webpack_require__(93795),a=__webpack_require__(73726),s=e(__webpack_require__(62358)),i=__webpack_require__(72625),t=__webpack_require__(81595),u=e(__webpack_require__(61969)),l=__webpack_require__(67219),n=__webpack_require__(2136),o=__webpack_require__(89296),d=__webpack_require__(56786);const c=(0,r.forwardRef)(((e,r)=>{const{children:t,...c}=e,v=(0,a.useDOMRef)(r),b=(0,n.useNavbar)(c),[x,q]=(0,i.pickChild)(t,u.default);return(0,d.jsx)(l.NavbarProvider,{value:b,children:(0,d.jsxs)(o.StyledNavbar,{ref:v,className:(0,s.default)("nextui-navbar",b.className),css:b.navbarCss,disableBlur:b.disableBlur,isBordered:b.isBordered,variant:b.variant,...b.otherProps,children:[(0,d.jsx)(o.StyledNavbarContainer,{className:"nextui-navbar-container",css:b.containerCss,children:x}),q]})})}));t.__DEV__&&(c.displayName="NextUI.Navbar"),c.toString=()=>".nextui-navbar";var v=c;exports["default"]=v,module.exports=exports.default;

/***/ }),

/***/ 89296:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledNavbarToggleIconContainer=exports.StyledNavbarToggle=exports.StyledNavbarItem=exports.StyledNavbarContent=exports.StyledNavbarContainer=exports.StyledNavbarCollapseWrapper=exports.StyledNavbarCollapseItem=exports.StyledNavbarCollapse=exports.StyledNavbarBrand=exports.StyledNavbar=exports.StyledCursorHighlight=exports.StyledBaseNavbarList=exports.StyledBaseNavbarItem=void 0;var r=__webpack_require__(88194),t=__webpack_require__(74042);const o={default:{$$navbarItemActiveColor:"$colors$link",$$navbarItemHighlightBackgroundColor:"$colors$primaryLight",$$navbarItemHighlightTextColor:"$colors$primaryLightContrast",$$navbarItemHighlightSolidBackgroundColor:"$colors$primary",$$navbarItemHighlightSolidTextColor:"$colors$primarySolidContrast"},neutral:{$$navbarItemActiveColor:"$colors$neutral",$$navbarItemHighlightBackgroundColor:"$colors$neutralLight",$$navbarItemHighlightTextColor:"$colors$text",$$navbarItemHighlightSolidBackgroundColor:"$colors$neutral",$$navbarItemHighlightSolidTextColor:"$colors$neutralSolidContrast"},primary:{$$navbarItemActiveColor:"$colors$primary",$$navbarItemHighlightBackgroundColor:"$colors$primaryLight",$$navbarItemHighlightTextColor:"$colors$primaryLightContrast",$$navbarItemHighlightSolidBackgroundColor:"$colors$primary",$$navbarItemHighlightSolidTextColor:"$colors$primarySolidContrast"},secondary:{$$navbarItemActiveColor:"$colors$secondary",$$navbarItemHighlightBackgroundColor:"$colors$secondaryLight",$$navbarItemHighlightTextColor:"$colors$secondaryLightContrast",$$navbarItemHighlightSolidBackgroundColor:"$colors$secondary",$$navbarItemHighlightSolidTextColor:"$colors$secondarySolidContrast"},success:{$$navbarItemActiveColor:"$colors$success",$$navbarItemHighlightBackgroundColor:"$colors$successLight",$$navbarItemHighlightTextColor:"$colors$successLightContrast",$$navbarItemHighlightSolidBackgroundColor:"$colors$success",$$navbarItemHighlightSolidTextColor:"$colors$successSolidContrast"},warning:{$$navbarItemActiveColor:"$colors$warning",$$navbarItemHighlightBackgroundColor:"$colors$warningLight",$$navbarItemHighlightTextColor:"$colors$warningLightContrast",$$navbarItemHighlightSolidBackgroundColor:"$colors$warning",$$navbarItemHighlightSolidTextColor:"$colors$warningSolidContrast"},error:{$$navbarItemActiveColor:"$colors$error",$$navbarItemHighlightBackgroundColor:"$colors$errorLight",$$navbarItemHighlightTextColor:"$colors$errorLightContrast",$$navbarItemHighlightSolidBackgroundColor:"$colors$error",$$navbarItemHighlightSolidTextColor:"$colors$errorSolidContrast"}},a=(0,r.styled)("li",{mb:0,display:"flex",alignItems:"center",listStyleType:"none",lineHeight:"inherit"});exports.StyledBaseNavbarItem=a;const e=(0,r.styled)("ul",{m:0,listStyle:"none",lineHeight:"$xs",li:{mb:0}});exports.StyledBaseNavbarList=e;const i=(0,r.styled)(a,{opacity:0,paddingBottom:"$6",fontSize:"$lg",lineHeight:"$lg",fontWeight:"$normal",transformOrigin:"top",variants:{activeColor:o,isActive:{true:{color:"$$navbarItemActiveColor",fontWeight:"$semibold"}},disableAnimation:{true:{transition:"none"}}},defaultVariants:{activeColor:"default"}});exports.StyledNavbarCollapseItem=i;const n=(0,r.styled)(e,{py:"$8",px:"$$navbarPadding",overflowY:"scroll",maxHeight:"100%"});exports.StyledNavbarCollapseWrapper=n;const l=(0,r.styled)("div",{$$navbarListColor:"$colors$text",$$navbarListBackgroundColor:"$colors$background",$$navbarListBlurBackgroundColor:"$colors$backgroundAlpha",$$navbarListBlur:"16px",position:"absolute",top:0,left:0,right:0,background:"$$navbarListBackgroundColor",width:"100%",height:"0px",zIndex:"$4",boxSizing:"border-box",overflow:"hidden",variants:{isOpen:{true:{top:"$$navbarHeight",pb:"$$navbarHeight",height:"100vh"}},disableBlur:{false:{"@supports ((-webkit-backdrop-filter: none) or (backdrop-filter: none))":{bg:"$$navbarListBlurBackgroundColor",backdropFilter:"saturate(180%) blur($$navbarListBlur)","@media screen and (-webkit-min-device-pixel-ratio:0)":{[`& ${n}`]:{bg:"$$navbarListBlurBackgroundColor",backdropFilter:"saturate(180%) blur($$navbarListBlur)"}}}}},disableAnimation:{true:{[`& ${i}`]:{transition:"none"}}}},defaultVariants:{disableBlur:"false"}},t.cssHideShowIn);exports.StyledNavbarCollapse=l;const s=(0,r.styled)("div",{dflex:"center",flexDirection:"column",pointerEvents:"none",size:"22px","& .line":{height:"1px",width:"100%",backgroundColor:"$$navbarTextColor",transition:"transform 0.3s ease","&.top":{transform:"translateY(-4px) rotate(0deg)"},"&.bottom":{transform:"translateY(4px) rotate(0deg)"}},variants:{isExpanded:{true:{"& .line":{"&.top":{transform:"translateY(1px) rotate(45deg)"},"&.bottom":{transform:"translateY(0px) rotate(-45deg)"}}}}}});exports.StyledNavbarToggleIconContainer=s;const $=(0,r.styled)("button",{appearance:"none",background:"transparent",border:"none",cursor:"pointer",p:"$2",transition:"box-shadow 0.25s ease 0s, opacity 0.25s ease 0s",variants:{isPressed:{true:{opacity:.7}}}},t.cssHideShowIn,t.cssFocusVisible);exports.StyledNavbarToggle=$;const d=(0,r.styled)("span",{display:"flex",flexWrap:"nowrap",flexDirection:"row",justifyContent:"flex-start",bg:"transparent",alignItems:"center",textDecoration:"none",fontSize:"$base",whiteSpace:"nowrap",boxSizing:"border-box"},t.cssHideShowIn);exports.StyledNavbarBrand=d;const g=(0,r.styled)(a,{$$navbarItemFontSize:"inherit",$$navbarItemFontWeight:"$fontWeights$normal",fontSize:"$$navbarItemFontSize",fontWeight:"$$navbarItemFontWeight",position:"relative","> *":{zIndex:"$2",fontSize:"inherit !important",fontWeight:"inherit !important"},":first-child":{boxSizing:"content-box"},"&:before":{opacity:0,zIndex:"$1",content:'""',display:"block",position:"absolute",top:0,left:0,right:0,bottom:0,borderRadius:"$sm"},"&:after":{opacity:0,zIndex:"$1",content:'""',display:"block",position:"absolute",left:"0",right:"0",bottom:"0",height:"$$navbarItemUnderlineHeight",borderRadius:"0px",background:"$$navbarItemActiveColor"},variants:{activeColor:o,isActive:{true:{color:"$$navbarItemActiveColor",$$navbarItemFontWeight:"$fontWeights$semibold"}},variant:{default:{},underline:{color:"inherit",height:"100%"},"underline-rounded":{color:"inherit",height:"100%"},highlight:{},"highlight-solid":{},"highlight-rounded":{},"highlight-solid-rounded":{}},underlineHeight:{light:{$$navbarItemUnderlineHeight:"2px"},normal:{$$navbarItemUnderlineHeight:"4px"},bold:{$$navbarItemUnderlineHeight:"6px"},extrabold:{$$navbarItemUnderlineHeight:"8px"},black:{$$navbarItemUnderlineHeight:"10px"}},isDisabled:{true:{opacity:.5,cursor:"not-allowed"}}},compoundVariants:[{isActive:!0,variant:"underline",css:{color:"inherit","&:after":{opacity:1}}},{isActive:!0,variant:"underline-rounded",css:{color:"inherit","&:after":{opacity:1,borderRadius:"calc($$navbarItemUnderlineHeight / 2)"}}},{isActive:!0,variant:"highlight",css:{color:"$$navbarItemHighlightTextColor","*:first-child":{color:"inherit"},"&:before":{opacity:1,background:"$$navbarItemHighlightBackgroundColor"}}},{isActive:!0,variant:"highlight-solid",css:{color:"$$navbarItemHighlightSolidTextColor","*:first-child":{color:"inherit"},"&:before":{opacity:1,background:"$$navbarItemHighlightSolidBackgroundColor"}}},{isActive:!0,variant:"highlight-rounded",css:{color:"$$navbarItemHighlightTextColor","*:first-child":{color:"inherit"},"&:before":{opacity:1,background:"$$navbarItemHighlightBackgroundColor"}}},{isActive:!0,variant:"highlight-solid-rounded",css:{color:"$$navbarItemHighlightSolidTextColor","*:first-child":{color:"inherit"},"&:before":{opacity:1,background:"$$navbarItemHighlightSolidBackgroundColor"}}}],defaultVariants:{variant:"default",activeColor:"default",underlineHeight:"normal"}},t.cssHideShowIn);exports.StyledNavbarItem=g;const c=(0,r.styled)(a,{position:"absolute",top:"calc(50% - $$navbarItemMaxHeight * 0.5)",height:"$$navbarItemMaxHeight",background:"$neutralLight",borderRadius:"$sm",transition:"width 0.2s ease 0s, transform 0.2s ease 0s, opacity 0.2s ease 0s",variants:{color:o,isHighlightVariant:{true:{background:"$$navbarItemHighlightBackgroundColor"}},isHighlightSolidVariant:{true:{background:"$$navbarItemHighlightSolidBackgroundColor"}},isRounded:{true:{borderRadius:"$pill"}}}});exports.StyledCursorHighlight=c;const h=(0,r.styled)(e,{$$navbarContentItemGap:"$space$10",$$navbarContentItemHorizontalPadding:"$space$10",d:"flex",height:"100%",flexWrap:"nowrap",alignItems:"center",gap:"$$navbarContentItemGap",color:"inherit",variants:{enableCursorHighlight:{true:{zIndex:"$2",position:"relative"}}}},t.cssHideShowIn);exports.StyledNavbarContent=h;const b=(0,r.styled)("div",{width:"100%",height:"$$navbarHeight",minHeight:"$$navbarHeight",display:"flex",flexWrap:"nowrap",justifyContent:"space-between",alignItems:"center",position:"relative",boxSizing:"border-box",color:"inherit",px:"$$navbarPadding",bg:"$$navbarBackgroundColor",maxW:"$$navbarContainerMaxWidth",zIndex:"$5","@xsMax":{$$navbarPadding:"$space$6",$$navbarFloatingMargin:"$space$6"}});exports.StyledNavbarContainer=b;const v=(0,r.styled)("nav",{width:"100%",dflex:"center",position:"relative",height:"auto",color:"$$navbarTextColor",zIndex:"$2",variants:{variant:{static:{position:"static"},sticky:{top:0,right:0,left:0,position:"sticky"},floating:{top:0,right:0,left:0,position:"sticky","@safari":{top:"-5px"},[`& ${b}`]:{mt:"calc($$navbarFloatingMargin * 0.5)",mx:"$$navbarFloatingMargin",borderRadius:"$$navbarBorderRadius"},[`& ${n}`]:{px:"calc($$navbarFloatingMargin + $space$4)"}}},maxWidth:{xs:{$$navbarContainerMaxWidth:"$breakpoints$xs"},sm:{$$navbarContainerMaxWidth:"$breakpoints$sm"},md:{$$navbarContainerMaxWidth:"$breakpoints$md"},lg:{$$navbarContainerMaxWidth:"$breakpoints$lg"},xl:{$$navbarContainerMaxWidth:"$breakpoints$xl"},fluid:{$$navbarContainerMaxWidth:"100%"}},isBordered:{true:{[`& ${b}`]:{borderBottom:"$$navbarBorderWeight solid $$navbarBorderColor"}}},isCompact:{true:{$$navbarHeight:"$$navbarCompactHeight",$$navbarItemMaxHeight:"$$navbarCompactItemMaxHeight",$$navbarBorderRadius:"$radii$md"}},disableShadow:{false:{boxShadow:"$$navbarShadow"}},disableBlur:{false:{"@supports ((-webkit-backdrop-filter: none) or (backdrop-filter: none))":{[`& ${b}`]:{bg:"$$navbarBlurBackgroundColor",backdropFilter:"saturate(180%) blur($$navbarBlur)"}}}}},compoundVariants:[{isBordered:!0,variant:"floating",css:{[`& ${b}`]:{border:"$$navbarBorderWeight solid $$navbarBorderColor"}}},{variant:"floating",disableShadow:!1,css:{boxShadow:"none",[`& ${b}`]:{boxShadow:"$$navbarShadow"}}}],defaultVariants:{variant:"static",maxWidth:"lg",isBordered:!1,disableShadow:!1,disableBlur:!1}});exports.StyledNavbar=v;

/***/ }),

/***/ 67599:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports.useNavbarCollapse=function(e={}){var o;const{css:u,children:c,ref:p,transitionDelay:v=0,transitionTime:d=350,transitionMatrix:m={in:"matrix(1, 0, 0, 1, 0, 0)",out:"matrix(0.97, 0, 0, 1, 0, 20)"},className:f,...b}=e,[h,q]=(0,r.useState)(!1),x=(0,i.useNavbarContext)(),C=(0,t.useDOMRef)(p),[,R]=(0,l.pickChild)(c,a.default),[,O]=(0,s.default)(null,{scrollLayer:!0});(0,r.useEffect)((()=>{var e,r;x.isCollapseOpen?O(!0):(C.current&&(null==(r=C.current)||null==r.scrollTo||r.scrollTo({top:0})),q(!1),O(!1));const t=()=>{var e;C.current&&(null==(e=C.current)?void 0:e.scrollTop)>0&&!h&&q(!0)};return null==(e=C.current)||e.addEventListener("scroll",t),()=>{var e;null==(e=C.current)||e.removeEventListener("scroll",t)}}),[x.isCollapseOpen]);const T=(0,r.useMemo)((()=>{const e=[];var r;x.parentRef&&x.parentRef.current&&e.push({maxHeight:null==(r=x.parentRef.current)?void 0:r.clientHeight});return{...(0,n.arrayToObject)(e),...u}}),[null==(o=x.parentRef)?void 0:o.current,u]);return{css:u,domRef:C,children:c,items:R,collpaseCss:T,isOpen:x.isCollapseOpen,hasScrolled:h,transitionDelay:v,transitionTime:d,transitionMatrix:m,className:f,otherProps:b}};var r=__webpack_require__(18038),t=__webpack_require__(73726),l=__webpack_require__(72625),n=__webpack_require__(36828),s=e(__webpack_require__(66551)),a=e(__webpack_require__(92985)),i=__webpack_require__(67219);

/***/ }),

/***/ 47259:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.useNavbarContent=function(i={}){const{gap:n="$10",variant:l="default",activeColor:u="default",underlineHeight:o="normal",enableCursorHighlight:r=!1,isCursorHighlightRounded:a=!1,css:s,style:g,className:d,...c}=i,[h,v]=(0,e.useState)(null),[m,x]=(0,e.useState)(null),[C,p]=(0,e.useState)(null),[R,f]=(0,e.useState)(null),[H,B]=(0,e.useState)(!0),M=(0,e.useRef)(null),S=(0,e.useRef)(null),w=null==l||null==l.toString?void 0:l.toString(),b=null==w.includes?void 0:w.includes("highlight"),y=null==w.includes?void 0:w.includes("highlight-solid"),I=(0,e.useMemo)((()=>a||(null==w.includes?void 0:w.includes("rounded"))),[a,w]),$=(0,e.useMemo)((()=>b&&"$10"===n?"0px":n),[b,n]),P=(0,e.useMemo)((()=>H?"0ms":"200ms"),[H]),D=(0,e.useMemo)((()=>C||R?1:0),[R,C]),N=(0,e.useMemo)((()=>h?b?`${h.width}px`:`calc(${h.width}px + var(--nextui--navbarContentItemHorizontalPadding))`:"0px"),[w,h]),q=(0,e.useMemo)((()=>h&&m&&`translate(${h.left-m.left}px)`),[h,m]),z=(0,e.useMemo)((()=>b?"0px":"calc(var(--nextui--navbarContentItemHorizontalPadding) * 0.5 * -1)"),[b]),V=(0,e.useMemo)((()=>(0,t.mergeProps)({"--nextui--transitionDuration":P,"--nextui--opacity":D,"--nextui--width":N,"--nextui--transform":q,"--nextui--left":z},g||{})),[P,z,D,N,q,g]),_=(0,e.useMemo)((()=>h&&m&&r?{transitionDuration:"var(--nextui--transitionDuration)",opacity:"var(--nextui--opacity)",width:"var(--nextui--width)",transform:"var(--nextui--transform)",left:"var(--nextui--left)"}:{}),[h,m,r]);return{css:s,gap:$,variant:l,activeColor:u,activeItem:R,updateActiveItem:e=>{var t;f(e),p(e),v(null==e||null==e.getBoundingClientRect?void 0:e.getBoundingClientRect()),x(null==(t=S.current)||null==t.getBoundingClientRect?void 0:t.getBoundingClientRect())},highlightedItem:C,underlineHeight:o,cursorHighlightRef:M,isRounded:I,isHighlightVariant:b,isHighlightSolidVariant:y,isCursorHighlightRounded:a,enableCursorHighlight:r,cursorHighlightCss:_,repositionHighlight:(e,t)=>{var i,n;(null==e?void 0:e.target)instanceof Element&&(v(null==(i=e.target)||null==i.getBoundingClientRect?void 0:i.getBoundingClientRect()),x(null==(n=S.current)||null==n.getBoundingClientRect?void 0:n.getBoundingClientRect()),B(!C),p(t))},resetHighlight:()=>{R?(p(R),v(null==R||null==R.getBoundingClientRect?void 0:R.getBoundingClientRect())):p(null)},wrapperRef:S,className:d,style:V,otherProps:c}};var e=__webpack_require__(18038),t=__webpack_require__(77335);

/***/ }),

/***/ 2136:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var r=__webpack_require__(27574);exports.__esModule=!0,exports.useNavbar=function(r={}){const{css:s,containerCss:i,parentRef:$,isBordered:u,variant:c="static",height:d="76px",borderWeight:b="light",shouldHideOnScroll:g=!1,disableScrollHandler:h=!1,onScrollPositionChange:v,disableBlur:p=!1,className:m,...C}=r,[f,k]=(0,e.useState)(!1),[x,B]=(0,e.useState)(!1),{theme:H}=(0,t.default)(),M=(0,e.useMemo)((()=>u?`$borderWeights$${b}`:"0px"),[u,b]),q=(0,e.useMemo)((()=>p||x),[p,x]),y=(0,e.useMemo)((()=>"number"==typeof d?`${d}px`:d),[d]);(0,n.globalCss)({":root":{$$navbarHeight:y,$$navbarCompactHeight:"calc($$navbarHeight * 0.7)",$$navbarTextColor:"$colors$text",$$navbarBackgroundColor:"$colors$background",$$navbarBlurBackgroundColor:"$colors$backgroundAlpha",$$navbarItemMaxHeight:"calc($$navbarHeight * 0.5)",$$navbarCompactItemMaxHeight:"calc($$navbarHeight * 0.5)",$$navbarBorderColor:"$colors$border",$$navbarBorderRadius:"$radii$lg",$$navbarPadding:"$space$10",$$navbarFloatingMargin:"$space$10",$$navbarContainerMaxWidth:"$breakpoints$lg",$$navbarShadow:"$shadows$md",$$navbarBorderWeight:M,$$navbarBlur:"10px"}})(),(0,l.default)({elementRef:$,enabled:g||!h,callback:({prevPos:r,currPos:e})=>{null==v||v(e.y),g&&k((a=>{const o=e.y>r.y;return o!==a?o:a}))}});const S=(0,e.useMemo)((()=>{const r=[];var e,l,n,t,i,$;"floating"===c&&r.push({bg:`linear-gradient(180deg, ${(0,a.addColorAlpha)(null==H||null==(e=H.colors)||null==(l=e.background)?void 0:l.value,.95)} 44%, ${(0,a.addColorAlpha)(null==H||null==(n=H.colors)||null==(t=n.background)?void 0:t.value,.46)} 73%, ${(0,a.addColorAlpha)(null==H||null==(i=H.colors)||null==($=i.background)?void 0:$.value,0)})`});g&&r.push({position:"sticky",top:0,right:0,left:0,transform:f?"translateY(-100%)":"translateY(0)",transition:"transform 400ms ease"});return{...(0,o.arrayToObject)(r),...s}}),[s,null==H?void 0:H.colors,c,g,f]);return{css:s,variant:c,sticky:f,isBordered:u,containerCss:i,navbarCss:S,parentRef:$,borderWeight:b,shouldHideOnScroll:g,disableBlur:q,isCollapseOpen:x,setIsCollapseOpen:B,className:m,otherProps:C}};var e=__webpack_require__(18038),a=__webpack_require__(36403),o=__webpack_require__(36828),l=r(__webpack_require__(93517)),n=__webpack_require__(88194),t=r(__webpack_require__(47902));

/***/ }),

/***/ 19818:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var t=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledPaginationItemContent=exports.StyledPaginationItem=exports.StyledPaginationIcon=exports.StyledPaginationHighlight=exports.StyledPaginationEllipsis=exports.StyledPagination=void 0;var e=t(__webpack_require__(13561)),i=__webpack_require__(6713);exports.StyledPaginationEllipsis=i.StyledPaginationEllipsis,exports.StyledPaginationIcon=i.StyledPaginationIcon,exports.StyledPaginationItemContent=i.StyledPaginationItemContent,exports.StyledPaginationItem=i.StyledPaginationItem,exports.StyledPaginationHighlight=i.StyledPaginationHighlight,exports.StyledPagination=i.StyledPagination;var n=e.default;exports["default"]=n;

/***/ }),

/***/ 27675:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=o(r);if(t&&t.has(e))return t.get(e);var i={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var l in e)if("default"!==l&&Object.prototype.hasOwnProperty.call(e,l)){var s=n?Object.getOwnPropertyDescriptor(e,l):null;s&&(s.get||s.set)?Object.defineProperty(i,l,s):i[l]=e[l]}i.default=e,t&&t.set(e,i);return i}(__webpack_require__(18038)),t=e(__webpack_require__(42466)),i=__webpack_require__(6713),n=__webpack_require__(56786);function o(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(o=function(e){return e?t:r})(e)}var l=({value:e,isBefore:o,onlyDots:l,animated:s,bordered:a,onClick:u})=>{const[c,p]=(0,r.useState)(!1);return(0,n.jsx)(t.default,{animated:s,bordered:a,onlyDots:l,value:e,onClick:e=>u&&u(e),onMouseEnter:()=>p(!0),onMouseLeave:()=>p(!1),children:c?(0,n.jsxs)(i.StyledPaginationEllipsis,{className:"nextui-pagination-ellipsis",fill:"none",focusable:"false",isBefore:o,isEllipsis:!0,role:"presentation",shapeRendering:"geometricPrecision",stroke:"currentColor",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"1.5",viewBox:"0 0 24 24",children:[(0,n.jsx)("path",{d:"M13 17l5-5-5-5"}),(0,n.jsx)("path",{d:"M6 17l5-5-5-5"})]}):(0,n.jsxs)(i.StyledPaginationEllipsis,{fill:"none",isBefore:o,isEllipsis:!1,shapeRendering:"geometricPrecision",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"1.5",viewBox:"0 0 24 24",children:[(0,n.jsx)("circle",{cx:"12",cy:"12",fill:"currentColor",r:"1"}),(0,n.jsx)("circle",{cx:"19",cy:"12",fill:"currentColor",r:"1"}),(0,n.jsx)("circle",{cx:"5",cy:"12",fill:"currentColor",r:"1"})]})})};exports["default"]=l,module.exports=exports.default;

/***/ }),

/***/ 8360:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=o(t);if(r&&r.has(e))return r.get(e);var i={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if("default"!==a&&Object.prototype.hasOwnProperty.call(e,a)){var u=n?Object.getOwnPropertyDescriptor(e,a):null;u&&(u.get||u.set)?Object.defineProperty(i,a,u):i[a]=e[a]}i.default=e,r&&r.set(e,i);return i}(__webpack_require__(18038)),r=__webpack_require__(77335),i=e(__webpack_require__(62358)),n=__webpack_require__(6713),a=__webpack_require__(56786);function o(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(o=function(e){return e?r:t})(e)}const u="nextui-pagination-highlight",s=({active:e,shadow:o,noMargin:s,rounded:l,css:c,...p})=>{const[f,d]=(0,t.useState)(e),[g,v]=(0,t.useState)("");(0,t.useEffect)((()=>{if(e!==f){d(e),v(`${u}--moving`);const t=setTimeout((()=>{v(""),clearTimeout(t)}),350)}}),[e]);const h=(0,t.useMemo)((()=>s?`var(--nextui--paginationSize) * ${f}`:`var(--nextui--paginationSize) * ${f} + ${4*f+2}px`),[f,s]);return(0,a.jsx)(n.StyledPaginationHighlight,{"aria-hidden":!0,className:(0,i.default)(u,g,{[`${u}--rounded`]:l,[`${u}--active`]:e,[`${u}--no-margin`]:s,[`${u}--shadow`]:o},p.className),css:{left:"var(--nextui--paginationLeft)",...c},noMargin:s,rounded:l,shadow:o,style:(0,r.mergeProps)({"--nextui--paginationLeft":`calc(${h})`},(null==p?void 0:p.style)||{}),...p})};s.toString=()=>".nextui-pagination-highlight";var l=s;exports["default"]=l,module.exports=exports.default;

/***/ }),

/***/ 71325:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(18038)),t=e(__webpack_require__(42466)),o=__webpack_require__(6713),i=__webpack_require__(56786);const n=({isPrev:e,disabled:r,onlyDots:n,animated:a,bordered:s,onClick:l,...d})=>(0,i.jsx)(t.default,{preserveContent:!0,animated:a,bordered:s,disabled:r,onlyDots:n,value:e?"<":">",onClick:e=>l&&l(e),children:(0,i.jsx)(o.StyledPaginationIcon,{className:"nextui-pagination-icon",fill:"none",focusable:"false",isPrev:e,role:"presentation",viewBox:"0 0 24 24",xmlns:"http://www.w3.org/2000/svg",...d,children:(0,i.jsx)("path",{d:"M15.5 19l-7-7 7-7",stroke:"currentColor",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:1.5})})});n.toString=()=>".nextui-pagination-icon";var a=r.default.memo(n);exports["default"]=a,module.exports=exports.default;

/***/ }),

/***/ 42466:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=u(t);if(r&&r.has(e))return r.get(e);var n={},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if("default"!==i&&Object.prototype.hasOwnProperty.call(e,i)){var o=a?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(n,i,o):n[i]=e[i]}n.default=e,r&&r.set(e,n);return n}(__webpack_require__(18038)),r=__webpack_require__(60704),n=e(__webpack_require__(62358)),a=e(__webpack_require__(25457)),i=__webpack_require__(6713),o=__webpack_require__(56786);function u(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(u=function(e){return e?r:t})(e)}const s=e=>{if(e)switch(e){case r.DOTS:return"dots element";case"<":return"previous page button";case">":return"next page button";case"first":return"first page button";case"last":return"last page button";default:return`${e} item`}},l="nextui-pagination-item",d=({active:e,value:r,children:a,disabled:u,animated:d,bordered:c,onClick:p,onlyDots:f,preserveContent:b,...v})=>{const g=(0,t.useMemo)((()=>e?`${s(r)} active`:s(r)),[r,e]);return(0,o.jsx)(i.StyledPaginationItem,{active:e,animated:d,"aria-label":g,bordered:c,className:(0,n.default)(l,{[`${l}-active`]:e,[`${l}-animated`]:d,[`${l}-disabled`]:u,[`${l}-bordered`]:c,[`${l}-only-dots`]:f,[`${l}-preserve-content`]:b}),disabled:u,onlyDots:f,preserveContent:b,tabIndex:u?-1:0,onClick:e=>{u||p&&p(e)},...v,children:(0,o.jsx)(i.StyledPaginationItemContent,{className:`${l}-content`,children:a})})};d.toString=()=>".nextui-pagination-item";var c=(0,a.default)(d,{preserveContent:!1});exports["default"]=c,module.exports=exports.default;

/***/ }),

/***/ 13561:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=f(__webpack_require__(18038)),r=f(__webpack_require__(60704)),n=__webpack_require__(81595),i=e(__webpack_require__(62358)),a=e(__webpack_require__(42466)),o=e(__webpack_require__(27675)),d=e(__webpack_require__(71325)),l=e(__webpack_require__(8360)),s=__webpack_require__(6713),u=__webpack_require__(56786);function p(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(p=function(e){return e?r:t})(e)}function f(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=p(t);if(r&&r.has(e))return r.get(e);var n={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if("default"!==a&&Object.prototype.hasOwnProperty.call(e,a)){var o=i?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(n,a,o):n[a]=e[a]}return n.default=e,r&&r.set(e,n),n}const c="nextui-pagination",g=({page:e,initialPage:n,onlyDots:p,total:f,loop:g,siblings:b,boundaries:m,shadow:x,animated:y,bordered:v,dotsJump:h,controls:j,noMargin:P,onChange:q,rounded:D,...O})=>{const{range:$,active:w,setPage:M,previous:k,next:_,first:C,last:N}=(0,r.default)({page:e,initialPage:n,siblings:p?10:b,boundaries:p?10:m,total:f,onChange:q}),S=(0,t.useCallback)(((e,t)=>{if(e===r.DOTS){const r=t<$.indexOf(w);return(0,u.jsx)(o.default,{animated:y,bordered:v,isBefore:r,onlyDots:p,value:e,onClick:()=>M(r?w-h>=1?w-h:1:w+h<=f?w+h:f)},`${c}-item-${e}-${t}`)}return(0,u.jsx)(a.default,{active:e===w,animated:y,bordered:v,onlyDots:p,value:e,onClick:()=>e!==w&&M(e),children:e},`${c}-item-${e}-${t}`)}),[f,p,w,v,y,M]);return(0,u.jsxs)(s.StyledPagination,{bordered:v,className:(0,i.default)(c,{[`${c}--no-margin`]:P,[`${c}--bordered`]:v,[`${c}--shadow`]:x,[`${c}--rounded`]:D}),noMargin:P,onlyDots:p,rounded:D,...O,children:[j&&(0,u.jsx)(d.default,{isPrev:!0,animated:y,bordered:v,disabled:!g&&1===w,onlyDots:p,onClick:()=>g&&1===w?N():k()}),(0,u.jsx)(l.default,{active:j?$.indexOf(w)+1:$.indexOf(w),animated:y,noMargin:P,rounded:D,shadow:x}),$.map(S),j&&(0,u.jsx)(d.default,{animated:y,bordered:v,disabled:!g&&w===f,onlyDots:p,onClick:()=>g&&w===f?C():_()})]})};g.defaultProps={shadow:!1,controls:!0,bordered:!1,initialPage:1,siblings:1,boundaries:1,dotsJump:5,total:1,loop:!1,animated:!0,onlyDots:!1,noMargin:!1,rounded:!1},n.__DEV__&&(g.displayName="NextUI.Pagination"),g.toString=()=>".nextui-pagination";var b=t.default.memo(g);exports["default"]=b,module.exports=exports.default;

/***/ }),

/***/ 6713:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledPaginationItemContent=exports.StyledPaginationItem=exports.StyledPaginationIcon=exports.StyledPaginationHighlight=exports.StyledPaginationEllipsis=exports.StyledPagination=void 0;var i=__webpack_require__(88194),a=__webpack_require__(74042);const n=(0,i.keyframes)({"0%":{transform:"scale(1)"},"60%":{transform:"scale($$paginationScaleTransform)"},"100%":{transform:"scale(1)"}}),o=(0,i.styled)("svg",{color:"currentColor",stroke:"currentColor",variants:{isEllipsis:{true:{transform:"0deg"}},isBefore:{true:{}}},compoundVariants:[{isEllipsis:!0,isBefore:!0,css:{transform:"rotate(180deg)"}}]});exports.StyledPaginationEllipsis=o;const t=(0,i.styled)("svg",{transform:"rotate(180deg)",variants:{isPrev:{true:{transform:"rotate(0deg)"}}}});exports.StyledPaginationIcon=t;const e=(0,i.styled)("span",{position:"relative",display:"inline-flex",alignItems:"center",top:0,left:0,zIndex:"$2"});exports.StyledPaginationItemContent=e;const r=(0,i.styled)("button",{border:"none",position:"relative",display:"inline-flex",margin:"0 $$paginationItemMargin",ai:"center",jc:"center",padding:0,boxSizing:"border-box",tt:"capitalize",us:"none",whiteSpace:"nowrap",ta:"center",verticalAlign:"middle",bs:"none",outline:"none",height:"$$paginationSize",minWidth:"$$paginationSize",fs:"inherit",cursor:"pointer",br:"$$paginationItemRadius",color:"$text",bg:"$accents0","@motion":{transition:"none"},"&:hover":{bg:"$accents1"},[`& ${t}`]:{size:"$$paginationFontSize"},[`& ${o}`]:{size:"$$paginationFontSize"},variants:{active:{true:{fontWeight:"$bold",cursor:"default",boxShadow:"$sm",[`& ${e}`]:{color:"$white"}}},disabled:{true:{color:"$accents5",cursor:"not-allowed"}},bordered:{true:{bg:"transparent",border:"$$paginationItemBorderWeight solid $accents2"}},onlyDots:{true:{}},preserveContent:{true:{}},animated:{true:{transition:"transform 0.25s ease 0s, background 0.25s ease 0s, box-shadow 0.25s ease 0s"},false:{transition:"none"}}},compoundVariants:[{onlyDots:!0,preserveContent:!1,css:{[`& ${e}`]:{display:"none"}}},{animated:!0,disabled:!1,active:!1,css:{"&:active":{transform:"scale($$paginationScaleTransform)",fs:"calc($$paginationFontSize * 0.9)"}}}]},a.sharedFocus);exports.StyledPaginationItem=r;const s=(0,i.styled)("div",{position:"absolute",contain:"strict",top:"0px",zIndex:"$1",bg:"$$paginationColor",br:"$$paginationItemRadius",height:"$$paginationSize",minWidth:"$$paginationSize",animationName:`${n}`,animationDirection:"normal","&.nextui-pagination-highlight--moving":{transform:"scale($$paginationScaleTransform)"},"@motion":{transition:"none","&.nextui-pagination-highlight--moving":{transform:"scale(1)"}},variants:{animated:{true:{animationDuration:"350ms",animationTimingFunction:"ease",transition:"left 350ms ease 0s, transform 300ms ease 0s"},false:{animationDuration:"none",animationTimingFunction:"none",transition:"none","&.nextui-pagination-highlight--moving":{transform:"scale(1)"}}},noMargin:{true:{br:"$squared"}},rounded:{true:{}},shadow:{true:{normalShadowVar:"$$paginationShadowColor"}}},compoundVariants:[{rounded:!0,noMargin:!0,css:{br:"$pill"}}]});exports.StyledPaginationHighlight=s;const $=(0,i.styled)("nav",{m:0,p:0,d:"inline-flex",position:"relative",fontVariant:"tabular-nums",fontFeatureSettings:"tnum",variants:{color:{default:{$$paginationColor:"$colors$primary",$$paginationShadowColor:"$colors$primaryShadow"},primary:{$$paginationColor:"$colors$primary",$$paginationShadowColor:"$colors$primaryShadow"},secondary:{$$paginationColor:"$colors$secondary",$$paginationShadowColor:"$colors$secondaryShadow"},success:{$$paginationColor:"$colors$success",$$paginationShadowColor:"$colors$successShadow"},warning:{$$paginationColor:"$colors$warning",$$paginationShadowColor:"$colors$warningShadow"},error:{$$paginationColor:"$colors$error",$$paginationShadowColor:"$colors$errorShadow"},gradient:{$$paginationColor:"$colors$gradient",$$paginationShadowColor:"$colors$primaryShadow"}},size:{xs:{$$paginationWidth:"$space$10",$$paginationFontSize:"$space$5",fs:"$$paginationFontSize"},sm:{$$paginationWidth:"$space$12",$$paginationFontSize:"$space$6",fs:"$$paginationFontSize"},md:{$$paginationWidth:"$space$13",$$paginationFontSize:"$space$7",fs:"$$paginationFontSize"},lg:{$$paginationWidth:"$space$14",$$paginationFontSize:"$space$8",fs:"$$paginationFontSize"},xl:{$$paginationWidth:"$space$15",$$paginationFontSize:"$space$9",fs:"$$paginationFontSize"}},borderWeight:{light:{$$paginationItemBorderWeight:"$borderWeights$light"},normal:{$$paginationItemBorderWeight:"$borderWeights$normal"},bold:{$$paginationItemBorderWeight:"$borderWeights$bold"},extrabold:{$$paginationItemBorderWeight:"$borderWeights$extrabold"},black:{$$paginationItemBorderWeight:"$borderWeights$black"}},bordered:{true:{}},onlyDots:{true:{$$paginationSize:"calc($$paginationWidth / 2)",$$paginationItemRadius:"$radii$pill",$$paginationScaleTransform:1.05},false:{$$paginationSize:"$$paginationWidth",$$paginationScaleTransform:1.1}},rounded:{true:{$$paginationItemRadius:"$radii$pill"},false:{$$paginationItemRadius:"$radii$squared"}},noMargin:{true:{$$paginationItemRadius:"0px",$$paginationItemMargin:"0",[`& ${r}:first-of-type`]:{btlr:"$squared",bblr:"$squared"},[`& ${r}:last-of-type`]:{btrr:"$squared",bbrr:"$squared"}},false:{$$paginationItemMargin:"$space$1"}}},compoundVariants:[{bordered:!0,noMargin:!0,css:{[`& ${r}:not(:last-child)`]:{borderRight:0}}},{noMargin:!0,rounded:!0,css:{$$paginationItemRadius:"0px"}},{rounded:!1,noMargin:!0,css:{$$paginationItemRadius:"0px"}}],defaultVariants:{color:"default",size:"md",borderWeight:"normal",onlyDots:!1,noMargin:!1,rounded:!1}});exports.StyledPagination=$;

/***/ }),

/***/ 42354:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledPopoverContent=void 0;var r=e(__webpack_require__(50816)),t=e(__webpack_require__(29617)),o=e(__webpack_require__(69447)),p=__webpack_require__(34276);exports.StyledPopoverContent=p.StyledPopoverContent,r.default.Content=o.default,r.default.Trigger=t.default;var u=r.default;exports["default"]=u;

/***/ }),

/***/ 69447:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var s=m(r);if(s&&s.has(e))return s.get(e);var i={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var t in e)if("default"!==t&&Object.prototype.hasOwnProperty.call(e,t)){var n=o?Object.getOwnPropertyDescriptor(e,t):null;n&&(n.get||n.set)?Object.defineProperty(i,t,n):i[t]=e[t]}i.default=e,s&&s.set(e,i);return i}(__webpack_require__(18038)),s=__webpack_require__(27807),i=__webpack_require__(3031),o=__webpack_require__(94135),t=__webpack_require__(77335),n=e(__webpack_require__(91863)),a=__webpack_require__(81595),l=__webpack_require__(45728),u=e(__webpack_require__(62358)),d=__webpack_require__(34276),p=__webpack_require__(25952),c=__webpack_require__(96803),f=__webpack_require__(56786);function m(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,s=new WeakMap;return(m=function(e){return e?s:r})(e)}const v=r.default.forwardRef(((e,a)=>{const{children:m,as:v,css:b,className:x,...O}=e,{state:g,placement:y,overlayRef:P,disableAnimation:h,disableShadow:D,shouldCloseOnBlur:q,isDismissable:j,isKeyboardDismissDisabled:C,shouldCloseOnInteractOutside:w,getPopoverProps:M,isBordered:_,borderWeight:B,onClose:F,onEntered:S,onExited:E,isPositioned:N}=(0,p.usePopoverContext)(),R=(0,c.getTransformOrigin)(y),W=(0,r.useMemo)((()=>({transformOrigin:R,...b})),[R,b]),{modalProps:T}=(0,s.useModal)({isDisabled:!0}),{dialogProps:k}=(0,i.useDialog)({role:"dialog"},P),{overlayProps:I}=(0,s.useOverlay)({onClose:F,isOpen:g.isOpen,isDismissable:j&&g.isOpen,shouldCloseOnBlur:q,isKeyboardDismissDisabled:C,shouldCloseOnInteractOutside:w},P),V=(0,t.mergeProps)({isBordered:_,disableShadow:D,borderWeight:B},O),{isFocusVisible:A,focusProps:K}=(0,o.useFocusRing)(),U=(0,r.useMemo)((()=>({clearTime:h?0:300,enterTime:h?0:20,leaveTime:h?0:60,name:"nextui-popover-content",visible:g.isOpen,onEntered:S,onExited:E})),[h,g.isOpen]),z=(0,f.jsxs)(d.StyledPopoverContentContainer,{ref:(0,l.mergeRefs)(P,a),...M((0,t.mergeProps)(I,T,k,K,V),W),as:v,className:(0,u.default)("nextui-popover-content-container",x),disableAnimation:h,isFocusVisible:A,isPositioned:N,children:[(0,f.jsx)(s.DismissButton,{onDismiss:F}),(0,f.jsx)(d.StyledPopoverContent,{className:"nextui-popover-content",children:m}),(0,f.jsx)(s.DismissButton,{onDismiss:F})]});return(0,f.jsx)(f.Fragment,{children:(0,f.jsx)(o.FocusScope,{restoreFocus:!0,children:(0,f.jsx)(n.default,{...U,children:z})})})}));a.__DEV__&&(v.displayName="NextUI.PopoverContent"),v.toString=()=>".nextui-popover-content";var b=v;exports["default"]=b,module.exports=exports.default;

/***/ }),

/***/ 25952:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.usePopoverContext=exports.PopoverProvider=void 0;var e=__webpack_require__(19938);const[o,r]=(0,e.createContext)({name:"PopoverContext",errorMessage:"usePopoverContext: `context` is undefined. Seems you forgot to wrap all popover components within `<Popover />`"});exports.usePopoverContext=r,exports.PopoverProvider=o;

/***/ }),

/***/ 29617:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;var e=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=a(r);if(t&&t.has(e))return t.get(e);var o={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&Object.prototype.hasOwnProperty.call(e,u)){var i=n?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(o,u,i):o[u]=e[u]}o.default=e,t&&t.set(e,o);return o}(__webpack_require__(18038)),r=__webpack_require__(20662),t=__webpack_require__(77335),o=__webpack_require__(80345),n=__webpack_require__(72625),u=__webpack_require__(81595),i=__webpack_require__(25952),s=__webpack_require__(56786);function a(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(a=function(e){return e?t:r})(e)}const p=e.default.forwardRef(((u,a)=>{const{triggerRef:p,getTriggerProps:l}=(0,i.usePopoverContext)(),{children:f,...c}=u,d=(0,e.useMemo)((()=>"string"==typeof f?(0,s.jsx)(o.Text,{children:f}):e.Children.only(f)),[f]),{onPress:g,onKeyDown:P,onPressStart:y,...v}=(0,e.useMemo)((()=>l((0,t.mergeProps)(d.props,c),d.ref)),[l,d.props,c,d.ref]),{buttonProps:x}=(0,r.useButton)({onPress:g,onKeyDown:P,onPressStart:y,...v},p),[,m]=(0,n.pickChild)(u.children,o.Button),w=(0,e.useMemo)((()=>void 0!==(null==m?void 0:m[0])),[m]),M=(0,e.useMemo)((()=>({...v,onPress:g,onKeyDown:P,onPressStart:y})),[v,g,P,y]);return(0,e.cloneElement)(d,(0,t.mergeProps)(v,w?M:x))}));u.__DEV__&&(p.displayName="NextUI.PopoverTrigger"),p.toString=()=>".nextui-popover-trigger";var l=p;exports["default"]=l,module.exports=exports.default;

/***/ }),

/***/ 50816:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(18038)),t=__webpack_require__(27807),o=__webpack_require__(81595),i=__webpack_require__(54717),a=__webpack_require__(25952),u=__webpack_require__(56786);const s=r.default.forwardRef(((e,o)=>{const{children:s,...l}=e,p=(0,i.usePopover)({ref:o,...l}),[n,d]=r.default.Children.toArray(s),v=p.state.isOpen||!p.exited;return(0,u.jsxs)(a.PopoverProvider,{value:p,children:[n,v&&(0,u.jsx)(t.OverlayContainer,{children:d})]})}));o.__DEV__&&(s.displayName="NextUI.Popover"),s.toString=()=>".nextui-popover";var l=s;exports["default"]=l,module.exports=exports.default;

/***/ }),

/***/ 34276:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.appearanceOut=exports.appearanceIn=exports.StyledPopoverContentContainer=exports.StyledPopoverContent=void 0;var o=__webpack_require__(88194),e=__webpack_require__(74042);const i=(0,o.keyframes)({"0%":{opacity:0,transform:"translateZ(0)  scale(0.95)"},"60%":{opacity:.75,backfaceVisibility:"hidden",webkitFontSmoothing:"antialiased",transform:"translateZ(0) scale(1.05)"},"100%":{opacity:1,transform:"translateZ(0) scale(1)"}});exports.appearanceIn=i;const r=(0,o.keyframes)({"0%":{opacity:1,transform:"scale(1)"},"100%":{opacity:0,transform:"scale(0.5)"}});exports.appearanceOut=r;const t=(0,o.styled)("div",{$$popoverMinWidth:"$space$fit",$$popoverMinHeight:"$space$fit",$$popoverBorderRadius:"$radii$lg",$$popoverBackground:"$colors$backgroundContrast",$$popoverBoxShadow:"$shadows$md",$$popoverBorderColor:"$colors$border",boxShadow:"$$popoverBoxShadow",outline:"none",overflow:"hidden auto",bg:"$$popoverBackground",display:"inline-flex",flexDirection:"column",boxSizing:"border-box",minWidth:"$$popoverMinWidth",minHeight:"$$popoverMinHeight",maxWidth:"calc(100% - $$popoverMinWidth)",maxHeight:"calc(100% - $$popoverMinWidth)",borderRadius:"$$popoverBorderRadius",animationFillMode:"forwards",willChange:"transform, opacity","@motion":{transition:"none"},"&.nextui-popover-content-enter":{animationName:i,animationTimingFunction:"ease-out",animationDirection:"normal",animationDuration:"300ms",animationFillMode:"both"},"&.nextui-popover-content-leave":{animationName:r,animationTimingFunction:"ease-in",animationDuration:"60ms",animationFillMode:"both"},variants:{disableShadow:{true:{boxShadow:"none"}},isBordered:{true:{borderStyle:"solid",borderColor:"$$popoverBorderColor"}},borderWeight:{light:{bw:"$light",$$popoverBorderWeight:"$borderWeights$light"},normal:{bw:"$normal",$$popoverBorderWeight:"$borderWeights$normal"},bold:{bw:"$bold",$$popoverBorderWeight:"$borderWeights$bold"},extrabold:{bw:"$extrabold",$$popoverBorderWeight:"$borderWeights$extrabold"},black:{bw:"$black",$$popoverBorderWeight:"$borderWeights$black"}},isPositioned:{true:{visibility:"visible"},false:{visibility:"hidden"}},disableAnimation:{true:{transition:"none","&.nextui-popover-content-enter":{animation:"none"},"&.nextui-popover-content-leave":{animation:"none"}}}},defaultVariants:{isBordered:!1,borderWeight:"light"}},e.cssFocusVisible);exports.StyledPopoverContentContainer=t;const n=(0,o.styled)("div",{});exports.StyledPopoverContent=n;

/***/ }),

/***/ 54717:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.usePopover=function(a={}){const{ref:n,triggerRef:u,scrollRef:p,isOpen:d,defaultOpen:c,onOpenChange:g,isBordered:O,borderWeight:y,disableShadow:b,shouldFlip:f=!0,offset:m=12,placement:h="bottom",onClose:P,triggerType:v="dialog",isDismissable:C=!0,shouldCloseOnBlur:R=!1,isKeyboardDismissDisabled:k=!1,disableAnimation:q=!1,shouldCloseOnInteractOutside:D}=a,x=(0,e.useRef)(null),j=(0,e.useRef)(null),B=n||x,M=u||j,S=(0,l.useOverlayTriggerState)({isOpen:d,defaultOpen:c,onOpenChange:g}),[T,A]=(0,e.useState)(!S.isOpen),E=(0,e.useMemo)((()=>S.isOpen?"open":"closed"),[S.isOpen]),w=(0,e.useCallback)((()=>{null==P||P(),S.close()}),[S,P]),F=(0,e.useCallback)((()=>{A(!1)}),[]),I=(0,e.useCallback)((()=>{A(!0)}),[]),{triggerProps:K,overlayProps:W}=(0,r.useOverlayTrigger)({type:v},S,M),_=(0,e.useMemo)((()=>(0,i.getAriaPlacement)(h)),[h]),{overlayProps:H}=(0,r.useOverlayPosition)({isOpen:S.isOpen,targetRef:M,scrollRef:p,placement:_,overlayRef:B,shouldFlip:f,offset:m}),z=(0,e.useMemo)((()=>{var e;return!(null==(e=H.style)||!e.maxHeight)}),[H.style]),G=(0,e.useCallback)(((e={},r=null)=>({...null!=u&&u.current?(0,s.mergeProps)(K,e):(0,s.mergeProps)(e,K),ref:(0,t.mergeRefs)(M,r)})),[M,u,K]),J=(0,e.useCallback)(((e={},s={})=>{const r=H.style?Object.keys(H.style):[];let l={};r.forEach((e=>{const r=(0,o.isObject)(s)&&s[e];r&&(l={...l,[e]:r})}));const t=Object.keys(l).length>0?{...H,style:{...H.style,...l}}:H;return{css:s,...e,...W,...t,"data-state":E,"data-placement":h}}),[E,H,W,h]);return{state:S,exited:T,overlayRef:B,triggerRef:M,placement:h,disableShadow:b,disableAnimation:q,shouldCloseOnBlur:R,isDismissable:C,isBordered:O,borderWeight:y,isKeyboardDismissDisabled:k,shouldCloseOnInteractOutside:D,isOpen:S.isOpen,onClose:w,onExited:I,onEntered:F,triggerProps:K,overlayProps:W,positionProps:H,getTriggerProps:G,getPopoverProps:J,isPositioned:z}};var e=__webpack_require__(18038),s=__webpack_require__(77335),r=__webpack_require__(27807),l=__webpack_require__(56586),t=__webpack_require__(45728),o=__webpack_require__(36828),i=__webpack_require__(96803);

/***/ }),

/***/ 96803:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.getTransformOrigin=exports.getPopoverPlacementFromAxis=exports.getPopoverPlacement=exports.getAriaPlacement=void 0;exports.getAriaPlacement=t=>t?t.replace("-"," "):"bottom";exports.getPopoverPlacementFromAxis=t=>t?t.replace("-"," "):"bottom";exports.getPopoverPlacement=t=>t?t.replace(" ","-"):"bottom";exports.getTransformOrigin=t=>{if(!t)return"bottom";switch(t){case"bottom":default:return"top center";case"top":return"bottom center";case"left":return"right center";case"right":return"left center";case"bottom-left":return"top left";case"bottom-right":return"top right";case"top-left":return"bottom left";case"top-right":return"bottom right";case"left-top":return"right top";case"left-bottom":return"right bottom";case"right-top":return"left top";case"right-bottom":return"left bottom"}};

/***/ }),

/***/ 37598:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledProgressBar=exports.StyledProgress=void 0;var r=e(__webpack_require__(80776)),s=__webpack_require__(4587);exports.StyledProgress=s.StyledProgress,exports.StyledProgressBar=s.StyledProgressBar;var t=r.default;exports["default"]=t;

/***/ }),

/***/ 80776:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=l(r);if(t&&t.has(e))return t.get(e);var a={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if("default"!==s&&Object.prototype.hasOwnProperty.call(e,s)){var n=i?Object.getOwnPropertyDescriptor(e,s):null;n&&(n.get||n.set)?Object.defineProperty(a,s,n):a[s]=e[s]}a.default=e,t&&t.set(e,a);return a}(__webpack_require__(18038)),t=e(__webpack_require__(91863)),a=e(__webpack_require__(25457)),i=__webpack_require__(45036),s=e(__webpack_require__(62358)),n=__webpack_require__(81595),u=__webpack_require__(4587),o=__webpack_require__(56786);function l(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(l=function(e){return e?t:r})(e)}const d="nextui-progress",p=({value:e,max:a,min:n,striped:l,animated:p,shadow:c,indeterminated:f,css:m,...v})=>{const x=(0,r.useMemo)((()=>e>a?a:e<n?n:e),[e,n,a]),g=(0,r.useMemo)((()=>(0,i.valueToPercent)(x,n,a)),[x,n,a]);return(0,o.jsx)(u.StyledProgress,{"aria-label":"progress","aria-valuemax":a,"aria-valuemin":n,"aria-valuenow":x,css:{"nextui-progress-wrapper-enter":{opacity:0},".nextui-progress-wrapper-enter-active":{opacity:1,width:`${g}%`},...m},indeterminated:f,role:"progressbar",...v,children:(0,o.jsx)(t.default,{visible:!0,clearTime:300,enterTime:10,leaveTime:20,name:`${d}-wrapper`,children:(0,o.jsx)(u.StyledProgressBar,{animated:p,className:(0,s.default)(`${d}-bar`,{[`${d}-striped`]:l,[`${d}-indeterminated`]:f}),indeterminated:f,shadow:c,striped:l,...v})})})};n.__DEV__&&(p.displayName="NextUI.Progress"),p.toString=()=>".nextui-progress";const c=r.default.memo(p);var f=(0,a.default)(c,{striped:!1,animated:!0,shadow:!1,indeterminated:!1,value:0,min:0,max:100});exports["default"]=f,module.exports=exports.default;

/***/ }),

/***/ 4587:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledProgressBar=exports.StyledProgress=void 0;var r=__webpack_require__(88194);const o=(0,r.keyframes)({"0%":{left:"-40%"},"100%":{left:"100%"}}),s=(0,r.styled)("div",{margin:0,padding:0,width:"100%",position:"relative",overflow:"hidden",variants:{color:{default:{$$progressColor:"$colors$primary",$$progressShadowColor:"$colors$primaryShadow"},primary:{$$progressColor:"$colors$primary",$$progressShadowColor:"$colors$primaryShadow"},secondary:{$$progressColor:"$colors$secondary",$$progressShadowColor:"$colors$secondaryShadow"},success:{$$progressColor:"$colors$success",$$progressShadowColor:"$colors$successShadow"},warning:{$$progressColor:"$colors$warning",$$progressShadowColor:"$colors$warningShadow"},error:{$$progressColor:"$colors$error",$$progressShadowColor:"$colors$errorShadow"},gradient:{$$progressColor:"$colors$gradient",$$progressShadowColor:"$colors$primaryShadow"}},status:{default:{bg:"$accents2"},primary:{bg:"$primaryLight"},secondary:{bg:"$secondaryLight"},success:{bg:"$successLight"},warning:{bg:"$warningLight"},error:{bg:"$errorLight"}},size:{xs:{$$progressHeight:"$space$2",height:"$$progressHeight",br:"$$progressHeight"},sm:{$$progressHeight:"$space$4",height:"$$progressHeight",br:"$$progressHeight"},md:{$$progressHeight:"$space$8",height:"$$progressHeight",br:"$$progressHeight"},lg:{$$progressHeight:"$space$10",height:"$$progressHeight",br:"$$progressHeight"},xl:{$$progressHeight:"$space$11",height:"$$progressHeight",br:"$$progressHeight"}},indeterminated:{true:{overflow:"hidden"}},squared:{true:{br:"calc($$progressHeight * 0.25)"}}},defaultVariants:{color:"default",status:"default",size:"md"}});exports.StyledProgress=s;const e=(0,r.styled)("div",{margin:0,padding:0,width:0,opacity:0,height:"100%",minWidth:"inherit",bg:"$$progressColor",br:"inherit",transition:"width 0.5s cubic-bezier(0.4, 0, 0.2, 1)","@motion":{transition:"none"},variants:{animated:{false:{transition:"none"}},shadow:{true:{normalShadowVar:"$$progressShadowColor"}},striped:{true:{backgroundImage:"linear-gradient(45deg, rgba(0, 0, 0, 0.1) 25%, transparent 25%, transparent 50%, rgba(0, 0, 0, 0.1) 50%, rgba(0, 0, 0, 0.1) 75%, transparent 75%, transparent)",backgroundSize:"$space$lg $space$lg"}},indeterminated:{true:{position:"absolute",width:"0%",transitionProperty:"background-color, width, left, border-color,opacity, shadow, transform",transitionDuration:"300ms",willChange:"left",minWidth:"50%",animation:`1s ease 0s infinite normal none running ${o}`}}}});exports.StyledProgressBar=e;

/***/ }),

/***/ 96025:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledRadioText=exports.StyledRadioPoint=exports.StyledRadioLabel=exports.StyledRadioGroupContainer=exports.StyledRadioGroup=exports.StyledRadioDescription=exports.StyledRadioContainer=void 0;var o=e(__webpack_require__(51784)),t=e(__webpack_require__(58767)),d=__webpack_require__(84442);exports.StyledRadioLabel=d.StyledRadioLabel,exports.StyledRadioText=d.StyledRadioText,exports.StyledRadioPoint=d.StyledRadioPoint,exports.StyledRadioContainer=d.StyledRadioContainer,exports.StyledRadioDescription=d.StyledRadioDescription,exports.StyledRadioGroup=d.StyledRadioGroup,exports.StyledRadioGroupContainer=d.StyledRadioGroupContainer,o.default.Group=t.default;var r=o.default;exports["default"]=r;

/***/ }),

/***/ 33672:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.useRadioGroupContext=exports.RadioGroupProvider=void 0;var o=__webpack_require__(19938);const[e,t]=(0,o.createContext)({name:"RadioGroupContext",strict:!0,errorMessage:"useRadioGroupContext: `context` is undefined. Seems you forgot to wrap all checkbox components within `<Radio.Group />`"});exports.useRadioGroupContext=t,exports.RadioGroupProvider=e;

/***/ }),

/***/ 58767:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.RadioGroup=void 0;var r=e(__webpack_require__(18038)),o=e(__webpack_require__(62358)),i=__webpack_require__(73726),a=__webpack_require__(81595),s=__webpack_require__(82428),u=__webpack_require__(33672),t=__webpack_require__(84442),l=__webpack_require__(56786);const d=r.default.forwardRef(((e,r)=>{const{as:a,css:d,className:n,children:p,label:c,...x}=e,R=(0,s.useRadioGroup)({...x,label:c}),q=(0,i.useDOMRef)(r);return(0,l.jsxs)(t.StyledRadioGroup,{ref:q,as:a,className:(0,o.default)("nextui-radio-group",n),css:d,size:R.size,...R.radioGroupProps,children:[c&&(0,l.jsx)(t.StyledRadioGroupLabel,{className:"nextui-radio-group-label",...R.labelProps,children:c}),(0,l.jsx)(t.StyledRadioGroupContainer,{className:"nextui-radio-group-items",isRow:"horizontal"===R.orientation,role:"presentation",children:(0,l.jsx)(u.RadioGroupProvider,{value:R,children:p})})]})}));exports.RadioGroup=d,a.__DEV__&&(d.displayName="NextUI.RadioGroup"),d.toString=()=>".nextui-radio-group";var n=d;exports["default"]=n;

/***/ }),

/***/ 51784:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.Radio=void 0;var i=function(e,i){if(!i&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=c(i);if(r&&r.has(e))return r.get(e);var s={},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var t in e)if("default"!==t&&Object.prototype.hasOwnProperty.call(e,t)){var o=a?Object.getOwnPropertyDescriptor(e,t):null;o&&(o.get||o.set)?Object.defineProperty(s,t,o):s[t]=e[t]}s.default=e,r&&r.set(e,s);return s}(__webpack_require__(18038)),r=__webpack_require__(77335),s=__webpack_require__(94135),a=__webpack_require__(20198),t=e(__webpack_require__(62358)),o=__webpack_require__(81595),d=__webpack_require__(73726),u=__webpack_require__(87386),l=__webpack_require__(84442),n=__webpack_require__(56786);function c(e){if("function"!=typeof WeakMap)return null;var i=new WeakMap,r=new WeakMap;return(c=function(e){return e?r:i})(e)}const p=i.default.forwardRef(((e,o)=>{const{className:c,as:p,css:f,children:x,label:b,description:h,...v}=e,{size:y,color:q,inputRef:m,labelColor:R,isHovered:j,isSquared:P,isInvalid:k,isDisabled:D,autoFocus:N,disableAnimation:O,hoverProps:S,inputProps:_,isRequired:g}=(0,u.useRadio)({...v,children:null!=x?x:b}),w=(0,d.useFocusableRef)(o,m),{focusProps:F,isFocusVisible:M}=(0,s.useFocusRing)({autoFocus:N}),I=(0,i.useMemo)((()=>j?"is-hovered":D?"is-disabled":_.checked?"checked":"unchecked"),[D,_.checked,j]);return(0,n.jsxs)(l.StyledRadioLabel,{ref:w,...S,as:p,className:(0,t.default)("nextui-radio-label",`nextui-radio--${I}`,c),color:q,css:f,"data-state":I,disableAnimation:O,isChecked:_.checked,isDisabled:D,isHovered:j,isInvalid:k,isSquared:P,size:y,children:[(0,n.jsxs)(l.StyledRadioContainer,{className:"nextui-radio-container",children:[(0,n.jsx)(l.StyledRadioPoint,{className:"nextui-radio-point",isFocusVisible:M,...F,children:(0,n.jsx)(a.VisuallyHidden,{children:(0,n.jsx)("input",{ref:m,className:"nextui-radio-input",required:g,...(0,r.mergeProps)(_,F)})})}),(0,n.jsx)(l.StyledRadioText,{className:"nextui-radio-text",color:R,isDisabled:D,isInvalid:k,children:x})]}),h&&(0,n.jsx)(l.StyledRadioDescription,{className:"nextui-radio-description",isDisabled:D,isInvalid:k,children:h})]})}));exports.Radio=p,o.__DEV__&&(p.displayName="NextUI.Radio"),p.toString=()=>".nextui-radio";var f=p;exports["default"]=f;

/***/ }),

/***/ 84442:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledRadioText=exports.StyledRadioPoint=exports.StyledRadioLabel=exports.StyledRadioGroupLabel=exports.StyledRadioGroupContainer=exports.StyledRadioGroup=exports.StyledRadioDescription=exports.StyledRadioContainer=void 0;var o=__webpack_require__(88194),r=__webpack_require__(74042);const e=(0,o.styled)("span",{fontSize:"$$radioSize",us:"none",d:"inline-flex",ai:"center",variants:{color:{default:{color:"$text"},primary:{color:"$primary"},secondary:{color:"$secondary"},success:{color:"$success"},warning:{color:"$warning"},error:{color:"$error"}},isDisabled:{true:{color:"$accents5"}},isInvalid:{true:{color:"$error"}}}});exports.StyledRadioText=e;const i=(0,o.styled)("span",{size:"$$radioSize",br:"$$radioRadii",position:"relative",d:"inline-block",mr:"calc($$radioSize * 0.375)","&:after":{content:"",d:"block",position:"absolute",size:"$$radioSize",br:"$$radioRadii",boxSizing:"border-box",border:"2px solid $border"}},r.cssFocusVisible);exports.StyledRadioPoint=i;const a=(0,o.styled)("label",{d:"flex",w:"initial",ai:"flex-start",position:"relative",fd:"column",jc:"flex-start",cursor:"pointer","@motion":{[`& ${i}`]:{transition:"none","&:after":{transition:"none"}}},variants:{color:{default:{$$radioColor:"$colors$primary",$$radioColorHover:"$colors$primarySolidHover"},primary:{$$radioColor:"$colors$primary",$$radioColorHover:"$colors$primarySolidHover"},secondary:{$$radioColor:"$colors$secondary",$$radioColorHover:"$colors$secondarySolidHover"},success:{$$radioColor:"$colors$success",$$radioColorHover:"$colors$successSolidHover"},warning:{$$radioColor:"$colors$warning",$$radioColorHover:"$colors$warningSolidHover"},error:{$$radioColor:"$colors$error",$$radioColorHover:"$colors$errorSolidHover"}},size:{xs:{$$radioSize:"$space$7"},sm:{$$radioSize:"$space$8"},md:{$$radioSize:"$space$9"},lg:{$$radioSize:"$space$10"},xl:{$$radioSize:"$space$11"}},isHovered:{true:{}},isInvalid:{true:{$$radioColor:"$colors$error",$$radioColorHover:"$colors$errorSolidHover",[`& ${i}`]:{"&:after":{borderColor:"$colors$error"}}}},isDisabled:{true:{cursor:"not-allowed",$$radioColor:"$colors$accents4"}},isSquared:{true:{$$radioRadii:"$radii$squared"},false:{$$radioRadii:"$radii$rounded"}},isChecked:{true:{[`& ${i}`]:{"&:after":{border:"calc($$radioSize * 0.34) solid $$radioColor"}}}},disableAnimation:{true:{[`& ${i}`]:{transition:"none","&:after":{transition:"none"}}},false:{[`& ${i}`]:{transition:"$default","&:after":{transition:"$default"}}}}},defaultVariants:{size:"md",isSquared:!1,disableAnimation:!1},compoundVariants:[{isChecked:!0,isHovered:!0,css:{[`& ${i}`]:{"&:after":{border:"calc($$radioSize * 0.34) solid $$radioColorHover"}}}},{isChecked:!0,isDisabled:!0,isHovered:!0,css:{[`& ${i}`]:{"&:after":{border:"calc($$radioSize * 0.34) solid $$radioColor"}}}},{isChecked:!1,isDisabled:!1,isHovered:!0,css:{[`& ${i}`]:{bg:"$border"}}}]});exports.StyledRadioLabel=a;const s=(0,o.styled)("span",{color:"$accents7",fontSize:"calc($$radioSize * 0.85)",paddingLeft:"calc($$radioSize + $$radioSize * 0.375)",variants:{isInvalid:{true:{color:"$red500"}},isDisabled:{true:{color:"$accents5"}}}});exports.StyledRadioDescription=s;const $=(0,o.styled)("div",{w:"initial",position:"relative",d:"flex",fd:"row",ai:"center",jc:"flex-start"});exports.StyledRadioContainer=$;const d=(0,o.styled)("label",{d:"block",fontWeight:"$normal",fontSize:"calc($$checkboxSize * 0.9)",color:"$accents8",mb:"$3"});exports.StyledRadioGroupLabel=d;const l=(0,o.styled)("div",{border:0,margin:0,padding:0,display:"flex",fd:"column",variants:{size:{xs:{$$radioGroupGap:"$space$7"},sm:{$$radioGroupGap:"$space$8"},md:{$$radioGroupGap:"$space$9"},lg:{$$radioGroupGap:"$space$10"},xl:{$$radioGroupGap:"$space$11"}}}});exports.StyledRadioGroup=l;const t=(0,o.styled)("div",{display:"flex",flexDirection:"column",variants:{isRow:{true:{mt:0,flexDirection:"row",[`& ${a}:not(:last-child)`]:{mr:"$$radioSize"}},false:{mr:0,flexDirection:"column",[`& ${a}:not(:first-child)`]:{mt:"$$radioSize"}}}},defaultVariants:{isRow:!1}});exports.StyledRadioGroupContainer=t;

/***/ }),

/***/ 82428:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.useRadioGroup=void 0;var e=__webpack_require__(18038),o=__webpack_require__(4167),r=__webpack_require__(87642);exports.useRadioGroup=a=>{const{size:i="md",color:t="default",labelColor:u="default",orientation:s="vertical",isRequired:d,validationState:l,...p}=a,n=(0,e.useMemo)((()=>({...p,isRequired:d,orientation:s})),[p]),c=(0,o.useRadioGroupState)(n),{radioGroupProps:G,labelProps:R}=(0,r.useRadioGroup)(n,c);return{size:i,color:t,orientation:s,labelColor:u,isRequired:d,validationState:l,radioGroupState:c,radioGroupProps:G,labelProps:R}};

/***/ }),

/***/ 87386:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.useRadio=void 0;var e=__webpack_require__(18038),i=__webpack_require__(87642),o=__webpack_require__(34353),r=__webpack_require__(10084),a=__webpack_require__(81595),s=__webpack_require__(33672);exports.useRadio=u=>{var l,d,t;const n=(0,s.useRadioGroupContext)(),{size:v=(null!=(l=n.size)?l:"md"),color:c=(null!=(d=n.color)?d:"default"),labelColor:p=(null!=(t=n.labelColor)?t:"default"),autoFocus:R,isSquared:b=!1,isDisabled:q=!1,disableAnimation:m=!1,...f}=u;n&&a.__DEV__&&(void 0!==f.checked&&(0,r.warn)('Remove props "checked" if in the Radio.Group.',"Radio"),void 0===f.value&&(0,r.warn)('Props "value" must be defined if in the Radio.Group.',"Radio"));const h=(0,e.useRef)(null),{inputProps:_}=(0,i.useRadio)({...f,...n,isDisabled:q},n.radioGroupState,h),x=(0,e.useMemo)((()=>{var e;return null!=(e=_.disabled)&&e}),[_.disabled]),{hoverProps:D,isHovered:P}=(0,o.useHover)({isDisabled:x});return{size:v,color:c,inputRef:h,autoFocus:R,isDisabled:x,labelColor:p,isInvalid:(0,e.useMemo)((()=>"invalid"===n.validationState),[n.validationState]),isHovered:P,isSquared:b,isRequired:(0,e.useMemo)((()=>{var e;return null!=(e=n.isRequired)&&e}),[n.isRequired]),disableAnimation:m,inputProps:_,hoverProps:D}};

/***/ }),

/***/ 17235:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledRow=void 0;var r=e(__webpack_require__(29552)),t=__webpack_require__(18979);exports.StyledRow=t.StyledRow;var o=r.default;exports["default"]=o;

/***/ }),

/***/ 29552:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(18038)),t=e(__webpack_require__(25457)),a=e(__webpack_require__(18979)),l=__webpack_require__(56786);const s=({children:e,gap:r,justify:t,align:s,wrap:i,css:u,...o})=>(0,l.jsx)(a.default,{css:{flexWrap:i,$$rowGap:`calc(${r} * $space$lg)`,marginLeft:`calc(${r} * $space$lg / 2)`,marginRight:`calc(${r} * $space$lg / 2)`,justifyContent:t,alignItems:s,...u},...o,children:e});s.toString=()=>".nextui-row";const i=r.default.memo(s);var u=(0,t.default)(i,{gap:0,wrap:"nowrap",justify:"flex-start",align:"flex-start"});exports["default"]=u,module.exports=exports.default;

/***/ }),

/***/ 18979:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=exports.StyledRow=void 0;const e=(0,(__webpack_require__(88194).styled))("div",{display:"flex",position:"relative",boxSizing:"border-box",variants:{fluid:{true:{width:"100%"}}},defaultVariants:{fluid:!0}});exports.StyledRow=e;var t=e;exports["default"]=t;

/***/ }),

/***/ 76541:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledSnippetPre=exports.StyledSnippetCopyButtonIcon=exports.StyledSnippetCopyButton=void 0;var t=e(__webpack_require__(41671)),p=__webpack_require__(73324);exports.StyledSnippetPre=p.StyledSnippetPre,exports.StyledSnippetCopyButton=p.StyledSnippetCopyButton,exports.StyledSnippetCopyButtonIcon=p.StyledSnippetCopyButtonIcon;var o=t.default;exports["default"]=o;

/***/ }),

/***/ 88671:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=o(t);if(r&&r.has(e))return r.get(e);var i={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&Object.prototype.hasOwnProperty.call(e,u)){var l=n?Object.getOwnPropertyDescriptor(e,u):null;l&&(l.get||l.set)?Object.defineProperty(i,u,l):i[u]=e[u]}i.default=e,r&&r.set(e,i);return i}(__webpack_require__(18038)),r=e(__webpack_require__(25457)),i=__webpack_require__(73324),n=__webpack_require__(56786);function o(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(o=function(e){return e?r:t})(e)}const u=({size:e,fill:t,width:r,height:o,...u})=>(0,n.jsx)(i.StyledSnippetCopyButtonIcon,{height:e||o,viewBox:"0 0 24 24",width:e||r,xmlns:"http://www.w3.org/2000/svg",...u,children:(0,n.jsx)("path",{d:"M20 2H10c-1.103 0-2 .897-2 2v4H4c-1.103 0-2 .897-2 2v10c0 1.103.897 2 2 2h10c1.103 0 2-.897 2-2v-4h4c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zM4 20V10h10l.002 10H4zm16-6h-4v-4c0-1.103-.897-2-2-2h-4V4h10v10z",fill:t})});u.toString=()=>".nextui-snippet-copy-icon";const l=t.memo(u);var p=(0,r.default)(l,{width:18,height:18});exports["default"]=p,module.exports=exports.default;

/***/ }),

/***/ 41671:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=l(t);if(r&&r.has(e))return r.get(e);var o={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if("default"!==i&&Object.prototype.hasOwnProperty.call(e,i)){var p=n?Object.getOwnPropertyDescriptor(e,i):null;p&&(p.get||p.set)?Object.defineProperty(o,i,p):o[i]=e[i]}o.default=e,r&&r.set(e,o);return o}(__webpack_require__(18038)),r=e(__webpack_require__(52089)),o=e(__webpack_require__(25457)),n=e(__webpack_require__(12458)),i=__webpack_require__(81595),p=e(__webpack_require__(88671)),u=__webpack_require__(73324),s=__webpack_require__(56786);function l(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(l=function(e){return e?r:t})(e)}const a=({bordered:e,children:o,symbol:i,showTooltip:l,text:a,tooltipCopyText:c,tooltipCopiedText:d,tooltipColor:f,copy:y,...x})=>{const[m,b]=(0,t.useState)(!1),{copy:h}=(0,n.default)(),j=(0,t.useRef)(null),C=a&&Array.isArray(a),S=(0,t.useMemo)((()=>"prevent"!==y),[y]),v=(0,t.useMemo)((()=>C?(e=>e.reduce(((e,t)=>t?e?`${e}\n${t}`:t:e),""))(a):o?j.current?j.current.textContent:"":a),[j.current,o,a]),q=(0,t.useMemo)((()=>{const e=i.trim();return e?`${e} `:""}),[i]),w=()=>{v&&S&&(h(v),"slient"!==y&&b(!0))};return(0,s.jsxs)(u.StyledSnippet,{...x,children:[C?a.map(((e,t)=>(0,s.jsx)(u.StyledSnippetPre,{className:"nextui-snippet-pre",css:{"&:before":{content:q,us:"none"}},children:e},`${t}-${e}`))):(0,s.jsx)(u.StyledSnippetPre,{ref:j,className:"nextui-snippet-pre",css:{"&:before":{content:q,us:"none"}},children:o||a}),S&&"slient"!==y?(0,s.jsx)(r.default,{hideArrow:!0,rounded:!0,color:f,content:m?d:c,onVisibleChange:()=>{setTimeout((()=>{m&&b(!1)}),400)},children:(0,s.jsx)(u.StyledSnippetCopyButton,{className:"nextui-snippet-copy-button",onClick:w,children:(0,s.jsx)(p.default,{})})}):"prevent"!==y&&(0,s.jsx)(u.StyledSnippetCopyButton,{className:"nextui-snippet-copy-button",onClick:w,children:(0,s.jsx)(p.default,{})})]})};i.__DEV__&&(a.displayName="NextUI.Snippet"),a.toString=()=>".nextui-snippet";const c=t.default.memo(a);var d=(0,o.default)(c,{symbol:"$",showTooltip:!0,copy:"default",tooltipColor:"default",tooltipCopyText:"Copy",tooltipCopiedText:"Copied"});exports["default"]=d,module.exports=exports.default;

/***/ }),

/***/ 73324:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledSnippetPre=exports.StyledSnippetCopyButtonIcon=exports.StyledSnippetCopyButton=exports.StyledSnippet=void 0;var r=__webpack_require__(88194),o=__webpack_require__(74042);const e=(0,r.styled)("div",{display:"flex",position:"relative",width:"initial",maxWidth:"100%",padding:"calc($space$lg * 0.75) $space$lg",br:"$lg",bg:"$background",variants:{color:{default:{$$snippetBorderColor:"$border",$$snippetBgColor:"$background",color:"$text"},primary:{$$snippetBorderColor:"$border",$$snippetBgColor:"$primary",color:"$text"},success:{$$snippetBorderColor:"$success",$$snippetBgColor:"$background",color:"$success"},warning:{$$snippetBorderColor:"$warning",$$snippetBgColor:"$background",color:"$warning"},error:{$$snippetBorderColor:"$error",$$snippetBgColor:"$background",color:"$error"},secondary:{$$snippetBorderColor:"$secondary",$$snippetBgColor:"$background",color:"$secondary"},invert:{$$snippetBorderColor:"$foreground",$$snippetBgColor:"$foreground",color:"$background"}},borderWeight:{light:{$$borderWeight:"$light"},normal:{$$borderWeight:"$normal"},bold:{$$borderWeight:"$bold"},extrabold:{$$borderWeight:"$extrabold"},black:{$$borderWeight:"$black"}},bordered:{true:{border:"$$borderWeight solid $$snippetBorderColor"}},filled:{true:{backgroundColor:"$$snippetBgColor"}}},defaultVariants:{color:"default",borderWeight:"normal",filled:!1}});exports.StyledSnippet=e;const t=(0,r.styled)("pre",{margin:0,padding:0,border:"none",br:0,bgColor:"transparent",color:"inherit",fontSize:"$sm","*":{margin:0,padding:0,fontSize:"inherit",color:"inherit"},variants:{withCopyButton:{true:{width:"calc(100% - 2 * $lg)"},false:{width:"100%"}}}});exports.StyledSnippetPre=t;const n=(0,r.styled)("svg",{});exports.StyledSnippetCopyButtonIcon=n;const i=(0,r.styled)("button",{display:"inline-flex",jc:"center",border:"none",ai:"flex-start",bg:"transparent",width:"calc(2 * $space$lg)",br:"$xs",color:"inherit",transition:"opacity 0.2s ease 0s",cursor:"pointer",us:"none","@motion":{transition:"none"},"&:hover":{opacity:"0.7"},[`& ${n}`]:{path:{fill:"$accents6"}}},o.sharedFocus);exports.StyledSnippetCopyButton=i;

/***/ }),

/***/ 73441:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledSpacer=void 0;var r=e(__webpack_require__(81114)),t=__webpack_require__(74672);exports.StyledSpacer=t.StyledSpacer;var a=r.default;exports["default"]=a;

/***/ }),

/***/ 81114:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(18038)),t=e(__webpack_require__(25457)),i=__webpack_require__(72844),s=__webpack_require__(74672),a=__webpack_require__(56786);const u=({x:e,y:r,css:t,...u})=>{const n=(0,i.getMargin)(e),o=(0,i.getMargin)(r);return(0,a.jsx)(s.StyledSpacer,{"aria-hidden":"true",css:{marginLeft:`${n} !important`,marginTop:`${o} !important`,...t},...u})};u.toString=()=>".nextui-spacer";const n=r.default.memo(u);var o=(0,t.default)(n,{x:1,y:1});exports["default"]=o,module.exports=exports.default;

/***/ }),

/***/ 74672:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledSpacer=void 0;const e=(0,(__webpack_require__(88194).styled))("span",{size:"1px",variants:{inline:{true:{display:"inline-block"},false:{display:"block"}}},defaultVariants:{inline:!1}});exports.StyledSpacer=e;

/***/ }),

/***/ 39003:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var t=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledSwitchInput=exports.StyledSwitchContainer=exports.StyledSwitchCircle=exports.StyledSwitch=void 0;var e=t(__webpack_require__(90250)),r=__webpack_require__(81410);exports.StyledSwitchContainer=r.StyledSwitchContainer,exports.StyledSwitchInput=r.StyledSwitchInput,exports.StyledSwitchCircle=r.StyledSwitchCircle,exports.StyledSwitch=r.StyledSwitch;var i=e.default;exports["default"]=i;

/***/ }),

/***/ 90250:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=u(__webpack_require__(18038)),r=e(__webpack_require__(25457)),a=__webpack_require__(10084),n=u(__webpack_require__(60690)),i=e(__webpack_require__(62358)),d=__webpack_require__(81595),o=__webpack_require__(81410),s=__webpack_require__(56786);function c(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(c=function(e){return e?r:t})(e)}function u(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=c(t);if(r&&r.has(e))return r.get(e);var a={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if("default"!==i&&Object.prototype.hasOwnProperty.call(e,i)){var d=n?Object.getOwnPropertyDescriptor(e,i):null;d&&(d.get||d.set)?Object.defineProperty(a,i,d):a[i]=e[i]}return a.default=e,r&&r.set(e,a),a}const l="nextui-switch",f=({initialChecked:e,checked:r,disabled:c,onChange:u,squared:f,bordered:p,shadow:h,icon:b,iconOn:v,iconOff:w,animated:m,preventDefault:y,name:x,...k})=>{const[q,O]=(0,t.useState)(e);b&&d.__DEV__&&(v||w)&&(0,a.warn)('Remove props "icon" if iconOn or iconOff exists.',"Switch");const S=(0,t.useCallback)((e=>{if(c)return;const t={target:{checked:!q},stopPropagation:e.stopPropagation,preventDefault:e.preventDefault,nativeEvent:e};O(!q),u&&u(t)}),[c,q,u]),{bindings:g}=(0,n.default)((e=>{S(e)}),[n.KeyCode.Enter,n.KeyCode.Space],{disableGlobalEvent:!0,preventDefault:y}),j=(0,t.useMemo)((()=>{const e=b||v||w,t=Boolean(v),r=Boolean(w);return e?t&&q?v:r&&!q?w:e:null}),[q,b,v,w]);(0,t.useEffect)((()=>{void 0!==r&&O(r)}),[r]);const C=(0,t.useMemo)((()=>q?"checked":"unchecked"),[q]);return(0,s.jsxs)(o.StyledSwitchContainer,{animated:m,"data-state":C,disabled:c,...k,children:[(0,s.jsx)(o.StyledSwitchInput,{animated:m,bordered:p,checked:q,className:(0,i.default)(`${l}-input`),"data-state":C,disabled:c,tabIndex:-1,type:"checkbox",onChange:S,name:x}),(0,s.jsx)(o.StyledSwitch,{animated:m,"aria-checked":q,"aria-disabled":c,bordered:p,checked:q,className:(0,i.default)(l,`${l}--${C}`,{[`${l}-checked`]:q,[`${l}-disabled`]:c}),"data-state":C,disabled:c,role:"switch",shadow:h,squared:f,tabIndex:c?-1:0,...g,children:(0,s.jsx)(o.StyledSwitchCircle,{className:`${l}-circle`,children:j})})]})};f.toString=()=>".nextui-switch";const p=t.default.memo(f);var h=(0,r.default)(p,{disabled:!1,bordered:!1,shadow:!1,squared:!1,animated:!0,preventDefault:!0,initialChecked:!1});exports["default"]=h,module.exports=exports.default;

/***/ }),

/***/ 81410:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledSwitchInput=exports.StyledSwitchContainer=exports.StyledSwitchCircle=exports.StyledSwitch=void 0;var t=__webpack_require__(88194),i=__webpack_require__(74042);const $=(0,t.styled)("label",{WebkitTapHighlightColor:"transparent",d:"inline-block",verticalAlign:"center",whiteSpace:"nowrap",us:"none",transition:"$default",padding:"$1 0",position:"relative",cursor:"pointer","@motion":{transition:"none"},variants:{color:{default:{$$switchColor:"$colors$primary",$$switchColorShadow:"$colors$primaryShadow",$$switchColorHover:"$colors$primarySolidHover"},primary:{$$switchColor:"$colors$primary",$$switchColorShadow:"$colors$primaryShadow",$$switchColorHover:"$colors$primarySolidHover"},secondary:{$$switchColor:"$colors$secondary",$$switchColorShadow:"$colors$secondaryShadow",$$switchColorHover:"$colors$secondarySolidHover"},success:{$$switchColor:"$colors$success",$$switchColorShadow:"$colors$successShadow",$$switchColorHover:"$colors$successSolidHover"},warning:{$$switchColor:"$colors$warning",$$switchColorShadow:"$colors$warningShadow",$$switchColorHover:"$colors$warningSolidHover"},error:{$$switchColor:"$colors$error",$$switchColorShadow:"$colors$errorShadow",$$switchColorHover:"$colors$errorSolidHover"}},size:{xs:{$$switchWidth:"$space$12",$$switchHeight:"$space$9",width:" $$switchWidth",maxWidth:"$$switchWidth",height:"$$switchHeight"},sm:{$$switchWidth:"$space$14",$$switchHeight:"$space$10",width:"$$switchWidth",maxWidth:"$$switchWidth",height:"$$switchHeight"},md:{$$switchWidth:"$space$15",$$switchHeight:"$space$11",width:"$$switchWidth",maxWidth:"$$switchWidth",height:"$$switchHeight"},lg:{$$switchWidth:"$space$17",$$switchHeight:"$space$12",width:"$$switchWidth",maxWidth:"$$switchWidth",height:"$$switchHeight"},xl:{$$switchWidth:"$space$18",$$switchHeight:"$space$13",width:"$$switchWidth",maxWidth:"$$switchWidth",height:"$$switchHeight"}},borderWeight:{light:{$$switchBorderW:"$borderWeights$light"},normal:{$$switchBorderW:"$borderWeights$normal"},bold:{$$switchBorderW:"$borderWeights$bold"},extrabold:{$$switchBorderW:"$borderWeights$extrabold"},black:{$$switchBorderW:"$borderWeights$black"}},disabled:{true:{cursor:"not-allowed"}},animated:{false:{transition:"none"}}},defaultVariants:{color:"default",size:"md",borderWeight:"normal"}});exports.StyledSwitchContainer=$;const r=(0,t.styled)("span",{position:"absolute",display:"flex",size:"calc($$switchHeight * 0.7)",jc:"center",ai:"center",top:"calc(50% - $$switchHeight * 0.35)",left:"0",transition:"transform 0.25s ease, width 0.2s ease",bg:"$background",br:"$pill","& svg":{bg:"transparent",size:"calc($$switchHeight * 0.44)"},"@motion":{transition:"none"}});exports.StyledSwitchCircle=r;const o=(0,t.styled)("div",{opacity:1,width:"$$switchWidth",height:"$$switchHeight",transition:"$default",position:"relative",overflow:"hidden",padding:0,br:"$pill",bg:"$accents2","@motion":{transition:"none"},variants:{checked:{true:{bg:"$$switchColor","&:hover:not(&:active)":{bg:"$$switchColorHover"}}},bordered:{true:{bg:"transparent",border:"$$switchBorderW solid $border","&:hover":{borderColor:"$$switchColor"},[`& ${r}`]:{bg:"$accents2"}}},squared:{true:{br:"2px",[`& ${r}`]:{br:"2px"}}},shadow:{true:{}},disabled:{true:{borderColor:"$accents2",bg:"$accents2",[`& ${r}`]:{bg:"$accents4"}}},animated:{true:{"&:active":{[`& ${r}`]:{width:"calc($$switchHeight * 0.7 + ($$switchWidth / 10))"}}},false:{transition:"none",[`& ${r}`]:{transition:"none"}}}},compoundVariants:[{checked:!0,disabled:!0,css:{bg:"$accents3",[`& ${r}`]:{bg:"$accents0"},"&:hover:not(&:active)":{bg:"$accents4"}}},{shadow:!0,checked:!0,css:{normalShadowVar:"$$switchColorShadow"}},{checked:!0,bordered:!0,css:{bg:"$$switchColor",border:"$$switchBorderW solid transparent","&:hover:not(&:active)":{borderColor:"transparent"},[`& ${r}`]:{bg:"$background"}}}]},i.sharedFocus);exports.StyledSwitch=o;const e=(0,t.styled)("input",{[`& + ${o} > ${r}`]:{transform:"translateX(calc($$switchWidth / 15))"},[`&:checked + ${o} > ${r}`]:{transform:"translateX(calc($$switchWidth - $$switchWidth / 15 - $$switchHeight * 0.7))"},variants:{animated:{true:{[`& + ${o}:active > ${r}`]:{transform:"translateX(calc($$switchWidth / 7.5))"},[`&:checked + ${o}:active > ${r}`]:{transform:"translateX(calc($$switchWidth - $$switchWidth / 7.5 - $$switchWidth / 10 - $$switchHeight * 0.7))"}}},bordered:{true:{[`& + ${o} > ${r}`]:{transform:"translateX(calc($$switchWidth / 15 - $$switchBorderW / 2))"},[`&:checked + ${o} > ${r}`]:{transform:"translateX(calc($$switchWidth - $$switchWidth / 15 - $$switchBorderW * 1.5 - $$switchHeight * 0.7))"}}}},compoundVariants:[{animated:!0,bordered:!0,css:{[`& + ${o}:active > ${r}`]:{transform:"translateX(calc($$switchWidth / 7.5 - $$switchBorderW / 2))"},[`&:checked + ${o}:active > ${r}`]:{transform:"translateX(calc($$switchWidth - $$switchWidth / 7.5 - $$switchWidth / 10 - $$switchBorderW * 1.5 - $$switchHeight * 0.7))"}}}]},i.sharedVisuallyHidden);exports.StyledSwitchInput=e;

/***/ }),

/***/ 33718:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports.TableRow=exports.TableHeader=exports.TableColumn=exports.TableCell=exports.TableBody=void 0;var r=e(__webpack_require__(53591));exports.TableBody=r.default;var l=e(__webpack_require__(84384));exports.TableCell=l.default;var a=e(__webpack_require__(30462));exports.TableColumn=a.default;var t=e(__webpack_require__(3622));exports.TableHeader=t.default;var o=e(__webpack_require__(67135));exports.TableRow=o.default;

/***/ }),

/***/ 53591:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;var e=(__webpack_require__(96886).TableBody);exports["default"]=e,module.exports=exports.default;

/***/ }),

/***/ 84384:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;var e=(__webpack_require__(96886).Cell);exports["default"]=e,module.exports=exports.default;

/***/ }),

/***/ 30462:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;var e=(__webpack_require__(96886).Column);exports["default"]=e,module.exports=exports.default;

/***/ }),

/***/ 3622:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;var e=(__webpack_require__(96886).TableHeader);exports["default"]=e,module.exports=exports.default;

/***/ }),

/***/ 67135:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;var e=(__webpack_require__(96886).Row);exports["default"]=e,module.exports=exports.default;

/***/ }),

/***/ 71698:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledTableRow=exports.StyledTableHeaderCell=exports.StyledTableCell=exports.StyledTable=void 0;var l=e(__webpack_require__(2259)),a=e(__webpack_require__(45253)),t=__webpack_require__(33718),r=__webpack_require__(85664);exports.StyledTable=r.StyledTable,exports.StyledTableRow=r.StyledTableRow,exports.StyledTableCell=r.StyledTableCell,exports.StyledTableHeaderCell=r.StyledTableHeaderCell,l.default.Cell=t.TableCell,l.default.Column=t.TableColumn,l.default.Header=t.TableHeader,l.default.Row=t.TableRow,l.default.Body=t.TableBody,l.default.Pagination=a.default;var d=l.default;exports["default"]=d;

/***/ }),

/***/ 93302:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var l=b(t);if(l&&l.has(e))return l.get(e);var r={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in e)if("default"!==n&&Object.prototype.hasOwnProperty.call(e,n)){var a=o?Object.getOwnPropertyDescriptor(e,n):null;a&&(a.get||a.set)?Object.defineProperty(r,n,a):r[n]=e[n]}r.default=e,l&&l.set(e,r);return r}(__webpack_require__(18038)),l=__webpack_require__(77335),r=__webpack_require__(80345),o=e(__webpack_require__(62358)),n=__webpack_require__(85664),a=e(__webpack_require__(31065)),i=e(__webpack_require__(12739)),u=e(__webpack_require__(35627)),s=e(__webpack_require__(17619)),d=__webpack_require__(25193),c=__webpack_require__(97026),p=__webpack_require__(56786);function b(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,l=new WeakMap;return(b=function(e){return e?l:t})(e)}const f=({children:e,collection:b,state:f,animated:y,color:h,hasPagination:x,hideLoading:g,isStatic:v,...m})=>{var j,S,q,w,M,P;const{currentPage:C,rowsPerPage:N,collection:O,setCollection:k}=(0,d.useTableContext)(),T=(0,t.useMemo)((()=>(0,c.isInfinityScroll)(b)),[b.body.props]);t.default.useEffect((()=>{b!==O&&(null==k||k(b))}),[b,O]);const B="loading"===(null==(j=b.body)||null==(S=j.props)?void 0:S.loadingState)||"loadingMore"===(null==(q=b.body)||null==(w=q.props)?void 0:w.loadingState),L=(0,t.useMemo)((()=>{const e=[...b.body.childNodes];return x?null==e?void 0:e.slice((C-1)*N,C*N):e}),[x,b,C,N]),E=(0,t.useMemo)((()=>{const e=L.length;return e>=N&&!T?null:(0,p.jsx)("tr",{"aria-hidden":"true",className:"nextui-table-hidden-row",role:"row",children:(0,p.jsx)(n.StyledBaseTableCell,{"aria-hidden":"true",colSpan:b.columnCount,css:{height:"var(--nextui--tableBodyEmptySpaceHeight)"},style:(0,l.mergeProps)({"--nextui--tableBodyEmptySpaceHeight":T?"var(--nextui-space-10)":`calc(${N-e} * var(--nextui-space-15))`},(null==m?void 0:m.style)||{})})})}),[b.columnCount,L,N,T]);return(0,p.jsxs)(a.default,{as:"tbody",className:(0,o.default)("nextui-table-body",m.className),css:{position:"relative",...m.css,...null==(M=b.body)||null==(P=M.props)?void 0:P.css},isInfinityScroll:T,onScroll:e=>{if(!T)return;const t=e.target;var l,r;t.scrollHeight-(t.scrollTop+40)<=t.clientHeight&&!B&&(null==(l=b.body)||null==(r=l.props)||null==r.onLoadMore||r.onLoadMore())},...m,children:[e,null==L?void 0:L.map((e=>e.hasChildNodes?(0,p.jsx)(i.default,{"aria-hidden":"false",item:e,state:f,children:[...e.childNodes].map((e=>{var t;return null!=e&&null!=(t=e.props)&&t.isSelectionCell?(0,p.jsx)(s.default,{animated:y,cell:e,color:h,state:f},null==e?void 0:e.key):(0,p.jsx)(u.default,{cell:e,isStatic:v,state:f},null==e?void 0:e.key)}))},null==e?void 0:e.key):null)),!g&&B&&(0,p.jsx)(n.StyledTableLoadingRow,{"aria-hidden":"true",className:"nextui-table-hidden-row",isAbsolute:!T,isAtEnd:L.length>0,role:"row",children:(0,p.jsx)(n.StyledBaseTableCell,{"aria-hidden":"true",colSpan:b.columnCount,children:(0,p.jsx)(r.Loading,{color:h})})}),E]})};f.displayName="NextUI.TableBody",f.toString=()=>".nextui-table-body";var y=f;exports["default"]=y,module.exports=exports.default;

/***/ }),

/***/ 35627:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(18038)),s=__webpack_require__(46461),t=__webpack_require__(94135),l=__webpack_require__(77335),a=e(__webpack_require__(62358)),i=__webpack_require__(73726),o=__webpack_require__(85664),u=__webpack_require__(56786);const c=r.default.forwardRef((({cell:e,state:r,isStatic:c,...n},d)=>{const p=(0,i.useDOMRef)(d),{gridCellProps:f}=(0,s.useTableCell)({node:e},r,p),{isFocusVisible:b,focusProps:x}=(0,t.useFocusRing)(),q=c?{...f,onMouseDown:e=>e.stopPropagation(),onPointerDown:e=>e.stopPropagation()}:f;return(0,u.jsx)(o.StyledTableCell,{ref:p,className:(0,a.default)("nextui-table-cell",n.className),css:e.props.css,isFocusVisible:b,isStatic:c,...(0,l.mergeProps)(q,x,n),children:e.rendered})}));c.displayName="NextUI.TableCell",c.toString=()=>".nextui-table-cell";var n=c;exports["default"]=n,module.exports=exports.default;

/***/ }),

/***/ 17619:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=n(r);if(t&&t.has(e))return t.get(e);var l={},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&Object.prototype.hasOwnProperty.call(e,u)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(l,u,i):l[u]=e[u]}l.default=e,t&&t.set(e,l);return l}(__webpack_require__(18038)),t=__webpack_require__(46461),l=__webpack_require__(94135),a=__webpack_require__(77335),u=e(__webpack_require__(32140)),i=e(__webpack_require__(62358)),o=__webpack_require__(85664),s=__webpack_require__(56786);function n(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(n=function(e){return e?t:r})(e)}const c=r.default.forwardRef((({cell:e,state:n,color:c,animated:f,...p},d)=>{const b=(0,r.useRef)(null);(0,r.useImperativeHandle)(d,(()=>null==b?void 0:b.current));const{gridCellProps:x}=(0,t.useTableCell)({node:e},n,b),{checkboxProps:y}=(0,t.useTableSelectionCheckbox)({key:(null==e?void 0:e.parentKey)||e.key},n),{isFocusVisible:v,focusProps:h}=(0,l.useFocusRing)();return(0,s.jsx)(o.StyledTableCell,{ref:b,className:(0,i.default)("nextui-table-checkbox-cell",p.className),isFocusVisible:v,...(0,a.mergeProps)(x,h,p),children:(0,s.jsx)(u.default,{...y,color:c,css:{display:"inherit"},disableAnimation:!f})})}));c.displayName="NextUI.TableCheckboxCell",c.toString=()=>".nextui-table-checkbox-cell";var f=c;exports["default"]=f,module.exports=exports.default;

/***/ }),

/***/ 51778:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=d(__webpack_require__(18038)),t=__webpack_require__(46461),a=__webpack_require__(94135),l=__webpack_require__(77335),o=__webpack_require__(20198),u=e(__webpack_require__(62358)),i=d(__webpack_require__(64804)),n=__webpack_require__(85664),s=__webpack_require__(56786);function c(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(c=function(e){return e?t:r})(e)}function d(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=c(r);if(t&&t.has(e))return t.get(e);var a={},l=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in e)if("default"!==o&&Object.prototype.hasOwnProperty.call(e,o)){var u=l?Object.getOwnPropertyDescriptor(e,o):null;u&&(u.get||u.set)?Object.defineProperty(a,o,u):a[o]=e[o]}return a.default=e,t&&t.set(e,a),a}const p=r.default.forwardRef((({column:e,state:c,...d},p)=>{var f,b;const m=(0,r.useRef)(null);(0,r.useImperativeHandle)(p,(()=>null==m?void 0:m.current));const{columnHeaderProps:v}=(0,t.useTableColumnHeader)({node:e},c,m),{isFocusVisible:y,focusProps:x}=(0,a.useFocusRing)(),{hideHeader:q,...g}=e.props;return(0,s.jsxs)(n.StyledTableColumnHeader,{ref:m,className:(0,u.default)("nextui-table-column-header",d.className),colSpan:e.colspan,isFocusVisible:y,...(0,l.mergeProps)(d,v,x,g),children:[q?(0,s.jsx)(o.VisuallyHidden,{children:e.rendered}):e.rendered,g.allowsSorting&&(0,s.jsx)(i.default,{ascending:"ascending"===(null==(f=c.sortDescriptor)?void 0:f.direction),css:{position:"absolute",m:"0 $2",bottom:`calc(50% - ${i.ICON_SIZE/2}px)`},visible:(null==(b=c.sortDescriptor)?void 0:b.column)===e.key})]})}));p.displayName="NextUI.TableColumnHeader",p.toString=()=>".nextui-table-column-header";var f=p;exports["default"]=f,module.exports=exports.default;

/***/ }),

/***/ 25193:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports.useTableContext=exports["default"]=exports.TableContext=void 0;var t=e(__webpack_require__(18038)),r=__webpack_require__(56786);const o={footerAlign:"end",rowsPerPage:0,currentPage:1,animated:!0},a=t.default.createContext(o);exports.TableContext=a;exports.useTableContext=()=>t.default.useContext(a);var l={Provider:({children:e,defaultValues:l})=>{const[u,n]=t.default.useState((null==l?void 0:l.footerAlign)||o.footerAlign),[s,i]=t.default.useState(void 0===(null==l?void 0:l.animated)?o.animated:null==l?void 0:l.animated),[d,P]=t.default.useState(null==l?void 0:l.collection),[c,f]=t.default.useState(void 0===(null==l?void 0:l.rowsPerPage)?o.rowsPerPage:null==l?void 0:l.rowsPerPage),[v,g]=t.default.useState(o.currentPage),[x,m]=t.default.useState(null==l?void 0:l.color),C=t.default.useMemo((()=>({animated:s,footerAlign:u,collection:d,rowsPerPage:c,currentPage:v,color:x,setFooterAlign:n,setCollection:P,setAnimated:i,setRowsPerPage:f,setColor:m,setCurrentPage:g})),[s,x,d,u,c,v]);return(0,r.jsx)(a.Provider,{value:C,children:e})},Consumer:a.Consumer};exports["default"]=l;

/***/ }),

/***/ 17736:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=l(t);if(r&&r.has(e))return r.get(e);var o={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if("default"!==a&&Object.prototype.hasOwnProperty.call(e,a)){var u=n?Object.getOwnPropertyDescriptor(e,a):null;u&&(u.get||u.set)?Object.defineProperty(o,a,u):o[a]=e[a]}o.default=e,r&&r.set(e,o);return o}(__webpack_require__(18038)),r=e(__webpack_require__(62358)),o=__webpack_require__(25193),n=__webpack_require__(85664),a=__webpack_require__(56786);function l(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(l=function(e){return e?r:t})(e)}const u=t.default.forwardRef((({children:e,...l},u)=>{const i=(0,t.useRef)(null);(0,t.useImperativeHandle)(u,(()=>null==i?void 0:i.current));const{footerAlign:f}=(0,o.useTableContext)();return(0,a.jsx)(n.StyledTableFooter,{ref:i,align:l.align||f,className:(0,r.default)("nextui-table-footer",l.className),role:"rowgroup",...l,children:e})}));u.displayName="NextUI.TableFooter",u.toString=()=>".nextui-table-footer";var i=u;exports["default"]=i,module.exports=exports.default;

/***/ }),

/***/ 28727:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=l(r);if(t&&t.has(e))return t.get(e);var a={},u=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in e)if("default"!==n&&Object.prototype.hasOwnProperty.call(e,n)){var o=u?Object.getOwnPropertyDescriptor(e,n):null;o&&(o.get||o.set)?Object.defineProperty(a,n,o):a[n]=e[n]}a.default=e,t&&t.set(e,a);return a}(__webpack_require__(18038)),t=__webpack_require__(46461),a=e(__webpack_require__(62358)),u=__webpack_require__(85664),n=__webpack_require__(56786);function l(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(l=function(e){return e?t:r})(e)}const o=r.default.forwardRef((({children:e,item:l,state:o,...i},s)=>{const f=(0,r.useRef)(null);(0,r.useImperativeHandle)(s,(()=>null==f?void 0:f.current));const{rowProps:d}=(0,t.useTableHeaderRow)({node:l},o,f);return(0,n.jsx)(u.StyledTableHeaderRow,{ref:f,className:(0,a.default)("nextui-table-header-row",i.className),...i,...d,children:e})}));o.displayName="NextUI.TableHeaderRow",o.toString=()=>".nextui-table-header-row";var i=o;exports["default"]=i,module.exports=exports.default;

/***/ }),

/***/ 45253:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=l(t);if(r&&r.has(e))return r.get(e);var n={},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in e)if("default"!==o&&Object.prototype.hasOwnProperty.call(e,o)){var u=a?Object.getOwnPropertyDescriptor(e,o):null;u&&(u.get||u.set)?Object.defineProperty(n,o,u):n[o]=e[o]}n.default=e,r&&r.set(e,n);return n}(__webpack_require__(18038)),r=__webpack_require__(80345),n=e(__webpack_require__(62358)),a=__webpack_require__(25193),o=__webpack_require__(56786);function l(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(l=function(e){return e?r:t})(e)}const u=({align:e,rowsPerPage:l,onPageChange:u,...i})=>{const{color:s,animated:c,collection:f,footerAlign:p,rowsPerPage:d,setFooterAlign:g,setRowsPerPage:b,setCurrentPage:P}=(0,a.useTableContext)();t.default.useEffect((()=>{e&&e!==p&&(null==g||g(e))}),[e,p]),t.default.useEffect((()=>{l&&l!==d&&(null==b||b(l))}),[d,l]);const x=(0,t.useMemo)((()=>{var e;const t=null!=f&&f.body?[...null==f||null==(e=f.body)?void 0:e.childNodes].length:0;return d>0?Math.ceil(t/d):1}),[f,d]);return(0,o.jsx)(r.Pagination,{animated:c,className:(0,n.default)("nextui-table-pagination",i.className),color:i.color||s,total:x,onChange:e=>{null==P||P(e),null==u||u(e)},...i})};u.displayName="NextUI.TablePagination",u.toString=()=>".nextui-table-pagination";var i=u;exports["default"]=i,module.exports=exports.default;

/***/ }),

/***/ 31065:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;e(__webpack_require__(18038));var r=__webpack_require__(46461),t=e(__webpack_require__(25457)),u=e(__webpack_require__(62358)),a=__webpack_require__(85664),l=__webpack_require__(56786);var s=(0,t.default)((({children:e,...t})=>{const{rowGroupProps:s}=(0,r.useTableRowGroup)();return(0,l.jsx)(a.StyledTableRowGroup,{className:(0,u.default)("nextui-table-row-group",t.className),...t,...s,children:e})}),{as:"thead"});exports["default"]=s,module.exports=exports.default;

/***/ }),

/***/ 12739:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=o(r);if(t&&t.has(e))return t.get(e);var a={},s=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if("default"!==i&&Object.prototype.hasOwnProperty.call(e,i)){var u=s?Object.getOwnPropertyDescriptor(e,i):null;u&&(u.get||u.set)?Object.defineProperty(a,i,u):a[i]=e[i]}a.default=e,t&&t.set(e,a);return a}(__webpack_require__(18038)),t=__webpack_require__(46461),a=__webpack_require__(94135),s=__webpack_require__(77335),i=e(__webpack_require__(62358)),u=__webpack_require__(85664),l=__webpack_require__(56786);function o(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(o=function(e){return e?t:r})(e)}const n=r.default.forwardRef((({children:e,item:o,state:n,...c},d)=>{const f=(0,r.useRef)(null);(0,r.useImperativeHandle)(d,(()=>null==f?void 0:f.current));const{rowProps:p}=(0,t.useTableRow)({node:o},n,f),{isFocusVisible:b,focusProps:w}=(0,a.useFocusRing)(),y=n.disabledKeys.has(o.key);return(0,l.jsx)(u.StyledTableRow,{ref:f,className:(0,i.default)("nextui-table-row",{"nextui-table-row--selected":p["aria-selected"],"nextui-table-row--disabled":y},c.className),css:o.props.css,isDisabled:y,isFocusVisible:b,isSelected:!!p["aria-selected"],...(0,s.mergeProps)(p,w,c),children:e})}));n.displayName="NextUI.TableRow",n.toString=()=>".nextui-table-row";var c=n;exports["default"]=c,module.exports=exports.default;

/***/ }),

/***/ 92606:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=n(r);if(t&&t.has(e))return t.get(e);var l={},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in e)if("default"!==o&&Object.prototype.hasOwnProperty.call(e,o)){var i=a?Object.getOwnPropertyDescriptor(e,o):null;i&&(i.get||i.set)?Object.defineProperty(l,o,i):l[o]=e[o]}l.default=e,t&&t.set(e,l);return l}(__webpack_require__(18038)),t=__webpack_require__(46461),l=__webpack_require__(20198),a=__webpack_require__(94135),o=__webpack_require__(77335),i=e(__webpack_require__(32140)),u=e(__webpack_require__(62358)),s=__webpack_require__(85664),c=__webpack_require__(56786);function n(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(n=function(e){return e?t:r})(e)}const d=r.default.forwardRef((({column:e,state:n,color:d,animated:f,...p},b)=>{const x=(0,r.useRef)(null);(0,r.useImperativeHandle)(b,(()=>null==x?void 0:x.current));const y="single"===n.selectionManager.selectionMode,{columnHeaderProps:h}=(0,t.useTableColumnHeader)({node:e},n,x),{checkboxProps:m}=(0,t.useTableSelectAllCheckbox)(n),{isFocusVisible:v,focusProps:q}=(0,a.useFocusRing)();return(0,c.jsx)(s.StyledTableHeaderCell,{ref:x,className:(0,u.default)("nextui-table-select-all-checkbox",p.className),isFocusVisible:v,...(0,o.mergeProps)(h,q,p),children:y?(0,c.jsx)(l.VisuallyHidden,{children:m["aria-label"]}):(0,c.jsx)(i.default,{...m,color:d,css:{display:"inherit",$$checkboxBorderColor:"$colors$accents3"},disableAnimation:!f})})}));d.displayName="NextUI.TableSelectAllCheckbox",d.toString=()=>".nextui-table-select-all-checkbox";var f=d;exports["default"]=f,module.exports=exports.default;

/***/ }),

/***/ 64804:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.ICON_SIZE=void 0;e(__webpack_require__(18038));var t=__webpack_require__(88194),r=__webpack_require__(56786);const i=(0,t.styled)("svg",{opacity:0,transition:"$default",path:{fill:"$$tableRowTextColor"},variants:{visible:{true:{opacity:1}},ascending:{true:{transform:"rotate(180deg)"}}}});exports.ICON_SIZE=22;var a=e=>(0,r.jsx)(i,{"aria-hidden":"true",className:"nextui-table-sort-icon",fill:"none",focusable:"false",height:22,role:"presentation",viewBox:"0 0 24 24",width:22,xmlns:"http://www.w3.org/2000/svg",...e,children:(0,r.jsx)("path",{d:"M12 2C6.49 2 2 6.49 2 12C2 17.51 6.49 22 12 22C17.51 22 22 17.51 22 12C22 6.49 17.51 2 12 2ZM16.06 11.27L12.53 14.8C12.38 14.95 12.19 15.02 12 15.02C11.81 15.02 11.62 14.95 11.47 14.8L7.94 11.27C7.65 10.98 7.65 10.5 7.94 10.21C8.23 9.92 8.71 9.92 9 10.21L12 13.21L15 10.21C15.29 9.92 15.77 9.92 16.06 10.21C16.35 10.5 16.35 10.97 16.06 11.27Z"})});exports["default"]=a;

/***/ }),

/***/ 2259:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=y(t);if(r&&r.has(e))return r.get(e);var a={},l=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if("default"!==i&&Object.prototype.hasOwnProperty.call(e,i)){var o=l?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(a,i,o):a[i]=e[i]}a.default=e,r&&r.set(e,a);return a}(__webpack_require__(18038)),r=__webpack_require__(46461),a=__webpack_require__(96886),l=__webpack_require__(77335),i=__webpack_require__(80345),o=__webpack_require__(72625),n=e(__webpack_require__(25457)),s=e(__webpack_require__(62358)),u=__webpack_require__(73726),d=e(__webpack_require__(31065)),c=e(__webpack_require__(51778)),h=e(__webpack_require__(28727)),f=e(__webpack_require__(92606)),b=e(__webpack_require__(45253)),p=e(__webpack_require__(17736)),x=e(__webpack_require__(93302)),m=__webpack_require__(85664),g=e(__webpack_require__(25193)),q=__webpack_require__(97026),w=__webpack_require__(56786);function y(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(y=function(e){return e?r:t})(e)}const j=t.default.forwardRef(((e,n)=>{const{css:y,selectionMode:j,selectionBehavior:v,hideLoading:P,children:S,shadow:k,color:M,animated:C,borderWeight:O,bordered:N,hoverable:T,sticked:W,containerCss:D,className:R,..._}=e,[I,L]=(0,o.pickSingleChild)(S,b.default),{hasPagination:B,rowsPerPage:F}=(0,q.hasPaginationChild)(S,b.default),U=(0,a.useTableState)({...e,children:I,showSelectionCheckboxes:void 0!==e.showSelectionCheckboxes?e.showSelectionCheckboxes:"multiple"===j&&"replace"!==v}),V=(0,u.useDOMRef)(n),{collection:z}=U,{gridProps:A}=(0,r.useTable)(e,U,V),E=t.default.useMemo((()=>({collection:z,color:M,animated:C,rowsPerPage:F})),[z,C,M,F]),G=(0,t.useMemo)((()=>!("none"===j&&!T)),[j,T]);return(0,w.jsx)(g.default.Provider,{defaultValues:E,children:(0,w.jsx)(m.StyledTableContainer,{borderWeight:O,bordered:N,className:"nextui-table-container",css:D,shadow:k,children:(0,w.jsxs)(m.StyledTable,{ref:V,animated:C,className:(0,s.default)("nextui-table",R),color:M,css:y,hasPagination:B,hoverable:G,isMultiple:"multiple"===j,shadow:k,...(0,l.mergeProps)(A,_),children:[(0,w.jsxs)(d.default,{as:"thead",isFixed:(0,q.isInfinityScroll)(z),children:[z.headerRows.map((e=>(0,w.jsx)(h.default,{item:e,state:U,children:[...e.childNodes].map((e=>{var t;return null!=e&&null!=(t=e.props)&&t.isSelectionCell?(0,w.jsx)(f.default,{animated:C,color:M,column:e,state:U},null==e?void 0:e.key):(0,w.jsx)(c.default,{animated:C,column:e,state:U},null==e?void 0:e.key)}))},null==e?void 0:e.key))),!W&&(0,w.jsx)(i.Spacer,{as:"tr",className:"nextui-table-hidden-row",y:.4})]}),(0,w.jsx)(x.default,{animated:C,collection:z,color:M,hasPagination:B,hideLoading:P,isStatic:!G,state:U}),B&&(0,w.jsxs)(p.default,{children:[(0,w.jsx)(i.Spacer,{as:"tr",className:"nextui-table-hidden-row",y:.6}),(0,w.jsx)("tr",{role:"row",children:(0,w.jsx)("th",{colSpan:z.columnCount,role:"columnheader",tabIndex:-1,children:L})})]})]})})})}));j.displayName="NextUI.Table",j.toString=()=>".nextui-table";var v=(0,n.default)(j,{animated:!0,hideLoading:!1,selectionMode:"none",selectionBehavior:"toggle"});exports["default"]=v,module.exports=exports.default;

/***/ }),

/***/ 85664:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledTableRowGroup=exports.StyledTableRow=exports.StyledTableLoadingRow=exports.StyledTableHeaderRow=exports.StyledTableHeaderCell=exports.StyledTableFooter=exports.StyledTableContainer=exports.StyledTableColumnHeader=exports.StyledTableCell=exports.StyledTable=exports.StyledBaseTableCell=void 0;var t=__webpack_require__(88194),e=__webpack_require__(74042);const l=(0,t.styled)("tr",{ov:"visible"});exports.StyledTableHeaderRow=l;const r=(0,t.styled)("th",{height:"$14",cursor:"default",bg:"$accents0",color:"$accents7",fontSize:"$xs",textAlign:"left",position:"relative","@motion":{transition:"none"},"&:first-child":{pl:"$8",btlr:"$md",bblr:"$md"},"&:last-child":{pr:"$8",btrr:"$md",bbrr:"$md"},variants:{align:{start:{textAlign:"left"},center:{textAlign:"center"},end:{textAlign:"right"}},animated:{false:{transition:"none"}},allowsSorting:{true:{transition:"background 0.25s ease 0s, color 0.25s ease 0s",cursor:"pointer","@motion":{transition:"none"},"&:hover":{color:"$accents8",bg:"$accents1"}}}},defaultVariants:{align:"left",animated:!0},compoundVariants:[{animated:!1,allowsSorting:!0,css:{transition:"none"}}]},e.cssFocusVisible);exports.StyledTableColumnHeader=r;const o=(0,t.styled)(r,e.cssFocusVisible);exports.StyledTableHeaderCell=o;const i=(0,t.styled)("tfoot",{height:"$14",variants:{align:{start:{textAlign:"left"},center:{textAlign:"center"},end:{textAlign:"right"}}},defaultVariants:{align:"right"}});exports.StyledTableFooter=i;const s=(0,t.styled)("td",{});exports.StyledBaseTableCell=s;const a=(0,t.styled)(s,{position:"relative",userSelect:"none",cursor:"default",py:"$5",pr:"$5",zIndex:"$2",ov:"hidden",whiteSpace:"nowrap",textOverflow:"ellipsis","&:first-child":{pl:"$8"},"&:last-child":{pr:"$8"},"&:before":{zIndex:"-$1",transition:"background 0.25s ease 0s, opacity 0.25s ease 0s",content:'""',position:"absolute",size:"100%",top:0,left:0,opacity:0,transform:"translateZ(0)",backfaceVisibility:"hidden"},variants:{align:{start:{textAlign:"left"},center:{textAlign:"center"},end:{textAlign:"right"}},isStatic:{true:{cursor:"text",userSelect:"text"}}}},e.cssFocusVisible);exports.StyledTableCell=a;const n=(0,t.styled)("tr",{ov:"visible",color:"$text",variants:{isDisabled:{true:{color:"$accents3",pointerEvents:"none",cursor:"not-allowed"}},isSelected:{true:{color:"$$tableRowTextColor",[`& ${a}:before`]:{opacity:1,bg:"$$tableRowColor"}}}}},e.cssFocusVisible);exports.StyledTableRow=n;const d=(0,t.styled)("thead",{variants:{isFixed:{true:{display:"table",width:"100%",tableLayout:"fixed"}},isInfinityScroll:{true:{display:"block",height:"100%",overflow:"auto",pb:"$10",[`& ${n}`]:{display:"table",width:"100%",tableLayout:"fixed"}}}},defaultVariants:{isInfinityScroll:!1}});exports.StyledTableRowGroup=d;const $=(0,t.styled)("tr",{width:"100%",display:"flex",alignItems:"center",justifyContent:"center",height:"calc(100% - $space$14)",variants:{isAtEnd:{true:{height:"$space$18"}},isAbsolute:{true:{position:"absolute",left:"0",top:"$10"}}}});exports.StyledTableLoadingRow=$;const c=(0,t.styled)("table",{borderCollapse:"separate",borderSpacing:0,width:"100%",p:"$md $sm","@motion":{[`& ${a}:before`]:{transition:"none"}},variants:{animated:{false:{[`& ${a}:before`]:{transition:"none"}}},color:{primary:{$$tableRowColor:"$colors$primaryLight",$$tableRowTextColor:"$colors$primaryLightContrast"},secondary:{$$tableRowColor:"$colors$secondaryLight",$$tableRowTextColor:"$colors$secondaryLightContrast"},success:{$$tableRowColor:"$colors$successLight",$$tableRowTextColor:"$colors$successLightContrast"},warning:{$$tableRowColor:"$colors$warningLight",$$tableRowTextColor:"$colors$warningLightContrast"},error:{$$tableRowColor:"$colors$errorLight",$$tableRowTextColor:"$colors$errorLightContrast"}},striped:{true:{[`& ${n}[aria-selected=false]:nth-child(even)`]:{[`& ${a}`]:{bg:"$accents0"}},[`& ${n}:nth-child(even)`]:{[`& ${a}:first-child`]:{br:"$lg 0 0 $lg"},[`& ${a}:last-child`]:{br:"0 $lg $lg 0"}}}},sticked:{true:{p:0,[`& ${r}:first-child`]:{br:"$lg 0 0 0"},[`& ${r}:last-child`]:{br:"0 $lg 0 0"}}},lineWeight:{light:{$$tableLineWeight:"$borderWeights$light"},normal:{$$tableLineWeight:"$borderWeights$normal"},bold:{$$tableLineWeight:"$borderWeights$bold"},extrabold:{$$tableLineWeight:"$borderWeights$extrabold"},black:{$$tableLineWeight:"$borderWeights$black"}},headerLined:{true:{[`& ${r}`]:{position:"relative",bg:"transparent","&:after":{content:"",position:"absolute",left:0,right:0,bottom:0,height:"calc($$tableLineWeight * 1.5)",bg:"$accents1"},"&:first-child":{ml:"$12",br:"0","&:after":{left:"$space$md"}},"&:last-child":{br:"0","&:after":{right:"$space$md"}}}}},lined:{true:{[`& ${n}:not(:last-child)`]:{position:"relative",[`& ${a}:after`]:{content:"",position:"absolute",bottom:0,left:0,right:0,height:"$$tableLineWeight",bg:"$border"},[`& ${a}:first-child`]:{"&:after":{left:"$space$md"}},[`& ${a}:last-child`]:{"&:after":{right:"$space$md"}}},[`& ${n}[aria-selected=true]:not(last-child)`]:{[`& ${a}:after`]:{bg:"$$tableRowTextColor",opacity:.3}}}},fixed:{true:{tableLayout:"fixed"}},hoverable:{true:{[`& ${a}:first-child`]:{br:"$md 0 0 $md"},[`& ${a}:last-child`]:{br:"0 $md $md 0"},[`& ${n}`]:{cursor:"pointer"},[`& ${n}[aria-selected=false]`]:{"&:hover":{[`& ${a}:before`]:{opacity:1,bg:"$accents0"}}},[`& ${n}[aria-selected=true]`]:{"&:hover":{[`& ${a}:before`]:{opacity:.8}}}}},isMultiple:{true:{}},hasPagination:{true:{}},shadow:{true:{}},compact:{true:{[`& ${a}`]:{py:"$1"},[`& ${r}`]:{height:"$12","&:first-child":{br:"$sm 0 0 $sm"},"&:last-child":{br:"0 $sm $sm 0"}}}}},compoundVariants:[{isMultiple:!0,hoverable:!0,css:{[`& ${n}:not(:first-child):not(:last-child)`]:{[`& ${a}:first-child`]:{br:0},[`& ${a}:last-child`]:{br:0}},[`& ${n}:first-child`]:{[`& ${a}:first-child`]:{br:"$md 0 0 0"},[`& ${a}:last-child`]:{br:"0 $md 0 0"}},[`& ${n}:last-child`]:{[`& ${a}:first-child`]:{br:"0 0 0 $md"},[`& ${a}:last-child`]:{br:"0 0 $md 0"}}}},{isMultiple:!0,hoverable:!0,sticked:!0,css:{[`& ${n}:first-child`]:{[`& ${a}:first-child`]:{br:"0"},[`& ${a}:last-child`]:{br:"0"}}}},{compact:!0,shadow:!0,css:{p:"$md $sm"}},{compact:!0,sticked:!0,css:{p:0}},{sticked:!0,isMultiple:!1,hoverable:!0,hasPagination:!1,css:{[`& ${n}:not(:last-child)`]:{[`& ${a}`]:{br:"0"}},[`& ${n}:last-child`]:{[`& ${a}:first-child`]:{br:"0 0 0 $md"},[`& ${a}:last-child`]:{br:"0 0 $md 0"}}}},{sticked:!0,isMultiple:!1,hoverable:!0,hasPagination:!0,css:{[`& ${n}`]:{[`& ${a}`]:{br:"0"}}}},{sticked:!0,hasPagination:!0,css:{pb:"$5"}},{sticked:!0,hasPagination:!0,isMultiple:!0,hoverable:!0,css:{[`& ${n}:last-child`]:{[`& ${a}:first-child`]:{br:"0"},[`& ${a}:last-child`]:{br:"0"}}}}],defaultVariants:{sticked:!1,color:"primary",lineWeight:"light"}});exports.StyledTable=c;const b=(0,t.styled)("div",{display:"flex",flexDirection:"column",br:"$xl",overflowX:"auto",overflowY:"hidden",variants:{shadow:{true:{bs:"$md"}},bordered:{true:{borderStyle:"solid",borderColor:"$border"},false:{bw:0}},borderWeight:{light:{bw:"$light"},normal:{bw:"$normal"},bold:{bw:"$bold"},extrabold:{bw:"$extrabold"},black:{bw:"$black"}}},defaultVariants:{shadow:!0,borderWeight:"normal"}});exports.StyledTableContainer=b;

/***/ }),

/***/ 97026:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports.isInfinityScroll=exports.hasPaginationChild=void 0;var r=e(__webpack_require__(18038));exports.hasPaginationChild=(e,i)=>{const o=r.default.Children.toArray(e).find((e=>r.default.isValidElement(e)&&e.type===i));var a;return r.default.isValidElement(o)?{hasPagination:!0,rowsPerPage:(null==o||null==(a=o.props)?void 0:a.rowsPerPage)||0}:{hasPagination:!1,rowsPerPage:0}};exports.isInfinityScroll=e=>{var r;const i=null==(r=e.body)?void 0:r.props;return void 0!==(null==i?void 0:i.loadingState)&&"function"==typeof(null==i?void 0:i.onLoadMore)};

/***/ }),

/***/ 8901:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=exports.TextChild=void 0;var e=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=n(t);if(r&&r.has(e))return r.get(e);var o={},u=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if("default"!==i&&Object.prototype.hasOwnProperty.call(e,i)){var l=u?Object.getOwnPropertyDescriptor(e,i):null;l&&(l.get||l.set)?Object.defineProperty(o,i,l):o[i]=e[i]}o.default=e,r&&r.set(e,o);return o}(__webpack_require__(18038)),t=__webpack_require__(36403),r=__webpack_require__(73726),o=__webpack_require__(81595),u=__webpack_require__(63397),i=__webpack_require__(56786);function n(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(n=function(e){return e?r:t})(e)}const l=e.default.forwardRef(((o,n)=>{const{children:l,tag:a,color:s="default",transform:f,size:c,css:d,...p}=o,x=(0,r.useDOMRef)(n),y=(0,e.useMemo)((()=>(0,t.isNormalColor)(s)?"default"===s?"$text":`$${s}`:s),[s]);return(0,i.jsx)(u.StyledText,{ref:x,as:a,css:{color:y,fontSize:c,tt:f,...d},...p,children:l})}));exports.TextChild=l,o.__DEV__&&(l.displayName="NextUI.TextChild"),l.toString=()=>".nextui-text-child";var a=e.default.memo(l);exports["default"]=a;

/***/ }),

/***/ 2387:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledText=void 0;var t=e(__webpack_require__(19429)),r=__webpack_require__(63397);exports.StyledText=r.StyledText;var l=t.default;exports["default"]=l;

/***/ }),

/***/ 19429:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.Text=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=o(t);if(r&&r.has(e))return r.get(e);var n={},u=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if("default"!==i&&Object.prototype.hasOwnProperty.call(e,i)){var l=u?Object.getOwnPropertyDescriptor(e,i):null;l&&(l.get||l.set)?Object.defineProperty(n,i,l):n[i]=e[i]}n.default=e,r&&r.set(e,n);return n}(__webpack_require__(18038)),r=__webpack_require__(73726),n=__webpack_require__(81595),u=e(__webpack_require__(8901)),i=__webpack_require__(56786);function o(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(o=function(e){return e?r:t})(e)}const l=(e,t,r,n)=>{if(!e.length)return t;const o=e.slice(1,e.length);return(0,i.jsx)(u.default,{size:r,tag:e[0],transform:n,children:l(o,t,r)})},a=t.default.forwardRef(((e,n)=>{const{h1:o=!1,h2:a=!1,h3:s=!1,h4:f=!1,h5:c=!1,h6:p=!1,b:d=!1,small:h=!1,i:m=!1,span:b=!1,del:x=!1,em:y=!1,blockquote:j=!1,transform:O="none",size:g,children:q,...v}=e,M=(0,r.useDOMRef)(n),_={h1:o,h2:a,h3:s,h4:f,h5:c,h6:p,blockquote:j},k={span:b,small:h,b:d,em:y,i:m,del:x},w=Object.keys(_).filter((e=>_[e])),D=Object.keys(k).filter((e=>k[e])),P=(0,t.useMemo)((()=>w[0]?w[0]:D[0]?D[0]:"p"),[w,D]),z=D.filter((e=>e!==P)),R=(0,t.useMemo)((()=>z.length?l(z,q,g,O):q),[z,q,g,O]);return(0,i.jsx)(u.default,{ref:M,size:g,tag:P,transform:O,...v,children:R})}));exports.Text=a,n.__DEV__&&(a.displayName="NextUI.Text"),a.toString=()=>".nextui-text";var s=t.default.memo(a);exports["default"]=s;

/***/ }),

/***/ 63397:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledText=void 0;var e=__webpack_require__(88194),t=__webpack_require__(74042);const i=(0,e.styled)("p",{variants:{weight:{hairline:{fontWeight:"$hairline"},thin:{fontWeight:"$thin"},light:{fontWeight:"$light"},normal:{fontWeight:"$normal"},medium:{fontWeight:"$medium"},semibold:{fontWeight:"$semibold"},bold:{fontWeight:"$bold"},extrabold:{fontWeight:"$extrabold"},black:{fontWeight:"$black"}}}},t.cssHideShowIn);exports.StyledText=i;

/***/ }),

/***/ 59770:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(42383)).default;exports["default"]=r,module.exports=exports.default;

/***/ }),

/***/ 42383:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=f(t);if(r&&r.has(e))return r.get(e);var u={},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in e)if("default"!==n&&Object.prototype.hasOwnProperty.call(e,n)){var s=a?Object.getOwnPropertyDescriptor(e,n):null;s&&(s.get||s.set)?Object.defineProperty(u,n,s):u[n]=e[n]}u.default=e,r&&r.set(e,u);return u}(__webpack_require__(18038)),r=e(__webpack_require__(25457)),u=e(__webpack_require__(9492)),a=e(__webpack_require__(31650)),n=__webpack_require__(10084),s=__webpack_require__(65654),i=__webpack_require__(81595),o=__webpack_require__(79122),l=__webpack_require__(56786);function f(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(f=function(e){return e?r:t})(e)}const c=t.default.forwardRef(((e,r)=>{const f=(0,t.useRef)(null),c=t.default.useRef(0),p=t.default.useRef(),{cacheMeasurements:d,rows:x,maxRows:y,minRows:g,onChange:h,onHeightChange:m,css:w,...v}=e;Object.keys(v).forEach((e=>{s.excludedInputPropsForTextarea.indexOf(e)>-1&&delete v[e]}));const _=void 0!==v.value;i.__DEV__&&v.style&&("maxHeight"in v.style&&(0,n.warn)("Using `style.maxHeight` for <Textarea/> is not supported. Please use `maxRows`."),"minHeight"in v.style&&(0,n.warn)("Using `style.minHeight` for <Textarea/> is not supported. Please use `minRows`.")),(0,t.useImperativeHandle)(r,(()=>f.current));const q=()=>{const e=f.current,t=d&&p.current?p.current:(0,o.getSizingData)(e);if(!t)return;p.current=t;const[r,u]=(0,o.calculateNodeHeight)(t,_&&v.value||e.value||e.placeholder||"x",x||g,x||y);c.current!==r&&(c.current=r,e.style.setProperty("height",`${r}px`,"important"),m&&m(r,{rowHeight:u}))};return"undefined"!=typeof document&&((0,t.useLayoutEffect)(q),(0,a.default)(q)),(0,l.jsx)(u.default,{ref:f,as:"textarea",css:w,onChange:e=>{q(),h&&h(e)},...v})}));i.__DEV__&&(c.displayName="NextUI.Textarea"),c.toString=()=>".nextui-textarea";var p=(0,r.default)(c,{minRows:3,maxRows:6,cacheMeasurements:!0,initialValue:""});exports["default"]=p,module.exports=exports.default;

/***/ }),

/***/ 79122:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.getSizingData=exports.forceHiddenStyles=exports.calculateNodeHeight=void 0;var e=__webpack_require__(72625);const t=["borderBottomWidth","borderLeftWidth","borderRightWidth","borderTopWidth","boxSizing","fontFamily","fontSize","fontStyle","fontWeight","letterSpacing","lineHeight","paddingBottom","paddingLeft","paddingRight","paddingTop","tabSize","textIndent","textRendering","textTransform","width","wordBreak"],i={"min-height":"0","max-height":"none",height:"0",visibility:"hidden",overflow:"hidden",position:"absolute","z-index":"-1000",top:"0",right:"0"},o="undefined"!=typeof document&&!!document.documentElement.currentStyle,r=e=>{Object.keys(i).forEach((t=>{e.style.setProperty(t,i[t],"important")}))};exports.forceHiddenStyles=r;exports.getSizingData=i=>{const r=window.getComputedStyle(i);if(null===r)return null;const d=(0,e.pick)(t,r),{boxSizing:n}=d;if(""===n)return null;o&&"border-box"===n&&(d.width=parseFloat(d.width)+parseFloat(d.borderRightWidth)+parseFloat(d.borderLeftWidth)+parseFloat(d.paddingRight)+parseFloat(d.paddingLeft)+"px");return{sizingStyle:d,paddingSize:parseFloat(d.paddingBottom)+parseFloat(d.paddingTop),borderSize:parseFloat(d.borderBottomWidth)+parseFloat(d.borderTopWidth)}};let d=null;exports.calculateNodeHeight=(e,t,i=1,o=1/0)=>{d||(d=document.createElement("textarea"),d.setAttribute("tabindex","-1"),d.setAttribute("aria-hidden","true"),r(d)),null===d.parentNode&&document.body.appendChild(d);const{paddingSize:n,borderSize:a,sizingStyle:l}=e,{boxSizing:s}=l;Object.keys(l).forEach((e=>{const t=e;d.style[t]=l[t]})),r(d),d.value=t;let p=((e,t)=>{const i=e.scrollHeight;return"border-box"===t.sizingStyle.boxSizing?i+t.borderSize:i-t.paddingSize})(d,e);d.value="x";const g=d.scrollHeight-n;let h=g*i;"border-box"===s&&(h=h+n+a),p=Math.max(h,p);let b=g*o;return"border-box"===s&&(b=b+n+a),p=Math.min(b,p),[p,g]};

/***/ }),

/***/ 84613:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.blueDark=exports.blue=void 0;exports.blue={blue50:"#EDF5FF",blue100:"#E1EFFF",blue200:"#CEE4FE",blue300:"#B7D5F8",blue400:"#96C1F2",blue500:"#5EA2EF",blue600:"#0072F5",blue700:"#005FCC",blue800:"#004799",blue900:"#00254D"};exports.blueDark={blue50:"#10253E",blue100:"#102C4C",blue200:"#0F3158",blue300:"#0D3868",blue400:"#0A4281",blue500:"#0952A5",blue600:"#0072F5",blue700:"#3694FF",blue800:"#3694FF",blue900:"#EAF4FF"};

/***/ }),

/***/ 12896:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.cyanDark=exports.cyan=void 0;exports.cyan={cyan50:"#F0FCFF",cyan100:"#E6FAFE",cyan200:"#D7F8FE",cyan300:"#C3F4FD",cyan400:"#A5EEFD",cyan500:"#7EE7FC",cyan600:"#06B7DB",cyan700:"#09AACD",cyan800:"#0E8AAA",cyan900:"#053B48"};exports.cyanDark={cyan50:"#012A32",cyan100:"#023A46",cyan200:"#024B5A",cyan300:"#036072",cyan400:"#037086",cyan500:"#048EA9",cyan600:"#06B7DB",cyan700:"#33D9FA",cyan800:"#6FE4FB",cyan900:"#EBFBFE"};

/***/ }),

/***/ 19297:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.grayDark=exports.gray=void 0;exports.gray={gray50:"#F1F3F5",gray100:"#ECEEF0",gray200:"#E6E8EB",gray300:"#DFE3E6",gray400:"#D7DBDF",gray500:"#C1C8CD",gray600:"#889096",gray700:"#7E868C",gray800:"#687076",gray900:"#11181C"};exports.grayDark={gray50:"#16181A",gray100:"#26292B",gray200:"#2B2F31",gray300:"#313538",gray400:"#3A3F42",gray500:"#4C5155",gray600:"#697177",gray700:"#787F85",gray800:"#9BA1A6",gray900:"#ECEDEE"};

/***/ }),

/***/ 47143:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.greenDark=exports.green=void 0;exports.green={green50:"#F1FDF7",green100:"#E8FCF1",green200:"#DAFBE8",green300:"#C8F9DD",green400:"#ADF5CC",green500:"#88F1B6",green600:"#17C964",green700:"#13A452",green800:"#108944",green900:"#06371B"};exports.greenDark={green50:"#042F14",green100:"#06381B",green200:"#074A24",green300:"#0A6130",green400:"#0B7439",green500:"#0F9549",green600:"#17C964",green700:"#41EC8B",green800:"#78F2AD",green900:"#ECFDF4"};

/***/ }),

/***/ 16701:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0;var e=__webpack_require__(84613);Object.keys(e).forEach((function(r){"default"!==r&&"__esModule"!==r&&(r in exports&&exports[r]===e[r]||(exports[r]=e[r]))}));var r=__webpack_require__(18353);Object.keys(r).forEach((function(e){"default"!==e&&"__esModule"!==e&&(e in exports&&exports[e]===r[e]||(exports[e]=r[e]))}));var o=__webpack_require__(47143);Object.keys(o).forEach((function(e){"default"!==e&&"__esModule"!==e&&(e in exports&&exports[e]===o[e]||(exports[e]=o[e]))}));var t=__webpack_require__(80075);Object.keys(t).forEach((function(e){"default"!==e&&"__esModule"!==e&&(e in exports&&exports[e]===t[e]||(exports[e]=t[e]))}));var s=__webpack_require__(58891);Object.keys(s).forEach((function(e){"default"!==e&&"__esModule"!==e&&(e in exports&&exports[e]===s[e]||(exports[e]=s[e]))}));var u=__webpack_require__(12896);Object.keys(u).forEach((function(e){"default"!==e&&"__esModule"!==e&&(e in exports&&exports[e]===u[e]||(exports[e]=u[e]))}));var p=__webpack_require__(65359);Object.keys(p).forEach((function(e){"default"!==e&&"__esModule"!==e&&(e in exports&&exports[e]===p[e]||(exports[e]=p[e]))}));var n=__webpack_require__(19297);Object.keys(n).forEach((function(e){"default"!==e&&"__esModule"!==e&&(e in exports&&exports[e]===n[e]||(exports[e]=n[e]))}));

/***/ }),

/***/ 65359:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.pinkDark=exports.pink=void 0;exports.pink={pink50:"#FFF0FB",pink100:"#FFE5F8",pink200:"#FFD6F3",pink300:"#FFC2EE",pink400:"#FFA3E5",pink500:"#FF7AD9",pink600:"#FF4ECD",pink700:"#D6009A",pink800:"#B80084",pink900:"#4D0037"};exports.pinkDark={pink50:"#330025",pink100:"#470033",pink200:"#5C0042",pink300:"#750054",pink400:"#8A0063",pink500:"#AD007C",pink600:"#FF4ECD",pink700:"#FF2EC4",pink800:"#FF6BD5",pink900:"#FFEBF9"};

/***/ }),

/***/ 18353:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.purpleDark=exports.purple=void 0;exports.purple={purple50:"#F7F2FD",purple100:"#F1E8FB",purple200:"#EADCF8",purple300:"#E0CBF5",purple400:"#D1B1F0",purple500:"#BC8EE9",purple600:"#7828C8",purple700:"#6622AA",purple800:"#4D1980",purple900:"#290E44"};exports.purpleDark={purple50:"#1F0A33",purple100:"#240C3C",purple200:"#2E0F4D",purple300:"#3B1362",purple400:"#451773",purple500:"#571D91",purple600:"#7828C8",purple700:"#9750DD",purple800:"#B583E7",purple900:"#F7ECFC"};

/***/ }),

/***/ 58891:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.redDark=exports.red=void 0;exports.red={red50:"#FEF0F5",red100:"#FEE7EF",red200:"#FDD8E5",red300:"#FCC5D8",red400:"#FAA8C5",red500:"#F881AB",red600:"#F31260",red700:"#B80A47",red800:"#910838",red900:"#4E041E"};exports.redDark={red50:"#300313",red100:"#300313",red200:"#44041A",red300:"#5C0523",red400:"#6F062B",red500:"#910838",red600:"#F31260",red700:"#F4256D",red800:"#F75F94",red900:"#FDD8E5"};

/***/ }),

/***/ 80075:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.yellowDark=exports.yellow=void 0;exports.yellow={yellow50:"#FEF9F0",yellow100:"#FEF5E7",yellow200:"#FDEFD8",yellow300:"#FCE7C5",yellow400:"#FBDBA7",yellow500:"#F9CB80",yellow600:"#F5A524",yellow700:"#B97509",yellow800:"#925D07",yellow900:"#4E3104"};exports.yellowDark={yellow50:"#3A2503",yellow100:"#442B03",yellow200:"#583804",yellow300:"#704705",yellow400:"#845306",yellow500:"#A66908",yellow600:"#F5A524",yellow700:"#F6AD37",yellow800:"#F8C572",yellow900:"#FEF7EC"};

/***/ }),

/***/ 14588:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.defaultUtils=exports.defaultTokens=exports.defaultThemeMap=exports.defaultMedia=exports.defaultColors=exports["default"]=void 0;var e=__webpack_require__(85254);const r={fonts:{sans:"-apple-system, BlinkMacSystemFont, 'Segoe UI','Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans','Helvetica Neue', sans-serif;",mono:"Menlo, Monaco, 'Lucida Console', 'Liberation Mono', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono','Courier New', monospace;"},fontSizes:{xs:"0.75rem",sm:"0.875rem",base:"1rem",md:"1rem",lg:"1.125rem",xl:"1.25rem","2xl":"1.5rem","3xl":"1.875rem","4xl":"2.25rem","5xl":"3rem","6xl":"3.75rem","7xl":"4.5rem","8xl":"6rem","9xl":"8rem"},fontWeights:{hairline:100,thin:200,light:300,normal:400,medium:500,semibold:600,bold:700,extrabold:800,black:900},lineHeights:{xs:1,sm:1.25,base:1.5,md:1.5,lg:1.75,xl:1.75,"2xl":2,"3xl":2.25,"4xl":2.5,"5xl":1,"6xl":1,"7xl":1,"8xl":1,"9xl":1},letterSpacings:{tighter:"-0.05em",tight:"-0.025em",normal:"0",wide:"0.025em",wider:"0.05em",widest:"0.1em"},space:{0:"0rem",xs:"0.5rem",sm:"0.75rem",md:"1rem",lg:"1.25rem",xl:"2.25rem","2xl":"3rem","3xl":"5rem","4xl":"10rem","5xl":"14rem","6xl":"18rem","7xl":"24rem","8xl":"32rem","9xl":"40rem",min:"min-content",max:"max-content",fit:"fit-content",screen:"100vw",full:"100%",px:"1px",1:"0.125rem",2:"0.25rem",3:"0.375rem",4:"0.5rem",5:"0.625rem",6:"0.75rem",7:"0.875rem",8:"1rem",9:"1.25rem",10:"1.5rem",11:"1.75rem",12:"2rem",13:"2.25rem",14:"2.5rem",15:"2.75rem",16:"3rem",17:"3.5rem",18:"4rem",20:"5rem",24:"6rem",28:"7rem",32:"8rem",36:"9rem",40:"10rem",44:"11rem",48:"12rem",52:"13rem",56:"14rem",60:"15rem",64:"16rem",72:"18rem",80:"20rem",96:"24rem"},radii:{xs:"7px",sm:"9px",md:"12px",base:"14px",lg:"14px",xl:"18px","2xl":"24px","3xl":"32px",squared:"33%",rounded:"50%",pill:"9999px"},zIndices:{1:"100",2:"200",3:"300",4:"400",5:"500",10:"1000",max:"9999"},borderWeights:{light:"1px",normal:"2px",bold:"3px",extrabold:"4px",black:"5px"},transitions:{default:"all 250ms ease",button:"background 0.25s ease 0s, color 0.25s ease 0s, border-color 0.25s ease 0s, box-shadow 0.25s ease 0s, transform 0.25s ease 0s, opacity 0.25s ease 0s",avatar:"box-shadow 0.25s ease 0s, opacity 0.25s ease 0s",card:"transform 0.25s ease 0s, filter 0.25s ease 0s, box-shadow 0.25s ease 0s",dropdownItem:"background 0.12s ease, transform 0.12s ease, color 0.12s ease, box-shadow 0.12s ease 0s"},breakpoints:{xs:"650px",sm:"960px",md:"1280px",lg:"1400px",xl:"1920px"}};exports.defaultTokens=r;const a={white:"#ffffff",black:"#000000",primaryLight:"$blue200",primaryLightHover:"$blue300",primaryLightActive:"$blue400",primaryLightContrast:"$blue600",primary:"$blue600",primaryBorder:"$blue500",primaryBorderHover:"$blue600",primarySolidHover:"$blue700",primarySolidContrast:"$white",primaryShadow:"$blue500",secondaryLight:"$purple200",secondaryLightHover:"$purple300",secondaryLightActive:"$purple400",secondaryLightContrast:"$purple600",secondary:"$purple600",secondaryBorder:"$purple500",secondaryBorderHover:"$purple600",secondarySolidHover:"$purple700",secondarySolidContrast:"$white",secondaryShadow:"$purple500",successLight:"$green200",successLightHover:"$green300",successLightActive:"$green400",successLightContrast:"$green700",success:"$green600",successBorder:"$green500",successBorderHover:"$green600",successSolidHover:"$green700",successSolidContrast:"$white",successShadow:"$green500",warningLight:"$yellow200",warningLightHover:"$yellow300",warningLightActive:"$yellow400",warningLightContrast:"$yellow700",warning:"$yellow600",warningBorder:"$yellow500",warningBorderHover:"$yellow600",warningSolidHover:"$yellow700",warningSolidContrast:"$white",warningShadow:"$yellow500",errorLight:"$red200",errorLightHover:"$red300",errorLightActive:"$red400",errorLightContrast:"$red600",error:"$red600",errorBorder:"$red500",errorBorderHover:"$red600",errorSolidHover:"$red700",errorSolidContrast:"$white",errorShadow:"$red500",neutralLight:"$gray100",neutralLightHover:"$gray200",neutralLightActive:"$gray300",neutralLightContrast:"$gray800",neutral:"$gray600",neutralBorder:"$gray400",neutralBorderHover:"$gray500",neutralSolidHover:"$gray600",neutralSolidContrast:"$white",neutralShadow:"$gray400",gradient:"linear-gradient(112deg, $cyan600 -63.59%, $pink600 -20.3%, $blue600 70.46%)",accents0:"$gray50",accents1:"$gray100",accents2:"$gray200",accents3:"$gray300",accents4:"$gray400",accents5:"$gray500",accents6:"$gray600",accents7:"$gray700",accents8:"$gray800",accents9:"$gray900"};exports.defaultColors=a;const t={xs:`(min-width: ${r.breakpoints.xs})`,sm:`(min-width: ${r.breakpoints.sm})`,md:`(min-width: ${r.breakpoints.md})`,lg:`(min-width: ${r.breakpoints.lg})`,xl:`(min-width: ${r.breakpoints.xl})`,xsMin:`(min-width: ${r.breakpoints.xs})`,smMin:`(min-width: ${r.breakpoints.sm})`,mdMin:`(min-width: ${r.breakpoints.md})`,lgMin:`(min-width: ${r.breakpoints.lg})`,xlMin:`(min-width: ${r.breakpoints.xl})`,xsMax:`(max-width: ${r.breakpoints.xs})`,smMax:`(max-width: ${r.breakpoints.sm})`,mdMax:`(max-width: ${r.breakpoints.md})`,lgMax:`(max-width: ${r.breakpoints.lg})`,xlMax:`(max-width: ${r.breakpoints.xl})`,motion:"(prefers-reduced-motion: reduce)",safari:"not all and (min-resolution:.001dpcm)",hover:"(any-hover: hover)",dark:"(prefers-color-scheme: dark)",light:"(prefers-color-scheme: light)"};exports.defaultMedia=t;const o={p:e=>({padding:e}),pt:e=>({paddingTop:e}),pr:e=>({paddingRight:e}),pb:e=>({paddingBottom:e}),pl:e=>({paddingLeft:e}),px:e=>({paddingLeft:e,paddingRight:e}),py:e=>({paddingTop:e,paddingBottom:e}),m:e=>({margin:e}),mt:e=>({marginTop:e}),mr:e=>({marginRight:e}),mb:e=>({marginBottom:e}),ml:e=>({marginLeft:e}),mx:e=>({marginLeft:e,marginRight:e}),my:e=>({marginTop:e,marginBottom:e}),ta:e=>({textAlign:e}),tt:e=>({textTransform:e}),to:e=>({textOverflow:e}),d:e=>({display:e}),dflex:e=>({display:"flex",alignItems:e,justifyContent:e}),fd:e=>({flexDirection:e}),fw:e=>({flexWrap:e}),ai:e=>({alignItems:e}),ac:e=>({alignContent:e}),jc:e=>({justifyContent:e}),as:e=>({alignSelf:e}),fg:e=>({flexGrow:e}),fs:e=>({fontSize:e}),fb:e=>({flexBasis:e}),bc:e=>({backgroundColor:e}),bf:e=>({backdropFilter:e}),bg:e=>({background:e}),bgBlur:e=>({bf:"saturate(180%) blur(10px)",bg:e}),bgColor:e=>({backgroundColor:e}),backgroundClip:e=>({WebkitBackgroundClip:e,backgroundClip:e}),bgClip:e=>({WebkitBackgroundClip:e,backgroundClip:e}),br:e=>({borderRadius:e}),bw:e=>({borderWidth:e}),btrr:e=>({borderTopRightRadius:e}),bbrr:e=>({borderBottomRightRadius:e}),bblr:e=>({borderBottomLeftRadius:e}),btlr:e=>({borderTopLeftRadius:e}),bs:e=>({boxShadow:e}),ds:e=>({dropShadow:e}),shadow:e=>({boxShadow:e}),dshadow:e=>({dropShadow:e}),dropShadow:e=>({filter:`$dropShadows${e}`}),normalShadow:e=>({boxShadow:`0 4px 14px 0 $colors${e}`}),normalShadowVar:e=>({boxShadow:`0 4px 14px 0 ${e}`}),lh:e=>({lineHeight:e}),ov:e=>({overflow:e}),ox:e=>({overflowX:e}),oy:e=>({overflowY:e}),pe:e=>({pointerEvents:e}),events:e=>({pointerEvents:e}),us:e=>({WebkitUserSelect:e,userSelect:e}),userSelect:e=>({WebkitUserSelect:e,userSelect:e}),w:e=>({width:e}),h:e=>({height:e}),mw:e=>({maxWidth:e}),maxW:e=>({maxWidth:e}),mh:e=>({maxHeight:e}),maxH:e=>({maxHeight:e}),size:e=>({width:e,height:e}),minSize:e=>({minWidth:e,minHeight:e,width:e,height:e}),sizeMin:e=>({minWidth:e,minHeight:e,width:e,height:e}),maxSize:e=>({maxWidth:e,maxHeight:e}),sizeMax:e=>({maxWidth:e,maxHeight:e}),appearance:e=>({WebkitAppearance:e,appearance:e}),scale:e=>({transform:`scale(${e})`}),linearGradient:e=>({backgroundImage:`linear-gradient(${e})`}),tdl:e=>({textDecorationLine:e}),truncateText:e=>({maxWidth:e,whiteSpace:"nowrap",overflow:"hidden",textOverflow:"ellipsis"}),textGradient:e=>({backgroundImage:`linear-gradient(${e})`,WebkitBackgroundClip:"text",WebkitTextFillColor:"transparent","&::selection":{WebkitTextFillColor:"$colors$text"}})};exports.defaultUtils=o;const i={...e.defaultThemeMap,width:"space",height:"space",minWidth:"space",maxWidth:"space",minHeight:"space",maxHeight:"space",flexBasis:"space",gridTemplateColumns:"space",gridTemplateRows:"space",blockSize:"space",minBlockSize:"space",maxBlockSize:"space",inlineSize:"space",minInlineSize:"space",maxInlineSize:"space",borderWidth:"borderWeights"};exports.defaultThemeMap=i;var s={prefix:"nextui",theme:{...r,colors:a,shadows:{},dropShadows:{}},media:t,utils:o,themeMap:i};exports["default"]=s;

/***/ }),

/***/ 16764:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;var r=__webpack_require__(36403),e=__webpack_require__(16701),o={colors:{background:"$black",backgroundAlpha:"rgba(0, 0, 0, 0.6)",foreground:"$white",backgroundContrast:"$accents0",...e.blueDark,...e.purpleDark,...e.greenDark,...e.yellowDark,...e.redDark,...e.cyanDark,...e.pinkDark,...e.grayDark,primaryLight:"$blue50",primaryLightHover:"$blue100",primaryLightActive:"$blue200",primaryLightContrast:"$blue600",secondaryLight:"$purple50",secondaryLightHover:"$purple100",secondaryLightActive:"$purple200",secondaryLightContrast:"$purple800",secondary:"$purple700",secondaryBorder:"$purple500",secondaryBorderHover:"$purple600",secondarySolidHover:"$purple700",secondaryShadow:"$purple500",successLight:"$green50",successLightHover:"$green100",successLightActive:"$green200",warningLight:"$yellow50",warningLightHover:"$yellow100",warningLightActive:"$yellow200",errorLight:"$red50",errorLightHover:"$red100",errorLightActive:"$red200",errorLightContrast:"$red700",neutralLight:"$gray200",neutralLightHover:"$gray300",neutralLightActive:"$gray400",neutralSolidContrast:"$white",textLight:(0,r.addColorAlpha)(e.grayDark.gray900,.2),text:"$gray900",linkLight:(0,r.addColorAlpha)(e.blueDark.blue600,.2),link:"$blue700",codeLight:"$cyan50",code:"$cyan600",selection:"$pink800",border:"rgba(255, 255, 255, 0.15)"},shadows:{xs:"0 2px 8px 1px rgb(0 0 0 / 0.07), 0 1px 1px -1px rgb(0 0 0 / 0.04)",sm:"0 2px 8px 2px rgb(0 0 0 / 0.07), 0 2px 4px -1px rgb(0 0 0 / 0.04)",md:"0 12px 20px 6px rgb(0 0 0 / 0.08)",lg:"0 12px 34px 6px rgb(0 0 0 / 0.18)",xl:"0 25px 65px 0px rgb(0 0 0 / 0.35)"},dropShadows:{xs:"drop-shadow(0 2px 4px rgb(0 0 0 / 0.07)) drop-shadow(0 1px 1px rgb(0 0 0 / 0.04))",sm:"drop-shadow(0 2px 8px rgb(0 0 0 / 0.07)) drop-shadow(0 2px 4px rgb(0 0 0 / 0.04))",md:"drop-shadow(0 4px 12px rgb(0 0 0 / 0.08)) drop-shadow(0 20px 8px rgb(0 0 0 / 0.04))",lg:"drop-shadow(0 12px 24px rgb(0 0 0 / 0.15)) drop-shadow(0 12px 14px rgb(0 0 0 / 0.1))",xl:"drop-shadow(0 25px 34px rgb(0 0 0 / 0.35))"}};exports["default"]=o,module.exports=exports.default;

/***/ }),

/***/ 51982:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;var p=__webpack_require__(36403),r=__webpack_require__(16701),o={colors:{background:"$white",backgroundAlpha:"rgba(255, 255, 255, 0.8)",foreground:"$black",backgroundContrast:"$white",...r.blue,...r.purple,...r.green,...r.yellow,...r.red,...r.cyan,...r.pink,...r.gray,textLight:(0,p.addColorAlpha)(r.gray.gray900,.2),text:"$gray900",linkLight:(0,p.addColorAlpha)(r.blue.blue600,.2),link:"$blue600",codeLight:"$pink100",code:"$pink600",selection:"$blue200",border:"rgba(0, 0, 0, 0.15)"},shadows:{xs:"0 2px 8px 1px rgb(104 112 118 / 0.07), 0 1px 1px -1px rgb(104 112 118 / 0.04)",sm:"0 2px 8px 2px rgb(104 112 118 / 0.07), 0 2px 4px -1px rgb(104 112 118 / 0.04)",md:"0 12px 20px 6px rgb(104 112 118 / 0.08)",lg:"0 12px 34px 6px rgb(104 112 118 / 0.18)",xl:"0 25px 65px 0px rgb(104 112 118 / 0.35)"},dropShadows:{xs:"drop-shadow(0 2px 4px rgb(104 112 118 / 0.07)) drop-shadow(0 1px 1px rgb(104 112 118 / 0.04))",sm:"drop-shadow(0 2px 8px rgb(104 112 118 / 0.07)) drop-shadow(0 2px 4px rgb(104 112 118 / 0.04))",md:"drop-shadow(0 4px 12px rgb(104 112 118 / 0.08)) drop-shadow(0 20px 8px rgb(104 112 118 / 0.04))",lg:"drop-shadow(0 12px 24px rgb(104 112 118 / 0.15)) drop-shadow(0 12px 14px rgb(104 112 118 / 0.1))",xl:"drop-shadow(0 25px 34px rgb(104 112 118 / 0.35))"}};exports["default"]=o,module.exports=exports.default;

/***/ }),

/***/ 74042:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.sharedVisuallyHidden=exports.sharedFocus=exports.cssShowIn=exports.cssNoBlurriness=exports.cssHideShowIn=exports.cssHideIn=exports.cssFocusVisible=void 0;var s=__webpack_require__(88194);const o=(0,s.css)({WebkitTapHighlightColor:"transparent","&:focus:not(&:focus-visible)":{boxShadow:"none"},"&:focus":{outline:"none",boxShadow:"0 0 0 2px $colors$background, 0 0 0 4px $colors$primary"},"@safari":{WebkitTapHighlightColor:"transparent",outline:"none"}});exports.sharedFocus=o;const e=(0,s.css)({outline:"none",variants:{isFocusVisible:{true:{boxShadow:"0 0 0 2px $colors$background, 0 0 0 4px $colors$primary"},false:{}}}});exports.cssFocusVisible=e;const n=(0,s.css)({transform:"translateZ(0)",backfaceVisibility:"hidden"});exports.cssNoBlurriness=n;const i=(0,s.css)({border:"0px",clip:"rect(0px, 0px, 0px, 0px)",height:"1px",width:"1px",margin:"-1px",padding:"0px",overflow:"hidden",whiteSpace:"nowrap",position:"absolute"});exports.sharedVisuallyHidden=i;const r=(0,s.css)({variants:{hideIn:{xs:{"@xsMax":{display:"none"}},sm:{"@smMax":{display:"none"}},md:{"@mdMax":{display:"none"}},lg:{"@lgMax":{display:"none"}},xl:{"@xlMax":{display:"none"}}}}});exports.cssHideIn=r;const a=(0,s.css)({variants:{showIn:{xs:{"@xs":{display:"none"}},sm:{"@sm":{display:"none"}},md:{"@md":{display:"none"}},lg:{"@lg":{display:"none"}},xl:{"@xl":{display:"none"}}}}});exports.cssShowIn=a;const t=(0,s.css)(r,a);exports.cssHideShowIn=t;

/***/ }),

/***/ 88194:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports.theme=exports.styled=exports.keyframes=exports.globalCss=exports.getStitchesTheme=exports.getCssText=exports.css=exports.createThemeBase=exports.createTheme=exports.config=void 0;var t=__webpack_require__(85254),s=e(__webpack_require__(77159)),r=e(__webpack_require__(14588)),o=e(__webpack_require__(51982)),a=e(__webpack_require__(16764));exports.getStitchesTheme=e=>(0,s.default)(e,r.default.theme);const c=(0,t.createStitches)({...r.default,theme:{...r.default.theme,shadows:{...o.default.shadows},dropShadows:{...o.default.dropShadows},colors:{...r.default.theme.colors,...o.default.colors}}}),h=c.createTheme;exports.createThemeBase=h;const l=c.styled;exports.styled=l;const p=c.css;exports.css=p;const m=c.globalCss;exports.globalCss=m;const d=c.keyframes;exports.keyframes=d;const u=c.getCssText;exports.getCssText=u;const x=c.theme;exports.theme=x;const i=c.config;exports.config=i;exports.createTheme=({type:e,theme:t,className:r})=>{if(!e)throw new Error("Theme type is required");return h(r||`${e}-theme`,(0,s.default)("dark"===e?a.default:o.default,t))};

/***/ }),

/***/ 66756:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports.defaultContext=exports["default"]=void 0;var t=e(__webpack_require__(18038));const r={isDark:!1,theme:(__webpack_require__(88194).theme),type:"light"};exports.defaultContext=r;var a=t.default.createContext(r);exports["default"]=a;

/***/ }),

/***/ 62356:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=m(__webpack_require__(18038)),r=__webpack_require__(65444),u=__webpack_require__(27807),n=e(__webpack_require__(94754)),a=e(__webpack_require__(25457)),l=e(__webpack_require__(77159)),o=__webpack_require__(36828),i=e(__webpack_require__(90658)),s=__webpack_require__(89026),d=m(__webpack_require__(66756)),c=__webpack_require__(56786);function f(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(f=function(e){return e?r:t})(e)}function m(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=f(t);if(r&&r.has(e))return r.get(e);var u={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if("default"!==a&&Object.prototype.hasOwnProperty.call(e,a)){var l=n?Object.getOwnPropertyDescriptor(e,a):null;l&&(l.get||l.set)?Object.defineProperty(u,a,l):u[a]=e[a]}return u.default=e,r&&r.set(e,u),u}var v=(0,a.default)((({theme:e,disableBaseline:a,children:f})=>{const{isBrowser:m}=(0,i.default)(),[v,p]=(0,t.useState)(d.defaultContext.type),b=e=>{p((t=>t!==e?e:t))},h=e=>{const t=(0,s.getDocumentTheme)(e);t&&b(t)},y=(0,t.useMemo)((()=>{const e=m?(0,s.getDocumentCSSTokens)():{},t=(0,l.default)((0,o.copyObject)(d.defaultContext.theme),e),r=(0,s.getThemeName)(v);return{theme:t,type:r,isDark:"dark"===r}}),[v,m]);return(0,t.useEffect)((()=>{var e,t,r;h(null==(e=document)?void 0:e.documentElement);const u=new MutationObserver((e=>{var t;if(e&&e.length>0&&"BODY"===(null==(t=e[0])?void 0:t.target.nodeName)){var r,u,n;const e=null==(r=document)||null==(u=r.body)||null==(n=u.dataset)?void 0:n.theme;e&&b(e)}else{var a;h(null==(a=document)?void 0:a.documentElement)}}));return u.observe(null==(t=document)?void 0:t.documentElement,{attributes:!0,attributeFilter:["data-theme","style"]}),u.observe(null==(r=document)?void 0:r.body,{attributes:!0,attributeFilter:["data-theme","style"]}),()=>u.disconnect()}),[]),(0,t.useEffect)((()=>{m&&e&&null!=e&&e.className&&((0,s.changeTheme)(e.className),b((0,s.getThemeName)(e.className)))}),[m,e]),(0,c.jsx)(r.SSRProvider,{children:(0,c.jsx)(u.OverlayProvider,{children:(0,c.jsxs)(d.default.Provider,{value:y,children:[!a&&(0,c.jsx)(n.default,{}),f]})})})}),{disableBaseline:!1});exports["default"]=v,module.exports=exports.default;

/***/ }),

/***/ 89026:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports.getTokenValue=exports.getThemeName=exports.getDocumentTheme=exports.getDocumentCSSTokens=exports.changeTheme=void 0;var t=e(__webpack_require__(62358)),l=__webpack_require__(36403),r=e(__webpack_require__(14588)),o=e(__webpack_require__(51982));const u=(e,t,o=1)=>{if("undefined"==typeof document||!e)return"";let s=getComputedStyle(document.documentElement);const n=`--${r.default.prefix}-${e}-${t}`,c=s.getPropertyValue(n);if(c&&c.includes("var")&&u(e,c),c&&1!==o){if(c.includes("rgb"))return(0,l.rgbToRgba)(c,o);if(c.includes("#"))return(0,l.hexToRGBA)(c,o)}return c};exports.getTokenValue=u;exports.getDocumentCSSTokens=()=>{const e=[...Object.keys(r.default.theme.colors),...Object.keys(o.default.colors)],t=Object.keys(o.default.shadows);return{colors:e.reduce(((e,t)=>{const l=u("colors",t);return l&&(e[t]={prefix:r.default.prefix,scale:"colors",token:t,value:l}),e}),{}),shadows:t.reduce(((e,t)=>{const l=u("shadows",t);return l&&(e[t]={prefix:r.default.prefix,scale:"shadows",token:t,value:l}),e}),{})}};exports.getDocumentTheme=e=>{var t;const l=(null==e||null==(t=e.getAttribute("style"))?void 0:t.split(";").map((e=>e.trim())).filter((e=>e.includes("color-scheme"))))||[],r=l.length>0?l[0].replace("color-scheme: ","").replace(";",""):"";return(null==e?void 0:e.getAttribute("data-theme"))||r};const s=e=>"string"==typeof e&&null!=e&&e.includes("-theme")?null==e?void 0:e.replace("-theme",""):e;exports.getThemeName=s;exports.changeTheme=e=>{var l,r;if(!document)return;const o=document.documentElement,u=(null==o||null==(l=o.getAttribute("class"))?void 0:l.split(" ").filter((e=>!e.includes("theme")&&!e.includes("light")&&!e.includes("dark"))))||[],n=(null==o||null==(r=o.getAttribute("style"))?void 0:r.split(";").filter((e=>!e.includes("color-scheme")&&e.length)).map((e=>`${e};`)))||[],c=s(e);null==o||o.setAttribute("class",(0,t.default)(u,`${c}-theme`)),null==o||o.setAttribute("style",(0,t.default)(n,`color-scheme: ${c};`))};

/***/ }),

/***/ 52089:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var t=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledTooltipTrigger=exports.StyledTooltipContent=exports.StyledTooltipArrow=exports.StyledTooltip=void 0;var e=t(__webpack_require__(25844)),o=__webpack_require__(28490);exports.StyledTooltipTrigger=o.StyledTooltipTrigger,exports.StyledTooltipArrow=o.StyledTooltipArrow,exports.StyledTooltipContent=o.StyledTooltipContent,exports.StyledTooltip=o.StyledTooltip;var r=e.default;exports["default"]=r;

/***/ }),

/***/ 50730:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.getRect=exports.getPlacement=exports.getIconPlacement=exports.defaultTooltipPlacement=void 0;const t={top:-1e3,left:-1e3,right:-1e3,bottom:-1e3,width:0,height:0};exports.getRect=o=>{if(!o||!o.current)return t;const e=o.current.getBoundingClientRect();return{...e,width:e.width||e.right-e.left,height:e.height||e.bottom-e.top,top:e.top+document.documentElement.scrollTop,bottom:e.bottom+document.documentElement.scrollTop,left:e.left+document.documentElement.scrollLeft,right:e.right+document.documentElement.scrollLeft}};exports.defaultTooltipPlacement={top:"-1000px",left:"-1000px",transform:"none"};exports.getPlacement=(t,o,e)=>{const r={top:{top:o.top-e+"px",left:`${o.left+o.width/2}px`,transform:"translate(-50%, -100%)"},topStart:{top:o.top-e+"px",left:`${o.left}px`,transform:"translate(0, -100%)"},topEnd:{top:o.top-e+"px",left:`${o.left+o.width}px`,transform:"translate(-100%, -100%)"},bottom:{top:`${o.bottom+e}px`,left:`${o.left+o.width/2}px`,transform:"translate(-50%, 0)"},bottomStart:{top:`${o.bottom+e}px`,left:`${o.left}px`,transform:"translate(0, 0)"},bottomEnd:{top:`${o.bottom+e}px`,left:`${o.left+o.width}px`,transform:"translate(-100%, 0)"},left:{top:`${o.top+o.height/2}px`,left:o.left-e+"px",transform:"translate(-100%, -50%)"},leftStart:{top:`${o.top}px`,left:o.left-e+"px",transform:"translate(-100%, 0)"},leftEnd:{top:`${o.top+o.height}px`,left:o.left-e+"px",transform:"translate(-100%, -100%)"},right:{top:`${o.top+o.height/2}px`,left:`${o.right+e}px`,transform:"translate(0, -50%)"},rightStart:{top:`${o.top}px`,left:`${o.right+e}px`,transform:"translate(0, 0)"},rightEnd:{top:`${o.top+o.height}px`,left:`${o.right+e}px`,transform:"translate(0, -100%)"}};return r[t]||r.top};exports.getIconPlacement=(t,o)=>{const e={top:{top:"auto",right:"auto",left:"50%",bottom:"0px",transform:"translate(-50%, 100%) rotate(45deg)"},topStart:{top:"auto",right:"auto",left:"8%",bottom:"0px",transform:"translate(8%, 100%) rotate(45deg)"},topEnd:{top:"auto",right:"8%",left:"auto",bottom:"0px",transform:"translate(8%, 100%) rotate(45deg)"},bottom:{top:"0px",right:"auto",left:"50%",bottom:"auto",transform:"translate(-50%, -100%) rotate(225deg)"},bottomStart:{top:"0px",right:"auto",left:"8%",bottom:"auto",transform:"translate(8%, -100%) rotate(225deg)"},bottomEnd:{top:"0px",right:"8%",left:"auto",bottom:"auto",transform:"translate(8%, -100%) rotate(225deg)"},left:{top:"50%",right:`-${o-1}px`,left:"auto",bottom:"auto",transform:"translate(100%, -50%) rotate(-45deg)"},leftStart:{top:"calc(15% + 1px)",right:`-${o-1}px`,left:"auto",bottom:"auto",transform:"translate(100%, 0) rotate(-45deg)"},leftEnd:{top:"auto",right:`-${o-1}px`,left:"auto",bottom:"calc(15% + 1px)",transform:"translate(100%, 0) rotate(-45deg)"},right:{top:"50%",right:"auto",left:`-${o-1}px`,bottom:"auto",transform:"translate(-100%, -50%) rotate(135deg)"},rightStart:{top:"calc(15% + 1px)",right:"auto",left:`-${o-1}px`,bottom:"auto",transform:"translate(-100%, 0) rotate(135deg)"},rightEnd:{top:"auto",right:"auto",left:`-${o-1}px`,bottom:"calc(15% + 1px)",transform:"translate(-100%, 0) rotate(135deg)"}};return e[t]||e.top};

/***/ }),

/***/ 93559:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=f(t);if(r&&r.has(e))return r.get(e);var o={},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var l in e)if("default"!==l&&Object.prototype.hasOwnProperty.call(e,l)){var n=a?Object.getOwnPropertyDescriptor(e,l):null;n&&(n.get||n.set)?Object.defineProperty(o,l,n):o[l]=e[l]}o.default=e,r&&r.set(e,o);return o}(__webpack_require__(18038)),r=__webpack_require__(98704),o=e(__webpack_require__(79090)),a=e(__webpack_require__(31650)),l=e(__webpack_require__(91863)),n=e(__webpack_require__(31709)),i=e(__webpack_require__(62358)),s=e(__webpack_require__(25457)),u=__webpack_require__(28490),c=__webpack_require__(50730),p=__webpack_require__(56786);function f(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(f=function(e){return e?r:t})(e)}const d="nextui-tooltip",m=({children:e,parent:s,visible:f,offset:m,placement:v,rounded:w,animated:y,className:h,hideArrow:x,css:q,...b})=>{const g=(0,o.default)("tooltip"),j=(0,t.useRef)(null),[P,O]=(0,t.useState)(c.defaultTooltipPlacement);if(!s)return null;const $=()=>{const e=(0,c.getPlacement)(v,(0,c.getRect)(s),m);O(e)},{transform:M,top:T,left:k,right:N,bottom:S}=(0,t.useMemo)((()=>(0,c.getIconPlacement)(v,5)),[v]);(0,a.default)($),(0,n.default)((()=>$())),(0,t.useEffect)((()=>{$()}),[f]);const _=(0,t.useMemo)((()=>f?"open":"closed"),[f]);return g?(0,r.createPortal)((0,p.jsx)(l.default,{enterTime:20,leaveTime:20,name:`${d}-wrapper`,visible:f,children:(0,p.jsx)(u.StyledTooltipContent,{ref:j,animated:y,className:(0,i.default)(`${d}-content`,`${d}--${_}`,h),css:{left:P.left,top:`calc(${P.top} + 6px)`,transform:P.transform,[`&.${d}-wrapper-enter-active`]:{opacity:1,top:P.top},...q},"data-state":_,onClick:e=>{e.stopPropagation(),e.nativeEvent.stopImmediatePropagation()},...b,children:(0,p.jsxs)(u.StyledTooltip,{className:(0,i.default)(d,{[`${d}--with-arrow`]:!x}),"data-state":_,hideArrow:x,role:"tooltip",children:[(0,p.jsx)(u.StyledTooltipArrow,{className:`${d}-arrow`,css:{left:k,top:T,right:N,bottom:S,transform:M}}),e]})})}),g):null};m.toString=()=>".nextui-tooltip-content";var v=(0,s.default)(m,{placement:"top",offset:12,className:""});exports["default"]=v,module.exports=exports.default;

/***/ }),

/***/ 25844:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=a(t);if(r&&r.has(e))return r.get(e);var o={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if("default"!==i&&Object.prototype.hasOwnProperty.call(e,i)){var l=n?Object.getOwnPropertyDescriptor(e,i):null;l&&(l.get||l.set)?Object.defineProperty(o,i,l):o[i]=e[i]}o.default=e,r&&r.set(e,o);return o}(__webpack_require__(18038)),r=e(__webpack_require__(25457)),o=e(__webpack_require__(69152)),n=e(__webpack_require__(93559)),i=__webpack_require__(28490),l=__webpack_require__(56786);function a(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(a=function(e){return e?r:t})(e)}const s=({children:e,initialVisible:r,content:a,offset:s,placement:u,portalClassName:c,enterDelay:d,leaveDelay:f,trigger:p,rounded:b,animated:v,shadow:h,className:m,color:w,contentColor:y,onVisibleChange:g,hideArrow:x,css:k,triggerCss:C,onClick:j,keepMounted:D,visible:M,isDisabled:q,...O})=>{const N=(0,t.useRef)(),P=(0,t.useRef)(null),[T,V]=(0,t.useState)(r),_={animated:v,visible:T,css:k,shadow:h,offset:s,placement:u,rounded:b,color:w,contentColor:y,hideArrow:x,parent:P,className:c},A=e=>{const t=()=>{clearTimeout(N.current),N.current=void 0},r=e=>{V(e),g(e),t()};t(),N.current=e?window.setTimeout((()=>r(!0)),d):window.setTimeout((()=>r(!1)),f)},R=e=>{"hover"===p&&A(e)};return(0,o.default)(P,(()=>"click"===p&&!D&&A(!1))),(0,t.useEffect)((()=>{void 0!==M&&A(M)}),[M]),(0,l.jsxs)(i.StyledTooltipTrigger,{ref:P,className:`nextui-tooltip-button ${m}`,css:C,role:"button",tabIndex:-1,onBlur:()=>R(!1),onClickCapture:()=>{"click"===p&&A(!T),null==j||j()},onFocus:()=>R(!0),onKeyUp:()=>R(!0),onMouseEnter:()=>R(!0),onMouseLeave:()=>R(!1),...O,children:[e,a&&!q?(0,l.jsx)(n.default,{..._,children:a}):null]})};s.toString=()=>".nextui-tooltip";var u=(0,r.default)(s,{initialVisible:!1,hideArrow:!1,animated:!0,shadow:!0,rounded:!1,keepMounted:!1,isDisabled:!1,trigger:"hover",enterDelay:0,leaveDelay:0,className:"",portalClassName:"",onVisibleChange:()=>{}});exports["default"]=u,module.exports=exports.default;

/***/ }),

/***/ 28490:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledTooltipTrigger=exports.StyledTooltipContent=exports.StyledTooltipArrow=exports.StyledTooltip=void 0;var o=__webpack_require__(88194);const t=(0,o.styled)("div",{width:"max-content",display:"inherit"});exports.StyledTooltipTrigger=t;const r=(0,o.styled)("span",{display:"none",content:"",size:"$5",zIndex:"-2",background:"$$tooltipColor",br:"0px 0px 2px 0px",position:"absolute"});exports.StyledTooltipArrow=r;const l=(0,o.styled)("div",{position:"relative",fs:"$sm",padding:0,variants:{hideArrow:{false:{[`& ${r}`]:{display:"block"}}}}});exports.StyledTooltip=l;const e=(0,o.styled)("div",{position:"absolute",width:"auto",padding:"$3 $sm",opacity:0,zIndex:"$10",br:"$lg","@motion":{transition:"none"},variants:{color:{default:{$$tooltipColor:"$colors$background",bg:"$$tooltipColor"},primary:{$$tooltipColor:"$colors$primary",bg:"$$tooltipColor"},secondary:{$$tooltipColor:"$colors$secondary",bg:"$$tooltipColor"},success:{$$tooltipColor:"$colors$success",bg:"$$tooltipColor"},warning:{$$tooltipColor:"$colors$warning",bg:"$$tooltipColor"},error:{$$tooltipColor:"$colors$error",bg:"$$tooltipColor"},invert:{$$tooltipColor:"$colors$foreground",bg:"$$tooltipColor"}},contentColor:{default:{$$tooltipTextColor:"$colors$text",color:"$$tooltipTextColor"},primary:{$$tooltipTextColor:"$colors$primary",color:"$$tooltipTextColor"},secondary:{$$tooltipTextColor:"$colors$secondary",color:"$$tooltipTextColor"},success:{$$tooltipTextColor:"$colors$success",color:"$$tooltipTextColor"},warning:{$$tooltipTextColor:"$colors$warning",color:"$$tooltipTextColor"},error:{$$tooltipTextColor:"$colors$error",color:"$$tooltipTextColor"},invert:{$$tooltipTextColor:"$colors$invert",color:"$$tooltipTextColor"}},rounded:{true:{br:"$pill"}},shadow:{true:{bs:"$md"}},animated:{true:{transition:"opacity 0.25s ease 0s, top 0.25s ease 0s"},false:{transition:"none"}}},compoundVariants:[{color:"primary",contentColor:"default",css:{$$tooltipTextColor:"$colors$white"}},{color:"secondary",contentColor:"default",css:{$$tooltipTextColor:"$colors$white"}},{color:"success",contentColor:"default",css:{$$tooltipTextColor:"$colors$white"}},{color:"error",contentColor:"default",css:{$$tooltipTextColor:"$colors$white"}},{color:"invert",contentColor:"default",css:{$$tooltipTextColor:"$colors$background"}}],defaultVariants:{color:"default",contentColor:"default"}});exports.StyledTooltipContent=e;

/***/ }),

/***/ 66551:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(78965)).default;exports["default"]=r,module.exports=exports.default;

/***/ }),

/***/ 78965:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;var e=__webpack_require__(18038);const t={scrollLayer:!1},r=new Map,o=e=>!!(e.touches&&e.touches.length>1)||(e.preventDefault(),!1);var n=(n,u)=>{if("undefined"==typeof document)return[!1,e=>e];const s=n||(0,e.useRef)(document.body),[d,c]=(0,e.useState)(!1),a={...t,...u||{}},l=()=>!a.scrollLayer&&(!("undefined"==typeof window||!window.navigator)&&/iP(ad|hone|od)/.test(window.navigator.platform));return(0,e.useEffect)((()=>{if(!s||!s.current)return;const e=s.current.style.overflow;if(d){if(r.has(s.current))return;return l()?document.addEventListener("touchmove",o,{passive:!1}):s.current.style.overflow="hidden",void r.set(s.current,{last:e})}if(r.has(s.current)){if(l())document.removeEventListener("touchmove",o);else{const e=r.get(s.current);s.current.style.overflow=e.last}r.delete(s.current)}}),[d,s]),[d,c]};exports["default"]=n,module.exports=exports.default;

/***/ }),

/***/ 31709:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(28728)).default;exports["default"]=r,module.exports=exports.default;

/***/ }),

/***/ 28728:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;var e=__webpack_require__(18038);var t=t=>{(0,e.useEffect)((()=>{const e=e=>t(e);return document.addEventListener("click",e),()=>document.removeEventListener("click",e)}),[t])};exports["default"]=t,module.exports=exports.default;

/***/ }),

/***/ 69152:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(56244)).default;exports["default"]=r,module.exports=exports.default;

/***/ }),

/***/ 56244:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;var e=__webpack_require__(18038);var t=(t,r)=>{(0,e.useEffect)((()=>{const e=e=>{const o=t.current;e&&o&&!o.contains(e.target)&&r(e)};return document.addEventListener("click",e),()=>document.removeEventListener("click",e)}),[t,r])};exports["default"]=t,module.exports=exports.default;

/***/ }),

/***/ 12458:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(70885)).default;exports["default"]=r,module.exports=exports.default;

/***/ }),

/***/ 70885:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=__webpack_require__(18038),t=e(__webpack_require__(79090)),o=__webpack_require__(10084),n=__webpack_require__(81595);const a={onError:()=>n.__DEV__&&(0,o.warn)("Failed to copy.","use-clipboard")};var l=(e=a)=>{const o=(0,t.default)("clipboard"),n=(0,r.useCallback)((r=>{((r,t)=>{if(!r||!t)return;const o=window.getSelection();if(!o)return;r.style.whiteSpace="pre",r.textContent=t;const n=window.document.createRange();o.removeAllRanges(),n.selectNode(r),o.addRange(n);try{window.document.execCommand("copy")}catch(r){e.onError&&e.onError()}o.removeAllRanges(),r&&(r.textContent="")})(o,r)}),[o]);return{copy:n}};exports["default"]=l,module.exports=exports.default;

/***/ }),

/***/ 32821:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(81503)).default;exports["default"]=r,module.exports=exports.default;

/***/ }),

/***/ 81503:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;var e=__webpack_require__(18038);var t=t=>{const[r,u]=(0,e.useState)((()=>"function"==typeof t?t():t)),o=(0,e.useRef)(t);(0,e.useEffect)((()=>{o.current=r}),[r]);return[r,e=>{const t="function"==typeof e?e(o.current):e;o.current=t,u(t)},o]};exports["default"]=t,module.exports=exports.default;

/***/ }),

/***/ 19964:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(38904)).default;exports["default"]=r,module.exports=exports.default;

/***/ }),

/***/ 38904:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;var e=__webpack_require__(18038);var t=(t=!1,r)=>{const[o,u]=(0,e.useState)(t),[n,l]=(0,e.useState)(0),[s,i]=(0,e.useState)(0);return{visible:o,x:n,y:s,onClick:e=>{if(!r.current)return;const t=r.current.getBoundingClientRect();u(!0),l(e.clientX-t.left),i(e.clientY-t.top)},onCompleted:()=>{u(!1),l(0),i(0)}}};exports["default"]=t,module.exports=exports.default;

/***/ }),

/***/ 46960:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(72443)).default;exports["default"]=r,module.exports=exports.default;

/***/ }),

/***/ 72443:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=e(__webpack_require__(32821));var r=e=>{const[r,u,a]=(0,t.default)(e);return{value:r,setValue:u,currentRef:a,reset:()=>u(e),bindings:{value:r,onChange:e=>{"object"==typeof e&&e.target?u(e.target.value):u(e)}}}};exports["default"]=r,module.exports=exports.default;

/***/ }),

/***/ 20027:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(86186)).default;exports["default"]=r,module.exports=exports.default;

/***/ }),

/***/ 86186:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;var e=__webpack_require__(18038);var r=function(r,{threshold:t=0,root:n=null,rootMargin:o="0%",freezeOnceVisible:s=!1}={}){const[i,u]=(0,e.useState)(),l=(null==i?void 0:i.isIntersecting)&&s,d=!(null==i||!i.isIntersecting),c=([e])=>{u(e)};return(0,e.useEffect)((()=>{if("undefined"==typeof window)return;const e=null==r?void 0:r.current;if(!!!window.IntersectionObserver||l||!e)return;const s=new IntersectionObserver(c,{threshold:t,root:n,rootMargin:o});return s.observe(e),()=>s.disconnect()}),[r,t,n,o,l]),{entry:i,setEntry:u,isVisible:d,isFrozen:l}};exports["default"]=r,module.exports=exports.default;

/***/ }),

/***/ 88957:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.KeyMod=exports.KeyCode=void 0;exports.KeyCode={Unknown:0,Backspace:8,Tab:9,Enter:13,Shift:16,Ctrl:17,Alt:18,PauseBreak:19,CapsLock:20,Escape:27,Space:32,PageUp:33,PageDown:34,End:35,Home:36,LeftArrow:37,UpArrow:38,RightArrow:39,DownArrow:40,Insert:45,Delete:46,KEY_0:48,KEY_1:49,KEY_2:50,KEY_3:51,KEY_4:52,KEY_5:53,KEY_6:54,KEY_7:55,KEY_8:56,KEY_9:57,KEY_A:65,KEY_B:66,KEY_C:67,KEY_D:68,KEY_E:69,KEY_F:70,KEY_G:71,KEY_H:72,KEY_I:73,KEY_J:74,KEY_K:75,KEY_L:76,KEY_M:77,KEY_N:78,KEY_O:79,KEY_P:80,KEY_Q:81,KEY_R:82,KEY_S:83,KEY_T:84,KEY_U:85,KEY_V:86,KEY_W:87,KEY_X:88,KEY_Y:89,KEY_Z:90,Meta:91,F1:112,F2:113,F3:114,F4:115,F5:116,F6:117,F7:118,F8:119,F9:120,F10:121,F11:122,F12:123,NumLock:144,ScrollLock:145,Equal:187,Minus:189,Backquote:192,Backslash:220};exports.KeyMod={CtrlCmd:2048,Shift:1024,Alt:512,WinCtrl:256};

/***/ }),

/***/ 67635:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.getCtrlKeysByPlatform=exports.getActiveModMap=void 0;var e=__webpack_require__(36828),t=__webpack_require__(72625),r=__webpack_require__(88957);exports.getCtrlKeysByPlatform=()=>({CtrlCmd:(0,t.isMac)()?"metaKey":"ctrlKey",WinCtrl:(0,t.isMac)()?"ctrlKey":"metaKey"});exports.getActiveModMap=t=>{const o=t.filter((t=>!!(0,e.getKeyValue)(r.KeyMod,t))),l={CtrlCmd:!1,Shift:!1,Alt:!1,WinCtrl:!1};return o.forEach((t=>{const o=(0,e.getKeyValue)(r.KeyMod,t);l[o]=!0})),l};

/***/ }),

/***/ 60690:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(77277)),o=__webpack_require__(88957);exports.KeyMod=o.KeyMod,exports.KeyCode=o.KeyCode;var d=r.default;exports["default"]=d;

/***/ }),

/***/ 77277:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;var e=__webpack_require__(18038),t=__webpack_require__(36828),r=__webpack_require__(88957),o=__webpack_require__(67635);var n=(n,s,a={})=>{const l=Array.isArray(s)?s:[s],{disableGlobalEvent:u=!1,capture:p=!1,stopPropagation:d=!1,preventDefault:y=!1,event:i="keydown"}=a,c=(0,o.getActiveModMap)(l),f=l.filter((e=>!(0,t.getKeyValue)(r.KeyMod,e))),{CtrlCmd:v,WinCtrl:C}=(0,o.getCtrlKeysByPlatform)(),K=e=>{c.Shift&&!e.shiftKey||c.Alt&&!e.altKey||c.CtrlCmd&&!e[v]||c.WinCtrl&&!e[C]||f.length>0&&!f.includes(e.keyCode)||(d&&e.stopPropagation(),y&&e.preventDefault(),n&&n(e))};(0,e.useEffect)((()=>(u||document.addEventListener(i,K),()=>{document.removeEventListener(i,K)})),[u]);const k=(e,t=!1)=>e!==i||t!==p?()=>{}:e=>K(e);return{bindings:{onKeyDown:k("keydown"),onKeyDownCapture:k("keydown",!0),onKeyPress:k("keypress"),onKeyPressCapture:k("keypress",!0),onKeyUp:k("keyup"),onKeyUpCapture:k("keyup",!0)}}};exports["default"]=n,module.exports=exports.default;

/***/ }),

/***/ 60704:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=exports.DOTS=void 0;var e=__webpack_require__(18038),t=__webpack_require__(45036);exports.DOTS="dots";var r=({page:r,total:a,siblings:s=1,boundaries:n=1,initialPage:o=1,onChange:u})=>{const[i,g]=(0,e.useState)(r||o),l=(0,e.useMemo)((()=>void 0!==r),[r]);(0,e.useEffect)((()=>{r&&r!==i&&g(r)}),[r,i]);const d=(0,e.useCallback)((e=>{l||g(e),null==u||u(e)}),[g,u,l]),c=(0,e.useCallback)((e=>{d(e<=0?1:e>a?a:e)}),[d,a]);return{range:(0,e.useMemo)((()=>{if(2*s+3+2*n>=a)return(0,t.range)(1,a);const e=Math.max(i-s,n),r=Math.min(i+s,a-n),o=e>n+2,u=r<a-(n+1);if(!o&&u){const e=2*s+n+2;return[...(0,t.range)(1,e),"dots",...(0,t.range)(a-(n-1),a)]}if(o&&!u){const e=n+1+2*s;return[...(0,t.range)(1,n),"dots",...(0,t.range)(a-e,a)]}return[...(0,t.range)(1,n),"dots",...(0,t.range)(e,r),"dots",...(0,t.range)(a-n+1,a)]}),[a,s,i]),active:i,setPage:c,next:()=>c(i+1),previous:()=>c(i-1),first:()=>c(1),last:()=>c(a)}};exports["default"]=r;

/***/ }),

/***/ 79090:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(13915)).default;exports["default"]=r,module.exports=exports.default;

/***/ }),

/***/ 13915:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=__webpack_require__(18038),r=e(__webpack_require__(90658)),u=__webpack_require__(72625);const l=e=>{const t=document.createElement("div");return t.setAttribute("id",e),t};var o=(e=(0,u.getId)(),o)=>{const s=`nextui-${e}`,{isBrowser:i}=(0,r.default)(),[n,d]=(0,t.useState)(i?l(s):null);return(0,t.useEffect)((()=>{const e=(o?o():null)||document.body,t=null==e?void 0:e.querySelector(`#${s}`),r=t||l(s);t||e.appendChild(r),d(r)}),[]),n};exports["default"]=o,module.exports=exports.default;

/***/ }),

/***/ 57539:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(62806)).default;exports["default"]=r,module.exports=exports.default;

/***/ }),

/***/ 62806:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.getRealShape=exports["default"]=void 0;var e=__webpack_require__(18038);const t=(e,t)=>{if(!e)return 0;const i=e.includes("px")?+e.split("px")[0]:e.includes("%")?+e.split("%")[0]*t*.01:e;return Number.isNaN(+i)?0:+i},i=e=>{if(!e||"undefined"==typeof window)return{width:0,height:0};const i=e.getBoundingClientRect(),{width:r,height:h}=window.getComputedStyle(e);return{width:t(`${r}`,i.width),height:t(`${h}`,i.height)}};exports.getRealShape=i;var r=t=>{const[r,h]=(0,e.useState)({width:0,height:0}),n=()=>{const{width:e,height:r}=i(t.current);h({width:e,height:r})};return(0,e.useEffect)((()=>n()),[t.current]),[r,n]};exports["default"]=r;

/***/ }),

/***/ 31650:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(71275)).default;exports["default"]=r,module.exports=exports.default;

/***/ }),

/***/ 71275:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;var e=__webpack_require__(18038);var r=(r,t=!0)=>{(0,e.useEffect)((()=>{const e=()=>r();return t&&e(),window.addEventListener("resize",e),()=>window.removeEventListener("resize",e)}),[])};exports["default"]=r,module.exports=exports.default;

/***/ }),

/***/ 93517:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(53845)).default;exports["default"]=r,module.exports=exports.default;

/***/ }),

/***/ 53845:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;var e=__webpack_require__(18038);const r="undefined"!=typeof window;function t(e){return r?e?{x:e.scrollLeft,y:e.scrollTop}:{x:window.scrollX,y:window.scrollY}:{x:0,y:0}}var n=r=>{const{elementRef:n,wait:l=30,callback:o,enabled:u}=r,c=(0,e.useRef)(u?t(null==n?void 0:n.current):{x:0,y:0});let s=null;const d=()=>{const e=t(null==n?void 0:n.current);"function"==typeof o&&o({prevPos:c.current,currPos:e}),c.current=e,s=null};return(0,e.useEffect)((()=>{if(!u)return;const e=()=>{l?null===s&&(s=setTimeout(d,l)):d()},r=(null==n?void 0:n.current)||window;return r.addEventListener("scroll",e),()=>r.removeEventListener("scroll",e)}),[null==n?void 0:n.current,l,u]),c.current};exports["default"]=n,module.exports=exports.default;

/***/ }),

/***/ 90658:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(66354)).default;exports["default"]=r,module.exports=exports.default;

/***/ }),

/***/ 66354:
/***/ ((module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=void 0;var e=__webpack_require__(18038);var t=()=>{const[t,o]=(0,e.useState)(!1);return(0,e.useEffect)((()=>{o(Boolean("undefined"!=typeof window&&window.document&&window.document.createElement))}),[]),{isBrowser:t,isServer:!t}};exports["default"]=t,module.exports=exports.default;

/***/ }),

/***/ 47902:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(4222)).default;exports["default"]=r,module.exports=exports.default;

/***/ }),

/***/ 4222:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=e(__webpack_require__(18038)),r=e(__webpack_require__(66756));var u=()=>t.default.useContext(r.default);exports["default"]=u,module.exports=exports.default;

/***/ }),

/***/ 96956:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledUserName=exports.StyledUserInfo=exports.StyledUserDesc=exports.StyledUser=void 0;var r=e(__webpack_require__(76846)),s=e(__webpack_require__(51313)),t=__webpack_require__(40);exports.StyledUser=t.StyledUser,exports.StyledUserInfo=t.StyledUserInfo,exports.StyledUserName=t.StyledUserName,exports.StyledUserDesc=t.StyledUserDesc,r.default.Link=s.default;var l=r.default;exports["default"]=l;

/***/ }),

/***/ 51313:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var r=e(__webpack_require__(18038)),t=e(__webpack_require__(74222)),l=e(__webpack_require__(62358)),a=__webpack_require__(81595),u=__webpack_require__(56786);const i=r.default.forwardRef(((e,r)=>{const{rel:a="noopener",color:i="primary",target:s="_blank",className:o,children:n,...d}=e;return(0,u.jsx)(t.default,{ref:r,className:(0,l.default)("nextui-user-link",o),color:i,rel:a,target:s,...d,children:n})}));a.__DEV__&&(i.displayName="NextUI.UserLink"),i.toString=()=>".nextui-user-link";var s=r.default.memo(i);exports["default"]=s,module.exports=exports.default;

/***/ }),

/***/ 76846:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports["default"]=exports.User=void 0;var e=__webpack_require__(94135),r=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=a(r);if(t&&t.has(e))return t.get(e);var s={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in e)if("default"!==o&&Object.prototype.hasOwnProperty.call(e,o)){var u=n?Object.getOwnPropertyDescriptor(e,o):null;u&&(u.get||u.set)?Object.defineProperty(s,o,u):s[o]=e[o]}s.default=e,t&&t.set(e,s);return s}(__webpack_require__(18038)),t=__webpack_require__(77335),s=__webpack_require__(80345),n=__webpack_require__(73726),o=__webpack_require__(81595),u=__webpack_require__(40),i=__webpack_require__(56786);function a(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(a=function(e){return e?t:r})(e)}const c=r.default.forwardRef(((o,a)=>{const{as:c,css:l,src:d,text:f,name:p,children:x,altText:m,color:y,squared:b,bordered:j,size:q,description:v,zoomed:O,pointer:g,...U}=o,_=(0,n.useDOMRef)(a),{isFocusVisible:h,focusProps:M}=(0,e.useFocusRing)(),N=(0,r.useMemo)((()=>{if("button"===c)return{borderRadius:"$xs",background:"none",appearance:"none",p:0,m:0,outline:"none",border:"none",cursor:"pointer"}}),[c]);return(0,i.jsxs)(u.StyledUser,{ref:_,as:c,...(0,t.mergeProps)(U,M),css:{...N,...l},isFocusVisible:h,children:[(0,i.jsx)(s.Avatar,{alt:m,bordered:j,className:"nextui-user-avatar",color:y,pointer:g,size:q,squared:b,src:d,text:f,zoomed:O}),(0,i.jsxs)(u.StyledUserInfo,{className:"nextui-user-info",children:[(0,i.jsx)(u.StyledUserName,{className:"nextui-user-name",children:p}),(0,i.jsx)(u.StyledUserDesc,{className:"nextui-user-desc",children:v||x})]})]})}));exports.User=c,o.__DEV__&&(c.displayName="NextUI.User"),c.toString=()=>".nextui-user";var l=c;exports["default"]=l;

/***/ }),

/***/ 40:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.StyledUserName=exports.StyledUserInfo=exports.StyledUserDesc=exports.StyledUser=void 0;var e=__webpack_require__(88194),s=__webpack_require__(74042);const t=(0,e.styled)("div",{d:"inline-flex",p:"0 $sm",jc:"center",ai:"center",w:"max-content",maxWidth:"100%",transition:"transform 250ms ease 0ms, box-shadow 0.25s ease 0s","@motion":{transition:"none"}},s.cssFocusVisible);exports.StyledUser=t;const o=(0,e.styled)("div",{ml:"$sm",d:"inline-flex",fd:"column",alignItems:"flex-start",whiteSpace:"nowrap"});exports.StyledUserInfo=o;const r=(0,e.styled)("span",{fontSize:"$sm",color:"$text",lh:"$sm",fontWeight:"$medium",maxW:"$60",to:"ellipsis",ov:"hidden"});exports.StyledUserName=r;const n=(0,e.styled)("span",{fontSize:"$xs",color:"$accents7","*:first-child":{mt:0},"*:last-child":{mb:0}});exports.StyledUserDesc=n;

/***/ }),

/***/ 31675:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.reboundAnimation=exports.appearanceOut=exports.appearanceIn=void 0;var a=__webpack_require__(88194);const e=(0,a.keyframes)({"0%":{transform:"scale(0.95)"},"40%":{transform:"scale(1.02)"},"80%":{transform:"scale(0.98)"},"100%":{transform:"scale(1)"}});exports.reboundAnimation=e;const r=(0,a.keyframes)({"0%":{opacity:0,transform:"scale(0.95)"},"60%":{opacity:.75,transform:"scale(1.02)"},"100%":{opacity:1,transform:"scale(1)"}});exports.appearanceIn=r;const s=(0,a.keyframes)({"0%":{opacity:1,transform:"scale(1)"},"100%":{opacity:0,transform:"scale(0.95)"}});exports.appearanceOut=s;

/***/ }),

/***/ 81595:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.__TEST__=exports.__DEV__=void 0,exports.isArray=r,exports.isEmpty=function(t){return r(t)?e(t):o(t)?s(t):null==t||""===t},exports.isEmptyArray=e,exports.isEmptyObject=s,exports.isFunction=function(t){return"function"==typeof t},exports.isObject=o;const t="production"!=="production";exports.__DEV__=t;const n="test"==="production";function r(t){return Array.isArray(t)}function e(t){return r(t)&&0===t.length}function o(t){const n=typeof t;return null!=t&&("object"===n||"function"===n)&&!r(t)}function s(t){return o(t)&&0===Object.keys(t).length}exports.__TEST__=n;

/***/ }),

/***/ 99389:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports.stroke=exports["default"]=void 0;e(__webpack_require__(18038));var r=__webpack_require__(88194),t=e(__webpack_require__(62358)),s=__webpack_require__(81595),i=__webpack_require__(56786);const o=(0,r.keyframes)({"100%":{strokeDashoffset:0}});exports.stroke=o;const a=(0,r.styled)("svg",{d:"block",path:{transformOrigin:"50% 50%",strokeDasharray:48,strokeDashoffset:48,animation:`${o} .25s cubic-bezier(0.650, 0.000, 0.450, 1.000) forwards`}}),c=e=>{const{width:r=24,height:s=24,size:o,strokeWidth:c=3,fill:l="currentColor",css:h,className:n}=e;return(0,i.jsx)(a,{className:(0,t.default)("nextui-checkmark",n),css:h,height:o||s,role:"img",viewBox:"0 0 52 52",width:o||r,xmlns:"http://www.w3.org/2000/svg",children:(0,i.jsx)("path",{d:"M14.1 27.2l7.1 7.2 16.7-16.8",fill:"none",stroke:l,strokeWidth:c})})};s.__DEV__&&(c.displayName="NextUI.Checkmark"),c.toString=()=>".nextui-checkmark";var l=c;exports["default"]=l;

/***/ }),

/***/ 77162:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=a(t);if(r&&r.has(e))return r.get(e);var i={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var l in e)if("default"!==l&&Object.prototype.hasOwnProperty.call(e,l)){var o=n?Object.getOwnPropertyDescriptor(e,l):null;o&&(o.get||o.set)?Object.defineProperty(i,l,o):i[l]=e[l]}i.default=e,r&&r.set(e,i);return i}(__webpack_require__(18038)),r=e(__webpack_require__(25457)),i=__webpack_require__(56786);function a(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(a=function(e){return e?r:t})(e)}const n=({size:e,fill:t,plain:r,width:a,height:n,className:l,...o})=>r?(0,i.jsx)("svg",{className:l,fill:"none",height:e||n,stroke:t,strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,viewBox:"0 0 24 24",width:e||a,...o,children:(0,i.jsx)("path",{d:"M18 6L6 18M6 6l12 12"})}):(0,i.jsx)("svg",{className:l,height:e||n,viewBox:"0 0 24 24",width:e||a,...o,children:(0,i.jsx)("path",{d:"M12 2a10 10 0 1010 10A10.016 10.016 0 0012 2zm3.36 12.3a.754.754 0 010 1.06.748.748 0 01-1.06 0l-2.3-2.3-2.3 2.3a.748.748 0 01-1.06 0 .754.754 0 010-1.06l2.3-2.3-2.3-2.3A.75.75 0 019.7 8.64l2.3 2.3 2.3-2.3a.75.75 0 011.06 1.06l-2.3 2.3z",fill:t})}),l=t.memo(n);var o=(0,r.default)(l,{width:24,height:24,plain:!1,className:""});exports["default"]=o,module.exports=exports.default;

/***/ }),

/***/ 62358:
/***/ ((module, exports) => {

function e(r){var t,o,f="";if("string"==typeof r||"number"==typeof r)f+=r;else if("object"==typeof r)if(Array.isArray(r))for(t=0;t<r.length;t++)r[t]&&(o=e(r[t]))&&(f&&(f+=" "),f+=o);else for(t in r)r[t]&&(f&&(f+=" "),f+=t);return f}exports.__esModule=!0,exports["default"]=function(...r){var t,o,f=0,n="";for(;f<r.length;)(t=r[f++])&&(o=e(t))&&(n&&(n+=" "),n+=o);return n},module.exports=exports.default;

/***/ }),

/***/ 72625:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports.setChildrenIndex=exports.pickSingleChild=exports.pickChild=exports.pick=exports.isMac=exports.isChildElement=exports.isBrowser=exports.hasChild=exports.getId=exports.flattenArray=void 0;var t=e(__webpack_require__(18038));exports.getId=()=>Math.random().toString(32).slice(2,10);exports.hasChild=(e,r)=>(t.default.Children.map(e,(e=>t.default.isValidElement(e)?e.type:null))||[]).includes(r);exports.pick=(e,t)=>e.reduce(((e,r)=>(e[r]=t[r],e)),{});const r=(e,r)=>{let n=[];return[t.default.Children.map(e,(e=>t.default.isValidElement(e)&&e.type===r?(n.push(e),null):e)),n.length>=0?n:void 0]};exports.pickChild=r;exports.pickSingleChild=(e,t)=>{const[n,i]=r(e,t);let l=null;return i&&i.length>=1&&(l=i.length>=0?i[0]:void 0),[n,l]};exports.isChildElement=(e,t)=>{if(!e||!t)return!1;let r=t;for(;r;){if(r===e)return!0;r=r.parentNode}return!1};const n=()=>Boolean("undefined"!=typeof window&&window.document&&window.document.createElement);exports.isBrowser=n;exports.isMac=()=>!!n()&&navigator.platform.toUpperCase().indexOf("MAC")>=0;exports.setChildrenIndex=(e,r=[])=>{if(0===t.default.Children.count(e))return[];const n=0===r.length,i=(e,r={})=>t.default.cloneElement(e,r);let l=0;return t.default.Children.map(e,(e=>{if(!t.default.isValidElement(e))return e;if(l+=1,n)return i(e,{index:l});return r.find((t=>t===e.type))?i(e,{index:l}):(l-=1,e)}))};const i=e=>e.reduce(((e,t)=>e.concat(Array.isArray(t)?i(t):t)),[]);exports.flattenArray=i;

/***/ }),

/***/ 36403:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.rgbToRgba=exports.isSimpleColor=exports.isNormalColor=exports.isHex=exports.isCssVar=exports.isColor=exports.invertHex=exports.hexToRgb=exports.hexToRGBA=exports.hexFromString=exports.getCssVar=exports.colorToRgbValues=exports.addColorAlpha=void 0;var r=__webpack_require__(65654);const e=(r,e=null)=>{if("undefined"==typeof document||!r)return"";const o=e||document.documentElement,s=t(r)?r.replace("var(","").replace(")",""):r.includes("--")?r:`--${r}`;return getComputedStyle(o).getPropertyValue(s)};exports.getCssVar=e;const t=r=>!(!r||0!==(null==r?void 0:r.indexOf("var(")));exports.isCssVar=t;const o=r=>/#[a-fA-F0-9]{3,6}/g.test(r);exports.isHex=o;const s=(r,e=1)=>{let t=0,o=0,s=0;return 4==r.length?(t="0x"+r[1]+r[1],o="0x"+r[2]+r[2],s="0x"+r[3]+r[3]):7==r.length&&(t="0x"+r[1]+r[2],o="0x"+r[3]+r[4],s="0x"+r[5]+r[6]),`rgba(${+t},${+o},${+s},${e})`};exports.hexToRGBA=s;exports.isNormalColor=e=>{let t=r.normalColors.find((r=>r===e));return null!=t};exports.isSimpleColor=e=>{let t=r.simpleColors.find((r=>r===e));return null!=t};exports.isColor=r=>{let e=(new Option).style;return e.color=r,e.color==r};const n=r=>{const e=r.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,((r,e,t,o)=>`${e}${e}${t}${t}${o}${o}`)),t=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);if(!t)throw new Error(`Next UI: Unsupported ${r} color.`);return[Number.parseInt(t[1],16),Number.parseInt(t[2],16),Number.parseInt(t[3],16)]};exports.hexToRgb=n;exports.hexFromString=(r,e="",t=!1)=>{const o=r.match(/#[a-fA-F0-9]{6}|#[a-fA-F0-9]{3}$/g);return o&&o.length>0?t?o[o.length-1]:o:e};const l=r=>{const o=t(r)?e(r):r;if("#"===o.charAt(0))return n(o);const s=o.replace(/ /g,""),l=o.substr(0,4),p=s.match(/\((.+)\)/);return l.startsWith("rgb")&&p?p[1].split(",").map((r=>Number.parseFloat(r))):(console.warn('NextUI: Only supports ["RGB", "RGBA", "HEX"] color.'),[0,0,0])};exports.colorToRgbValues=l;exports.addColorAlpha=(r,n=1)=>{if(!r)return"";const p=t(r)?e(r):r;if(o(p))return s(p,n);if(!/^#|rgb|RGB/.test(p))return p;const[a,i,x]=l(p);return`rgba(${a}, ${i}, ${x}, ${n>1?1:n<0?0:n})`};function p(r,e){return e=e||2,(new Array(e).join("0")+r).slice(-e)}exports.rgbToRgba=(r,e=1)=>{const[t,o,s]=r.split(",").map((r=>Number.parseFloat(r)));return`rgba(${t}, ${o}, ${s}, ${e>1?1:e<0?0:e})`};exports.invertHex=(r,o=!0)=>{let s=t(r)?e(r):r;if(0===s.indexOf("#")&&(s=s.slice(1)),3===s.length&&(s=s[0]+s[0]+s[1]+s[1]+s[2]+s[2]),6!==s.length)return r;let n=parseInt(s.slice(0,2),16),l=parseInt(s.slice(2,4),16),a=parseInt(s.slice(4,6),16);return o?.299*n+.587*l+.114*a>186?"#000000":"#FFFFFF":(n=255-n,l=255-l,a=255-a,"#"+p(n.toString(16))+p(l.toString(16))+p(a.toString(16)))};

/***/ }),

/***/ 10084:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.warn=void 0;const o={};exports.warn=(e,n)=>{const r=`[Next UI]${n?` [${n}]`:" "}: ${e}`;if("undefined"!=typeof console&&!o[r]){if(o[r]=!0,"production"!=="production")return console.error(r);console.warn(r)}};

/***/ }),

/***/ 19938:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.createContext=function(t={}){const{strict:r=!0,errorMessage:n="useContext: `context` is undefined. Seems you forgot to wrap component within the Provider",name:o}=t,a=e.createContext(void 0);return a.displayName=o,[a.Provider,function t(){const o=e.useContext(a);if(!o&&r){const e=new Error(n);throw e.name="ContextError",null==Error.captureStackTrace||Error.captureStackTrace(e,t),e}return o},a]};var e=function(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var n=t(r);if(n&&n.has(e))return n.get(e);var o={},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&Object.prototype.hasOwnProperty.call(e,u)){var c=a?Object.getOwnPropertyDescriptor(e,u):null;c&&(c.get||c.set)?Object.defineProperty(o,u,c):o[u]=e[u]}o.default=e,n&&n.set(e,o);return o}(__webpack_require__(18038));function t(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,n=new WeakMap;return(t=function(e){return e?n:r})(e)}

/***/ }),

/***/ 91863:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=n(t);if(r&&r.has(e))return r.get(e);var l={},u=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if("default"!==a&&Object.prototype.hasOwnProperty.call(e,a)){var o=u?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(l,a,o):l[a]=e[a]}l.default=e,r&&r.set(e,l);return l}(__webpack_require__(18038)),r=e(__webpack_require__(62358));function n(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(n=function(e){return e?r:t})(e)}const l=({children:e,onExited:n,onEntered:l,className:u,childrenRef:a,enterTime:o=60,leaveTime:i=60,clearTime:s=60,visible:c=!1,name:f="transition",...p})=>{const[d,m]=(0,t.useState)(""),[v,y]=(0,t.useState)(c);return(0,t.useLayoutEffect)((()=>{const e=c?"enter":"leave";c&&!v&&y(!0),m(`${f}-${e}`);const t=c?o:i,r=setTimeout((()=>{m(`${f}-${e} ${f}-${e}-active`),"leave"===e?null==n||n():null==l||l(),clearTimeout(r)}),t),u=setTimeout((()=>{c||(m(""),y(!1)),clearTimeout(u)}),t+s);return()=>{clearTimeout(r),clearTimeout(u)}}),[c,v]),(0,t.useEffect)((()=>{if(null==a||!a.current)return;const e=d.split(" "),t=a.current.className.split(" ").filter((e=>!e.includes(f)));a.current.className=(0,r.default)(t,e)}),[a,d]),t.default.isValidElement(e)&&v?t.default.cloneElement(e,{...p,className:(0,r.default)(e.props.className,u,!(null!=a&&a.current)&&d)}):null};var u=t.default.memo(l);exports["default"]=u,module.exports=exports.default;

/***/ }),

/***/ 77159:
/***/ ((module, exports) => {

exports.__esModule=!0,exports["default"]=function t(e){var o,r,l=Array.prototype.slice.call(arguments,1);for(;l.length;)for(r in o=l.shift())o.hasOwnProperty(r)&&("object"==typeof e[r]&&e[r]&&"[object Array]"!==Object.prototype.toString.call(e[r])&&"object"==typeof o[r]&&null!==o[r]?e[r]=t({},e[r],o[r]):e[r]=o[r]);return e},module.exports=exports.default;

/***/ }),

/***/ 72844:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.getMargin=void 0;exports.getMargin=e=>`calc(${15.25*e}pt + 1px * ${e-1})`;

/***/ }),

/***/ 73726:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.canUseDOM=t,exports.createDOMRef=n,exports.createFocusableRef=u,exports.detectBrowser=function(e){return!!r&&function(e){const{userAgent:t,vendor:r}=e,n=/(android)/i.test(t);switch(!0){case/CriOS/.test(t):return"Chrome for iOS";case/Edg\//.test(t):return"Edge";case n&&/Silk\//.test(t):return"Silk";case/Chrome/.test(t)&&/Google Inc/.test(r):return"Chrome";case/Firefox\/\d+\.\d+$/.test(t):return"Firefox";case n:return"AOSP";case/MSIE|Trident/.test(t):return"IE";case/Safari/.test(e.userAgent)&&/Apple Computer/.test(t):return"Safari";case/AppleWebKit/.test(t):return"WebKit";default:return null}}(window.navigator)===e},exports.detectDeviceType=function(e){const{userAgent:t}=e;return/(tablet)|(iPad)|(Nexus 9)/i.test(t)?"tablet":/(mobi)/i.test(t)?"phone":"desktop"},exports.detectOS=function(e){return!!r&&function(e){const{userAgent:t,platform:r}=e;switch(!0){case/Android/.test(t):return"Android";case/iPhone|iPad|iPod/.test(r):return"iOS";case/Win/.test(r):return"Windows";case/Mac/.test(r):return"Mac";case/CrOS/.test(t):return"Chrome OS";case/Firefox/.test(t):return"Firefox OS";default:return null}}(window.navigator)===e},exports.detectTouch=function(){return!!r&&(null===window.ontouchstart&&null===window.ontouchmove&&null===window.ontouchend)},exports.isBrowser=void 0,exports.useDOMRef=function(t){const r=(0,e.useRef)(null);return(0,e.useImperativeHandle)(t,(()=>r.current)),r},exports.useFocusableRef=function(t,r){const n=(0,e.useRef)(null);return(0,e.useImperativeHandle)(t,(()=>u(n,r))),n},exports.useSyncRef=function(t,r){(0,e.useLayoutEffect)((()=>{if(t&&t.ref&&r&&r.current)return t.ref.current=r.current,()=>{var e;null!=(e=t.ref)&&e.current&&(t.ref.current=null)}}),[t,r])};var e=__webpack_require__(18038);function t(){return!("undefined"==typeof window||!window.document||!window.document.createElement)}const r=t();function n(e){return{UNSAFE_getDOMNode:()=>e.current}}function u(e,t=e){return{...n(e),focus(){t.current&&t.current.focus()}}}exports.isBrowser=r;

/***/ }),

/***/ 24192:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=exports.StyledDrip=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=l(t);if(r&&r.has(e))return r.get(e);var i={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in e)if("default"!==o&&Object.prototype.hasOwnProperty.call(e,o)){var a=n?Object.getOwnPropertyDescriptor(e,o):null;a&&(a.get||a.set)?Object.defineProperty(i,o,a):i[o]=e[o]}i.default=e,r&&r.set(e,i);return i}(__webpack_require__(18038)),r=__webpack_require__(88194),i=e(__webpack_require__(25457)),n=e(__webpack_require__(62358)),o=__webpack_require__(56786);function l(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(l=function(e){return e?r:t})(e)}const a=(0,r.keyframes)({"0%":{opacity:0,transform:"scale(0.25)"},"30%":{opacity:1},"80%":{opacity:.5},"100%":{transform:"scale(28)",opacity:0}}),s=(0,r.styled)("div",{position:"absolute",left:0,right:0,top:0,bottom:0,"& svg":{position:"absolute",animation:`350ms linear ${a}`,animationFillMode:"forwards",width:"$md",height:"$md"}});exports.StyledDrip=s;const u=({visible:e,x:r,y:i,color:l,onCompleted:a,className:u,...f})=>{const c=(0,t.useRef)(null),d=Number.isNaN(+i)?0:i-10,p=Number.isNaN(+r)?0:r-10;return(0,t.useEffect)((()=>{let e=c.current;if(e)return e.addEventListener("animationend",a),()=>{e&&e.removeEventListener("animationend",a)}})),e?(0,o.jsx)(s,{ref:c,className:(0,n.default)("nextui-drip",u),...f,children:(0,o.jsx)("svg",{height:"20",style:{top:d,left:p},viewBox:"0 0 20 20",width:"20",children:(0,o.jsx)("g",{fill:"none",fillRule:"evenodd",stroke:"none",strokeWidth:"1",children:(0,o.jsx)("g",{className:"nextui-drip-filler",fill:l,children:(0,o.jsx)("rect",{height:"100%",rx:"10",width:"100%"})})})})}):null},f=t.default.memo(u);var c=(0,i.default)(f,{visible:!1,x:0,y:0,className:""});exports["default"]=c;

/***/ }),

/***/ 96075:
/***/ ((module, exports, __webpack_require__) => {

var e=__webpack_require__(27574);exports.__esModule=!0,exports["default"]=void 0;var t=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=a(t);if(r&&r.has(e))return r.get(e);var u={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if("default"!==i&&Object.prototype.hasOwnProperty.call(e,i)){var o=n?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(u,i,o):u[i]=e[i]}u.default=e,r&&r.set(e,u);return u}(__webpack_require__(18038)),r=__webpack_require__(88194),u=e(__webpack_require__(25457)),n=e(__webpack_require__(57539)),i=__webpack_require__(56786);function a(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(a=function(e){return e?r:t})(e)}const o=(0,r.styled)("div",{p:0,m:0,h:0,opacity:0,overflow:"hidden",variants:{expanded:{true:{opacity:1}}}});var s=(0,u.default)((({isExpanded:e,delay:r,animated:u,css:a,children:s})=>{const[c,l]=(0,t.useState)(e?"auto":"0"),[d,f]=(0,t.useState)(e),p=(0,t.useRef)(null),h=(0,t.useRef)(),m=(0,t.useRef)(),x=(0,t.useRef)(),[y,v]=(0,n.default)(p);return(0,t.useEffect)((()=>l(`${y.height}px`)),[y.height]),(0,t.useEffect)((()=>{if(e!==d)return e||(v(),l(`${y.height}px`)),h.current=window.setTimeout((()=>{f(e),clearTimeout(h.current)}),30),e?x.current=window.setTimeout((()=>{l("auto"),clearTimeout(x.current)}),r):m.current=window.setTimeout((()=>{clearTimeout(m.current)}),r/2),()=>{clearTimeout(h.current),clearTimeout(m.current),clearTimeout(x.current)}}),[e]),(0,i.jsx)(o,{css:{height:d?c:"0",transition:u?`height ${r}ms ease 0ms,\n    opacity ${1.5*r}ms ease 0ms;`:"none",...a},expanded:d,children:(0,i.jsx)("div",{ref:p,className:"nextui-expand-content",children:s})})}),{isExpanded:!1,animated:!0,delay:200});exports["default"]=s,module.exports=exports.default;

/***/ }),

/***/ 45036:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.range=function(e,r){const n=r-e+1;return Array.from({length:n},((r,n)=>n+e))},exports.valueToPercent=function(e,r,n){return 100*(e-r)/(n-r)};

/***/ }),

/***/ 36828:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.renameProp=exports.omitObject=exports.isObject=exports.getProp=exports.getKeyValue=exports.copyObject=exports.cleanObjectKeys=exports.cleanObject=exports.arrayToObject=void 0;const e=e=>e&&"object"==typeof e;exports.isObject=e;exports.renameProp=(e,r,{[e]:t,...o})=>({[r]:t,...o});exports.copyObject=r=>e(r)?r instanceof Array?[...r]:{...r}:r;exports.omitObject=(r,t)=>{if(!e(r))return r;if(r instanceof Array)return[...r];const o={...r};return t.forEach((e=>o[e]&&delete o[e])),o};exports.cleanObject=r=>{if(!e(r))return r;if(r instanceof Array)return[...r];const t={...r};return Object.keys(t).forEach((e=>{void 0!==t[e]&&null!==t[e]||delete t[e]})),t};exports.cleanObjectKeys=(r,t=[])=>{if(!e(r))return r;if(r instanceof Array)return[...r];const o={...r};return t.forEach((e=>{o[e]&&delete o[e]})),o};exports.getKeyValue=(r,t)=>e(r)?r instanceof Array?[...r]:r[t]:r;exports.getProp=(e,r,t,o)=>{const s="string"==typeof r?r.split("."):[r];for(o=0;o<s.length&&e;o+=1)e=e[s[o]];return void 0===e?t:e};exports.arrayToObject=e=>e.length&&Array.isArray(e)?e.reduce(((e,r)=>({...e,...r})),{}):{};

/***/ }),

/***/ 65654:
/***/ ((__unused_webpack_module, exports) => {

exports.__esModule=!0,exports.tuple=exports.textWeights=exports.textTransforms=exports.simpleColors=exports.normalWeights=exports.normalLoaders=exports.normalColors=exports.extraColors=exports.extendedColorsNoGradient=exports.extendedColors=exports.excludedInputPropsForTextarea=void 0;const e=(...e)=>e;exports.tuple=e;e("xs","sm","md","lg","xl");const t=e("default","primary","secondary","success","warning","error","gradient");exports.normalColors=t;const r=e("default","primary","secondary","success","warning","error");exports.simpleColors=r;const o=e("default","primary","secondary","success","warning","error","invert","gradient");exports.extendedColors=o;const n=e("default","primary","secondary","success","warning","error","invert");exports.extendedColorsNoGradient=n;const s=e("default","primary","secondary","success","warning","error","dark","lite","alert","purple","violet","gradient","cyan");exports.extraColors=s;const l=e("default","points","points-opacity","gradient","spinner");exports.normalLoaders=l;const a=e("light","normal","bold","extrabold","black");exports.normalWeights=a;const i=e("normal","bold","lighter","bolder","inherit","initial","revert","unset");exports.textWeights=i;const c=e("none","capitalize","uppercase","lowercase","full-width","full-size-kana","inherit","initial","revert","unset");exports.textTransforms=c;e("default","slient","prevent"),e("hover","click"),e("top","topStart","topEnd","left","leftStart","leftEnd","bottom","bottomStart","bottomEnd","right","rightStart","rightEnd"),e("static","relative","absolute","fixed","sticky","inherit","initial","revert","unset"),e("contain","cover","fill","none","scale-down","inherit","initial","revert","unset"),e("start","center","end","left","right"),e("flex-start","center","flex-end","space-between","space-around","space-evenly"),e("flex-start","flex-end","center","stretch","baseline"),e("stretch","center","flex-start","flex-end","space-between","space-around"),e("row","row-reverse","column","column-reverse"),e("nowrap","wrap","wrap-reverse"),e("flex","block","grid","inline","inline-block","inline-flex","inline-grid"),e("left","right"),e("start","center","end");const d=e("clearable","as","rounded","labelLeft","labelRight","contentLeft","contentRight","contentClickable","contentLeftStyling","contentRightStyling","onContentClick","onClearClick","css");exports.excludedInputPropsForTextarea=d;e("toggle","replace"),e("none","single","multiple"),e("flat","light","solid","shadow"),e("flat","bordered","shadow");

/***/ }),

/***/ 45728:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.assignRef=r,exports.mergeRefs=function(...e){return n=>{e.forEach((e=>r(e,n)))}};var e=__webpack_require__(81595);function r(r,n){if(null!=r)if((0,e.isFunction)(r))r(n);else try{r.current=n}catch(e){throw new Error(`Cannot assign value '${n}' to ref '${r}'`)}}

/***/ }),

/***/ 93795:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.__esModule=!0,exports.forwardRef=function(e){return(0,r.forwardRef)(e)};var r=__webpack_require__(18038);

/***/ }),

/***/ 25457:
/***/ ((module, exports) => {

exports.__esModule=!0,exports["default"]=void 0;var e=(e,o)=>(e.defaultProps=o,e);exports["default"]=e,module.exports=exports.default;

/***/ }),

/***/ 20662:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $eeQ2i$reactariautils = __webpack_require__(13431);
var $eeQ2i$reactariafocus = __webpack_require__(75494);
var $eeQ2i$reactariainteractions = __webpack_require__(92390);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useButton", () => $988353faa005faf8$export$ea18c227d4417cc3);
$parcel$export(module.exports, "useToggleButton", () => $c49208f7d2aac50b$export$51e84d46ca0bc451);




function $988353faa005faf8$export$ea18c227d4417cc3(props, ref) {
    let { elementType: elementType = 'button' , isDisabled: isDisabled , onPress: onPress , onPressStart: onPressStart , onPressEnd: onPressEnd , onPressChange: onPressChange , preventFocusOnPress: // @ts-ignore - undocumented
    preventFocusOnPress , allowFocusWhenDisabled: // @ts-ignore - undocumented
    allowFocusWhenDisabled , // @ts-ignore
    onClick: deprecatedOnClick , href: href , target: target , rel: rel , type: type = 'button'  } = props;
    let additionalProps;
    if (elementType === 'button') additionalProps = {
        type: type,
        disabled: isDisabled
    };
    else additionalProps = {
        role: 'button',
        tabIndex: isDisabled ? undefined : 0,
        href: elementType === 'a' && isDisabled ? undefined : href,
        target: elementType === 'a' ? target : undefined,
        type: elementType === 'input' ? type : undefined,
        disabled: elementType === 'input' ? isDisabled : undefined,
        'aria-disabled': !isDisabled || elementType === 'input' ? undefined : isDisabled,
        rel: elementType === 'a' ? rel : undefined
    };
    let { pressProps: pressProps , isPressed: isPressed  } = $eeQ2i$reactariainteractions.usePress({
        onPressStart: onPressStart,
        onPressEnd: onPressEnd,
        onPressChange: onPressChange,
        onPress: onPress,
        isDisabled: isDisabled,
        preventFocusOnPress: preventFocusOnPress,
        ref: ref
    });
    let { focusableProps: focusableProps  } = $eeQ2i$reactariafocus.useFocusable(props, ref);
    if (allowFocusWhenDisabled) focusableProps.tabIndex = isDisabled ? -1 : focusableProps.tabIndex;
    let buttonProps = $eeQ2i$reactariautils.mergeProps(focusableProps, pressProps, $eeQ2i$reactariautils.filterDOMProps(props, {
        labelable: true
    }));
    return {
        isPressed: isPressed,
        buttonProps: $eeQ2i$reactariautils.mergeProps(additionalProps, buttonProps, {
            'aria-haspopup': props['aria-haspopup'],
            'aria-expanded': props['aria-expanded'],
            'aria-controls': props['aria-controls'],
            'aria-pressed': props['aria-pressed'],
            onClick: (e)=>{
                if (deprecatedOnClick) {
                    deprecatedOnClick(e);
                    console.warn('onClick is deprecated, please use onPress');
                }
            }
        })
    };
}





function $c49208f7d2aac50b$export$51e84d46ca0bc451(props, state, ref) {
    const { isSelected: isSelected  } = state;
    const { isPressed: isPressed , buttonProps: buttonProps  } = $988353faa005faf8$export$ea18c227d4417cc3({
        ...props,
        onPress: $eeQ2i$reactariautils.chain(state.toggle, props.onPress)
    }, ref);
    return {
        isPressed: isPressed,
        buttonProps: $eeQ2i$reactariautils.mergeProps(buttonProps, {
            'aria-pressed': isSelected
        })
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 75494:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $aB6Cp$react = __webpack_require__(18038);
var $aB6Cp$reactariautils = __webpack_require__(13431);
var $aB6Cp$reactariainteractions = __webpack_require__(92390);
var $aB6Cp$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "FocusScope", () => $a7a032acae3ddda9$export$20e40289641fbbb6);
$parcel$export(module.exports, "useFocusManager", () => $a7a032acae3ddda9$export$10c5169755ce7bd7);
$parcel$export(module.exports, "getFocusableTreeWalker", () => $a7a032acae3ddda9$export$2d6ec8fc375ceafa);
$parcel$export(module.exports, "createFocusManager", () => $a7a032acae3ddda9$export$c5251b9e124bf29);
$parcel$export(module.exports, "isElementInChildOfActiveScope", () => $a7a032acae3ddda9$export$1258395f99bf9cbf);
$parcel$export(module.exports, "FocusRing", () => $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d);
$parcel$export(module.exports, "FocusableProvider", () => $fb504d83237fd6ac$export$13f3202a3e5ddd5);
$parcel$export(module.exports, "useFocusable", () => $fb504d83237fd6ac$export$4c014de7c8940b4c);
$parcel$export(module.exports, "useFocusRing", () => $581a96d6eb128c1b$export$4e328f61c538687f);
$parcel$export(module.exports, "focusSafely", () => $1c7f9157d722357d$export$80f3e147d781571c);
$parcel$export(module.exports, "useHasTabbableChild", () => $259c6413a286f2e6$export$eac1895992b9f3d6);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1c7f9157d722357d$export$80f3e147d781571c(element) {
    // If the user is interacting with a virtual cursor, e.g. screen reader, then
    // wait until after any animated transitions that are currently occurring on
    // the page before shifting focus. This avoids issues with VoiceOver on iOS
    // causing the page to scroll when moving focus if the element is transitioning
    // from off the screen.
    if ((0, $aB6Cp$reactariainteractions.getInteractionModality)() === "virtual") {
        let lastFocusedElement = document.activeElement;
        (0, $aB6Cp$reactariautils.runAfterTransition)(()=>{
            // If focus did not move and the element is still in the document, focus it.
            if (document.activeElement === lastFocusedElement && document.contains(element)) (0, $aB6Cp$reactariautils.focusWithoutScrolling)(element);
        });
    } else (0, $aB6Cp$reactariautils.focusWithoutScrolling)(element);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d5156037ad898a4d$var$isStyleVisible(element) {
    if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) return false;
    let { display: display , visibility: visibility  } = element.style;
    let isVisible = display !== "none" && visibility !== "hidden" && visibility !== "collapse";
    if (isVisible) {
        const { getComputedStyle: getComputedStyle  } = element.ownerDocument.defaultView;
        let { display: computedDisplay , visibility: computedVisibility  } = getComputedStyle(element);
        isVisible = computedDisplay !== "none" && computedVisibility !== "hidden" && computedVisibility !== "collapse";
    }
    return isVisible;
}
function $d5156037ad898a4d$var$isAttributeVisible(element, childElement) {
    return !element.hasAttribute("hidden") && (element.nodeName === "DETAILS" && childElement && childElement.nodeName !== "SUMMARY" ? element.hasAttribute("open") : true);
}
function $d5156037ad898a4d$export$e989c0fffaa6b27a(element, childElement) {
    return element.nodeName !== "#comment" && $d5156037ad898a4d$var$isStyleVisible(element) && $d5156037ad898a4d$var$isAttributeVisible(element, childElement) && (!element.parentElement || $d5156037ad898a4d$export$e989c0fffaa6b27a(element.parentElement, element));
}




const $a7a032acae3ddda9$var$FocusContext = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createContext(null);
let $a7a032acae3ddda9$var$activeScope = null;
function $a7a032acae3ddda9$export$20e40289641fbbb6(props) {
    let { children: children , contain: contain , restoreFocus: restoreFocus , autoFocus: autoFocus  } = props;
    let startRef = (0, $aB6Cp$react.useRef)();
    let endRef = (0, $aB6Cp$react.useRef)();
    let scopeRef = (0, $aB6Cp$react.useRef)([]);
    let { parentNode: parentNode  } = (0, $aB6Cp$react.useContext)($a7a032acae3ddda9$var$FocusContext) || {};
    // Create a tree node here so we can add children to it even before it is added to the tree.
    let node = (0, $aB6Cp$react.useMemo)(()=>new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: scopeRef
        }), [
        scopeRef
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),
        // use the active scope as the parent instead of the parent from context. Layout effects run bottom
        // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope
        // that is being added should get the activeScope as its parent.
        let parent = parentNode || $a7a032acae3ddda9$export$d06fae2ee68b101e.root;
        if ($a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(parent.scopeRef) && $a7a032acae3ddda9$var$activeScope && !$a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, parent.scopeRef)) {
            let activeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
            if (activeNode) parent = activeNode;
        }
        // Add the node to the parent, and to the tree.
        parent.addChild(node);
        $a7a032acae3ddda9$export$d06fae2ee68b101e.addNode(node);
    }, [
        node,
        parentNode
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let node = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef);
        node.contain = contain;
    }, [
        contain
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        // Find all rendered nodes between the sentinels and add them to the scope.
        let node = startRef.current.nextSibling;
        let nodes = [];
        while(node && node !== endRef.current){
            nodes.push(node);
            node = node.nextSibling;
        }
        scopeRef.current = nodes;
    }, [
        children
    ]);
    $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain);
    $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus);
    // this layout effect needs to run last so that focusScopeTree cleanup happens at the last moment possible
    (0, $aB6Cp$react.useEffect)(()=>{
        if (scopeRef) {
            let activeElement = document.activeElement;
            let scope = null;
            // In strict mode, active scope is incorrectly updated since cleanup will run even though scope hasn't unmounted.
            // To fix this, we need to update the actual activeScope here
            if ($a7a032acae3ddda9$var$isElementInScope(activeElement, scopeRef.current)) {
                // Since useLayoutEffect runs for children first, we need to traverse the focusScope tree and find the bottom most scope that
                // contains the active element and set that as the activeScope
                for (let node of $a7a032acae3ddda9$export$d06fae2ee68b101e.traverse())if ($a7a032acae3ddda9$var$isElementInScope(activeElement, node.scopeRef.current)) scope = node;
                if (scope === $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef)) $a7a032acae3ddda9$var$activeScope = scope.scopeRef;
            }
            return ()=>{
                // Scope may have been re-parented.
                let parentScope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).parent.scopeRef;
                // Restore the active scope on unmount if this scope or a descendant scope is active.
                // Parent effect cleanups run before children, so we need to check if the
                // parent scope actually still exists before restoring the active scope to it.
                if ((scopeRef === $a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope(scopeRef, $a7a032acae3ddda9$var$activeScope)) && (!parentScope || $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(parentScope))) $a7a032acae3ddda9$var$activeScope = parentScope;
                $a7a032acae3ddda9$export$d06fae2ee68b101e.removeTreeNode(scopeRef);
            };
        }
    }, [
        scopeRef
    ]);
    let focusManager = (0, $aB6Cp$react.useMemo)(()=>$a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef), []);
    let value = (0, $aB6Cp$react.useMemo)(()=>({
            focusManager: focusManager,
            parentNode: node
        }), [
        node,
        focusManager
    ]);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement($a7a032acae3ddda9$var$FocusContext.Provider, {
        value: value
    }, /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement("span", {
        "data-focus-scope-start": true,
        hidden: true,
        ref: startRef
    }), children, /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement("span", {
        "data-focus-scope-end": true,
        hidden: true,
        ref: endRef
    }));
}
function $a7a032acae3ddda9$export$10c5169755ce7bd7() {
    var _useContext;
    return (_useContext = (0, $aB6Cp$react.useContext)($a7a032acae3ddda9$var$FocusContext)) === null || _useContext === void 0 ? void 0 : _useContext.focusManager;
}
function $a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef) {
    return {
        focusNext (opts = {}) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[0].previousElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = sentinel;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = {}) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[scope.length - 1].nextElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = sentinel;
                previousNode = walker.previousNode();
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = {}) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[0].previousElementSibling;
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = {}) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[scope.length - 1].nextElementSibling;
            let previousNode = walker.previousNode();
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        }
    };
}
const $a7a032acae3ddda9$var$focusableElements = [
    "input:not([disabled]):not([type=hidden])",
    "select:not([disabled])",
    "textarea:not([disabled])",
    "button:not([disabled])",
    "a[href]",
    "area[href]",
    "summary",
    "iframe",
    "object",
    "embed",
    "audio[controls]",
    "video[controls]",
    "[contenteditable]"
];
const $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
$a7a032acae3ddda9$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(':not([hidden]):not([tabindex="-1"]),');
function $a7a032acae3ddda9$var$getScopeRoot(scope) {
    return scope[0].parentElement;
}
function $a7a032acae3ddda9$var$shouldContainFocus(scopeRef) {
    let scope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
    while(scope && scope.scopeRef !== scopeRef){
        if (scope.contain) return false;
        scope = scope.parent;
    }
    return true;
}
function $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain) {
    let focusedNode = (0, $aB6Cp$react.useRef)();
    let raf = (0, $aB6Cp$react.useRef)(null);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let scope = scopeRef.current;
        if (!contain) {
            // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment
            if (raf.current) {
                cancelAnimationFrame(raf.current);
                raf.current = null;
            }
            return;
        }
        // Handle the Tab key to contain focus within the scope
        let onKeyDown = (e)=>{
            if (e.key !== "Tab" || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) return;
            let focusedElement = document.activeElement;
            let scope = scopeRef.current;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scope)) return;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: true
            }, scope);
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!nextElement) {
                walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;
                nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            }
            e.preventDefault();
            if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
        };
        let onFocus = (e)=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if ((!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) && $a7a032acae3ddda9$var$isElementInScope(e.target, scopeRef.current)) {
                $a7a032acae3ddda9$var$activeScope = scopeRef;
                focusedNode.current = e.target;
            } else if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(e.target, scopeRef)) {
                // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),
                // restore focus to the previously focused node or the first tabbable element in the active scope.
                if (focusedNode.current) focusedNode.current.focus();
                else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
            } else if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) focusedNode.current = e.target;
        };
        let onBlur = (e)=>{
            // Firefox doesn't shift focus back to the Dialog properly without this
            if (raf.current) cancelAnimationFrame(raf.current);
            raf.current = requestAnimationFrame(()=>{
                // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe
                if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(document.activeElement, scopeRef)) {
                    $a7a032acae3ddda9$var$activeScope = scopeRef;
                    if (document.body.contains(e.target)) {
                        focusedNode.current = e.target;
                        focusedNode.current.focus();
                    } else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
                }
            });
        };
        document.addEventListener("keydown", onKeyDown, false);
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        scope.forEach((element)=>element.addEventListener("focusout", onBlur, false));
        return ()=>{
            document.removeEventListener("keydown", onKeyDown, false);
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
            scope.forEach((element)=>element.removeEventListener("focusout", onBlur, false));
        };
    }, [
        scopeRef,
        contain
    ]);
    // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur
    // eslint-disable-next-line arrow-body-style
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        return ()=>{
            if (raf.current) cancelAnimationFrame(raf.current);
        };
    }, [
        raf
    ]);
}
function $a7a032acae3ddda9$var$isElementInAnyScope(element) {
    return $a7a032acae3ddda9$var$isElementInChildScope(element);
}
function $a7a032acae3ddda9$var$isElementInScope(element, scope) {
    return scope.some((node)=>node.contains(element));
}
function $a7a032acae3ddda9$var$isElementInChildScope(element, scope = null) {
    // If the element is within a top layer element (e.g. toasts), always allow moving focus there.
    if (element instanceof Element && element.closest("[data-react-aria-top-layer]")) return true;
    // node.contains in isElementInScope covers child scopes that are also DOM children,
    // but does not cover child scopes in portals.
    for (let { scopeRef: s  } of $a7a032acae3ddda9$export$d06fae2ee68b101e.traverse($a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scope))){
        if ($a7a032acae3ddda9$var$isElementInScope(element, s.current)) return true;
    }
    return false;
}
function $a7a032acae3ddda9$export$1258395f99bf9cbf(element) {
    return $a7a032acae3ddda9$var$isElementInChildScope(element, $a7a032acae3ddda9$var$activeScope);
}
function $a7a032acae3ddda9$var$isAncestorScope(ancestor, scope) {
    var _focusScopeTree_getTreeNode;
    let parent = (_focusScopeTree_getTreeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scope)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : _focusScopeTree_getTreeNode.parent;
    while(parent){
        if (parent.scopeRef === ancestor) return true;
        parent = parent.parent;
    }
    return false;
}
function $a7a032acae3ddda9$var$focusElement(element, scroll = false) {
    if (element != null && !scroll) try {
        (0, $1c7f9157d722357d$export$80f3e147d781571c)(element);
    } catch (err) {
    // ignore
    }
    else if (element != null) try {
        element.focus();
    } catch (err) {
    // ignore
    }
}
function $a7a032acae3ddda9$var$focusFirstInScope(scope, tabbable = true) {
    let sentinel = scope[0].previousElementSibling;
    let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
        tabbable: tabbable
    }, scope);
    walker.currentNode = sentinel;
    let nextNode = walker.nextNode();
    // If the scope does not contain a tabbable element, use the first focusable element.
    if (tabbable && !nextNode) {
        walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
            tabbable: false
        }, scope);
        walker.currentNode = sentinel;
        nextNode = walker.nextNode();
    }
    $a7a032acae3ddda9$var$focusElement(nextNode);
}
function $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus) {
    const autoFocusRef = (0, ($parcel$interopDefault($aB6Cp$react))).useRef(autoFocus);
    (0, $aB6Cp$react.useEffect)(()=>{
        if (autoFocusRef.current) {
            $a7a032acae3ddda9$var$activeScope = scopeRef;
            if (!$a7a032acae3ddda9$var$isElementInScope(document.activeElement, $a7a032acae3ddda9$var$activeScope.current)) $a7a032acae3ddda9$var$focusFirstInScope(scopeRef.current);
        }
        autoFocusRef.current = false;
    }, [
        scopeRef
    ]);
}
function $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restore, contain) {
    // tracks the active scope, in case restore and contain are both false.
    // if either are true, this is tracked in useRestoreFocus or useFocusContainment.
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if (restore || contain) return;
        let scope = scopeRef.current;
        let onFocus = (e)=>{
            let target = e.target;
            if ($a7a032acae3ddda9$var$isElementInScope(target, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
            else if (!$a7a032acae3ddda9$var$isElementInAnyScope(target)) $a7a032acae3ddda9$var$activeScope = null;
        };
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        return ()=>{
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
        };
    }, [
        scopeRef,
        restore,
        contain
    ]);
}
function $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef) {
    let scope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
    while(scope && scope.scopeRef !== scopeRef){
        if (scope.nodeToRestore) return false;
        scope = scope.parent;
    }
    return (scope === null || scope === void 0 ? void 0 : scope.scopeRef) === scopeRef;
}
function $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
    // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.
    const nodeToRestoreRef = (0, $aB6Cp$react.useRef)(typeof document !== "undefined" ? document.activeElement : null);
    // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus
    // restoring-non-containing scopes should only care if they become active so they can perform the restore
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let scope = scopeRef.current;
        if (!restoreFocus || contain) return;
        let onFocus = ()=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if ((!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) && $a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
        };
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        return ()=>{
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        scopeRef,
        contain
    ]);
    // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if (!restoreFocus) return;
        $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = nodeToRestoreRef.current;
        // Handle the Tab key so that tabbing out of the scope goes to the next element
        // after the node that had focus when the scope mounted. This is important when
        // using portals for overlays, so that focus goes to the expected element when
        // tabbing out of the overlay.
        let onKeyDown = (e)=>{
            if (e.key !== "Tab" || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) return;
            let focusedElement = document.activeElement;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scopeRef.current)) return;
            let nodeToRestore = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;
            // Create a DOM tree walker that matches all tabbable elements
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(document.body, {
                tabbable: true
            });
            // Find the next tabbable element after the currently focused element
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!document.body.contains(nodeToRestore) || nodeToRestore === document.body) {
                nodeToRestore = null;
                $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = null;
            }
            // If there is no next element, or it is outside the current scope, move focus to the
            // next element after the node to restore to instead.
            if ((!nextElement || !$a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {
                walker.currentNode = nodeToRestore;
                // Skip over elements within the scope, in case the scope immediately follows the node to restore.
                do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
                while ($a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current));
                e.preventDefault();
                e.stopPropagation();
                if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
                else // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)
                // then move focus to the body.
                // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)
                if (!$a7a032acae3ddda9$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();
                else $a7a032acae3ddda9$var$focusElement(nodeToRestore, true);
            }
        };
        if (!contain) document.addEventListener("keydown", onKeyDown, true);
        return ()=>{
            if (!contain) document.removeEventListener("keydown", onKeyDown, true);
            let nodeToRestore = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;
            // if we already lost focus to the body and this was the active scope, then we should attempt to restore
            if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps
            ($a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current) || document.activeElement === document.body && $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef))) {
                // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it
                let clonedTree = $a7a032acae3ddda9$export$d06fae2ee68b101e.clone();
                requestAnimationFrame(()=>{
                    // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere
                    if (document.activeElement === document.body) {
                        // look up the tree starting with our scope to find a nodeToRestore still in the DOM
                        let treeNode = clonedTree.getTreeNode(scopeRef);
                        while(treeNode){
                            if (treeNode.nodeToRestore && document.body.contains(treeNode.nodeToRestore)) {
                                $a7a032acae3ddda9$var$focusElement(treeNode.nodeToRestore);
                                return;
                            }
                            treeNode = treeNode.parent;
                        }
                        // If no nodeToRestore was found, focus the first element in the nearest
                        // ancestor scope that is still in the tree.
                        treeNode = clonedTree.getTreeNode(scopeRef);
                        while(treeNode){
                            if (treeNode.scopeRef && $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(treeNode.scopeRef)) {
                                $a7a032acae3ddda9$var$focusFirstInScope(treeNode.scopeRef.current, true);
                                return;
                            }
                            treeNode = treeNode.parent;
                        }
                    }
                });
            }
        };
    }, [
        scopeRef,
        restoreFocus,
        contain
    ]);
}
function $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, opts, scope) {
    let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR : $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR;
    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode (node) {
            var _opts_from;
            // Skip nodes inside the starting node.
            if (opts === null || opts === void 0 ? void 0 : (_opts_from = opts.from) === null || _opts_from === void 0 ? void 0 : _opts_from.contains(node)) return NodeFilter.FILTER_REJECT;
            if (node.matches(selector) && (0, $d5156037ad898a4d$export$e989c0fffaa6b27a)(node) && (!scope || $a7a032acae3ddda9$var$isElementInScope(node, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node))) return NodeFilter.FILTER_ACCEPT;
            return NodeFilter.FILTER_SKIP;
        }
    });
    if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;
    return walker;
}
function $a7a032acae3ddda9$export$c5251b9e124bf29(ref, defaultOptions = {}) {
    return {
        focusNext (opts = {}) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = root;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            else {
                let next = $a7a032acae3ddda9$var$last(walker);
                if (next) $a7a032acae3ddda9$var$focusElement(next, true);
                return next;
            }
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = root;
                previousNode = $a7a032acae3ddda9$var$last(walker);
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let next = $a7a032acae3ddda9$var$last(walker);
            if (next) $a7a032acae3ddda9$var$focusElement(next, true);
            return next;
        }
    };
}
function $a7a032acae3ddda9$var$last(walker) {
    let next;
    let last;
    do {
        last = walker.lastChild();
        if (last) next = last;
    }while (last);
    return next;
}
class $a7a032acae3ddda9$var$Tree {
    get size() {
        return this.fastMap.size;
    }
    getTreeNode(data) {
        return this.fastMap.get(data);
    }
    addTreeNode(scopeRef, parent, nodeToRestore) {
        let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);
        let node = new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: scopeRef
        });
        parentNode.addChild(node);
        node.parent = parentNode;
        this.fastMap.set(scopeRef, node);
        if (nodeToRestore) node.nodeToRestore = nodeToRestore;
    }
    addNode(node) {
        this.fastMap.set(node.scopeRef, node);
    }
    removeTreeNode(scopeRef) {
        // never remove the root
        if (scopeRef === null) return;
        let node = this.fastMap.get(scopeRef);
        let parentNode = node.parent;
        // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing
        // if we are, then replace the siblings restore with the restore from the scope we're removing
        for (let current of this.traverse())if (current !== node && node.nodeToRestore && current.nodeToRestore && node.scopeRef.current && $a7a032acae3ddda9$var$isElementInScope(current.nodeToRestore, node.scopeRef.current)) current.nodeToRestore = node.nodeToRestore;
        let children = node.children;
        parentNode.removeChild(node);
        if (children.size > 0) children.forEach((child)=>parentNode.addChild(child));
        this.fastMap.delete(node.scopeRef);
    }
    // Pre Order Depth First
    *traverse(node = this.root) {
        if (node.scopeRef != null) yield node;
        if (node.children.size > 0) for (let child of node.children)yield* this.traverse(child);
    }
    clone() {
        let newTree = new $a7a032acae3ddda9$var$Tree();
        for (let node of this.traverse())newTree.addTreeNode(node.scopeRef, node.parent.scopeRef, node.nodeToRestore);
        return newTree;
    }
    constructor(){
        this.fastMap = new Map();
        this.root = new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: null
        });
        this.fastMap.set(null, this.root);
    }
}
class $a7a032acae3ddda9$var$TreeNode {
    addChild(node) {
        this.children.add(node);
        node.parent = this;
    }
    removeChild(node) {
        this.children.delete(node);
        node.parent = undefined;
    }
    constructor(props){
        this.children = new Set();
        this.contain = false;
        this.scopeRef = props.scopeRef;
    }
}
let $a7a032acae3ddda9$export$d06fae2ee68b101e = new $a7a032acae3ddda9$var$Tree();


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 




function $581a96d6eb128c1b$export$4e328f61c538687f(props = {}) {
    let { autoFocus: autoFocus = false , isTextInput: isTextInput , within: within  } = props;
    let state = (0, $aB6Cp$react.useRef)({
        isFocused: false,
        isFocusVisible: autoFocus || (0, $aB6Cp$reactariainteractions.isFocusVisible)()
    });
    let [isFocused, setFocused] = (0, $aB6Cp$react.useState)(false);
    let [isFocusVisibleState, setFocusVisible] = (0, $aB6Cp$react.useState)(()=>state.current.isFocused && state.current.isFocusVisible);
    let updateState = (0, $aB6Cp$react.useCallback)(()=>setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
    let onFocusChange = (0, $aB6Cp$react.useCallback)((isFocused)=>{
        state.current.isFocused = isFocused;
        setFocused(isFocused);
        updateState();
    }, [
        updateState
    ]);
    (0, $aB6Cp$reactariainteractions.useFocusVisibleListener)((isFocusVisible)=>{
        state.current.isFocusVisible = isFocusVisible;
        updateState();
    }, [], {
        isTextInput: isTextInput
    });
    let { focusProps: focusProps  } = (0, $aB6Cp$reactariainteractions.useFocus)({
        isDisabled: within,
        onFocusChange: onFocusChange
    });
    let { focusWithinProps: focusWithinProps  } = (0, $aB6Cp$reactariainteractions.useFocusWithin)({
        isDisabled: !within,
        onFocusWithinChange: onFocusChange
    });
    return {
        isFocused: isFocused,
        isFocusVisible: isFocusVisibleState,
        focusProps: within ? focusWithinProps : focusProps
    };
}


function $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d(props) {
    let { children: children , focusClass: focusClass , focusRingClass: focusRingClass  } = props;
    let { isFocused: isFocused , isFocusVisible: isFocusVisible , focusProps: focusProps  } = (0, $581a96d6eb128c1b$export$4e328f61c538687f)(props);
    let child = (0, ($parcel$interopDefault($aB6Cp$react))).Children.only(children);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).cloneElement(child, (0, $aB6Cp$reactariautils.mergeProps)(child.props, {
        ...focusProps,
        className: (0, ($parcel$interopDefault($aB6Cp$clsx)))({
            [focusClass || ""]: isFocused,
            [focusRingClass || ""]: isFocusVisible
        })
    }));
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



let $fb504d83237fd6ac$var$FocusableContext = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createContext(null);
function $fb504d83237fd6ac$var$useFocusableContext(ref) {
    let context = (0, $aB6Cp$react.useContext)($fb504d83237fd6ac$var$FocusableContext) || {};
    (0, $aB6Cp$reactariautils.useSyncRef)(context, ref);
    // eslint-disable-next-line
    let { ref: _ , ...otherProps } = context;
    return otherProps;
}
/**
 * Provides DOM props to the nearest focusable child.
 */ function $fb504d83237fd6ac$var$FocusableProvider(props, ref) {
    let { children: children , ...otherProps } = props;
    let context = {
        ...otherProps,
        ref: ref
    };
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement($fb504d83237fd6ac$var$FocusableContext.Provider, {
        value: context
    }, children);
}
let $fb504d83237fd6ac$export$13f3202a3e5ddd5 = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).forwardRef($fb504d83237fd6ac$var$FocusableProvider);
function $fb504d83237fd6ac$export$4c014de7c8940b4c(props, domRef) {
    let { focusProps: focusProps  } = (0, $aB6Cp$reactariainteractions.useFocus)(props);
    let { keyboardProps: keyboardProps  } = (0, $aB6Cp$reactariainteractions.useKeyboard)(props);
    let interactions = (0, $aB6Cp$reactariautils.mergeProps)(focusProps, keyboardProps);
    let domProps = $fb504d83237fd6ac$var$useFocusableContext(domRef);
    let interactionProps = props.isDisabled ? {} : domProps;
    let autoFocusRef = (0, $aB6Cp$react.useRef)(props.autoFocus);
    (0, $aB6Cp$react.useEffect)(()=>{
        if (autoFocusRef.current && domRef.current) (0, $1c7f9157d722357d$export$80f3e147d781571c)(domRef.current);
        autoFocusRef.current = false;
    }, [
        domRef
    ]);
    return {
        focusableProps: (0, $aB6Cp$reactariautils.mergeProps)({
            ...interactions,
            tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined
        }, interactionProps)
    };
}




/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $259c6413a286f2e6$export$eac1895992b9f3d6(ref, options) {
    let isDisabled = options === null || options === void 0 ? void 0 : options.isDisabled;
    let [hasTabbableChild, setHasTabbableChild] = (0, $aB6Cp$react.useState)(false);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if ((ref === null || ref === void 0 ? void 0 : ref.current) && !isDisabled) {
            let update = ()=>{
                if (ref.current) {
                    let walker = (0, $a7a032acae3ddda9$export$2d6ec8fc375ceafa)(ref.current, {
                        tabbable: true
                    });
                    setHasTabbableChild(!!walker.nextNode());
                }
            };
            update();
            // Update when new elements are inserted, or the tabIndex/disabled attribute updates.
            let observer = new MutationObserver(update);
            observer.observe(ref.current, {
                subtree: true,
                childList: true,
                attributes: true,
                attributeFilter: [
                    "tabIndex",
                    "disabled"
                ]
            });
            return ()=>{
                // Disconnect mutation observer when a React update occurs on the top-level component
                // so we update synchronously after re-rendering. Otherwise React will emit act warnings
                // in tests since mutation observers fire asynchronously. The mutation observer is necessary
                // so we also update if a child component re-renders and adds/removes something tabbable.
                observer.disconnect();
            };
        }
    });
    return isDisabled ? false : hasTabbableChild;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 92390:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $goTMa$reactariautils = __webpack_require__(13431);
var $goTMa$react = __webpack_require__(18038);
var $goTMa$reactariassr = __webpack_require__(50897);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "Pressable", () => $e1dbec26039c051d$export$27c701ed9e449e99);
$parcel$export(module.exports, "PressResponder", () => $3596bae48579386f$export$3351871ee4b288b8);
$parcel$export(module.exports, "useFocus", () => $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6);
$parcel$export(module.exports, "isFocusVisible", () => $e77252a287ef94ab$export$b9b3dfddab17db27);
$parcel$export(module.exports, "getInteractionModality", () => $e77252a287ef94ab$export$630ff653c5ada6a9);
$parcel$export(module.exports, "setInteractionModality", () => $e77252a287ef94ab$export$8397ddfc504fdb9a);
$parcel$export(module.exports, "useInteractionModality", () => $e77252a287ef94ab$export$98e20ec92f614cfe);
$parcel$export(module.exports, "useFocusVisible", () => $e77252a287ef94ab$export$ffd9e5021c1fb2d6);
$parcel$export(module.exports, "useFocusVisibleListener", () => $e77252a287ef94ab$export$ec71b4b83ac08ec3);
$parcel$export(module.exports, "useFocusWithin", () => $d16842bbd0359d1b$export$420e68273165f4ec);
$parcel$export(module.exports, "useHover", () => $ffbc150311c75f01$export$ae780daf29e6d456);
$parcel$export(module.exports, "useInteractOutside", () => $edcfa848c42f94f4$export$872b660ac5a1ff98);
$parcel$export(module.exports, "useKeyboard", () => $892d64db2a3c53b0$export$8f71654801c2f7cd);
$parcel$export(module.exports, "useMove", () => $c09386fc48fa427d$export$36da96379f79f245);
$parcel$export(module.exports, "usePress", () => $0294ea432cd92340$export$45712eceda6fad21);
$parcel$export(module.exports, "useScrollWheel", () => $a3dbce0aed7087e2$export$2123ff2b87c81ca);
$parcel$export(module.exports, "useLongPress", () => $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element
// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually
let $f7e14e656343df57$var$state = "default";
let $f7e14e656343df57$var$savedUserSelect = "";
let $f7e14e656343df57$var$modifiedElementMap = new WeakMap();
function $f7e14e656343df57$export$16a4697467175487(target) {
    if ((0, $goTMa$reactariautils.isIOS)()) {
        if ($f7e14e656343df57$var$state === "default") {
            $f7e14e656343df57$var$savedUserSelect = document.documentElement.style.webkitUserSelect;
            document.documentElement.style.webkitUserSelect = "none";
        }
        $f7e14e656343df57$var$state = "disabled";
    } else if (target instanceof HTMLElement || target instanceof SVGElement) {
        // If not iOS, store the target's original user-select and change to user-select: none
        // Ignore state since it doesn't apply for non iOS
        $f7e14e656343df57$var$modifiedElementMap.set(target, target.style.userSelect);
        target.style.userSelect = "none";
    }
}
function $f7e14e656343df57$export$b0d6fa1ab32e3295(target) {
    if ((0, $goTMa$reactariautils.isIOS)()) {
        // If the state is already default, there's nothing to do.
        // If it is restoring, then there's no need to queue a second restore.
        if ($f7e14e656343df57$var$state !== "disabled") return;
        $f7e14e656343df57$var$state = "restoring";
        // There appears to be a delay on iOS where selection still might occur
        // after pointer up, so wait a bit before removing user-select.
        setTimeout(()=>{
            // Wait for any CSS transitions to complete so we don't recompute style
            // for the whole page in the middle of the animation and cause jank.
            (0, $goTMa$reactariautils.runAfterTransition)(()=>{
                // Avoid race conditions
                if ($f7e14e656343df57$var$state === "restoring") {
                    if (document.documentElement.style.webkitUserSelect === "none") document.documentElement.style.webkitUserSelect = $f7e14e656343df57$var$savedUserSelect || "";
                    $f7e14e656343df57$var$savedUserSelect = "";
                    $f7e14e656343df57$var$state = "default";
                }
            });
        }, 300);
    } else if (target instanceof HTMLElement || target instanceof SVGElement) // If not iOS, restore the target's original user-select if any
    // Ignore state since it doesn't apply for non iOS
    {
        if (target && $f7e14e656343df57$var$modifiedElementMap.has(target)) {
            let targetOldUserSelect = $f7e14e656343df57$var$modifiedElementMap.get(target);
            if (target.style.userSelect === "none") target.style.userSelect = targetOldUserSelect;
            if (target.getAttribute("style") === "") target.removeAttribute("style");
            $f7e14e656343df57$var$modifiedElementMap.delete(target);
        }
    }
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $01d3f539e91688c8$export$5165eccb35aaadb5 = (0, ($parcel$interopDefault($goTMa$react))).createContext(null);
$01d3f539e91688c8$export$5165eccb35aaadb5.displayName = "PressResponderContext";



function $0294ea432cd92340$var$usePressResponderContext(props) {
    // Consume context from <PressResponder> and merge with props.
    let context = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));
    if (context) {
        let { register: register , ...contextProps } = context;
        props = (0, $goTMa$reactariautils.mergeProps)(contextProps, props);
        register();
    }
    (0, $goTMa$reactariautils.useSyncRef)(context, props.ref);
    return props;
}
function $0294ea432cd92340$export$45712eceda6fad21(props) {
    let { onPress: onPress , onPressChange: onPressChange , onPressStart: onPressStart , onPressEnd: onPressEnd , onPressUp: onPressUp , isDisabled: isDisabled , isPressed: isPressedProp , preventFocusOnPress: preventFocusOnPress , shouldCancelOnPointerExit: shouldCancelOnPointerExit , allowTextSelectionOnPress: allowTextSelectionOnPress , // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: _ , ...domProps } = $0294ea432cd92340$var$usePressResponderContext(props);
    let [isPressed, setPressed] = (0, $goTMa$react.useState)(false);
    let ref = (0, $goTMa$react.useRef)({
        isPressed: false,
        ignoreEmulatedMouseEvents: false,
        ignoreClickAfterPress: false,
        didFirePressStart: false,
        activePointerId: null,
        target: null,
        isOverTarget: false,
        pointerType: null
    });
    let { addGlobalListener: addGlobalListener , removeAllGlobalListeners: removeAllGlobalListeners  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let triggerPressStart = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        let state = ref.current;
        if (isDisabled || state.didFirePressStart) return;
        if (onPressStart) onPressStart({
            type: "pressstart",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
        if (onPressChange) onPressChange(true);
        state.didFirePressStart = true;
        setPressed(true);
    });
    let triggerPressEnd = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType, wasPressed = true)=>{
        let state = ref.current;
        if (!state.didFirePressStart) return;
        state.ignoreClickAfterPress = true;
        state.didFirePressStart = false;
        if (onPressEnd) onPressEnd({
            type: "pressend",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
        if (onPressChange) onPressChange(false);
        setPressed(false);
        if (onPress && wasPressed && !isDisabled) onPress({
            type: "press",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let triggerPressUp = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        if (isDisabled) return;
        if (onPressUp) onPressUp({
            type: "pressup",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let cancel = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        let state = ref.current;
        if (state.isPressed) {
            if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
            state.isPressed = false;
            state.isOverTarget = false;
            state.activePointerId = null;
            state.pointerType = null;
            removeAllGlobalListeners();
            if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
        }
    });
    let cancelOnPointerExit = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (shouldCancelOnPointerExit) cancel(e);
    });
    let pressProps = (0, $goTMa$react.useMemo)(()=>{
        let state = ref.current;
        let pressProps = {
            onKeyDown (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {
                    if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                    e.stopPropagation();
                    // If the event is repeating, it may have started on a different element
                    // after which focus moved to the current element. Ignore these events and
                    // only handle the first key down event.
                    if (!state.isPressed && !e.repeat) {
                        state.target = e.currentTarget;
                        state.isPressed = true;
                        triggerPressStart(e, "keyboard");
                        // Focus may move before the key up event, so register the event on the document
                        // instead of the same element where the key down event occurred.
                        addGlobalListener(document, "keyup", onKeyUp, false);
                    }
                } else if (e.key === "Enter" && $0294ea432cd92340$var$isHTMLAnchorLink(e.currentTarget)) // If the target is a link, we won't have handled this above because we want the default
                // browser behavior to open the link when pressing Enter. But we still need to prevent
                // default so that elements above do not also handle it (e.g. table row).
                e.stopPropagation();
            },
            onKeyUp (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target)) triggerPressUp($0294ea432cd92340$var$createEvent(state.target, e), "keyboard");
            },
            onClick (e) {
                if (e && !e.currentTarget.contains(e.target)) return;
                if (e && e.button === 0) {
                    e.stopPropagation();
                    if (isDisabled) e.preventDefault();
                    // If triggered from a screen reader or by using element.click(),
                    // trigger as if it were a keyboard click.
                    if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && (state.pointerType === "virtual" || (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent))) {
                        // Ensure the element receives focus (VoiceOver on iOS does not do this)
                        if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                        triggerPressStart(e, "virtual");
                        triggerPressUp(e, "virtual");
                        triggerPressEnd(e, "virtual");
                    }
                    state.ignoreEmulatedMouseEvents = false;
                    state.ignoreClickAfterPress = false;
                }
            }
        };
        let onKeyUp = (e)=>{
            if (state.isPressed && $0294ea432cd92340$var$isValidKeyboardEvent(e, state.target)) {
                if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                e.stopPropagation();
                state.isPressed = false;
                let target = e.target;
                triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), "keyboard", state.target.contains(target));
                removeAllGlobalListeners();
                // If the target is a link, trigger the click method to open the URL,
                // but defer triggering pressEnd until onClick event handler.
                if (state.target instanceof HTMLElement && state.target.contains(target) && ($0294ea432cd92340$var$isHTMLAnchorLink(state.target) || state.target.getAttribute("role") === "link")) state.target.click();
            }
        };
        if (typeof PointerEvent !== "undefined") {
            pressProps.onPointerDown = (e)=>{
                // Only handle left clicks, and ignore events that bubbled through portals.
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.
                // Ignore and let the onClick handler take care of it instead.
                // https://bugs.webkit.org/show_bug.cgi?id=222627
                // https://bugs.webkit.org/show_bug.cgi?id=223202
                if ((0, $goTMa$reactariautils.isVirtualPointerEvent)(e.nativeEvent)) {
                    state.pointerType = "virtual";
                    return;
                }
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on pointer down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                state.pointerType = e.pointerType;
                e.stopPropagation();
                if (!state.isPressed) {
                    state.isPressed = true;
                    state.isOverTarget = true;
                    state.activePointerId = e.pointerId;
                    state.target = e.currentTarget;
                    if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                    if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);
                    triggerPressStart(e, state.pointerType);
                    addGlobalListener(document, "pointermove", onPointerMove, false);
                    addGlobalListener(document, "pointerup", onPointerUp, false);
                    addGlobalListener(document, "pointercancel", onPointerCancel, false);
                }
            };
            pressProps.onMouseDown = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (e.button === 0) {
                    // Chrome and Firefox on touch Windows devices require mouse down events
                    // to be canceled in addition to pointer events, or an extra asynchronous
                    // focus event will be fired.
                    if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                    e.stopPropagation();
                }
            };
            pressProps.onPointerUp = (e)=>{
                // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.
                if (!e.currentTarget.contains(e.target) || state.pointerType === "virtual") return;
                // Only handle left clicks
                // Safari on iOS sometimes fires pointerup events, even
                // when the touch isn't over the target, so double check.
                if (e.button === 0 && $0294ea432cd92340$var$isOverTarget(e, e.currentTarget)) triggerPressUp(e, state.pointerType || e.pointerType);
            };
            // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.
            // Use pointer move events instead to implement our own hit testing.
            // See https://bugs.webkit.org/show_bug.cgi?id=199803
            let onPointerMove = (e)=>{
                if (e.pointerId !== state.activePointerId) return;
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0) {
                    if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    state.isPressed = false;
                    state.isOverTarget = false;
                    state.activePointerId = null;
                    state.pointerType = null;
                    removeAllGlobalListeners();
                    if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
                }
            };
            let onPointerCancel = (e)=>{
                cancel(e);
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.
                cancel(e);
            };
        } else {
            pressProps.onMouseDown = (e)=>{
                // Only handle left clicks
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on mouse down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                e.stopPropagation();
                if (state.ignoreEmulatedMouseEvents) return;
                state.isPressed = true;
                state.isOverTarget = true;
                state.target = e.currentTarget;
                state.pointerType = (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent) ? "virtual" : "mouse";
                if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(document, "mouseup", onMouseUp, false);
            };
            pressProps.onMouseEnter = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = true;
                    triggerPressStart(e, state.pointerType);
                }
            };
            pressProps.onMouseLeave = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            pressProps.onMouseUp = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType);
            };
            let onMouseUp = (e)=>{
                // Only handle left clicks
                if (e.button !== 0) return;
                state.isPressed = false;
                removeAllGlobalListeners();
                if (state.ignoreEmulatedMouseEvents) {
                    state.ignoreEmulatedMouseEvents = false;
                    return;
                }
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                state.isOverTarget = false;
            };
            pressProps.onTouchStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                let touch = $0294ea432cd92340$var$getTouchFromEvent(e.nativeEvent);
                if (!touch) return;
                state.activePointerId = touch.identifier;
                state.ignoreEmulatedMouseEvents = true;
                state.isOverTarget = true;
                state.isPressed = true;
                state.target = e.currentTarget;
                state.pointerType = "touch";
                // Due to browser inconsistencies, especially on mobile browsers, we prevent default
                // on the emulated mouse event and handle focusing the pressable element ourselves.
                if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(window, "scroll", onScroll, true);
            };
            pressProps.onTouchMove = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart(e, state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            pressProps.onTouchEnd = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    triggerPressUp(e, state.pointerType);
                    triggerPressEnd(e, state.pointerType);
                } else if (state.isOverTarget) triggerPressEnd(e, state.pointerType, false);
                state.isPressed = false;
                state.activePointerId = null;
                state.isOverTarget = false;
                state.ignoreEmulatedMouseEvents = true;
                if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
                removeAllGlobalListeners();
            };
            pressProps.onTouchCancel = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed) cancel(e);
            };
            let onScroll = (e)=>{
                if (state.isPressed && e.target.contains(state.target)) cancel({
                    currentTarget: state.target,
                    shiftKey: false,
                    ctrlKey: false,
                    metaKey: false,
                    altKey: false
                });
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                cancel(e);
            };
        }
        return pressProps;
    }, [
        addGlobalListener,
        isDisabled,
        preventFocusOnPress,
        removeAllGlobalListeners,
        allowTextSelectionOnPress,
        cancel,
        cancelOnPointerExit,
        triggerPressEnd,
        triggerPressStart,
        triggerPressUp
    ]);
    // Remove user-select: none in case component unmounts immediately after pressStart
    // eslint-disable-next-line arrow-body-style
    (0, $goTMa$react.useEffect)(()=>{
        return ()=>{
            if (!allowTextSelectionOnPress) // eslint-disable-next-line react-hooks/exhaustive-deps
            (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(ref.current.target);
        };
    }, [
        allowTextSelectionOnPress
    ]);
    return {
        isPressed: isPressedProp || isPressed,
        pressProps: (0, $goTMa$reactariautils.mergeProps)(domProps, pressProps)
    };
}
function $0294ea432cd92340$var$isHTMLAnchorLink(target) {
    return target.tagName === "A" && target.hasAttribute("href");
}
function $0294ea432cd92340$var$isValidKeyboardEvent(event, currentTarget) {
    const { key: key , code: code  } = event;
    const element = currentTarget;
    const role = element.getAttribute("role");
    // Accessibility for keyboards. Space and Enter only.
    // "Spacebar" is for IE 11
    return (key === "Enter" || key === " " || key === "Spacebar" || code === "Space") && !(element instanceof HTMLInputElement && !$0294ea432cd92340$var$isValidInputKey(element, key) || element instanceof HTMLTextAreaElement || element.isContentEditable) && // A link with a valid href should be handled natively,
    // unless it also has role='button' and was triggered using Space.
    (!$0294ea432cd92340$var$isHTMLAnchorLink(element) || role === "button" && key !== "Enter") && // An element with role='link' should only trigger with Enter key
    !(role === "link" && key !== "Enter");
}
function $0294ea432cd92340$var$getTouchFromEvent(event) {
    const { targetTouches: targetTouches  } = event;
    if (targetTouches.length > 0) return targetTouches[0];
    return null;
}
function $0294ea432cd92340$var$getTouchById(event, pointerId) {
    const changedTouches = event.changedTouches;
    for(let i = 0; i < changedTouches.length; i++){
        const touch = changedTouches[i];
        if (touch.identifier === pointerId) return touch;
    }
    return null;
}
function $0294ea432cd92340$var$createEvent(target, e) {
    return {
        currentTarget: target,
        shiftKey: e.shiftKey,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey
    };
}
function $0294ea432cd92340$var$getPointClientRect(point) {
    let offsetX = point.width / 2 || point.radiusX || 0;
    let offsetY = point.height / 2 || point.radiusY || 0;
    return {
        top: point.clientY - offsetY,
        right: point.clientX + offsetX,
        bottom: point.clientY + offsetY,
        left: point.clientX - offsetX
    };
}
function $0294ea432cd92340$var$areRectanglesOverlapping(a, b) {
    // check if they cannot overlap on x axis
    if (a.left > b.right || b.left > a.right) return false;
    // check if they cannot overlap on y axis
    if (a.top > b.bottom || b.top > a.bottom) return false;
    return true;
}
function $0294ea432cd92340$var$isOverTarget(point, target) {
    let rect = target.getBoundingClientRect();
    let pointRect = $0294ea432cd92340$var$getPointClientRect(point);
    return $0294ea432cd92340$var$areRectanglesOverlapping(rect, pointRect);
}
function $0294ea432cd92340$var$shouldPreventDefault(target) {
    // We cannot prevent default if the target is a draggable element.
    return !(target instanceof HTMLElement) || !target.draggable;
}
function $0294ea432cd92340$var$shouldPreventDefaultKeyboard(target, key) {
    if (target instanceof HTMLInputElement) return !$0294ea432cd92340$var$isValidInputKey(target, key);
    if (target instanceof HTMLButtonElement) return target.type !== "submit";
    return true;
}
const $0294ea432cd92340$var$nonTextInputTypes = new Set([
    "checkbox",
    "radio",
    "range",
    "color",
    "file",
    "image",
    "button",
    "submit",
    "reset"
]);
function $0294ea432cd92340$var$isValidInputKey(target, key) {
    // Only space should toggle checkboxes and radios, not enter.
    return target.type === "checkbox" || target.type === "radio" ? key === " " : $0294ea432cd92340$var$nonTextInputTypes.has(target.type);
}



const $e1dbec26039c051d$export$27c701ed9e449e99 = /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).forwardRef(({ children: children , ...props }, ref)=>{
    let newRef = (0, $goTMa$react.useRef)();
    ref = ref !== null && ref !== void 0 ? ref : newRef;
    let { pressProps: pressProps  } = (0, $0294ea432cd92340$export$45712eceda6fad21)({
        ...props,
        ref: ref
    });
    let child = (0, ($parcel$interopDefault($goTMa$react))).Children.only(children);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).cloneElement(child, // @ts-ignore
    {
        ref: ref,
        ...(0, $goTMa$reactariautils.mergeProps)(child.props, pressProps)
    });
});


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $3596bae48579386f$export$3351871ee4b288b8 = /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).forwardRef(({ children: children , ...props }, ref)=>{
    let isRegistered = (0, $goTMa$react.useRef)(false);
    let prevContext = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));
    let context = (0, $goTMa$reactariautils.mergeProps)(prevContext || {}, {
        ...props,
        ref: ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref),
        register () {
            isRegistered.current = true;
            if (prevContext) prevContext.register();
        }
    });
    (0, $goTMa$reactariautils.useSyncRef)(prevContext, ref);
    (0, $goTMa$react.useEffect)(()=>{
        if (!isRegistered.current) {
            console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.");
            isRegistered.current = true; // only warn once in strict mode.
        }
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).createElement((0, $01d3f539e91688c8$export$5165eccb35aaadb5).Provider, {
        value: context
    }, children);
});


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

class $625cf83917e112ad$export$905e7fc544a71f36 {
    isDefaultPrevented() {
        return this.nativeEvent.defaultPrevented;
    }
    preventDefault() {
        this.defaultPrevented = true;
        this.nativeEvent.preventDefault();
    }
    stopPropagation() {
        this.nativeEvent.stopPropagation();
        this.isPropagationStopped = ()=>true;
    }
    isPropagationStopped() {
        return false;
    }
    persist() {}
    constructor(type, nativeEvent){
        this.nativeEvent = nativeEvent;
        this.target = nativeEvent.target;
        this.currentTarget = nativeEvent.currentTarget;
        this.relatedTarget = nativeEvent.relatedTarget;
        this.bubbles = nativeEvent.bubbles;
        this.cancelable = nativeEvent.cancelable;
        this.defaultPrevented = nativeEvent.defaultPrevented;
        this.eventPhase = nativeEvent.eventPhase;
        this.isTrusted = nativeEvent.isTrusted;
        this.timeStamp = nativeEvent.timeStamp;
        this.type = type;
    }
}
function $625cf83917e112ad$export$715c682d09d639cc(onBlur) {
    let stateRef = (0, $goTMa$react.useRef)({
        isFocused: false,
        observer: null
    });
    // Clean up MutationObserver on unmount. See below.
    // eslint-disable-next-line arrow-body-style
    (0, $goTMa$reactariautils.useLayoutEffect)(()=>{
        const state = stateRef.current;
        return ()=>{
            if (state.observer) {
                state.observer.disconnect();
                state.observer = null;
            }
        };
    }, []);
    let dispatchBlur = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
    });
    // This function is called during a React onFocus event.
    return (0, $goTMa$react.useCallback)((e)=>{
        // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142
        // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a
        // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.
        // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.
        if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {
            stateRef.current.isFocused = true;
            let target = e.target;
            let onBlurHandler = (e)=>{
                stateRef.current.isFocused = false;
                if (target.disabled) // For backward compatibility, dispatch a (fake) React synthetic event.
                dispatchBlur(new $625cf83917e112ad$export$905e7fc544a71f36("blur", e));
                // We no longer need the MutationObserver once the target is blurred.
                if (stateRef.current.observer) {
                    stateRef.current.observer.disconnect();
                    stateRef.current.observer = null;
                }
            };
            target.addEventListener("focusout", onBlurHandler, {
                once: true
            });
            stateRef.current.observer = new MutationObserver(()=>{
                if (stateRef.current.isFocused && target.disabled) {
                    stateRef.current.observer.disconnect();
                    let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
                    target.dispatchEvent(new FocusEvent("blur", {
                        relatedTarget: relatedTargetEl
                    }));
                    target.dispatchEvent(new FocusEvent("focusout", {
                        bubbles: true,
                        relatedTarget: relatedTargetEl
                    }));
                }
            });
            stateRef.current.observer.observe(target, {
                attributes: true,
                attributeFilter: [
                    "disabled"
                ]
            });
        }
    }, [
        dispatchBlur
    ]);
}


function $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6(props) {
    let { isDisabled: isDisabled , onFocus: onFocusProp , onBlur: onBlurProp , onFocusChange: onFocusChange  } = props;
    const onBlur = (0, $goTMa$react.useCallback)((e)=>{
        if (e.target === e.currentTarget) {
            if (onBlurProp) onBlurProp(e);
            if (onFocusChange) onFocusChange(false);
            return true;
        }
    }, [
        onBlurProp,
        onFocusChange
    ]);
    const onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);
    const onFocus = (0, $goTMa$react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (e.target === e.currentTarget && document.activeElement === e.target) {
            if (onFocusProp) onFocusProp(e);
            if (onFocusChange) onFocusChange(true);
            onSyntheticFocus(e);
        }
    }, [
        onFocusChange,
        onFocusProp,
        onSyntheticFocus
    ]);
    return {
        focusProps: {
            onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,
            onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : undefined
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions



let $e77252a287ef94ab$var$currentModality = null;
let $e77252a287ef94ab$var$changeHandlers = new Set();
let $e77252a287ef94ab$var$hasSetupGlobalListeners = false;
let $e77252a287ef94ab$var$hasEventBeforeFocus = false;
let $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
// Only Tab or Esc keys will make focus visible on text input elements
const $e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS = {
    Tab: true,
    Escape: true
};
function $e77252a287ef94ab$var$triggerChangeHandlers(modality, e) {
    for (let handler of $e77252a287ef94ab$var$changeHandlers)handler(modality, e);
}
/**
 * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.
 */ function $e77252a287ef94ab$var$isValidKey(e) {
    // Control and Shift keys trigger when navigating back to the tab with keyboard.
    return !(e.metaKey || !(0, $goTMa$reactariautils.isMac)() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
function $e77252a287ef94ab$var$handleKeyboardEvent(e) {
    $e77252a287ef94ab$var$hasEventBeforeFocus = true;
    if ($e77252a287ef94ab$var$isValidKey(e)) {
        $e77252a287ef94ab$var$currentModality = "keyboard";
        $e77252a287ef94ab$var$triggerChangeHandlers("keyboard", e);
    }
}
function $e77252a287ef94ab$var$handlePointerEvent(e) {
    $e77252a287ef94ab$var$currentModality = "pointer";
    if (e.type === "mousedown" || e.type === "pointerdown") {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$triggerChangeHandlers("pointer", e);
    }
}
function $e77252a287ef94ab$var$handleClickEvent(e) {
    if ((0, $goTMa$reactariautils.isVirtualClick)(e)) {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$currentModality = "virtual";
    }
}
function $e77252a287ef94ab$var$handleFocusEvent(e) {
    // Firefox fires two extra focus events when the user first clicks into an iframe:
    // first on the window, then on the document. We ignore these events so they don't
    // cause keyboard focus rings to appear.
    if (e.target === window || e.target === document) return;
    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.
    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.
    if (!$e77252a287ef94ab$var$hasEventBeforeFocus && !$e77252a287ef94ab$var$hasBlurredWindowRecently) {
        $e77252a287ef94ab$var$currentModality = "virtual";
        $e77252a287ef94ab$var$triggerChangeHandlers("virtual", e);
    }
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
}
function $e77252a287ef94ab$var$handleWindowBlur() {
    // When the window is blurred, reset state. This is necessary when tabbing out of the window,
    // for example, since a subsequent focus event won't be fired.
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = true;
}
/**
 * Setup global event listeners to control when keyboard focus style should be visible.
 */ function $e77252a287ef94ab$var$setupGlobalFocusEvents() {
    if (typeof window === "undefined" || $e77252a287ef94ab$var$hasSetupGlobalListeners) return;
    // Programmatic focus() calls shouldn't affect the current input modality.
    // However, we need to detect other cases when a focus event occurs without
    // a preceding user event (e.g. screen reader focus). Overriding the focus
    // method on HTMLElement.prototype is a bit hacky, but works.
    let focus = HTMLElement.prototype.focus;
    HTMLElement.prototype.focus = function() {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        focus.apply(this, arguments);
    };
    document.addEventListener("keydown", $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener("keyup", $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener("click", $e77252a287ef94ab$var$handleClickEvent, true);
    // Register focus events on the window so they are sure to happen
    // before React's event listeners (registered on the document).
    window.addEventListener("focus", $e77252a287ef94ab$var$handleFocusEvent, true);
    window.addEventListener("blur", $e77252a287ef94ab$var$handleWindowBlur, false);
    if (typeof PointerEvent !== "undefined") {
        document.addEventListener("pointerdown", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("pointermove", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("pointerup", $e77252a287ef94ab$var$handlePointerEvent, true);
    } else {
        document.addEventListener("mousedown", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("mousemove", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("mouseup", $e77252a287ef94ab$var$handlePointerEvent, true);
    }
    $e77252a287ef94ab$var$hasSetupGlobalListeners = true;
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e77252a287ef94ab$var$setupGlobalFocusEvents();
    else document.addEventListener("DOMContentLoaded", $e77252a287ef94ab$var$setupGlobalFocusEvents);
}
function $e77252a287ef94ab$export$b9b3dfddab17db27() {
    return $e77252a287ef94ab$var$currentModality !== "pointer";
}
function $e77252a287ef94ab$export$630ff653c5ada6a9() {
    return $e77252a287ef94ab$var$currentModality;
}
function $e77252a287ef94ab$export$8397ddfc504fdb9a(modality) {
    $e77252a287ef94ab$var$currentModality = modality;
    $e77252a287ef94ab$var$triggerChangeHandlers(modality, null);
}
function $e77252a287ef94ab$export$98e20ec92f614cfe() {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    let [modality, setModality] = (0, $goTMa$react.useState)($e77252a287ef94ab$var$currentModality);
    (0, $goTMa$react.useEffect)(()=>{
        let handler = ()=>{
            setModality($e77252a287ef94ab$var$currentModality);
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    }, []);
    return (0, $goTMa$reactariassr.useIsSSR)() ? null : modality;
}
/**
 * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that
 * focus visible style can be properly set.
 */ function $e77252a287ef94ab$var$isKeyboardFocusEvent(isTextInput, modality, e) {
    return !(isTextInput && modality === "keyboard" && e instanceof KeyboardEvent && !$e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);
}
function $e77252a287ef94ab$export$ffd9e5021c1fb2d6(props = {}) {
    let { isTextInput: isTextInput , autoFocus: autoFocus  } = props;
    let [isFocusVisibleState, setFocusVisible] = (0, $goTMa$react.useState)(autoFocus || $e77252a287ef94ab$export$b9b3dfddab17db27());
    $e77252a287ef94ab$export$ec71b4b83ac08ec3((isFocusVisible)=>{
        setFocusVisible(isFocusVisible);
    }, [
        isTextInput
    ], {
        isTextInput: isTextInput
    });
    return {
        isFocusVisible: isFocusVisibleState
    };
}
function $e77252a287ef94ab$export$ec71b4b83ac08ec3(fn, deps, opts) {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    (0, $goTMa$react.useEffect)(()=>{
        let handler = (modality, e)=>{
            if (!$e77252a287ef94ab$var$isKeyboardFocusEvent(opts === null || opts === void 0 ? void 0 : opts.isTextInput, modality, e)) return;
            fn($e77252a287ef94ab$export$b9b3dfddab17db27());
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, deps);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $d16842bbd0359d1b$export$420e68273165f4ec(props) {
    let { isDisabled: isDisabled , onBlurWithin: onBlurWithin , onFocusWithin: onFocusWithin , onFocusWithinChange: onFocusWithinChange  } = props;
    let state = (0, $goTMa$react.useRef)({
        isFocusWithin: false
    });
    let onBlur = (0, $goTMa$react.useCallback)((e)=>{
        // We don't want to trigger onBlurWithin and then immediately onFocusWithin again
        // when moving focus inside the element. Only trigger if the currentTarget doesn't
        // include the relatedTarget (where focus is moving).
        if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {
            state.current.isFocusWithin = false;
            if (onBlurWithin) onBlurWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(false);
        }
    }, [
        onBlurWithin,
        onFocusWithinChange,
        state
    ]);
    let onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);
    let onFocus = (0, $goTMa$react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (!state.current.isFocusWithin && document.activeElement === e.target) {
            if (onFocusWithin) onFocusWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(true);
            state.current.isFocusWithin = true;
            onSyntheticFocus(e);
        }
    }, [
        onFocusWithin,
        onFocusWithinChange,
        onSyntheticFocus
    ]);
    if (isDisabled) return {
        focusWithinProps: {
            onFocus: null,
            onBlur: null
        }
    };
    return {
        focusWithinProps: {
            onFocus: onFocus,
            onBlur: onBlur
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

// iOS fires onPointerEnter twice: once with pointerType="touch" and again with pointerType="mouse".
// We want to ignore these emulated events so they do not trigger hover behavior.
// See https://bugs.webkit.org/show_bug.cgi?id=214609.
let $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
let $ffbc150311c75f01$var$hoverCount = 0;
function $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents() {
    $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = true;
    // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter
    // with pointerType="mouse" immediately after onPointerUp and before onFocus. On other
    // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in
    // the distant future because a user previously touched the element.
    setTimeout(()=>{
        $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
    }, 50);
}
function $ffbc150311c75f01$var$handleGlobalPointerEvent(e) {
    if (e.pointerType === "touch") $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $ffbc150311c75f01$var$setupGlobalTouchEvents() {
    if (typeof document === "undefined") return;
    if (typeof PointerEvent !== "undefined") document.addEventListener("pointerup", $ffbc150311c75f01$var$handleGlobalPointerEvent);
    else document.addEventListener("touchend", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    $ffbc150311c75f01$var$hoverCount++;
    return ()=>{
        $ffbc150311c75f01$var$hoverCount--;
        if ($ffbc150311c75f01$var$hoverCount > 0) return;
        if (typeof PointerEvent !== "undefined") document.removeEventListener("pointerup", $ffbc150311c75f01$var$handleGlobalPointerEvent);
        else document.removeEventListener("touchend", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    };
}
function $ffbc150311c75f01$export$ae780daf29e6d456(props) {
    let { onHoverStart: onHoverStart , onHoverChange: onHoverChange , onHoverEnd: onHoverEnd , isDisabled: isDisabled  } = props;
    let [isHovered, setHovered] = (0, $goTMa$react.useState)(false);
    let state = (0, $goTMa$react.useRef)({
        isHovered: false,
        ignoreEmulatedMouseEvents: false,
        pointerType: "",
        target: null
    }).current;
    (0, $goTMa$react.useEffect)($ffbc150311c75f01$var$setupGlobalTouchEvents, []);
    let { hoverProps: hoverProps , triggerHoverEnd: triggerHoverEnd  } = (0, $goTMa$react.useMemo)(()=>{
        let triggerHoverStart = (event, pointerType)=>{
            state.pointerType = pointerType;
            if (isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target)) return;
            state.isHovered = true;
            let target = event.currentTarget;
            state.target = target;
            if (onHoverStart) onHoverStart({
                type: "hoverstart",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(true);
            setHovered(true);
        };
        let triggerHoverEnd = (event, pointerType)=>{
            state.pointerType = "";
            state.target = null;
            if (pointerType === "touch" || !state.isHovered) return;
            state.isHovered = false;
            let target = event.currentTarget;
            if (onHoverEnd) onHoverEnd({
                type: "hoverend",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(false);
            setHovered(false);
        };
        let hoverProps = {};
        if (typeof PointerEvent !== "undefined") {
            hoverProps.onPointerEnter = (e)=>{
                if ($ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents && e.pointerType === "mouse") return;
                triggerHoverStart(e, e.pointerType);
            };
            hoverProps.onPointerLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);
            };
        } else {
            hoverProps.onTouchStart = ()=>{
                state.ignoreEmulatedMouseEvents = true;
            };
            hoverProps.onMouseEnter = (e)=>{
                if (!state.ignoreEmulatedMouseEvents && !$ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, "mouse");
                state.ignoreEmulatedMouseEvents = false;
            };
            hoverProps.onMouseLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, "mouse");
            };
        }
        return {
            hoverProps: hoverProps,
            triggerHoverEnd: triggerHoverEnd
        };
    }, [
        onHoverStart,
        onHoverChange,
        onHoverEnd,
        isDisabled,
        state
    ]);
    (0, $goTMa$react.useEffect)(()=>{
        // Call the triggerHoverEnd as soon as isDisabled changes to true
        // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering
        if (isDisabled) triggerHoverEnd({
            currentTarget: state.target
        }, state.pointerType);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        isDisabled
    ]);
    return {
        hoverProps: hoverProps,
        isHovered: isHovered
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $edcfa848c42f94f4$export$872b660ac5a1ff98(props) {
    let { ref: ref , onInteractOutside: onInteractOutside , isDisabled: isDisabled , onInteractOutsideStart: onInteractOutsideStart  } = props;
    let stateRef = (0, $goTMa$react.useRef)({
        isPointerDown: false,
        ignoreEmulatedMouseEvents: false
    });
    let onPointerDown = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (onInteractOutside && $edcfa848c42f94f4$var$isValidEvent(e, ref)) {
            if (onInteractOutsideStart) onInteractOutsideStart(e);
            stateRef.current.isPointerDown = true;
        }
    });
    let triggerInteractOutside = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (onInteractOutside) onInteractOutside(e);
    });
    (0, $goTMa$react.useEffect)(()=>{
        let state = stateRef.current;
        if (isDisabled) return;
        // Use pointer events if available. Otherwise, fall back to mouse and touch events.
        if (typeof PointerEvent !== "undefined") {
            let onPointerUp = (e)=>{
                if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            // changing these to capture phase fixed combobox
            document.addEventListener("pointerdown", onPointerDown, true);
            document.addEventListener("pointerup", onPointerUp, true);
            return ()=>{
                document.removeEventListener("pointerdown", onPointerDown, true);
                document.removeEventListener("pointerup", onPointerUp, true);
            };
        } else {
            let onMouseUp = (e)=>{
                if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;
                else if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            let onTouchEnd = (e)=>{
                state.ignoreEmulatedMouseEvents = true;
                if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            document.addEventListener("mousedown", onPointerDown, true);
            document.addEventListener("mouseup", onMouseUp, true);
            document.addEventListener("touchstart", onPointerDown, true);
            document.addEventListener("touchend", onTouchEnd, true);
            return ()=>{
                document.removeEventListener("mousedown", onPointerDown, true);
                document.removeEventListener("mouseup", onMouseUp, true);
                document.removeEventListener("touchstart", onPointerDown, true);
                document.removeEventListener("touchend", onTouchEnd, true);
            };
        }
    }, [
        ref,
        isDisabled,
        onPointerDown,
        triggerInteractOutside
    ]);
}
function $edcfa848c42f94f4$var$isValidEvent(event, ref) {
    if (event.button > 0) return false;
    if (event.target) {
        // if the event target is no longer in the document, ignore
        const ownerDocument = event.target.ownerDocument;
        if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;
        // If the target is within a top layer element (e.g. toasts), ignore.
        if (event.target.closest("[data-react-aria-top-layer]")) return false;
    }
    return ref.current && !ref.current.contains(event.target);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $951fbcbbca8db6ce$export$48d1ea6320830260(handler) {
    if (!handler) return;
    let shouldStopPropagation = true;
    return (e)=>{
        let event = {
            ...e,
            preventDefault () {
                e.preventDefault();
            },
            isDefaultPrevented () {
                return e.isDefaultPrevented();
            },
            stopPropagation () {
                console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
            },
            continuePropagation () {
                shouldStopPropagation = false;
            }
        };
        handler(event);
        if (shouldStopPropagation) e.stopPropagation();
    };
}


function $892d64db2a3c53b0$export$8f71654801c2f7cd(props) {
    return {
        keyboardProps: props.isDisabled ? {} : {
            onKeyDown: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyDown),
            onKeyUp: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyUp)
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $c09386fc48fa427d$export$36da96379f79f245(props) {
    let { onMoveStart: onMoveStart , onMove: onMove , onMoveEnd: onMoveEnd  } = props;
    let state = (0, $goTMa$react.useRef)({
        didMove: false,
        lastPosition: null,
        id: null
    });
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let move = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType, deltaX, deltaY)=>{
        if (deltaX === 0 && deltaY === 0) return;
        if (!state.current.didMove) {
            state.current.didMove = true;
            onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart({
                type: "movestart",
                pointerType: pointerType,
                shiftKey: originalEvent.shiftKey,
                metaKey: originalEvent.metaKey,
                ctrlKey: originalEvent.ctrlKey,
                altKey: originalEvent.altKey
            });
        }
        onMove({
            type: "move",
            pointerType: pointerType,
            deltaX: deltaX,
            deltaY: deltaY,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let end = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)();
        if (state.current.didMove) onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd({
            type: "moveend",
            pointerType: pointerType,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let moveProps = (0, $goTMa$react.useMemo)(()=>{
        let moveProps = {};
        let start = ()=>{
            (0, $f7e14e656343df57$export$16a4697467175487)();
            state.current.didMove = false;
        };
        if (typeof PointerEvent === "undefined") {
            let onMouseMove = (e)=>{
                if (e.button === 0) {
                    move(e, "mouse", e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onMouseUp = (e)=>{
                if (e.button === 0) {
                    end(e, "mouse");
                    removeGlobalListener(window, "mousemove", onMouseMove, false);
                    removeGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            moveProps.onMouseDown = (e)=>{
                if (e.button === 0) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    addGlobalListener(window, "mousemove", onMouseMove, false);
                    addGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            let onTouchMove = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id);
                if (touch >= 0) {
                    let { pageX: pageX , pageY: pageY  } = e.changedTouches[touch];
                    move(e, "touch", pageX - state.current.lastPosition.pageX, pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: pageX,
                        pageY: pageY
                    };
                }
            };
            let onTouchEnd = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id);
                if (touch >= 0) {
                    end(e, "touch");
                    state.current.id = null;
                    removeGlobalListener(window, "touchmove", onTouchMove);
                    removeGlobalListener(window, "touchend", onTouchEnd);
                    removeGlobalListener(window, "touchcancel", onTouchEnd);
                }
            };
            moveProps.onTouchStart = (e)=>{
                if (e.changedTouches.length === 0 || state.current.id != null) return;
                let { pageX: pageX , pageY: pageY , identifier: identifier  } = e.changedTouches[0];
                start();
                e.stopPropagation();
                e.preventDefault();
                state.current.lastPosition = {
                    pageX: pageX,
                    pageY: pageY
                };
                state.current.id = identifier;
                addGlobalListener(window, "touchmove", onTouchMove, false);
                addGlobalListener(window, "touchend", onTouchEnd, false);
                addGlobalListener(window, "touchcancel", onTouchEnd, false);
            };
        } else {
            let onPointerMove = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    // Problems with PointerEvent#movementX/movementY:
                    // 1. it is always 0 on macOS Safari.
                    // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS
                    move(e, pointerType, e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    end(e, pointerType);
                    state.current.id = null;
                    removeGlobalListener(window, "pointermove", onPointerMove, false);
                    removeGlobalListener(window, "pointerup", onPointerUp, false);
                    removeGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
            moveProps.onPointerDown = (e)=>{
                if (e.button === 0 && state.current.id == null) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    state.current.id = e.pointerId;
                    addGlobalListener(window, "pointermove", onPointerMove, false);
                    addGlobalListener(window, "pointerup", onPointerUp, false);
                    addGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
        }
        let triggerKeyboardMove = (e, deltaX, deltaY)=>{
            start();
            move(e, "keyboard", deltaX, deltaY);
            end(e, "keyboard");
        };
        moveProps.onKeyDown = (e)=>{
            switch(e.key){
                case "Left":
                case "ArrowLeft":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, -1, 0);
                    break;
                case "Right":
                case "ArrowRight":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 1, 0);
                    break;
                case "Up":
                case "ArrowUp":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, -1);
                    break;
                case "Down":
                case "ArrowDown":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, 1);
                    break;
            }
        };
        return moveProps;
    }, [
        state,
        addGlobalListener,
        removeGlobalListener,
        move,
        end
    ]);
    return {
        moveProps: moveProps
    };
}



/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $a3dbce0aed7087e2$export$2123ff2b87c81ca(props, ref) {
    let { onScroll: onScroll , isDisabled: isDisabled  } = props;
    let onScrollHandler = (0, $goTMa$react.useCallback)((e)=>{
        // If the ctrlKey is pressed, this is a zoom event, do nothing.
        if (e.ctrlKey) return;
        // stop scrolling the page
        e.preventDefault();
        e.stopPropagation();
        if (onScroll) onScroll({
            deltaX: e.deltaX,
            deltaY: e.deltaY
        });
    }, [
        onScroll
    ]);
    (0, $goTMa$reactariautils.useEvent)(ref, "wheel", isDisabled ? null : onScrollHandler);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD = 500;
function $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9(props) {
    let { isDisabled: isDisabled , onLongPressStart: onLongPressStart , onLongPressEnd: onLongPressEnd , onLongPress: onLongPress , threshold: threshold = $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD , accessibilityDescription: accessibilityDescription  } = props;
    const timeRef = (0, $goTMa$react.useRef)(null);
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let { pressProps: pressProps  } = (0, $0294ea432cd92340$export$45712eceda6fad21)({
        isDisabled: isDisabled,
        onPressStart (e) {
            if (e.pointerType === "mouse" || e.pointerType === "touch") {
                if (onLongPressStart) onLongPressStart({
                    ...e,
                    type: "longpressstart"
                });
                timeRef.current = setTimeout(()=>{
                    // Prevent other usePress handlers from also handling this event.
                    e.target.dispatchEvent(new PointerEvent("pointercancel", {
                        bubbles: true
                    }));
                    if (onLongPress) onLongPress({
                        ...e,
                        type: "longpress"
                    });
                    timeRef.current = null;
                }, threshold);
                // Prevent context menu, which may be opened on long press on touch devices
                if (e.pointerType === "touch") {
                    let onContextMenu = (e)=>{
                        e.preventDefault();
                    };
                    addGlobalListener(e.target, "contextmenu", onContextMenu, {
                        once: true
                    });
                    addGlobalListener(window, "pointerup", ()=>{
                        // If no contextmenu event is fired quickly after pointerup, remove the handler
                        // so future context menu events outside a long press are not prevented.
                        setTimeout(()=>{
                            removeGlobalListener(e.target, "contextmenu", onContextMenu);
                        }, 30);
                    }, {
                        once: true
                    });
                }
            }
        },
        onPressEnd (e) {
            if (timeRef.current) clearTimeout(timeRef.current);
            if (onLongPressEnd && (e.pointerType === "mouse" || e.pointerType === "touch")) onLongPressEnd({
                ...e,
                type: "longpressend"
            });
        }
    });
    let descriptionProps = (0, $goTMa$reactariautils.useDescription)(onLongPress && !isDisabled ? accessibilityDescription : null);
    return {
        longPressProps: (0, $goTMa$reactariautils.mergeProps)(pressProps, descriptionProps)
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 50897:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $4hxXn$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "SSRProvider", () => $29383e587d62412a$export$9f8ac96af4b1b2ae);
$parcel$export(module.exports, "useSSRSafeId", () => $29383e587d62412a$export$619500959fc48b26);
$parcel$export(module.exports, "useIsSSR", () => $29383e587d62412a$export$535bd6ca7f90a273);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We must avoid a circular dependency with @react-aria/utils, and this useLayoutEffect is
// guarded by a check that it only runs on the client side.
// eslint-disable-next-line rulesdir/useLayoutEffectRule

// Default context value to use in case there is no SSRProvider. This is fine for
// client-only apps. In order to support multiple copies of React Aria potentially
// being on the page at once, the prefix is set to a random number. SSRProvider
// will reset this to zero for consistency between server and client, so in the
// SSR case multiple copies of React Aria is not supported.
const $29383e587d62412a$var$defaultContext = {
    prefix: String(Math.round(Math.random() * 10000000000)),
    current: 0,
    isSSR: false
};
const $29383e587d62412a$var$SSRContext = /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createContext($29383e587d62412a$var$defaultContext);
// This is only used in React < 18.
function $29383e587d62412a$var$LegacySSRProvider(props) {
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let counter = $29383e587d62412a$var$useCounter(cur === $29383e587d62412a$var$defaultContext);
    let [isSSR, setIsSSR] = (0, $4hxXn$react.useState)(true);
    let value = (0, $4hxXn$react.useMemo)(()=>({
            // If this is the first SSRProvider, start with an empty string prefix, otherwise
            // append and increment the counter.
            prefix: cur === $29383e587d62412a$var$defaultContext ? "" : `${cur.prefix}-${counter}`,
            current: 0,
            isSSR: isSSR
        }), [
        cur,
        counter,
        isSSR
    ]);
    // If on the client, and the component was initially server rendered,
    // then schedule a layout effect to update the component after hydration.
    if (typeof window !== "undefined") // This if statement technically breaks the rules of hooks, but is safe
    // because the condition never changes after mounting.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, $4hxXn$react.useLayoutEffect)(()=>{
        setIsSSR(false);
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$SSRContext.Provider, {
        value: value
    }, props.children);
}
let $29383e587d62412a$var$warnedAboutSSRProvider = false;
function $29383e587d62412a$export$9f8ac96af4b1b2ae(props) {
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function") {
        if (!$29383e587d62412a$var$warnedAboutSSRProvider) {
            console.warn("In React 18, SSRProvider is not necessary and is a noop. You can remove it from your app.");
            $29383e587d62412a$var$warnedAboutSSRProvider = true;
        }
        return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement((0, ($parcel$interopDefault($4hxXn$react))).Fragment, null, props.children);
    }
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$LegacySSRProvider, props);
}
let $29383e587d62412a$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
let $29383e587d62412a$var$componentIds = new WeakMap();
function $29383e587d62412a$var$useCounter(isDisabled = false) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let ref = (0, $4hxXn$react.useRef)(null);
    // eslint-disable-next-line rulesdir/pure-render
    if (ref.current === null && !isDisabled) {
        var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner;
        // In strict mode, React renders components twice, and the ref will be reset to null on the second render.
        // This means our id counter will be incremented twice instead of once. This is a problem because on the
        // server, components are only rendered once and so ids generated on the server won't match the client.
        // In React 18, useId was introduced to solve this, but it is not available in older versions. So to solve this
        // we need to use some React internals to access the underlying Fiber instance, which is stable between renders.
        // This is exposed as ReactCurrentOwner in development, which is all we need since StrictMode only runs in development.
        // To ensure that we only increment the global counter once, we store the starting id for this component in
        // a weak map associated with the Fiber. On the second render, we reset the global counter to this value.
        // Since React runs the second render immediately after the first, this is safe.
        // @ts-ignore
        let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, ($parcel$interopDefault($4hxXn$react))).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;
        if (currentOwner) {
            let prevComponentValue = $29383e587d62412a$var$componentIds.get(currentOwner);
            if (prevComponentValue == null) // On the first render, and first call to useId, store the id and state in our weak map.
            $29383e587d62412a$var$componentIds.set(currentOwner, {
                id: ctx.current,
                state: currentOwner.memoizedState
            });
            else if (currentOwner.memoizedState !== prevComponentValue.state) {
                // On the second render, the memoizedState gets reset by React.
                // Reset the counter, and remove from the weak map so we don't
                // do this for subsequent useId calls.
                ctx.current = prevComponentValue.id;
                $29383e587d62412a$var$componentIds.delete(currentOwner);
            }
        }
        // eslint-disable-next-line rulesdir/pure-render
        ref.current = ++ctx.current;
    }
    // eslint-disable-next-line rulesdir/pure-render
    return ref.current;
}
function $29383e587d62412a$var$useLegacySSRSafeId(defaultId) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    // If we are rendering in a non-DOM environment, and there's no SSRProvider,
    // provide a warning to hint to the developer to add one.
    if (ctx === $29383e587d62412a$var$defaultContext && !$29383e587d62412a$var$canUseDOM) console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
    let counter = $29383e587d62412a$var$useCounter(!!defaultId);
    return defaultId || `react-aria${ctx.prefix}-${counter}`;
}
function $29383e587d62412a$var$useModernSSRSafeId(defaultId) {
    // @ts-ignore
    let id = (0, ($parcel$interopDefault($4hxXn$react))).useId();
    let [didSSR] = (0, $4hxXn$react.useState)($29383e587d62412a$export$535bd6ca7f90a273());
    let prefix = didSSR ? "react-aria" : `react-aria${$29383e587d62412a$var$defaultContext.prefix}`;
    return defaultId || `${prefix}-${id}`;
}
const $29383e587d62412a$export$619500959fc48b26 = typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function" ? $29383e587d62412a$var$useModernSSRSafeId : $29383e587d62412a$var$useLegacySSRSafeId;
function $29383e587d62412a$var$getSnapshot() {
    return false;
}
function $29383e587d62412a$var$getServerSnapshot() {
    return true;
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function $29383e587d62412a$var$subscribe(onStoreChange) {
    // noop
    return ()=>{};
}
function $29383e587d62412a$export$535bd6ca7f90a273() {
    // In React 18, we can use useSyncExternalStore to detect if we're server rendering or hydrating.
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"] === "function") return (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"]($29383e587d62412a$var$subscribe, $29383e587d62412a$var$getSnapshot, $29383e587d62412a$var$getServerSnapshot);
    // eslint-disable-next-line react-hooks/rules-of-hooks
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    return cur.isSSR;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 13431:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $1Yh1N$reactstatelyutils = __webpack_require__(12259);
var $1Yh1N$react = __webpack_require__(18038);
var $1Yh1N$reactariassr = __webpack_require__(50897);
var $1Yh1N$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useId", () => $8c61827343eed941$export$f680877a34711e37);
$parcel$export(module.exports, "mergeIds", () => $8c61827343eed941$export$cd8c9cb68f842629);
$parcel$export(module.exports, "useSlotId", () => $8c61827343eed941$export$b4cc09c592e8fdb8);
$parcel$export(module.exports, "chain", () => $1e2191638e54f613$export$e08e3b67e392101e);
$parcel$export(module.exports, "mergeProps", () => $f847cd1382ea7cd4$export$9d1611c77c2fe928);
$parcel$export(module.exports, "mergeRefs", () => $f05dc24eafaeb7e2$export$c9058316764c140e);
$parcel$export(module.exports, "filterDOMProps", () => $8d15d0e1797d4238$export$457c3d6518dd4c6f);
$parcel$export(module.exports, "focusWithoutScrolling", () => $1117b6c0d4c4c164$export$de79e2c695e052f3);
$parcel$export(module.exports, "getOffset", () => $16ec41ef3e36c19c$export$622cea445a1c5b7d);
$parcel$export(module.exports, "runAfterTransition", () => $e8117ebcab55be6a$export$24490316f764c430);
$parcel$export(module.exports, "useDrag1D", () => $28ed3fb20343b78b$export$7bbed75feba39706);
$parcel$export(module.exports, "useGlobalListeners", () => $4571ff54ac709100$export$4eaf04e54aa8eed6);
$parcel$export(module.exports, "useLabels", () => $6ec78bde395c477d$export$d6875122194c7b44);
$parcel$export(module.exports, "useObjectRef", () => $475b35fe72ba49b3$export$4338b53315abf666);
$parcel$export(module.exports, "useUpdateEffect", () => $29293a6f5c75b37e$export$496315a1608d9602);
$parcel$export(module.exports, "useLayoutEffect", () => $78605a5d7424e31b$export$e5c5a5f917a5871c);
$parcel$export(module.exports, "useResizeObserver", () => $37733e1652f47193$export$683480f191c0e3ea);
$parcel$export(module.exports, "useSyncRef", () => $6fc733991a9f977c$export$4debdb1a3f0fa79e);
$parcel$export(module.exports, "getScrollParent", () => $d796e7157ac96470$export$cfa2225e87938781);
$parcel$export(module.exports, "isScrollable", () => $d796e7157ac96470$export$2bb74740c4e19def);
$parcel$export(module.exports, "useViewportSize", () => $8b24bab62f5c65ad$export$d699905dd57c73ca);
$parcel$export(module.exports, "useDescription", () => $34da4502ea8120db$export$f8aeda7b10753fa1);
$parcel$export(module.exports, "isMac", () => $9e20cff0af27e8cc$export$9ac100e40613ea10);
$parcel$export(module.exports, "isIPhone", () => $9e20cff0af27e8cc$export$186c6964ca17d99);
$parcel$export(module.exports, "isIPad", () => $9e20cff0af27e8cc$export$7bef049ce92e4224);
$parcel$export(module.exports, "isIOS", () => $9e20cff0af27e8cc$export$fedb369cb70207f1);
$parcel$export(module.exports, "isAppleDevice", () => $9e20cff0af27e8cc$export$e1865c3bedcd822b);
$parcel$export(module.exports, "isWebKit", () => $9e20cff0af27e8cc$export$78551043582a6a98);
$parcel$export(module.exports, "isChrome", () => $9e20cff0af27e8cc$export$6446a186d09e379e);
$parcel$export(module.exports, "isAndroid", () => $9e20cff0af27e8cc$export$a11b0059900ceec8);
$parcel$export(module.exports, "useEvent", () => $2a8c0bb1629926c8$export$90fc3a17d93f704c);
$parcel$export(module.exports, "useValueEffect", () => $19a2307bfabafaf1$export$14d238f342723f25);
$parcel$export(module.exports, "scrollIntoView", () => $449412113267a1fe$export$53a0910f038337bd);
$parcel$export(module.exports, "scrollIntoViewport", () => $449412113267a1fe$export$c826860796309d1b);
$parcel$export(module.exports, "clamp", () => $1Yh1N$reactstatelyutils.clamp);
$parcel$export(module.exports, "snapValueToStep", () => $1Yh1N$reactstatelyutils.snapValueToStep);
$parcel$export(module.exports, "isVirtualClick", () => $577e795361f19be9$export$60278871457622de);
$parcel$export(module.exports, "isVirtualPointerEvent", () => $577e795361f19be9$export$29bf1b5f2c56cf63);
$parcel$export(module.exports, "useEffectEvent", () => $1254e5bb94ac8761$export$7f54fc3180508a52);
$parcel$export(module.exports, "useDeepMemo", () => $20e6e72fbf5dc81e$export$722debc0e56fea39);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $78605a5d7424e31b$export$e5c5a5f917a5871c = typeof window !== "undefined" ? (0, ($parcel$interopDefault($1Yh1N$react))).useLayoutEffect : ()=>{};



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $19a2307bfabafaf1$export$14d238f342723f25(defaultValue) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultValue);
    let valueRef = (0, $1Yh1N$react.useRef)(value);
    let effect = (0, $1Yh1N$react.useRef)(null);
    // Must be stable so that `queue` is stable.
    let nextIter = (0, $1Yh1N$react.useCallback)(()=>{
        // Run the generator to the next yield.
        let newValue = effect.current.next();
        while(!newValue.done && valueRef.current === newValue.value)// If the value is the same as the current value,
        // then continue to the next yield. Otherwise,
        // set the value in state and wait for the next layout effect.
        newValue = effect.current.next();
        // If the generator is done, reset the effect.
        if (newValue.done) {
            effect.current = null;
            return;
        }
        // Always update valueRef when setting the state.
        // This is needed because the function is not regenerated with the new state value since
        // they must be stable across renders. Instead, it gets carried in the ref, but the setState
        // is also needed in order to cause a rerender.
        setValue(newValue.value);
        valueRef.current = newValue.value;
    // this list of dependencies is stable, setState and refs never change after first render.
    }, [
        setValue,
        valueRef,
        effect
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        // If there is an effect currently running, continue to the next yield.
        if (effect.current) nextIter();
    });
    // queue must be a stable function, much like setState.
    let queue = (0, $1Yh1N$react.useCallback)((fn)=>{
        effect.current = fn(valueRef.current);
        nextIter();
    // this list of dependencies is stable, setState and refs never change after first render.
    // in addition, nextIter is stable as outlined above
    }, [
        nextIter,
        effect,
        valueRef
    ]);
    return [
        value,
        queue
    ];
}


let $8c61827343eed941$var$idsUpdaterMap = new Map();
function $8c61827343eed941$export$f680877a34711e37(defaultId) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultId);
    let nextId = (0, $1Yh1N$react.useRef)(null);
    let res = (0, $1Yh1N$reactariassr.useSSRSafeId)(value);
    let updateValue = (0, $1Yh1N$react.useCallback)((val)=>{
        nextId.current = val;
    }, []);
    $8c61827343eed941$var$idsUpdaterMap.set(res, updateValue);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        let r = res;
        return ()=>{
            $8c61827343eed941$var$idsUpdaterMap.delete(r);
        };
    }, [
        res
    ]);
    // This cannot cause an infinite loop because the ref is updated first.
    // eslint-disable-next-line
    (0, $1Yh1N$react.useEffect)(()=>{
        let newId = nextId.current;
        if (newId) {
            nextId.current = null;
            setValue(newId);
        }
    });
    return res;
}
function $8c61827343eed941$export$cd8c9cb68f842629(idA, idB) {
    if (idA === idB) return idA;
    let setIdA = $8c61827343eed941$var$idsUpdaterMap.get(idA);
    if (setIdA) {
        setIdA(idB);
        return idB;
    }
    let setIdB = $8c61827343eed941$var$idsUpdaterMap.get(idB);
    if (setIdB) {
        setIdB(idA);
        return idA;
    }
    return idB;
}
function $8c61827343eed941$export$b4cc09c592e8fdb8(depArray = []) {
    let id = $8c61827343eed941$export$f680877a34711e37();
    let [resolvedId, setResolvedId] = (0, $19a2307bfabafaf1$export$14d238f342723f25)(id);
    let updateId = (0, $1Yh1N$react.useCallback)(()=>{
        setResolvedId(function*() {
            yield id;
            yield document.getElementById(id) ? id : undefined;
        });
    }, [
        id,
        setResolvedId
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(updateId, [
        id,
        updateId,
        ...depArray
    ]);
    return resolvedId;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /**
 * Calls all functions in the order they were chained with the same arguments.
 */ function $1e2191638e54f613$export$e08e3b67e392101e(...callbacks) {
    return (...args)=>{
        for (let callback of callbacks)if (typeof callback === "function") callback(...args);
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $f847cd1382ea7cd4$export$9d1611c77c2fe928(...args) {
    // Start with a base clone of the first argument. This is a lot faster than starting
    // with an empty object and adding properties as we go.
    let result = {
        ...args[0]
    };
    for(let i = 1; i < args.length; i++){
        let props = args[i];
        for(let key in props){
            let a = result[key];
            let b = props[key];
            // Chain events
            if (typeof a === "function" && typeof b === "function" && // This is a lot faster than a regex.
            key[0] === "o" && key[1] === "n" && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = (0, $1e2191638e54f613$export$e08e3b67e392101e)(a, b);
            else if ((key === "className" || key === "UNSAFE_className") && typeof a === "string" && typeof b === "string") result[key] = (0, ($parcel$interopDefault($1Yh1N$clsx)))(a, b);
            else if (key === "id" && a && b) result.id = (0, $8c61827343eed941$export$cd8c9cb68f842629)(a, b);
            else result[key] = b !== undefined ? b : a;
        }
    }
    return result;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $f05dc24eafaeb7e2$export$c9058316764c140e(...refs) {
    if (refs.length === 1) return refs[0];
    return (value)=>{
        for (let ref of refs){
            if (typeof ref === "function") ref(value);
            else if (ref != null) ref.current = value;
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ const $8d15d0e1797d4238$var$DOMPropNames = new Set([
    "id"
]);
const $8d15d0e1797d4238$var$labelablePropNames = new Set([
    "aria-label",
    "aria-labelledby",
    "aria-describedby",
    "aria-details"
]);
const $8d15d0e1797d4238$var$propRe = /^(data-.*)$/;
function $8d15d0e1797d4238$export$457c3d6518dd4c6f(props, opts = {}) {
    let { labelable: labelable , propNames: propNames  } = opts;
    let filteredProps = {};
    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($8d15d0e1797d4238$var$DOMPropNames.has(prop) || labelable && $8d15d0e1797d4238$var$labelablePropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $8d15d0e1797d4238$var$propRe.test(prop))) filteredProps[prop] = props[prop];
    return filteredProps;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $1117b6c0d4c4c164$export$de79e2c695e052f3(element) {
    if ($1117b6c0d4c4c164$var$supportsPreventScroll()) element.focus({
        preventScroll: true
    });
    else {
        let scrollableElements = $1117b6c0d4c4c164$var$getScrollableElements(element);
        element.focus();
        $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements);
    }
}
let $1117b6c0d4c4c164$var$supportsPreventScrollCached = null;
function $1117b6c0d4c4c164$var$supportsPreventScroll() {
    if ($1117b6c0d4c4c164$var$supportsPreventScrollCached == null) {
        $1117b6c0d4c4c164$var$supportsPreventScrollCached = false;
        try {
            var focusElem = document.createElement("div");
            focusElem.focus({
                get preventScroll () {
                    $1117b6c0d4c4c164$var$supportsPreventScrollCached = true;
                    return true;
                }
            });
        } catch (e) {
        // Ignore
        }
    }
    return $1117b6c0d4c4c164$var$supportsPreventScrollCached;
}
function $1117b6c0d4c4c164$var$getScrollableElements(element) {
    var parent = element.parentNode;
    var scrollableElements = [];
    var rootScrollingElement = document.scrollingElement || document.documentElement;
    while(parent instanceof HTMLElement && parent !== rootScrollingElement){
        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({
            element: parent,
            scrollTop: parent.scrollTop,
            scrollLeft: parent.scrollLeft
        });
        parent = parent.parentNode;
    }
    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
        element: rootScrollingElement,
        scrollTop: rootScrollingElement.scrollTop,
        scrollLeft: rootScrollingElement.scrollLeft
    });
    return scrollableElements;
}
function $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements) {
    for (let { element: element , scrollTop: scrollTop , scrollLeft: scrollLeft  } of scrollableElements){
        element.scrollTop = scrollTop;
        element.scrollLeft = scrollLeft;
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $16ec41ef3e36c19c$export$622cea445a1c5b7d(element, reverse, orientation = "horizontal") {
    let rect = element.getBoundingClientRect();
    if (reverse) return orientation === "horizontal" ? rect.right : rect.bottom;
    return orientation === "horizontal" ? rect.left : rect.top;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We store a global list of elements that are currently transitioning,
// mapped to a set of CSS properties that are transitioning for that element.
// This is necessary rather than a simple count of transitions because of browser
// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather
// than one or the other. So we need to track what's actually transitioning so that
// we can ignore these duplicate events.
let $e8117ebcab55be6a$var$transitionsByElement = new Map();
// A list of callbacks to call once there are no transitioning elements.
let $e8117ebcab55be6a$var$transitionCallbacks = new Set();
function $e8117ebcab55be6a$var$setupGlobalEvents() {
    if (typeof window === "undefined") return;
    let onTransitionStart = (e)=>{
        // Add the transitioning property to the list for this element.
        let transitions = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!transitions) {
            transitions = new Set();
            $e8117ebcab55be6a$var$transitionsByElement.set(e.target, transitions);
            // The transitioncancel event must be registered on the element itself, rather than as a global
            // event. This enables us to handle when the node is deleted from the document while it is transitioning.
            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.
            e.target.addEventListener("transitioncancel", onTransitionEnd);
        }
        transitions.add(e.propertyName);
    };
    let onTransitionEnd = (e)=>{
        // Remove property from list of transitioning properties.
        let properties = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!properties) return;
        properties.delete(e.propertyName);
        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.
        if (properties.size === 0) {
            e.target.removeEventListener("transitioncancel", onTransitionEnd);
            $e8117ebcab55be6a$var$transitionsByElement.delete(e.target);
        }
        // If no transitioning elements, call all of the queued callbacks.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) {
            for (let cb of $e8117ebcab55be6a$var$transitionCallbacks)cb();
            $e8117ebcab55be6a$var$transitionCallbacks.clear();
        }
    };
    document.body.addEventListener("transitionrun", onTransitionStart);
    document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e8117ebcab55be6a$var$setupGlobalEvents();
    else document.addEventListener("DOMContentLoaded", $e8117ebcab55be6a$var$setupGlobalEvents);
}
function $e8117ebcab55be6a$export$24490316f764c430(fn) {
    // Wait one frame to see if an animation starts, e.g. a transition on mount.
    requestAnimationFrame(()=>{
        // If no transitions are running, call the function immediately.
        // Otherwise, add it to a list of callbacks to run at the end of the animation.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) fn();
        else $e8117ebcab55be6a$var$transitionCallbacks.add(fn);
    });
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 

// Keep track of elements that we are currently handling dragging for via useDrag1D.
// If there's an ancestor and a descendant both using useDrag1D(), and the user starts
// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.
const $28ed3fb20343b78b$var$draggingElements = [];
function $28ed3fb20343b78b$export$7bbed75feba39706(props) {
    console.warn("useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html");
    let { containerRef: containerRef , reverse: reverse , orientation: orientation , onHover: onHover , onDrag: onDrag , onPositionChange: onPositionChange , onIncrement: onIncrement , onDecrement: onDecrement , onIncrementToMax: onIncrementToMax , onDecrementToMin: onDecrementToMin , onCollapseToggle: onCollapseToggle  } = props;
    let getPosition = (e)=>orientation === "horizontal" ? e.clientX : e.clientY;
    let getNextOffset = (e)=>{
        let containerOffset = (0, $16ec41ef3e36c19c$export$622cea445a1c5b7d)(containerRef.current, reverse, orientation);
        let mouseOffset = getPosition(e);
        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;
        return nextOffset;
    };
    let dragging = (0, $1Yh1N$react.useRef)(false);
    let prevPosition = (0, $1Yh1N$react.useRef)(0);
    // Keep track of the current handlers in a ref so that the events can access them.
    let handlers = (0, $1Yh1N$react.useRef)({
        onPositionChange: onPositionChange,
        onDrag: onDrag
    });
    handlers.current.onDrag = onDrag;
    handlers.current.onPositionChange = onPositionChange;
    let onMouseDragged = (e)=>{
        e.preventDefault();
        let nextOffset = getNextOffset(e);
        if (!dragging.current) {
            dragging.current = true;
            if (handlers.current.onDrag) handlers.current.onDrag(true);
            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        }
        if (prevPosition.current === nextOffset) return;
        prevPosition.current = nextOffset;
        if (onPositionChange) onPositionChange(nextOffset);
    };
    let onMouseUp = (e)=>{
        const target = e.target;
        dragging.current = false;
        let nextOffset = getNextOffset(e);
        if (handlers.current.onDrag) handlers.current.onDrag(false);
        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        $28ed3fb20343b78b$var$draggingElements.splice($28ed3fb20343b78b$var$draggingElements.indexOf(target), 1);
        window.removeEventListener("mouseup", onMouseUp, false);
        window.removeEventListener("mousemove", onMouseDragged, false);
    };
    let onMouseDown = (e)=>{
        const target = e.currentTarget;
        // If we're already handling dragging on a descendant with useDrag1D, then
        // we don't want to handle the drag motion on this target as well.
        if ($28ed3fb20343b78b$var$draggingElements.some((elt)=>target.contains(elt))) return;
        $28ed3fb20343b78b$var$draggingElements.push(target);
        window.addEventListener("mousemove", onMouseDragged, false);
        window.addEventListener("mouseup", onMouseUp, false);
    };
    let onMouseEnter = ()=>{
        if (onHover) onHover(true);
    };
    let onMouseOut = ()=>{
        if (onHover) onHover(false);
    };
    let onKeyDown = (e)=>{
        switch(e.key){
            case "Left":
            case "ArrowLeft":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Up":
            case "ArrowUp":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Right":
            case "ArrowRight":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Down":
            case "ArrowDown":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Home":
                e.preventDefault();
                if (onDecrementToMin) onDecrementToMin();
                break;
            case "End":
                e.preventDefault();
                if (onIncrementToMax) onIncrementToMax();
                break;
            case "Enter":
                e.preventDefault();
                if (onCollapseToggle) onCollapseToggle();
                break;
        }
    };
    return {
        onMouseDown: onMouseDown,
        onMouseEnter: onMouseEnter,
        onMouseOut: onMouseOut,
        onKeyDown: onKeyDown
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $4571ff54ac709100$export$4eaf04e54aa8eed6() {
    let globalListeners = (0, $1Yh1N$react.useRef)(new Map());
    let addGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        // Make sure we remove the listener after it is called with the `once` option.
        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{
            globalListeners.current.delete(listener);
            listener(...args);
        } : listener;
        globalListeners.current.set(listener, {
            type: type,
            eventTarget: eventTarget,
            fn: fn,
            options: options
        });
        eventTarget.addEventListener(type, listener, options);
    }, []);
    let removeGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        var _globalListeners_current_get;
        let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
        eventTarget.removeEventListener(type, fn, options);
        globalListeners.current.delete(listener);
    }, []);
    let removeAllGlobalListeners = (0, $1Yh1N$react.useCallback)(()=>{
        globalListeners.current.forEach((value, key)=>{
            removeGlobalListener(value.eventTarget, value.type, key, value.options);
        });
    }, [
        removeGlobalListener
    ]);
    // eslint-disable-next-line arrow-body-style
    (0, $1Yh1N$react.useEffect)(()=>{
        return removeAllGlobalListeners;
    }, [
        removeAllGlobalListeners
    ]);
    return {
        addGlobalListener: addGlobalListener,
        removeGlobalListener: removeGlobalListener,
        removeAllGlobalListeners: removeAllGlobalListeners
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6ec78bde395c477d$export$d6875122194c7b44(props, defaultLabel) {
    let { id: id , "aria-label": label , "aria-labelledby": labelledBy  } = props;
    // If there is both an aria-label and aria-labelledby,
    // combine them by pointing to the element itself.
    id = (0, $8c61827343eed941$export$f680877a34711e37)(id);
    if (labelledBy && label) {
        let ids = new Set([
            id,
            ...labelledBy.trim().split(/\s+/)
        ]);
        labelledBy = [
            ...ids
        ].join(" ");
    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\s+/).join(" ");
    // If no labels are provided, use the default
    if (!label && !labelledBy && defaultLabel) label = defaultLabel;
    return {
        id: id,
        "aria-label": label,
        "aria-labelledby": labelledBy
    };
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $475b35fe72ba49b3$export$4338b53315abf666(forwardedRef) {
    const objRef = (0, $1Yh1N$react.useRef)();
    return (0, $1Yh1N$react.useMemo)(()=>({
            get current () {
                return objRef.current;
            },
            set current (value){
                objRef.current = value;
                if (typeof forwardedRef === "function") forwardedRef(value);
                else if (forwardedRef) forwardedRef.current = value;
            }
        }), [
        forwardedRef
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $29293a6f5c75b37e$export$496315a1608d9602(effect, dependencies) {
    const isInitialMount = (0, $1Yh1N$react.useRef)(true);
    const lastDeps = (0, $1Yh1N$react.useRef)(null);
    (0, $1Yh1N$react.useEffect)(()=>{
        isInitialMount.current = true;
        return ()=>{
            isInitialMount.current = false;
        };
    }, []);
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isInitialMount.current) isInitialMount.current = false;
        else if (!lastDeps.current || dependencies.some((dep, i)=>!Object.is(dep, lastDeps[i]))) effect();
        lastDeps.current = dependencies;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencies);
}




function $37733e1652f47193$var$hasResizeObserver() {
    return typeof window.ResizeObserver !== "undefined";
}
function $37733e1652f47193$export$683480f191c0e3ea(options) {
    const { ref: ref , onResize: onResize  } = options;
    (0, $1Yh1N$react.useEffect)(()=>{
        let element = ref === null || ref === void 0 ? void 0 : ref.current;
        if (!element) return;
        if (!$37733e1652f47193$var$hasResizeObserver()) {
            window.addEventListener("resize", onResize, false);
            return ()=>{
                window.removeEventListener("resize", onResize, false);
            };
        } else {
            const resizeObserverInstance = new window.ResizeObserver((entries)=>{
                if (!entries.length) return;
                onResize();
            });
            resizeObserverInstance.observe(element);
            return ()=>{
                if (element) resizeObserverInstance.unobserve(element);
            };
        }
    }, [
        onResize,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6fc733991a9f977c$export$4debdb1a3f0fa79e(context, ref) {
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (context && context.ref && ref) {
            context.ref.current = ref.current;
            return ()=>{
                context.ref.current = null;
            };
        }
    }, [
        context,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d796e7157ac96470$export$cfa2225e87938781(node) {
    if ($d796e7157ac96470$export$2bb74740c4e19def(node)) node = node.parentElement;
    while(node && !$d796e7157ac96470$export$2bb74740c4e19def(node))node = node.parentElement;
    return node || document.scrollingElement || document.documentElement;
}
function $d796e7157ac96470$export$2bb74740c4e19def(node) {
    let style = window.getComputedStyle(node);
    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// @ts-ignore
let $8b24bab62f5c65ad$var$visualViewport = typeof window !== "undefined" && window.visualViewport;
function $8b24bab62f5c65ad$export$d699905dd57c73ca() {
    let [size, setSize] = (0, $1Yh1N$react.useState)(()=>$8b24bab62f5c65ad$var$getViewportSize());
    (0, $1Yh1N$react.useEffect)(()=>{
        // Use visualViewport api to track available height even on iOS virtual keyboard opening
        let onResize = ()=>{
            setSize((size)=>{
                let newSize = $8b24bab62f5c65ad$var$getViewportSize();
                if (newSize.width === size.width && newSize.height === size.height) return size;
                return newSize;
            });
        };
        if (!$8b24bab62f5c65ad$var$visualViewport) window.addEventListener("resize", onResize);
        else $8b24bab62f5c65ad$var$visualViewport.addEventListener("resize", onResize);
        return ()=>{
            if (!$8b24bab62f5c65ad$var$visualViewport) window.removeEventListener("resize", onResize);
            else $8b24bab62f5c65ad$var$visualViewport.removeEventListener("resize", onResize);
        };
    }, []);
    return size;
}
function $8b24bab62f5c65ad$var$getViewportSize() {
    return {
        width: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.width) || window.innerWidth,
        height: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.height) || window.innerHeight
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

let $34da4502ea8120db$var$descriptionId = 0;
const $34da4502ea8120db$var$descriptionNodes = new Map();
function $34da4502ea8120db$export$f8aeda7b10753fa1(description) {
    let [id, setId] = (0, $1Yh1N$react.useState)(undefined);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (!description) return;
        let desc = $34da4502ea8120db$var$descriptionNodes.get(description);
        if (!desc) {
            let id = `react-aria-description-${$34da4502ea8120db$var$descriptionId++}`;
            setId(id);
            let node = document.createElement("div");
            node.id = id;
            node.style.display = "none";
            node.textContent = description;
            document.body.appendChild(node);
            desc = {
                refCount: 0,
                element: node
            };
            $34da4502ea8120db$var$descriptionNodes.set(description, desc);
        } else setId(desc.element.id);
        desc.refCount++;
        return ()=>{
            if (--desc.refCount === 0) {
                desc.element.remove();
                $34da4502ea8120db$var$descriptionNodes.delete(description);
            }
        };
    }, [
        description
    ]);
    return {
        "aria-describedby": description ? id : undefined
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $9e20cff0af27e8cc$var$testUserAgent(re) {
    var _window_navigator_userAgentData;
    if (typeof window === "undefined" || window.navigator == null) return false;
    return ((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand)=>re.test(brand.brand))) || re.test(window.navigator.userAgent);
}
function $9e20cff0af27e8cc$var$testPlatform(re) {
    var _window_navigator_userAgentData;
    return typeof window !== "undefined" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $9e20cff0af27e8cc$export$9ac100e40613ea10() {
    return $9e20cff0af27e8cc$var$testPlatform(/^Mac/i);
}
function $9e20cff0af27e8cc$export$186c6964ca17d99() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPhone/i);
}
function $9e20cff0af27e8cc$export$7bef049ce92e4224() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
    $9e20cff0af27e8cc$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
}
function $9e20cff0af27e8cc$export$fedb369cb70207f1() {
    return $9e20cff0af27e8cc$export$186c6964ca17d99() || $9e20cff0af27e8cc$export$7bef049ce92e4224();
}
function $9e20cff0af27e8cc$export$e1865c3bedcd822b() {
    return $9e20cff0af27e8cc$export$9ac100e40613ea10() || $9e20cff0af27e8cc$export$fedb369cb70207f1();
}
function $9e20cff0af27e8cc$export$78551043582a6a98() {
    return $9e20cff0af27e8cc$var$testUserAgent(/AppleWebKit/i) && !$9e20cff0af27e8cc$export$6446a186d09e379e();
}
function $9e20cff0af27e8cc$export$6446a186d09e379e() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Chrome/i);
}
function $9e20cff0af27e8cc$export$a11b0059900ceec8() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Android/i);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1254e5bb94ac8761$export$7f54fc3180508a52(fn) {
    const ref = (0, $1Yh1N$react.useRef)(null);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        ref.current = fn;
    }, [
        fn
    ]);
    return (0, $1Yh1N$react.useCallback)((...args)=>{
        const f = ref.current;
        return f(...args);
    }, []);
}


function $2a8c0bb1629926c8$export$90fc3a17d93f704c(ref, event, handler, options) {
    let handleEvent = (0, $1254e5bb94ac8761$export$7f54fc3180508a52)(handler);
    let isDisabled = handler == null;
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isDisabled) return;
        let element = ref.current;
        element.addEventListener(event, handleEvent, options);
        return ()=>{
            element.removeEventListener(event, handleEvent, options);
        };
    }, [
        ref,
        event,
        options,
        isDisabled,
        handleEvent
    ]);
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $449412113267a1fe$export$53a0910f038337bd(scrollView, element) {
    let offsetX = $449412113267a1fe$var$relativeOffset(scrollView, element, "left");
    let offsetY = $449412113267a1fe$var$relativeOffset(scrollView, element, "top");
    let width = element.offsetWidth;
    let height = element.offsetHeight;
    let x = scrollView.scrollLeft;
    let y = scrollView.scrollTop;
    // Account for top/left border offsetting the scroll top/Left
    let { borderTopWidth: borderTopWidth , borderLeftWidth: borderLeftWidth  } = getComputedStyle(scrollView);
    let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);
    let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);
    // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width
    let maxX = borderAdjustedX + scrollView.clientWidth;
    let maxY = borderAdjustedY + scrollView.clientHeight;
    if (offsetX <= x) x = offsetX - parseInt(borderLeftWidth, 10);
    else if (offsetX + width > maxX) x += offsetX + width - maxX;
    if (offsetY <= borderAdjustedY) y = offsetY - parseInt(borderTopWidth, 10);
    else if (offsetY + height > maxY) y += offsetY + height - maxY;
    scrollView.scrollLeft = x;
    scrollView.scrollTop = y;
}
/**
 * Computes the offset left or top from child to ancestor by accumulating
 * offsetLeft or offsetTop through intervening offsetParents.
 */ function $449412113267a1fe$var$relativeOffset(ancestor, child, axis) {
    const prop = axis === "left" ? "offsetLeft" : "offsetTop";
    let sum = 0;
    while(child.offsetParent){
        sum += child[prop];
        if (child.offsetParent === ancestor) break;
        else if (child.offsetParent.contains(ancestor)) {
            // If the ancestor is not `position:relative`, then we stop at
            // _its_ offset parent, and we subtract off _its_ offset, so that
            // we end up with the proper offset from child to ancestor.
            sum -= ancestor[prop];
            break;
        }
        child = child.offsetParent;
    }
    return sum;
}
function $449412113267a1fe$export$c826860796309d1b(targetElement, opts) {
    if (document.contains(targetElement)) {
        let root = document.scrollingElement || document.documentElement;
        let isScrollPrevented = window.getComputedStyle(root).overflow === "hidden";
        // If scrolling is not currently prevented then we aren’t in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view
        if (!isScrollPrevented) {
            var // use scrollIntoView({block: 'nearest'}) instead of .focus to check if the element is fully in view or not since .focus()
            // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically
            _targetElement_scrollIntoView;
            let { left: originalLeft , top: originalTop  } = targetElement.getBoundingClientRect();
            targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {
                block: "nearest"
            });
            let { left: newLeft , top: newTop  } = targetElement.getBoundingClientRect();
            // Account for sub pixel differences from rounding
            if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {
                var _opts_containingElement, _opts_containingElement_scrollIntoView, _targetElement_scrollIntoView1;
                opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {
                    block: "center",
                    inline: "center"
                });
                (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {
                    block: "nearest"
                });
            }
        } else {
            let scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.
            while(targetElement && scrollParent && targetElement !== root && scrollParent !== root){
                $449412113267a1fe$export$53a0910f038337bd(scrollParent, targetElement);
                targetElement = scrollParent;
                scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            }
        }
    }
}



/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $577e795361f19be9$export$60278871457622de(event) {
    // JAWS/NVDA with Firefox.
    if (event.mozInputSource === 0 && event.isTrusted) return true;
    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead
    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check
    // to detect TalkBack virtual clicks.
    if ((0, $9e20cff0af27e8cc$export$a11b0059900ceec8)() && event.pointerType) return event.type === "click" && event.buttons === 1;
    return event.detail === 0 && !event.pointerType;
}
function $577e795361f19be9$export$29bf1b5f2c56cf63(event) {
    // If the pointer size is zero, then we assume it's from a screen reader.
    // Android TalkBack double tap will sometimes return a event with width and height of 1
    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.
    // Cannot use "event.pressure === 0" as the sole check due to Safari pointer events always returning pressure === 0
    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush
    // Talkback double tap from Windows Firefox touch screen press
    return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse";
}



/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 
function $20e6e72fbf5dc81e$export$722debc0e56fea39(value, isEqual) {
    // Using a ref during render is ok here because it's only an optimization – both values are equivalent.
    // If a render is thrown away, it'll still work the same no matter if the next render is the same or not.
    let lastValue = (0, $1Yh1N$react.useRef)(null);
    if (value && lastValue.current && isEqual(value, lastValue.current)) value = lastValue.current;
    lastValue.current = value;
    return value;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 29422:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $k0DcK$react = __webpack_require__(18038);
var $k0DcK$reactariatoggle = __webpack_require__(3788);
var $k0DcK$reactariautils = __webpack_require__(77335);
var $k0DcK$reactarialabel = __webpack_require__(26894);
var $k0DcK$reactstatelytoggle = __webpack_require__(841);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useCheckbox", () => $468c774d7db917b7$export$e375f10ce42261c5);
$parcel$export(module.exports, "useCheckboxGroup", () => $253685172d17db7d$export$49ff6f28c54f1cbe);
$parcel$export(module.exports, "useCheckboxGroupItem", () => $07e03121d6ac83c8$export$353b32fc6898d37d);


function $468c774d7db917b7$export$e375f10ce42261c5(props, state, inputRef) {
    let { inputProps: inputProps  } = $k0DcK$reactariatoggle.useToggle(props, state, inputRef);
    let { isSelected: isSelected  } = state;
    let { isIndeterminate: isIndeterminate  } = props;
    $k0DcK$react.useEffect(()=>{
        // indeterminate is a property, but it can only be set via javascript
        // https://css-tricks.com/indeterminate-checkboxes/
        if (inputRef.current) inputRef.current.indeterminate = isIndeterminate;
    });
    return {
        inputProps: {
            ...inputProps,
            checked: isSelected,
            'aria-checked': isIndeterminate ? 'mixed' : isSelected
        }
    };
}


const $64fc3370e682155f$export$31440636951aa68c = new WeakMap();
const $64fc3370e682155f$export$a3077e9c93f7360f = new WeakMap();
const $64fc3370e682155f$export$d5679492e2864181 = new WeakMap();




function $253685172d17db7d$export$49ff6f28c54f1cbe(props, state) {
    let { isDisabled: isDisabled , name: name  } = props;
    let { labelProps: labelProps , fieldProps: fieldProps , descriptionProps: descriptionProps , errorMessageProps: errorMessageProps  } = $k0DcK$reactarialabel.useField({
        ...props,
        // Checkbox group is not an HTML input element so it
        // shouldn't be labeled by a <label> element.
        labelElementType: 'span'
    });
    $64fc3370e682155f$export$a3077e9c93f7360f.set(state, descriptionProps.id);
    $64fc3370e682155f$export$d5679492e2864181.set(state, errorMessageProps.id);
    let domProps = $k0DcK$reactariautils.filterDOMProps(props, {
        labelable: true
    });
    // Pass name prop from group to all items by attaching to the state.
    $64fc3370e682155f$export$31440636951aa68c.set(state, name);
    return {
        groupProps: $k0DcK$reactariautils.mergeProps(domProps, {
            role: 'group',
            'aria-disabled': isDisabled || undefined,
            ...fieldProps
        }),
        labelProps: labelProps,
        descriptionProps: descriptionProps,
        errorMessageProps: errorMessageProps
    };
}





function $07e03121d6ac83c8$export$353b32fc6898d37d(props, state, inputRef) {
    const toggleState = $k0DcK$reactstatelytoggle.useToggleState({
        isReadOnly: props.isReadOnly || state.isReadOnly,
        isSelected: state.isSelected(props.value),
        onChange (isSelected) {
            if (isSelected) state.addValue(props.value);
            else state.removeValue(props.value);
            if (props.onChange) props.onChange(isSelected);
        }
    });
    let { inputProps: inputProps  } = $468c774d7db917b7$export$e375f10ce42261c5({
        ...props,
        isReadOnly: props.isReadOnly || state.isReadOnly,
        isDisabled: props.isDisabled || state.isDisabled,
        name: props.name || $64fc3370e682155f$export$31440636951aa68c.get(state)
    }, toggleState, inputRef);
    return {
        inputProps: {
            ...inputProps,
            'aria-describedby': [
                state.validationState === 'invalid' ? $64fc3370e682155f$export$d5679492e2864181.get(state) : null,
                $64fc3370e682155f$export$a3077e9c93f7360f.get(state)
            ].filter(Boolean).join(' ') || undefined
        }
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 3031:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $6vrKB$reactariautils = __webpack_require__(78659);
var $6vrKB$reactariafocus = __webpack_require__(9637);
var $6vrKB$react = __webpack_require__(18038);
var $6vrKB$reactariaoverlays = __webpack_require__(27807);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useDialog", () => $e7b76b4fae4e4c55$export$d55e7ee900f34e93);




function $e7b76b4fae4e4c55$export$d55e7ee900f34e93(props, ref) {
    let { role: role = 'dialog'  } = props;
    let titleId = $6vrKB$reactariautils.useSlotId();
    titleId = props['aria-label'] ? undefined : titleId;
    let isRefocusing = $6vrKB$react.useRef(false);
    // Focus the dialog itself on mount, unless a child element is already focused.
    $6vrKB$react.useEffect(()=>{
        if (ref.current && !ref.current.contains(document.activeElement)) {
            $6vrKB$reactariafocus.focusSafely(ref.current);
            // Safari on iOS does not move the VoiceOver cursor to the dialog
            // or announce that it has opened until it has rendered. A workaround
            // is to wait for half a second, then blur and re-focus the dialog.
            let timeout = setTimeout(()=>{
                if (document.activeElement === ref.current) {
                    isRefocusing.current = true;
                    ref.current.blur();
                    $6vrKB$reactariafocus.focusSafely(ref.current);
                    isRefocusing.current = false;
                }
            }, 500);
            return ()=>{
                clearTimeout(timeout);
            };
        }
    }, [
        ref
    ]);
    $6vrKB$reactariaoverlays.useOverlayFocusContain();
    // We do not use aria-modal due to a Safari bug which forces the first focusable element to be focused
    // on mount when inside an iframe, no matter which element we programmatically focus.
    // See https://bugs.webkit.org/show_bug.cgi?id=211934.
    // useModal sets aria-hidden on all elements outside the dialog, so the dialog will behave as a modal
    // even without aria-modal on the dialog itself.
    return {
        dialogProps: {
            ...$6vrKB$reactariautils.filterDOMProps(props, {
                labelable: true
            }),
            role: role,
            tabIndex: -1,
            'aria-labelledby': props['aria-labelledby'] || titleId,
            // Prevent blur events from reaching useOverlay, which may cause
            // popovers to close. Since focus is contained within the dialog,
            // we don't want this to occur due to the above useEffect.
            onBlur: (e)=>{
                if (isRefocusing.current) e.stopPropagation();
            }
        },
        titleProps: {
            id: titleId
        }
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 9637:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $aB6Cp$react = __webpack_require__(18038);
var $aB6Cp$reactariautils = __webpack_require__(78659);
var $aB6Cp$reactariainteractions = __webpack_require__(16151);
var $aB6Cp$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "FocusScope", () => $a7a032acae3ddda9$export$20e40289641fbbb6);
$parcel$export(module.exports, "useFocusManager", () => $a7a032acae3ddda9$export$10c5169755ce7bd7);
$parcel$export(module.exports, "getFocusableTreeWalker", () => $a7a032acae3ddda9$export$2d6ec8fc375ceafa);
$parcel$export(module.exports, "createFocusManager", () => $a7a032acae3ddda9$export$c5251b9e124bf29);
$parcel$export(module.exports, "isElementInChildOfActiveScope", () => $a7a032acae3ddda9$export$1258395f99bf9cbf);
$parcel$export(module.exports, "FocusRing", () => $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d);
$parcel$export(module.exports, "FocusableProvider", () => $fb504d83237fd6ac$export$13f3202a3e5ddd5);
$parcel$export(module.exports, "useFocusable", () => $fb504d83237fd6ac$export$4c014de7c8940b4c);
$parcel$export(module.exports, "useFocusRing", () => $581a96d6eb128c1b$export$4e328f61c538687f);
$parcel$export(module.exports, "focusSafely", () => $1c7f9157d722357d$export$80f3e147d781571c);
$parcel$export(module.exports, "useHasTabbableChild", () => $259c6413a286f2e6$export$eac1895992b9f3d6);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1c7f9157d722357d$export$80f3e147d781571c(element) {
    // If the user is interacting with a virtual cursor, e.g. screen reader, then
    // wait until after any animated transitions that are currently occurring on
    // the page before shifting focus. This avoids issues with VoiceOver on iOS
    // causing the page to scroll when moving focus if the element is transitioning
    // from off the screen.
    if ((0, $aB6Cp$reactariainteractions.getInteractionModality)() === "virtual") {
        let lastFocusedElement = document.activeElement;
        (0, $aB6Cp$reactariautils.runAfterTransition)(()=>{
            // If focus did not move and the element is still in the document, focus it.
            if (document.activeElement === lastFocusedElement && document.contains(element)) (0, $aB6Cp$reactariautils.focusWithoutScrolling)(element);
        });
    } else (0, $aB6Cp$reactariautils.focusWithoutScrolling)(element);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d5156037ad898a4d$var$isStyleVisible(element) {
    if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) return false;
    let { display: display , visibility: visibility  } = element.style;
    let isVisible = display !== "none" && visibility !== "hidden" && visibility !== "collapse";
    if (isVisible) {
        const { getComputedStyle: getComputedStyle  } = element.ownerDocument.defaultView;
        let { display: computedDisplay , visibility: computedVisibility  } = getComputedStyle(element);
        isVisible = computedDisplay !== "none" && computedVisibility !== "hidden" && computedVisibility !== "collapse";
    }
    return isVisible;
}
function $d5156037ad898a4d$var$isAttributeVisible(element, childElement) {
    return !element.hasAttribute("hidden") && (element.nodeName === "DETAILS" && childElement && childElement.nodeName !== "SUMMARY" ? element.hasAttribute("open") : true);
}
function $d5156037ad898a4d$export$e989c0fffaa6b27a(element, childElement) {
    return element.nodeName !== "#comment" && $d5156037ad898a4d$var$isStyleVisible(element) && $d5156037ad898a4d$var$isAttributeVisible(element, childElement) && (!element.parentElement || $d5156037ad898a4d$export$e989c0fffaa6b27a(element.parentElement, element));
}




const $a7a032acae3ddda9$var$FocusContext = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createContext(null);
let $a7a032acae3ddda9$var$activeScope = null;
function $a7a032acae3ddda9$export$20e40289641fbbb6(props) {
    let { children: children , contain: contain , restoreFocus: restoreFocus , autoFocus: autoFocus  } = props;
    let startRef = (0, $aB6Cp$react.useRef)();
    let endRef = (0, $aB6Cp$react.useRef)();
    let scopeRef = (0, $aB6Cp$react.useRef)([]);
    let { parentNode: parentNode  } = (0, $aB6Cp$react.useContext)($a7a032acae3ddda9$var$FocusContext) || {};
    // Create a tree node here so we can add children to it even before it is added to the tree.
    let node = (0, $aB6Cp$react.useMemo)(()=>new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: scopeRef
        }), [
        scopeRef
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),
        // use the active scope as the parent instead of the parent from context. Layout effects run bottom
        // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope
        // that is being added should get the activeScope as its parent.
        let parent = parentNode || $a7a032acae3ddda9$export$d06fae2ee68b101e.root;
        if ($a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(parent.scopeRef) && $a7a032acae3ddda9$var$activeScope && !$a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, parent.scopeRef)) {
            let activeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
            if (activeNode) parent = activeNode;
        }
        // Add the node to the parent, and to the tree.
        parent.addChild(node);
        $a7a032acae3ddda9$export$d06fae2ee68b101e.addNode(node);
    }, [
        node,
        parentNode
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let node = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef);
        node.contain = contain;
    }, [
        contain
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        // Find all rendered nodes between the sentinels and add them to the scope.
        let node = startRef.current.nextSibling;
        let nodes = [];
        while(node && node !== endRef.current){
            nodes.push(node);
            node = node.nextSibling;
        }
        scopeRef.current = nodes;
    }, [
        children
    ]);
    $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain);
    $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus);
    // this layout effect needs to run last so that focusScopeTree cleanup happens at the last moment possible
    (0, $aB6Cp$react.useEffect)(()=>{
        if (scopeRef) {
            let activeElement = document.activeElement;
            let scope = null;
            // In strict mode, active scope is incorrectly updated since cleanup will run even though scope hasn't unmounted.
            // To fix this, we need to update the actual activeScope here
            if ($a7a032acae3ddda9$var$isElementInScope(activeElement, scopeRef.current)) {
                // Since useLayoutEffect runs for children first, we need to traverse the focusScope tree and find the bottom most scope that
                // contains the active element and set that as the activeScope
                for (let node of $a7a032acae3ddda9$export$d06fae2ee68b101e.traverse())if ($a7a032acae3ddda9$var$isElementInScope(activeElement, node.scopeRef.current)) scope = node;
                if (scope === $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef)) $a7a032acae3ddda9$var$activeScope = scope.scopeRef;
            }
            return ()=>{
                // Scope may have been re-parented.
                let parentScope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).parent.scopeRef;
                // Restore the active scope on unmount if this scope or a descendant scope is active.
                // Parent effect cleanups run before children, so we need to check if the
                // parent scope actually still exists before restoring the active scope to it.
                if ((scopeRef === $a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope(scopeRef, $a7a032acae3ddda9$var$activeScope)) && (!parentScope || $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(parentScope))) $a7a032acae3ddda9$var$activeScope = parentScope;
                $a7a032acae3ddda9$export$d06fae2ee68b101e.removeTreeNode(scopeRef);
            };
        }
    }, [
        scopeRef
    ]);
    let focusManager = (0, $aB6Cp$react.useMemo)(()=>$a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef), []);
    let value = (0, $aB6Cp$react.useMemo)(()=>({
            focusManager: focusManager,
            parentNode: node
        }), [
        node,
        focusManager
    ]);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement($a7a032acae3ddda9$var$FocusContext.Provider, {
        value: value
    }, /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement("span", {
        "data-focus-scope-start": true,
        hidden: true,
        ref: startRef
    }), children, /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement("span", {
        "data-focus-scope-end": true,
        hidden: true,
        ref: endRef
    }));
}
function $a7a032acae3ddda9$export$10c5169755ce7bd7() {
    var _useContext;
    return (_useContext = (0, $aB6Cp$react.useContext)($a7a032acae3ddda9$var$FocusContext)) === null || _useContext === void 0 ? void 0 : _useContext.focusManager;
}
function $a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef) {
    return {
        focusNext (opts = {}) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[0].previousElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = sentinel;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = {}) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[scope.length - 1].nextElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = sentinel;
                previousNode = walker.previousNode();
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = {}) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[0].previousElementSibling;
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = {}) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[scope.length - 1].nextElementSibling;
            let previousNode = walker.previousNode();
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        }
    };
}
const $a7a032acae3ddda9$var$focusableElements = [
    "input:not([disabled]):not([type=hidden])",
    "select:not([disabled])",
    "textarea:not([disabled])",
    "button:not([disabled])",
    "a[href]",
    "area[href]",
    "summary",
    "iframe",
    "object",
    "embed",
    "audio[controls]",
    "video[controls]",
    "[contenteditable]"
];
const $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
$a7a032acae3ddda9$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(':not([hidden]):not([tabindex="-1"]),');
function $a7a032acae3ddda9$var$getScopeRoot(scope) {
    return scope[0].parentElement;
}
function $a7a032acae3ddda9$var$shouldContainFocus(scopeRef) {
    let scope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
    while(scope && scope.scopeRef !== scopeRef){
        if (scope.contain) return false;
        scope = scope.parent;
    }
    return true;
}
function $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain) {
    let focusedNode = (0, $aB6Cp$react.useRef)();
    let raf = (0, $aB6Cp$react.useRef)(null);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let scope = scopeRef.current;
        if (!contain) {
            // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment
            if (raf.current) {
                cancelAnimationFrame(raf.current);
                raf.current = null;
            }
            return;
        }
        // Handle the Tab key to contain focus within the scope
        let onKeyDown = (e)=>{
            if (e.key !== "Tab" || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) return;
            let focusedElement = document.activeElement;
            let scope = scopeRef.current;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scope)) return;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: true
            }, scope);
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!nextElement) {
                walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;
                nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            }
            e.preventDefault();
            if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
        };
        let onFocus = (e)=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if ((!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) && $a7a032acae3ddda9$var$isElementInScope(e.target, scopeRef.current)) {
                $a7a032acae3ddda9$var$activeScope = scopeRef;
                focusedNode.current = e.target;
            } else if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(e.target, scopeRef)) {
                // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),
                // restore focus to the previously focused node or the first tabbable element in the active scope.
                if (focusedNode.current) focusedNode.current.focus();
                else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
            } else if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) focusedNode.current = e.target;
        };
        let onBlur = (e)=>{
            // Firefox doesn't shift focus back to the Dialog properly without this
            if (raf.current) cancelAnimationFrame(raf.current);
            raf.current = requestAnimationFrame(()=>{
                // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe
                if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(document.activeElement, scopeRef)) {
                    $a7a032acae3ddda9$var$activeScope = scopeRef;
                    if (document.body.contains(e.target)) {
                        focusedNode.current = e.target;
                        focusedNode.current.focus();
                    } else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
                }
            });
        };
        document.addEventListener("keydown", onKeyDown, false);
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        scope.forEach((element)=>element.addEventListener("focusout", onBlur, false));
        return ()=>{
            document.removeEventListener("keydown", onKeyDown, false);
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
            scope.forEach((element)=>element.removeEventListener("focusout", onBlur, false));
        };
    }, [
        scopeRef,
        contain
    ]);
    // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur
    // eslint-disable-next-line arrow-body-style
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        return ()=>{
            if (raf.current) cancelAnimationFrame(raf.current);
        };
    }, [
        raf
    ]);
}
function $a7a032acae3ddda9$var$isElementInAnyScope(element) {
    return $a7a032acae3ddda9$var$isElementInChildScope(element);
}
function $a7a032acae3ddda9$var$isElementInScope(element, scope) {
    return scope.some((node)=>node.contains(element));
}
function $a7a032acae3ddda9$var$isElementInChildScope(element, scope = null) {
    // If the element is within a top layer element (e.g. toasts), always allow moving focus there.
    if (element instanceof Element && element.closest("[data-react-aria-top-layer]")) return true;
    // node.contains in isElementInScope covers child scopes that are also DOM children,
    // but does not cover child scopes in portals.
    for (let { scopeRef: s  } of $a7a032acae3ddda9$export$d06fae2ee68b101e.traverse($a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scope))){
        if ($a7a032acae3ddda9$var$isElementInScope(element, s.current)) return true;
    }
    return false;
}
function $a7a032acae3ddda9$export$1258395f99bf9cbf(element) {
    return $a7a032acae3ddda9$var$isElementInChildScope(element, $a7a032acae3ddda9$var$activeScope);
}
function $a7a032acae3ddda9$var$isAncestorScope(ancestor, scope) {
    var _focusScopeTree_getTreeNode;
    let parent = (_focusScopeTree_getTreeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scope)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : _focusScopeTree_getTreeNode.parent;
    while(parent){
        if (parent.scopeRef === ancestor) return true;
        parent = parent.parent;
    }
    return false;
}
function $a7a032acae3ddda9$var$focusElement(element, scroll = false) {
    if (element != null && !scroll) try {
        (0, $1c7f9157d722357d$export$80f3e147d781571c)(element);
    } catch (err) {
    // ignore
    }
    else if (element != null) try {
        element.focus();
    } catch (err) {
    // ignore
    }
}
function $a7a032acae3ddda9$var$focusFirstInScope(scope, tabbable = true) {
    let sentinel = scope[0].previousElementSibling;
    let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
        tabbable: tabbable
    }, scope);
    walker.currentNode = sentinel;
    let nextNode = walker.nextNode();
    // If the scope does not contain a tabbable element, use the first focusable element.
    if (tabbable && !nextNode) {
        walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
            tabbable: false
        }, scope);
        walker.currentNode = sentinel;
        nextNode = walker.nextNode();
    }
    $a7a032acae3ddda9$var$focusElement(nextNode);
}
function $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus) {
    const autoFocusRef = (0, ($parcel$interopDefault($aB6Cp$react))).useRef(autoFocus);
    (0, $aB6Cp$react.useEffect)(()=>{
        if (autoFocusRef.current) {
            $a7a032acae3ddda9$var$activeScope = scopeRef;
            if (!$a7a032acae3ddda9$var$isElementInScope(document.activeElement, $a7a032acae3ddda9$var$activeScope.current)) $a7a032acae3ddda9$var$focusFirstInScope(scopeRef.current);
        }
        autoFocusRef.current = false;
    }, [
        scopeRef
    ]);
}
function $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restore, contain) {
    // tracks the active scope, in case restore and contain are both false.
    // if either are true, this is tracked in useRestoreFocus or useFocusContainment.
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if (restore || contain) return;
        let scope = scopeRef.current;
        let onFocus = (e)=>{
            let target = e.target;
            if ($a7a032acae3ddda9$var$isElementInScope(target, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
            else if (!$a7a032acae3ddda9$var$isElementInAnyScope(target)) $a7a032acae3ddda9$var$activeScope = null;
        };
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        return ()=>{
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
        };
    }, [
        scopeRef,
        restore,
        contain
    ]);
}
function $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef) {
    let scope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
    while(scope && scope.scopeRef !== scopeRef){
        if (scope.nodeToRestore) return false;
        scope = scope.parent;
    }
    return (scope === null || scope === void 0 ? void 0 : scope.scopeRef) === scopeRef;
}
function $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
    // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.
    const nodeToRestoreRef = (0, $aB6Cp$react.useRef)(typeof document !== "undefined" ? document.activeElement : null);
    // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus
    // restoring-non-containing scopes should only care if they become active so they can perform the restore
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let scope = scopeRef.current;
        if (!restoreFocus || contain) return;
        let onFocus = ()=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if ((!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) && $a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
        };
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        return ()=>{
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        scopeRef,
        contain
    ]);
    // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if (!restoreFocus) return;
        $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = nodeToRestoreRef.current;
        // Handle the Tab key so that tabbing out of the scope goes to the next element
        // after the node that had focus when the scope mounted. This is important when
        // using portals for overlays, so that focus goes to the expected element when
        // tabbing out of the overlay.
        let onKeyDown = (e)=>{
            if (e.key !== "Tab" || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) return;
            let focusedElement = document.activeElement;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scopeRef.current)) return;
            let nodeToRestore = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;
            // Create a DOM tree walker that matches all tabbable elements
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(document.body, {
                tabbable: true
            });
            // Find the next tabbable element after the currently focused element
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!document.body.contains(nodeToRestore) || nodeToRestore === document.body) {
                nodeToRestore = null;
                $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = null;
            }
            // If there is no next element, or it is outside the current scope, move focus to the
            // next element after the node to restore to instead.
            if ((!nextElement || !$a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {
                walker.currentNode = nodeToRestore;
                // Skip over elements within the scope, in case the scope immediately follows the node to restore.
                do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
                while ($a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current));
                e.preventDefault();
                e.stopPropagation();
                if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
                else // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)
                // then move focus to the body.
                // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)
                if (!$a7a032acae3ddda9$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();
                else $a7a032acae3ddda9$var$focusElement(nodeToRestore, true);
            }
        };
        if (!contain) document.addEventListener("keydown", onKeyDown, true);
        return ()=>{
            if (!contain) document.removeEventListener("keydown", onKeyDown, true);
            let nodeToRestore = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;
            // if we already lost focus to the body and this was the active scope, then we should attempt to restore
            if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps
            ($a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current) || document.activeElement === document.body && $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef))) {
                // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it
                let clonedTree = $a7a032acae3ddda9$export$d06fae2ee68b101e.clone();
                requestAnimationFrame(()=>{
                    // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere
                    if (document.activeElement === document.body) {
                        // look up the tree starting with our scope to find a nodeToRestore still in the DOM
                        let treeNode = clonedTree.getTreeNode(scopeRef);
                        while(treeNode){
                            if (treeNode.nodeToRestore && document.body.contains(treeNode.nodeToRestore)) {
                                $a7a032acae3ddda9$var$focusElement(treeNode.nodeToRestore);
                                return;
                            }
                            treeNode = treeNode.parent;
                        }
                        // If no nodeToRestore was found, focus the first element in the nearest
                        // ancestor scope that is still in the tree.
                        treeNode = clonedTree.getTreeNode(scopeRef);
                        while(treeNode){
                            if (treeNode.scopeRef && $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(treeNode.scopeRef)) {
                                $a7a032acae3ddda9$var$focusFirstInScope(treeNode.scopeRef.current, true);
                                return;
                            }
                            treeNode = treeNode.parent;
                        }
                    }
                });
            }
        };
    }, [
        scopeRef,
        restoreFocus,
        contain
    ]);
}
function $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, opts, scope) {
    let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR : $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR;
    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode (node) {
            var _opts_from;
            // Skip nodes inside the starting node.
            if (opts === null || opts === void 0 ? void 0 : (_opts_from = opts.from) === null || _opts_from === void 0 ? void 0 : _opts_from.contains(node)) return NodeFilter.FILTER_REJECT;
            if (node.matches(selector) && (0, $d5156037ad898a4d$export$e989c0fffaa6b27a)(node) && (!scope || $a7a032acae3ddda9$var$isElementInScope(node, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node))) return NodeFilter.FILTER_ACCEPT;
            return NodeFilter.FILTER_SKIP;
        }
    });
    if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;
    return walker;
}
function $a7a032acae3ddda9$export$c5251b9e124bf29(ref, defaultOptions = {}) {
    return {
        focusNext (opts = {}) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = root;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            else {
                let next = $a7a032acae3ddda9$var$last(walker);
                if (next) $a7a032acae3ddda9$var$focusElement(next, true);
                return next;
            }
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = root;
                previousNode = $a7a032acae3ddda9$var$last(walker);
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let next = $a7a032acae3ddda9$var$last(walker);
            if (next) $a7a032acae3ddda9$var$focusElement(next, true);
            return next;
        }
    };
}
function $a7a032acae3ddda9$var$last(walker) {
    let next;
    let last;
    do {
        last = walker.lastChild();
        if (last) next = last;
    }while (last);
    return next;
}
class $a7a032acae3ddda9$var$Tree {
    get size() {
        return this.fastMap.size;
    }
    getTreeNode(data) {
        return this.fastMap.get(data);
    }
    addTreeNode(scopeRef, parent, nodeToRestore) {
        let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);
        let node = new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: scopeRef
        });
        parentNode.addChild(node);
        node.parent = parentNode;
        this.fastMap.set(scopeRef, node);
        if (nodeToRestore) node.nodeToRestore = nodeToRestore;
    }
    addNode(node) {
        this.fastMap.set(node.scopeRef, node);
    }
    removeTreeNode(scopeRef) {
        // never remove the root
        if (scopeRef === null) return;
        let node = this.fastMap.get(scopeRef);
        let parentNode = node.parent;
        // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing
        // if we are, then replace the siblings restore with the restore from the scope we're removing
        for (let current of this.traverse())if (current !== node && node.nodeToRestore && current.nodeToRestore && node.scopeRef.current && $a7a032acae3ddda9$var$isElementInScope(current.nodeToRestore, node.scopeRef.current)) current.nodeToRestore = node.nodeToRestore;
        let children = node.children;
        parentNode.removeChild(node);
        if (children.size > 0) children.forEach((child)=>parentNode.addChild(child));
        this.fastMap.delete(node.scopeRef);
    }
    // Pre Order Depth First
    *traverse(node = this.root) {
        if (node.scopeRef != null) yield node;
        if (node.children.size > 0) for (let child of node.children)yield* this.traverse(child);
    }
    clone() {
        let newTree = new $a7a032acae3ddda9$var$Tree();
        for (let node of this.traverse())newTree.addTreeNode(node.scopeRef, node.parent.scopeRef, node.nodeToRestore);
        return newTree;
    }
    constructor(){
        this.fastMap = new Map();
        this.root = new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: null
        });
        this.fastMap.set(null, this.root);
    }
}
class $a7a032acae3ddda9$var$TreeNode {
    addChild(node) {
        this.children.add(node);
        node.parent = this;
    }
    removeChild(node) {
        this.children.delete(node);
        node.parent = undefined;
    }
    constructor(props){
        this.children = new Set();
        this.contain = false;
        this.scopeRef = props.scopeRef;
    }
}
let $a7a032acae3ddda9$export$d06fae2ee68b101e = new $a7a032acae3ddda9$var$Tree();


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 




function $581a96d6eb128c1b$export$4e328f61c538687f(props = {}) {
    let { autoFocus: autoFocus = false , isTextInput: isTextInput , within: within  } = props;
    let state = (0, $aB6Cp$react.useRef)({
        isFocused: false,
        isFocusVisible: autoFocus || (0, $aB6Cp$reactariainteractions.isFocusVisible)()
    });
    let [isFocused, setFocused] = (0, $aB6Cp$react.useState)(false);
    let [isFocusVisibleState, setFocusVisible] = (0, $aB6Cp$react.useState)(()=>state.current.isFocused && state.current.isFocusVisible);
    let updateState = (0, $aB6Cp$react.useCallback)(()=>setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
    let onFocusChange = (0, $aB6Cp$react.useCallback)((isFocused)=>{
        state.current.isFocused = isFocused;
        setFocused(isFocused);
        updateState();
    }, [
        updateState
    ]);
    (0, $aB6Cp$reactariainteractions.useFocusVisibleListener)((isFocusVisible)=>{
        state.current.isFocusVisible = isFocusVisible;
        updateState();
    }, [], {
        isTextInput: isTextInput
    });
    let { focusProps: focusProps  } = (0, $aB6Cp$reactariainteractions.useFocus)({
        isDisabled: within,
        onFocusChange: onFocusChange
    });
    let { focusWithinProps: focusWithinProps  } = (0, $aB6Cp$reactariainteractions.useFocusWithin)({
        isDisabled: !within,
        onFocusWithinChange: onFocusChange
    });
    return {
        isFocused: isFocused,
        isFocusVisible: isFocusVisibleState,
        focusProps: within ? focusWithinProps : focusProps
    };
}


function $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d(props) {
    let { children: children , focusClass: focusClass , focusRingClass: focusRingClass  } = props;
    let { isFocused: isFocused , isFocusVisible: isFocusVisible , focusProps: focusProps  } = (0, $581a96d6eb128c1b$export$4e328f61c538687f)(props);
    let child = (0, ($parcel$interopDefault($aB6Cp$react))).Children.only(children);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).cloneElement(child, (0, $aB6Cp$reactariautils.mergeProps)(child.props, {
        ...focusProps,
        className: (0, ($parcel$interopDefault($aB6Cp$clsx)))({
            [focusClass || ""]: isFocused,
            [focusRingClass || ""]: isFocusVisible
        })
    }));
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



let $fb504d83237fd6ac$var$FocusableContext = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createContext(null);
function $fb504d83237fd6ac$var$useFocusableContext(ref) {
    let context = (0, $aB6Cp$react.useContext)($fb504d83237fd6ac$var$FocusableContext) || {};
    (0, $aB6Cp$reactariautils.useSyncRef)(context, ref);
    // eslint-disable-next-line
    let { ref: _ , ...otherProps } = context;
    return otherProps;
}
/**
 * Provides DOM props to the nearest focusable child.
 */ function $fb504d83237fd6ac$var$FocusableProvider(props, ref) {
    let { children: children , ...otherProps } = props;
    let context = {
        ...otherProps,
        ref: ref
    };
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement($fb504d83237fd6ac$var$FocusableContext.Provider, {
        value: context
    }, children);
}
let $fb504d83237fd6ac$export$13f3202a3e5ddd5 = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).forwardRef($fb504d83237fd6ac$var$FocusableProvider);
function $fb504d83237fd6ac$export$4c014de7c8940b4c(props, domRef) {
    let { focusProps: focusProps  } = (0, $aB6Cp$reactariainteractions.useFocus)(props);
    let { keyboardProps: keyboardProps  } = (0, $aB6Cp$reactariainteractions.useKeyboard)(props);
    let interactions = (0, $aB6Cp$reactariautils.mergeProps)(focusProps, keyboardProps);
    let domProps = $fb504d83237fd6ac$var$useFocusableContext(domRef);
    let interactionProps = props.isDisabled ? {} : domProps;
    let autoFocusRef = (0, $aB6Cp$react.useRef)(props.autoFocus);
    (0, $aB6Cp$react.useEffect)(()=>{
        if (autoFocusRef.current && domRef.current) (0, $1c7f9157d722357d$export$80f3e147d781571c)(domRef.current);
        autoFocusRef.current = false;
    }, [
        domRef
    ]);
    return {
        focusableProps: (0, $aB6Cp$reactariautils.mergeProps)({
            ...interactions,
            tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined
        }, interactionProps)
    };
}




/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $259c6413a286f2e6$export$eac1895992b9f3d6(ref, options) {
    let isDisabled = options === null || options === void 0 ? void 0 : options.isDisabled;
    let [hasTabbableChild, setHasTabbableChild] = (0, $aB6Cp$react.useState)(false);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if ((ref === null || ref === void 0 ? void 0 : ref.current) && !isDisabled) {
            let update = ()=>{
                if (ref.current) {
                    let walker = (0, $a7a032acae3ddda9$export$2d6ec8fc375ceafa)(ref.current, {
                        tabbable: true
                    });
                    setHasTabbableChild(!!walker.nextNode());
                }
            };
            update();
            // Update when new elements are inserted, or the tabIndex/disabled attribute updates.
            let observer = new MutationObserver(update);
            observer.observe(ref.current, {
                subtree: true,
                childList: true,
                attributes: true,
                attributeFilter: [
                    "tabIndex",
                    "disabled"
                ]
            });
            return ()=>{
                // Disconnect mutation observer when a React update occurs on the top-level component
                // so we update synchronously after re-rendering. Otherwise React will emit act warnings
                // in tests since mutation observers fire asynchronously. The mutation observer is necessary
                // so we also update if a child component re-renders and adds/removes something tabbable.
                observer.disconnect();
            };
        }
    });
    return isDisabled ? false : hasTabbableChild;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 16151:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $goTMa$reactariautils = __webpack_require__(78659);
var $goTMa$react = __webpack_require__(18038);
var $goTMa$reactariassr = __webpack_require__(17141);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "Pressable", () => $e1dbec26039c051d$export$27c701ed9e449e99);
$parcel$export(module.exports, "PressResponder", () => $3596bae48579386f$export$3351871ee4b288b8);
$parcel$export(module.exports, "useFocus", () => $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6);
$parcel$export(module.exports, "isFocusVisible", () => $e77252a287ef94ab$export$b9b3dfddab17db27);
$parcel$export(module.exports, "getInteractionModality", () => $e77252a287ef94ab$export$630ff653c5ada6a9);
$parcel$export(module.exports, "setInteractionModality", () => $e77252a287ef94ab$export$8397ddfc504fdb9a);
$parcel$export(module.exports, "useInteractionModality", () => $e77252a287ef94ab$export$98e20ec92f614cfe);
$parcel$export(module.exports, "useFocusVisible", () => $e77252a287ef94ab$export$ffd9e5021c1fb2d6);
$parcel$export(module.exports, "useFocusVisibleListener", () => $e77252a287ef94ab$export$ec71b4b83ac08ec3);
$parcel$export(module.exports, "useFocusWithin", () => $d16842bbd0359d1b$export$420e68273165f4ec);
$parcel$export(module.exports, "useHover", () => $ffbc150311c75f01$export$ae780daf29e6d456);
$parcel$export(module.exports, "useInteractOutside", () => $edcfa848c42f94f4$export$872b660ac5a1ff98);
$parcel$export(module.exports, "useKeyboard", () => $892d64db2a3c53b0$export$8f71654801c2f7cd);
$parcel$export(module.exports, "useMove", () => $c09386fc48fa427d$export$36da96379f79f245);
$parcel$export(module.exports, "usePress", () => $0294ea432cd92340$export$45712eceda6fad21);
$parcel$export(module.exports, "useScrollWheel", () => $a3dbce0aed7087e2$export$2123ff2b87c81ca);
$parcel$export(module.exports, "useLongPress", () => $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element
// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually
let $f7e14e656343df57$var$state = "default";
let $f7e14e656343df57$var$savedUserSelect = "";
let $f7e14e656343df57$var$modifiedElementMap = new WeakMap();
function $f7e14e656343df57$export$16a4697467175487(target) {
    if ((0, $goTMa$reactariautils.isIOS)()) {
        if ($f7e14e656343df57$var$state === "default") {
            $f7e14e656343df57$var$savedUserSelect = document.documentElement.style.webkitUserSelect;
            document.documentElement.style.webkitUserSelect = "none";
        }
        $f7e14e656343df57$var$state = "disabled";
    } else if (target instanceof HTMLElement || target instanceof SVGElement) {
        // If not iOS, store the target's original user-select and change to user-select: none
        // Ignore state since it doesn't apply for non iOS
        $f7e14e656343df57$var$modifiedElementMap.set(target, target.style.userSelect);
        target.style.userSelect = "none";
    }
}
function $f7e14e656343df57$export$b0d6fa1ab32e3295(target) {
    if ((0, $goTMa$reactariautils.isIOS)()) {
        // If the state is already default, there's nothing to do.
        // If it is restoring, then there's no need to queue a second restore.
        if ($f7e14e656343df57$var$state !== "disabled") return;
        $f7e14e656343df57$var$state = "restoring";
        // There appears to be a delay on iOS where selection still might occur
        // after pointer up, so wait a bit before removing user-select.
        setTimeout(()=>{
            // Wait for any CSS transitions to complete so we don't recompute style
            // for the whole page in the middle of the animation and cause jank.
            (0, $goTMa$reactariautils.runAfterTransition)(()=>{
                // Avoid race conditions
                if ($f7e14e656343df57$var$state === "restoring") {
                    if (document.documentElement.style.webkitUserSelect === "none") document.documentElement.style.webkitUserSelect = $f7e14e656343df57$var$savedUserSelect || "";
                    $f7e14e656343df57$var$savedUserSelect = "";
                    $f7e14e656343df57$var$state = "default";
                }
            });
        }, 300);
    } else if (target instanceof HTMLElement || target instanceof SVGElement) // If not iOS, restore the target's original user-select if any
    // Ignore state since it doesn't apply for non iOS
    {
        if (target && $f7e14e656343df57$var$modifiedElementMap.has(target)) {
            let targetOldUserSelect = $f7e14e656343df57$var$modifiedElementMap.get(target);
            if (target.style.userSelect === "none") target.style.userSelect = targetOldUserSelect;
            if (target.getAttribute("style") === "") target.removeAttribute("style");
            $f7e14e656343df57$var$modifiedElementMap.delete(target);
        }
    }
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $01d3f539e91688c8$export$5165eccb35aaadb5 = (0, ($parcel$interopDefault($goTMa$react))).createContext(null);
$01d3f539e91688c8$export$5165eccb35aaadb5.displayName = "PressResponderContext";



function $0294ea432cd92340$var$usePressResponderContext(props) {
    // Consume context from <PressResponder> and merge with props.
    let context = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));
    if (context) {
        let { register: register , ...contextProps } = context;
        props = (0, $goTMa$reactariautils.mergeProps)(contextProps, props);
        register();
    }
    (0, $goTMa$reactariautils.useSyncRef)(context, props.ref);
    return props;
}
function $0294ea432cd92340$export$45712eceda6fad21(props) {
    let { onPress: onPress , onPressChange: onPressChange , onPressStart: onPressStart , onPressEnd: onPressEnd , onPressUp: onPressUp , isDisabled: isDisabled , isPressed: isPressedProp , preventFocusOnPress: preventFocusOnPress , shouldCancelOnPointerExit: shouldCancelOnPointerExit , allowTextSelectionOnPress: allowTextSelectionOnPress , // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: _ , ...domProps } = $0294ea432cd92340$var$usePressResponderContext(props);
    let [isPressed, setPressed] = (0, $goTMa$react.useState)(false);
    let ref = (0, $goTMa$react.useRef)({
        isPressed: false,
        ignoreEmulatedMouseEvents: false,
        ignoreClickAfterPress: false,
        didFirePressStart: false,
        activePointerId: null,
        target: null,
        isOverTarget: false,
        pointerType: null
    });
    let { addGlobalListener: addGlobalListener , removeAllGlobalListeners: removeAllGlobalListeners  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let triggerPressStart = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        let state = ref.current;
        if (isDisabled || state.didFirePressStart) return;
        if (onPressStart) onPressStart({
            type: "pressstart",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
        if (onPressChange) onPressChange(true);
        state.didFirePressStart = true;
        setPressed(true);
    });
    let triggerPressEnd = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType, wasPressed = true)=>{
        let state = ref.current;
        if (!state.didFirePressStart) return;
        state.ignoreClickAfterPress = true;
        state.didFirePressStart = false;
        if (onPressEnd) onPressEnd({
            type: "pressend",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
        if (onPressChange) onPressChange(false);
        setPressed(false);
        if (onPress && wasPressed && !isDisabled) onPress({
            type: "press",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let triggerPressUp = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        if (isDisabled) return;
        if (onPressUp) onPressUp({
            type: "pressup",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let cancel = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        let state = ref.current;
        if (state.isPressed) {
            if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
            state.isPressed = false;
            state.isOverTarget = false;
            state.activePointerId = null;
            state.pointerType = null;
            removeAllGlobalListeners();
            if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
        }
    });
    let cancelOnPointerExit = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (shouldCancelOnPointerExit) cancel(e);
    });
    let pressProps = (0, $goTMa$react.useMemo)(()=>{
        let state = ref.current;
        let pressProps = {
            onKeyDown (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {
                    if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                    e.stopPropagation();
                    // If the event is repeating, it may have started on a different element
                    // after which focus moved to the current element. Ignore these events and
                    // only handle the first key down event.
                    if (!state.isPressed && !e.repeat) {
                        state.target = e.currentTarget;
                        state.isPressed = true;
                        triggerPressStart(e, "keyboard");
                        // Focus may move before the key up event, so register the event on the document
                        // instead of the same element where the key down event occurred.
                        addGlobalListener(document, "keyup", onKeyUp, false);
                    }
                } else if (e.key === "Enter" && $0294ea432cd92340$var$isHTMLAnchorLink(e.currentTarget)) // If the target is a link, we won't have handled this above because we want the default
                // browser behavior to open the link when pressing Enter. But we still need to prevent
                // default so that elements above do not also handle it (e.g. table row).
                e.stopPropagation();
            },
            onKeyUp (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target)) triggerPressUp($0294ea432cd92340$var$createEvent(state.target, e), "keyboard");
            },
            onClick (e) {
                if (e && !e.currentTarget.contains(e.target)) return;
                if (e && e.button === 0) {
                    e.stopPropagation();
                    if (isDisabled) e.preventDefault();
                    // If triggered from a screen reader or by using element.click(),
                    // trigger as if it were a keyboard click.
                    if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && (state.pointerType === "virtual" || (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent))) {
                        // Ensure the element receives focus (VoiceOver on iOS does not do this)
                        if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                        triggerPressStart(e, "virtual");
                        triggerPressUp(e, "virtual");
                        triggerPressEnd(e, "virtual");
                    }
                    state.ignoreEmulatedMouseEvents = false;
                    state.ignoreClickAfterPress = false;
                }
            }
        };
        let onKeyUp = (e)=>{
            if (state.isPressed && $0294ea432cd92340$var$isValidKeyboardEvent(e, state.target)) {
                if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                e.stopPropagation();
                state.isPressed = false;
                let target = e.target;
                triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), "keyboard", state.target.contains(target));
                removeAllGlobalListeners();
                // If the target is a link, trigger the click method to open the URL,
                // but defer triggering pressEnd until onClick event handler.
                if (state.target instanceof HTMLElement && state.target.contains(target) && ($0294ea432cd92340$var$isHTMLAnchorLink(state.target) || state.target.getAttribute("role") === "link")) state.target.click();
            }
        };
        if (typeof PointerEvent !== "undefined") {
            pressProps.onPointerDown = (e)=>{
                // Only handle left clicks, and ignore events that bubbled through portals.
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.
                // Ignore and let the onClick handler take care of it instead.
                // https://bugs.webkit.org/show_bug.cgi?id=222627
                // https://bugs.webkit.org/show_bug.cgi?id=223202
                if ((0, $goTMa$reactariautils.isVirtualPointerEvent)(e.nativeEvent)) {
                    state.pointerType = "virtual";
                    return;
                }
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on pointer down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                state.pointerType = e.pointerType;
                e.stopPropagation();
                if (!state.isPressed) {
                    state.isPressed = true;
                    state.isOverTarget = true;
                    state.activePointerId = e.pointerId;
                    state.target = e.currentTarget;
                    if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                    if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);
                    triggerPressStart(e, state.pointerType);
                    addGlobalListener(document, "pointermove", onPointerMove, false);
                    addGlobalListener(document, "pointerup", onPointerUp, false);
                    addGlobalListener(document, "pointercancel", onPointerCancel, false);
                }
            };
            pressProps.onMouseDown = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (e.button === 0) {
                    // Chrome and Firefox on touch Windows devices require mouse down events
                    // to be canceled in addition to pointer events, or an extra asynchronous
                    // focus event will be fired.
                    if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                    e.stopPropagation();
                }
            };
            pressProps.onPointerUp = (e)=>{
                // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.
                if (!e.currentTarget.contains(e.target) || state.pointerType === "virtual") return;
                // Only handle left clicks
                // Safari on iOS sometimes fires pointerup events, even
                // when the touch isn't over the target, so double check.
                if (e.button === 0 && $0294ea432cd92340$var$isOverTarget(e, e.currentTarget)) triggerPressUp(e, state.pointerType || e.pointerType);
            };
            // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.
            // Use pointer move events instead to implement our own hit testing.
            // See https://bugs.webkit.org/show_bug.cgi?id=199803
            let onPointerMove = (e)=>{
                if (e.pointerId !== state.activePointerId) return;
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0) {
                    if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    state.isPressed = false;
                    state.isOverTarget = false;
                    state.activePointerId = null;
                    state.pointerType = null;
                    removeAllGlobalListeners();
                    if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
                }
            };
            let onPointerCancel = (e)=>{
                cancel(e);
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.
                cancel(e);
            };
        } else {
            pressProps.onMouseDown = (e)=>{
                // Only handle left clicks
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on mouse down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                e.stopPropagation();
                if (state.ignoreEmulatedMouseEvents) return;
                state.isPressed = true;
                state.isOverTarget = true;
                state.target = e.currentTarget;
                state.pointerType = (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent) ? "virtual" : "mouse";
                if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(document, "mouseup", onMouseUp, false);
            };
            pressProps.onMouseEnter = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = true;
                    triggerPressStart(e, state.pointerType);
                }
            };
            pressProps.onMouseLeave = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            pressProps.onMouseUp = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType);
            };
            let onMouseUp = (e)=>{
                // Only handle left clicks
                if (e.button !== 0) return;
                state.isPressed = false;
                removeAllGlobalListeners();
                if (state.ignoreEmulatedMouseEvents) {
                    state.ignoreEmulatedMouseEvents = false;
                    return;
                }
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                state.isOverTarget = false;
            };
            pressProps.onTouchStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                let touch = $0294ea432cd92340$var$getTouchFromEvent(e.nativeEvent);
                if (!touch) return;
                state.activePointerId = touch.identifier;
                state.ignoreEmulatedMouseEvents = true;
                state.isOverTarget = true;
                state.isPressed = true;
                state.target = e.currentTarget;
                state.pointerType = "touch";
                // Due to browser inconsistencies, especially on mobile browsers, we prevent default
                // on the emulated mouse event and handle focusing the pressable element ourselves.
                if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(window, "scroll", onScroll, true);
            };
            pressProps.onTouchMove = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart(e, state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            pressProps.onTouchEnd = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    triggerPressUp(e, state.pointerType);
                    triggerPressEnd(e, state.pointerType);
                } else if (state.isOverTarget) triggerPressEnd(e, state.pointerType, false);
                state.isPressed = false;
                state.activePointerId = null;
                state.isOverTarget = false;
                state.ignoreEmulatedMouseEvents = true;
                if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
                removeAllGlobalListeners();
            };
            pressProps.onTouchCancel = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed) cancel(e);
            };
            let onScroll = (e)=>{
                if (state.isPressed && e.target.contains(state.target)) cancel({
                    currentTarget: state.target,
                    shiftKey: false,
                    ctrlKey: false,
                    metaKey: false,
                    altKey: false
                });
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                cancel(e);
            };
        }
        return pressProps;
    }, [
        addGlobalListener,
        isDisabled,
        preventFocusOnPress,
        removeAllGlobalListeners,
        allowTextSelectionOnPress,
        cancel,
        cancelOnPointerExit,
        triggerPressEnd,
        triggerPressStart,
        triggerPressUp
    ]);
    // Remove user-select: none in case component unmounts immediately after pressStart
    // eslint-disable-next-line arrow-body-style
    (0, $goTMa$react.useEffect)(()=>{
        return ()=>{
            if (!allowTextSelectionOnPress) // eslint-disable-next-line react-hooks/exhaustive-deps
            (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(ref.current.target);
        };
    }, [
        allowTextSelectionOnPress
    ]);
    return {
        isPressed: isPressedProp || isPressed,
        pressProps: (0, $goTMa$reactariautils.mergeProps)(domProps, pressProps)
    };
}
function $0294ea432cd92340$var$isHTMLAnchorLink(target) {
    return target.tagName === "A" && target.hasAttribute("href");
}
function $0294ea432cd92340$var$isValidKeyboardEvent(event, currentTarget) {
    const { key: key , code: code  } = event;
    const element = currentTarget;
    const role = element.getAttribute("role");
    // Accessibility for keyboards. Space and Enter only.
    // "Spacebar" is for IE 11
    return (key === "Enter" || key === " " || key === "Spacebar" || code === "Space") && !(element instanceof HTMLInputElement && !$0294ea432cd92340$var$isValidInputKey(element, key) || element instanceof HTMLTextAreaElement || element.isContentEditable) && // A link with a valid href should be handled natively,
    // unless it also has role='button' and was triggered using Space.
    (!$0294ea432cd92340$var$isHTMLAnchorLink(element) || role === "button" && key !== "Enter") && // An element with role='link' should only trigger with Enter key
    !(role === "link" && key !== "Enter");
}
function $0294ea432cd92340$var$getTouchFromEvent(event) {
    const { targetTouches: targetTouches  } = event;
    if (targetTouches.length > 0) return targetTouches[0];
    return null;
}
function $0294ea432cd92340$var$getTouchById(event, pointerId) {
    const changedTouches = event.changedTouches;
    for(let i = 0; i < changedTouches.length; i++){
        const touch = changedTouches[i];
        if (touch.identifier === pointerId) return touch;
    }
    return null;
}
function $0294ea432cd92340$var$createEvent(target, e) {
    return {
        currentTarget: target,
        shiftKey: e.shiftKey,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey
    };
}
function $0294ea432cd92340$var$getPointClientRect(point) {
    let offsetX = point.width / 2 || point.radiusX || 0;
    let offsetY = point.height / 2 || point.radiusY || 0;
    return {
        top: point.clientY - offsetY,
        right: point.clientX + offsetX,
        bottom: point.clientY + offsetY,
        left: point.clientX - offsetX
    };
}
function $0294ea432cd92340$var$areRectanglesOverlapping(a, b) {
    // check if they cannot overlap on x axis
    if (a.left > b.right || b.left > a.right) return false;
    // check if they cannot overlap on y axis
    if (a.top > b.bottom || b.top > a.bottom) return false;
    return true;
}
function $0294ea432cd92340$var$isOverTarget(point, target) {
    let rect = target.getBoundingClientRect();
    let pointRect = $0294ea432cd92340$var$getPointClientRect(point);
    return $0294ea432cd92340$var$areRectanglesOverlapping(rect, pointRect);
}
function $0294ea432cd92340$var$shouldPreventDefault(target) {
    // We cannot prevent default if the target is a draggable element.
    return !(target instanceof HTMLElement) || !target.draggable;
}
function $0294ea432cd92340$var$shouldPreventDefaultKeyboard(target, key) {
    if (target instanceof HTMLInputElement) return !$0294ea432cd92340$var$isValidInputKey(target, key);
    if (target instanceof HTMLButtonElement) return target.type !== "submit";
    return true;
}
const $0294ea432cd92340$var$nonTextInputTypes = new Set([
    "checkbox",
    "radio",
    "range",
    "color",
    "file",
    "image",
    "button",
    "submit",
    "reset"
]);
function $0294ea432cd92340$var$isValidInputKey(target, key) {
    // Only space should toggle checkboxes and radios, not enter.
    return target.type === "checkbox" || target.type === "radio" ? key === " " : $0294ea432cd92340$var$nonTextInputTypes.has(target.type);
}



const $e1dbec26039c051d$export$27c701ed9e449e99 = /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).forwardRef(({ children: children , ...props }, ref)=>{
    let newRef = (0, $goTMa$react.useRef)();
    ref = ref !== null && ref !== void 0 ? ref : newRef;
    let { pressProps: pressProps  } = (0, $0294ea432cd92340$export$45712eceda6fad21)({
        ...props,
        ref: ref
    });
    let child = (0, ($parcel$interopDefault($goTMa$react))).Children.only(children);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).cloneElement(child, // @ts-ignore
    {
        ref: ref,
        ...(0, $goTMa$reactariautils.mergeProps)(child.props, pressProps)
    });
});


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $3596bae48579386f$export$3351871ee4b288b8 = /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).forwardRef(({ children: children , ...props }, ref)=>{
    let isRegistered = (0, $goTMa$react.useRef)(false);
    let prevContext = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));
    let context = (0, $goTMa$reactariautils.mergeProps)(prevContext || {}, {
        ...props,
        ref: ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref),
        register () {
            isRegistered.current = true;
            if (prevContext) prevContext.register();
        }
    });
    (0, $goTMa$reactariautils.useSyncRef)(prevContext, ref);
    (0, $goTMa$react.useEffect)(()=>{
        if (!isRegistered.current) {
            console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.");
            isRegistered.current = true; // only warn once in strict mode.
        }
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).createElement((0, $01d3f539e91688c8$export$5165eccb35aaadb5).Provider, {
        value: context
    }, children);
});


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

class $625cf83917e112ad$export$905e7fc544a71f36 {
    isDefaultPrevented() {
        return this.nativeEvent.defaultPrevented;
    }
    preventDefault() {
        this.defaultPrevented = true;
        this.nativeEvent.preventDefault();
    }
    stopPropagation() {
        this.nativeEvent.stopPropagation();
        this.isPropagationStopped = ()=>true;
    }
    isPropagationStopped() {
        return false;
    }
    persist() {}
    constructor(type, nativeEvent){
        this.nativeEvent = nativeEvent;
        this.target = nativeEvent.target;
        this.currentTarget = nativeEvent.currentTarget;
        this.relatedTarget = nativeEvent.relatedTarget;
        this.bubbles = nativeEvent.bubbles;
        this.cancelable = nativeEvent.cancelable;
        this.defaultPrevented = nativeEvent.defaultPrevented;
        this.eventPhase = nativeEvent.eventPhase;
        this.isTrusted = nativeEvent.isTrusted;
        this.timeStamp = nativeEvent.timeStamp;
        this.type = type;
    }
}
function $625cf83917e112ad$export$715c682d09d639cc(onBlur) {
    let stateRef = (0, $goTMa$react.useRef)({
        isFocused: false,
        observer: null
    });
    // Clean up MutationObserver on unmount. See below.
    // eslint-disable-next-line arrow-body-style
    (0, $goTMa$reactariautils.useLayoutEffect)(()=>{
        const state = stateRef.current;
        return ()=>{
            if (state.observer) {
                state.observer.disconnect();
                state.observer = null;
            }
        };
    }, []);
    let dispatchBlur = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
    });
    // This function is called during a React onFocus event.
    return (0, $goTMa$react.useCallback)((e)=>{
        // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142
        // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a
        // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.
        // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.
        if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {
            stateRef.current.isFocused = true;
            let target = e.target;
            let onBlurHandler = (e)=>{
                stateRef.current.isFocused = false;
                if (target.disabled) // For backward compatibility, dispatch a (fake) React synthetic event.
                dispatchBlur(new $625cf83917e112ad$export$905e7fc544a71f36("blur", e));
                // We no longer need the MutationObserver once the target is blurred.
                if (stateRef.current.observer) {
                    stateRef.current.observer.disconnect();
                    stateRef.current.observer = null;
                }
            };
            target.addEventListener("focusout", onBlurHandler, {
                once: true
            });
            stateRef.current.observer = new MutationObserver(()=>{
                if (stateRef.current.isFocused && target.disabled) {
                    stateRef.current.observer.disconnect();
                    let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
                    target.dispatchEvent(new FocusEvent("blur", {
                        relatedTarget: relatedTargetEl
                    }));
                    target.dispatchEvent(new FocusEvent("focusout", {
                        bubbles: true,
                        relatedTarget: relatedTargetEl
                    }));
                }
            });
            stateRef.current.observer.observe(target, {
                attributes: true,
                attributeFilter: [
                    "disabled"
                ]
            });
        }
    }, [
        dispatchBlur
    ]);
}


function $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6(props) {
    let { isDisabled: isDisabled , onFocus: onFocusProp , onBlur: onBlurProp , onFocusChange: onFocusChange  } = props;
    const onBlur = (0, $goTMa$react.useCallback)((e)=>{
        if (e.target === e.currentTarget) {
            if (onBlurProp) onBlurProp(e);
            if (onFocusChange) onFocusChange(false);
            return true;
        }
    }, [
        onBlurProp,
        onFocusChange
    ]);
    const onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);
    const onFocus = (0, $goTMa$react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (e.target === e.currentTarget && document.activeElement === e.target) {
            if (onFocusProp) onFocusProp(e);
            if (onFocusChange) onFocusChange(true);
            onSyntheticFocus(e);
        }
    }, [
        onFocusChange,
        onFocusProp,
        onSyntheticFocus
    ]);
    return {
        focusProps: {
            onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,
            onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : undefined
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions



let $e77252a287ef94ab$var$currentModality = null;
let $e77252a287ef94ab$var$changeHandlers = new Set();
let $e77252a287ef94ab$var$hasSetupGlobalListeners = false;
let $e77252a287ef94ab$var$hasEventBeforeFocus = false;
let $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
// Only Tab or Esc keys will make focus visible on text input elements
const $e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS = {
    Tab: true,
    Escape: true
};
function $e77252a287ef94ab$var$triggerChangeHandlers(modality, e) {
    for (let handler of $e77252a287ef94ab$var$changeHandlers)handler(modality, e);
}
/**
 * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.
 */ function $e77252a287ef94ab$var$isValidKey(e) {
    // Control and Shift keys trigger when navigating back to the tab with keyboard.
    return !(e.metaKey || !(0, $goTMa$reactariautils.isMac)() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
function $e77252a287ef94ab$var$handleKeyboardEvent(e) {
    $e77252a287ef94ab$var$hasEventBeforeFocus = true;
    if ($e77252a287ef94ab$var$isValidKey(e)) {
        $e77252a287ef94ab$var$currentModality = "keyboard";
        $e77252a287ef94ab$var$triggerChangeHandlers("keyboard", e);
    }
}
function $e77252a287ef94ab$var$handlePointerEvent(e) {
    $e77252a287ef94ab$var$currentModality = "pointer";
    if (e.type === "mousedown" || e.type === "pointerdown") {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$triggerChangeHandlers("pointer", e);
    }
}
function $e77252a287ef94ab$var$handleClickEvent(e) {
    if ((0, $goTMa$reactariautils.isVirtualClick)(e)) {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$currentModality = "virtual";
    }
}
function $e77252a287ef94ab$var$handleFocusEvent(e) {
    // Firefox fires two extra focus events when the user first clicks into an iframe:
    // first on the window, then on the document. We ignore these events so they don't
    // cause keyboard focus rings to appear.
    if (e.target === window || e.target === document) return;
    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.
    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.
    if (!$e77252a287ef94ab$var$hasEventBeforeFocus && !$e77252a287ef94ab$var$hasBlurredWindowRecently) {
        $e77252a287ef94ab$var$currentModality = "virtual";
        $e77252a287ef94ab$var$triggerChangeHandlers("virtual", e);
    }
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
}
function $e77252a287ef94ab$var$handleWindowBlur() {
    // When the window is blurred, reset state. This is necessary when tabbing out of the window,
    // for example, since a subsequent focus event won't be fired.
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = true;
}
/**
 * Setup global event listeners to control when keyboard focus style should be visible.
 */ function $e77252a287ef94ab$var$setupGlobalFocusEvents() {
    if (typeof window === "undefined" || $e77252a287ef94ab$var$hasSetupGlobalListeners) return;
    // Programmatic focus() calls shouldn't affect the current input modality.
    // However, we need to detect other cases when a focus event occurs without
    // a preceding user event (e.g. screen reader focus). Overriding the focus
    // method on HTMLElement.prototype is a bit hacky, but works.
    let focus = HTMLElement.prototype.focus;
    HTMLElement.prototype.focus = function() {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        focus.apply(this, arguments);
    };
    document.addEventListener("keydown", $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener("keyup", $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener("click", $e77252a287ef94ab$var$handleClickEvent, true);
    // Register focus events on the window so they are sure to happen
    // before React's event listeners (registered on the document).
    window.addEventListener("focus", $e77252a287ef94ab$var$handleFocusEvent, true);
    window.addEventListener("blur", $e77252a287ef94ab$var$handleWindowBlur, false);
    if (typeof PointerEvent !== "undefined") {
        document.addEventListener("pointerdown", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("pointermove", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("pointerup", $e77252a287ef94ab$var$handlePointerEvent, true);
    } else {
        document.addEventListener("mousedown", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("mousemove", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("mouseup", $e77252a287ef94ab$var$handlePointerEvent, true);
    }
    $e77252a287ef94ab$var$hasSetupGlobalListeners = true;
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e77252a287ef94ab$var$setupGlobalFocusEvents();
    else document.addEventListener("DOMContentLoaded", $e77252a287ef94ab$var$setupGlobalFocusEvents);
}
function $e77252a287ef94ab$export$b9b3dfddab17db27() {
    return $e77252a287ef94ab$var$currentModality !== "pointer";
}
function $e77252a287ef94ab$export$630ff653c5ada6a9() {
    return $e77252a287ef94ab$var$currentModality;
}
function $e77252a287ef94ab$export$8397ddfc504fdb9a(modality) {
    $e77252a287ef94ab$var$currentModality = modality;
    $e77252a287ef94ab$var$triggerChangeHandlers(modality, null);
}
function $e77252a287ef94ab$export$98e20ec92f614cfe() {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    let [modality, setModality] = (0, $goTMa$react.useState)($e77252a287ef94ab$var$currentModality);
    (0, $goTMa$react.useEffect)(()=>{
        let handler = ()=>{
            setModality($e77252a287ef94ab$var$currentModality);
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    }, []);
    return (0, $goTMa$reactariassr.useIsSSR)() ? null : modality;
}
/**
 * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that
 * focus visible style can be properly set.
 */ function $e77252a287ef94ab$var$isKeyboardFocusEvent(isTextInput, modality, e) {
    return !(isTextInput && modality === "keyboard" && e instanceof KeyboardEvent && !$e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);
}
function $e77252a287ef94ab$export$ffd9e5021c1fb2d6(props = {}) {
    let { isTextInput: isTextInput , autoFocus: autoFocus  } = props;
    let [isFocusVisibleState, setFocusVisible] = (0, $goTMa$react.useState)(autoFocus || $e77252a287ef94ab$export$b9b3dfddab17db27());
    $e77252a287ef94ab$export$ec71b4b83ac08ec3((isFocusVisible)=>{
        setFocusVisible(isFocusVisible);
    }, [
        isTextInput
    ], {
        isTextInput: isTextInput
    });
    return {
        isFocusVisible: isFocusVisibleState
    };
}
function $e77252a287ef94ab$export$ec71b4b83ac08ec3(fn, deps, opts) {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    (0, $goTMa$react.useEffect)(()=>{
        let handler = (modality, e)=>{
            if (!$e77252a287ef94ab$var$isKeyboardFocusEvent(opts === null || opts === void 0 ? void 0 : opts.isTextInput, modality, e)) return;
            fn($e77252a287ef94ab$export$b9b3dfddab17db27());
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, deps);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $d16842bbd0359d1b$export$420e68273165f4ec(props) {
    let { isDisabled: isDisabled , onBlurWithin: onBlurWithin , onFocusWithin: onFocusWithin , onFocusWithinChange: onFocusWithinChange  } = props;
    let state = (0, $goTMa$react.useRef)({
        isFocusWithin: false
    });
    let onBlur = (0, $goTMa$react.useCallback)((e)=>{
        // We don't want to trigger onBlurWithin and then immediately onFocusWithin again
        // when moving focus inside the element. Only trigger if the currentTarget doesn't
        // include the relatedTarget (where focus is moving).
        if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {
            state.current.isFocusWithin = false;
            if (onBlurWithin) onBlurWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(false);
        }
    }, [
        onBlurWithin,
        onFocusWithinChange,
        state
    ]);
    let onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);
    let onFocus = (0, $goTMa$react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (!state.current.isFocusWithin && document.activeElement === e.target) {
            if (onFocusWithin) onFocusWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(true);
            state.current.isFocusWithin = true;
            onSyntheticFocus(e);
        }
    }, [
        onFocusWithin,
        onFocusWithinChange,
        onSyntheticFocus
    ]);
    if (isDisabled) return {
        focusWithinProps: {
            onFocus: null,
            onBlur: null
        }
    };
    return {
        focusWithinProps: {
            onFocus: onFocus,
            onBlur: onBlur
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

// iOS fires onPointerEnter twice: once with pointerType="touch" and again with pointerType="mouse".
// We want to ignore these emulated events so they do not trigger hover behavior.
// See https://bugs.webkit.org/show_bug.cgi?id=214609.
let $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
let $ffbc150311c75f01$var$hoverCount = 0;
function $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents() {
    $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = true;
    // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter
    // with pointerType="mouse" immediately after onPointerUp and before onFocus. On other
    // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in
    // the distant future because a user previously touched the element.
    setTimeout(()=>{
        $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
    }, 50);
}
function $ffbc150311c75f01$var$handleGlobalPointerEvent(e) {
    if (e.pointerType === "touch") $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $ffbc150311c75f01$var$setupGlobalTouchEvents() {
    if (typeof document === "undefined") return;
    if (typeof PointerEvent !== "undefined") document.addEventListener("pointerup", $ffbc150311c75f01$var$handleGlobalPointerEvent);
    else document.addEventListener("touchend", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    $ffbc150311c75f01$var$hoverCount++;
    return ()=>{
        $ffbc150311c75f01$var$hoverCount--;
        if ($ffbc150311c75f01$var$hoverCount > 0) return;
        if (typeof PointerEvent !== "undefined") document.removeEventListener("pointerup", $ffbc150311c75f01$var$handleGlobalPointerEvent);
        else document.removeEventListener("touchend", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    };
}
function $ffbc150311c75f01$export$ae780daf29e6d456(props) {
    let { onHoverStart: onHoverStart , onHoverChange: onHoverChange , onHoverEnd: onHoverEnd , isDisabled: isDisabled  } = props;
    let [isHovered, setHovered] = (0, $goTMa$react.useState)(false);
    let state = (0, $goTMa$react.useRef)({
        isHovered: false,
        ignoreEmulatedMouseEvents: false,
        pointerType: "",
        target: null
    }).current;
    (0, $goTMa$react.useEffect)($ffbc150311c75f01$var$setupGlobalTouchEvents, []);
    let { hoverProps: hoverProps , triggerHoverEnd: triggerHoverEnd  } = (0, $goTMa$react.useMemo)(()=>{
        let triggerHoverStart = (event, pointerType)=>{
            state.pointerType = pointerType;
            if (isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target)) return;
            state.isHovered = true;
            let target = event.currentTarget;
            state.target = target;
            if (onHoverStart) onHoverStart({
                type: "hoverstart",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(true);
            setHovered(true);
        };
        let triggerHoverEnd = (event, pointerType)=>{
            state.pointerType = "";
            state.target = null;
            if (pointerType === "touch" || !state.isHovered) return;
            state.isHovered = false;
            let target = event.currentTarget;
            if (onHoverEnd) onHoverEnd({
                type: "hoverend",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(false);
            setHovered(false);
        };
        let hoverProps = {};
        if (typeof PointerEvent !== "undefined") {
            hoverProps.onPointerEnter = (e)=>{
                if ($ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents && e.pointerType === "mouse") return;
                triggerHoverStart(e, e.pointerType);
            };
            hoverProps.onPointerLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);
            };
        } else {
            hoverProps.onTouchStart = ()=>{
                state.ignoreEmulatedMouseEvents = true;
            };
            hoverProps.onMouseEnter = (e)=>{
                if (!state.ignoreEmulatedMouseEvents && !$ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, "mouse");
                state.ignoreEmulatedMouseEvents = false;
            };
            hoverProps.onMouseLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, "mouse");
            };
        }
        return {
            hoverProps: hoverProps,
            triggerHoverEnd: triggerHoverEnd
        };
    }, [
        onHoverStart,
        onHoverChange,
        onHoverEnd,
        isDisabled,
        state
    ]);
    (0, $goTMa$react.useEffect)(()=>{
        // Call the triggerHoverEnd as soon as isDisabled changes to true
        // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering
        if (isDisabled) triggerHoverEnd({
            currentTarget: state.target
        }, state.pointerType);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        isDisabled
    ]);
    return {
        hoverProps: hoverProps,
        isHovered: isHovered
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $edcfa848c42f94f4$export$872b660ac5a1ff98(props) {
    let { ref: ref , onInteractOutside: onInteractOutside , isDisabled: isDisabled , onInteractOutsideStart: onInteractOutsideStart  } = props;
    let stateRef = (0, $goTMa$react.useRef)({
        isPointerDown: false,
        ignoreEmulatedMouseEvents: false
    });
    let onPointerDown = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (onInteractOutside && $edcfa848c42f94f4$var$isValidEvent(e, ref)) {
            if (onInteractOutsideStart) onInteractOutsideStart(e);
            stateRef.current.isPointerDown = true;
        }
    });
    let triggerInteractOutside = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (onInteractOutside) onInteractOutside(e);
    });
    (0, $goTMa$react.useEffect)(()=>{
        let state = stateRef.current;
        if (isDisabled) return;
        // Use pointer events if available. Otherwise, fall back to mouse and touch events.
        if (typeof PointerEvent !== "undefined") {
            let onPointerUp = (e)=>{
                if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            // changing these to capture phase fixed combobox
            document.addEventListener("pointerdown", onPointerDown, true);
            document.addEventListener("pointerup", onPointerUp, true);
            return ()=>{
                document.removeEventListener("pointerdown", onPointerDown, true);
                document.removeEventListener("pointerup", onPointerUp, true);
            };
        } else {
            let onMouseUp = (e)=>{
                if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;
                else if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            let onTouchEnd = (e)=>{
                state.ignoreEmulatedMouseEvents = true;
                if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            document.addEventListener("mousedown", onPointerDown, true);
            document.addEventListener("mouseup", onMouseUp, true);
            document.addEventListener("touchstart", onPointerDown, true);
            document.addEventListener("touchend", onTouchEnd, true);
            return ()=>{
                document.removeEventListener("mousedown", onPointerDown, true);
                document.removeEventListener("mouseup", onMouseUp, true);
                document.removeEventListener("touchstart", onPointerDown, true);
                document.removeEventListener("touchend", onTouchEnd, true);
            };
        }
    }, [
        ref,
        isDisabled,
        onPointerDown,
        triggerInteractOutside
    ]);
}
function $edcfa848c42f94f4$var$isValidEvent(event, ref) {
    if (event.button > 0) return false;
    if (event.target) {
        // if the event target is no longer in the document, ignore
        const ownerDocument = event.target.ownerDocument;
        if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;
        // If the target is within a top layer element (e.g. toasts), ignore.
        if (event.target.closest("[data-react-aria-top-layer]")) return false;
    }
    return ref.current && !ref.current.contains(event.target);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $951fbcbbca8db6ce$export$48d1ea6320830260(handler) {
    if (!handler) return;
    let shouldStopPropagation = true;
    return (e)=>{
        let event = {
            ...e,
            preventDefault () {
                e.preventDefault();
            },
            isDefaultPrevented () {
                return e.isDefaultPrevented();
            },
            stopPropagation () {
                console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
            },
            continuePropagation () {
                shouldStopPropagation = false;
            }
        };
        handler(event);
        if (shouldStopPropagation) e.stopPropagation();
    };
}


function $892d64db2a3c53b0$export$8f71654801c2f7cd(props) {
    return {
        keyboardProps: props.isDisabled ? {} : {
            onKeyDown: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyDown),
            onKeyUp: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyUp)
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $c09386fc48fa427d$export$36da96379f79f245(props) {
    let { onMoveStart: onMoveStart , onMove: onMove , onMoveEnd: onMoveEnd  } = props;
    let state = (0, $goTMa$react.useRef)({
        didMove: false,
        lastPosition: null,
        id: null
    });
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let move = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType, deltaX, deltaY)=>{
        if (deltaX === 0 && deltaY === 0) return;
        if (!state.current.didMove) {
            state.current.didMove = true;
            onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart({
                type: "movestart",
                pointerType: pointerType,
                shiftKey: originalEvent.shiftKey,
                metaKey: originalEvent.metaKey,
                ctrlKey: originalEvent.ctrlKey,
                altKey: originalEvent.altKey
            });
        }
        onMove({
            type: "move",
            pointerType: pointerType,
            deltaX: deltaX,
            deltaY: deltaY,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let end = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)();
        if (state.current.didMove) onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd({
            type: "moveend",
            pointerType: pointerType,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let moveProps = (0, $goTMa$react.useMemo)(()=>{
        let moveProps = {};
        let start = ()=>{
            (0, $f7e14e656343df57$export$16a4697467175487)();
            state.current.didMove = false;
        };
        if (typeof PointerEvent === "undefined") {
            let onMouseMove = (e)=>{
                if (e.button === 0) {
                    move(e, "mouse", e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onMouseUp = (e)=>{
                if (e.button === 0) {
                    end(e, "mouse");
                    removeGlobalListener(window, "mousemove", onMouseMove, false);
                    removeGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            moveProps.onMouseDown = (e)=>{
                if (e.button === 0) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    addGlobalListener(window, "mousemove", onMouseMove, false);
                    addGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            let onTouchMove = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id);
                if (touch >= 0) {
                    let { pageX: pageX , pageY: pageY  } = e.changedTouches[touch];
                    move(e, "touch", pageX - state.current.lastPosition.pageX, pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: pageX,
                        pageY: pageY
                    };
                }
            };
            let onTouchEnd = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id);
                if (touch >= 0) {
                    end(e, "touch");
                    state.current.id = null;
                    removeGlobalListener(window, "touchmove", onTouchMove);
                    removeGlobalListener(window, "touchend", onTouchEnd);
                    removeGlobalListener(window, "touchcancel", onTouchEnd);
                }
            };
            moveProps.onTouchStart = (e)=>{
                if (e.changedTouches.length === 0 || state.current.id != null) return;
                let { pageX: pageX , pageY: pageY , identifier: identifier  } = e.changedTouches[0];
                start();
                e.stopPropagation();
                e.preventDefault();
                state.current.lastPosition = {
                    pageX: pageX,
                    pageY: pageY
                };
                state.current.id = identifier;
                addGlobalListener(window, "touchmove", onTouchMove, false);
                addGlobalListener(window, "touchend", onTouchEnd, false);
                addGlobalListener(window, "touchcancel", onTouchEnd, false);
            };
        } else {
            let onPointerMove = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    // Problems with PointerEvent#movementX/movementY:
                    // 1. it is always 0 on macOS Safari.
                    // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS
                    move(e, pointerType, e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    end(e, pointerType);
                    state.current.id = null;
                    removeGlobalListener(window, "pointermove", onPointerMove, false);
                    removeGlobalListener(window, "pointerup", onPointerUp, false);
                    removeGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
            moveProps.onPointerDown = (e)=>{
                if (e.button === 0 && state.current.id == null) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    state.current.id = e.pointerId;
                    addGlobalListener(window, "pointermove", onPointerMove, false);
                    addGlobalListener(window, "pointerup", onPointerUp, false);
                    addGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
        }
        let triggerKeyboardMove = (e, deltaX, deltaY)=>{
            start();
            move(e, "keyboard", deltaX, deltaY);
            end(e, "keyboard");
        };
        moveProps.onKeyDown = (e)=>{
            switch(e.key){
                case "Left":
                case "ArrowLeft":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, -1, 0);
                    break;
                case "Right":
                case "ArrowRight":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 1, 0);
                    break;
                case "Up":
                case "ArrowUp":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, -1);
                    break;
                case "Down":
                case "ArrowDown":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, 1);
                    break;
            }
        };
        return moveProps;
    }, [
        state,
        addGlobalListener,
        removeGlobalListener,
        move,
        end
    ]);
    return {
        moveProps: moveProps
    };
}



/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $a3dbce0aed7087e2$export$2123ff2b87c81ca(props, ref) {
    let { onScroll: onScroll , isDisabled: isDisabled  } = props;
    let onScrollHandler = (0, $goTMa$react.useCallback)((e)=>{
        // If the ctrlKey is pressed, this is a zoom event, do nothing.
        if (e.ctrlKey) return;
        // stop scrolling the page
        e.preventDefault();
        e.stopPropagation();
        if (onScroll) onScroll({
            deltaX: e.deltaX,
            deltaY: e.deltaY
        });
    }, [
        onScroll
    ]);
    (0, $goTMa$reactariautils.useEvent)(ref, "wheel", isDisabled ? null : onScrollHandler);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD = 500;
function $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9(props) {
    let { isDisabled: isDisabled , onLongPressStart: onLongPressStart , onLongPressEnd: onLongPressEnd , onLongPress: onLongPress , threshold: threshold = $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD , accessibilityDescription: accessibilityDescription  } = props;
    const timeRef = (0, $goTMa$react.useRef)(null);
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let { pressProps: pressProps  } = (0, $0294ea432cd92340$export$45712eceda6fad21)({
        isDisabled: isDisabled,
        onPressStart (e) {
            if (e.pointerType === "mouse" || e.pointerType === "touch") {
                if (onLongPressStart) onLongPressStart({
                    ...e,
                    type: "longpressstart"
                });
                timeRef.current = setTimeout(()=>{
                    // Prevent other usePress handlers from also handling this event.
                    e.target.dispatchEvent(new PointerEvent("pointercancel", {
                        bubbles: true
                    }));
                    if (onLongPress) onLongPress({
                        ...e,
                        type: "longpress"
                    });
                    timeRef.current = null;
                }, threshold);
                // Prevent context menu, which may be opened on long press on touch devices
                if (e.pointerType === "touch") {
                    let onContextMenu = (e)=>{
                        e.preventDefault();
                    };
                    addGlobalListener(e.target, "contextmenu", onContextMenu, {
                        once: true
                    });
                    addGlobalListener(window, "pointerup", ()=>{
                        // If no contextmenu event is fired quickly after pointerup, remove the handler
                        // so future context menu events outside a long press are not prevented.
                        setTimeout(()=>{
                            removeGlobalListener(e.target, "contextmenu", onContextMenu);
                        }, 30);
                    }, {
                        once: true
                    });
                }
            }
        },
        onPressEnd (e) {
            if (timeRef.current) clearTimeout(timeRef.current);
            if (onLongPressEnd && (e.pointerType === "mouse" || e.pointerType === "touch")) onLongPressEnd({
                ...e,
                type: "longpressend"
            });
        }
    });
    let descriptionProps = (0, $goTMa$reactariautils.useDescription)(onLongPress && !isDisabled ? accessibilityDescription : null);
    return {
        longPressProps: (0, $goTMa$reactariautils.mergeProps)(pressProps, descriptionProps)
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 17141:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $4hxXn$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "SSRProvider", () => $29383e587d62412a$export$9f8ac96af4b1b2ae);
$parcel$export(module.exports, "useSSRSafeId", () => $29383e587d62412a$export$619500959fc48b26);
$parcel$export(module.exports, "useIsSSR", () => $29383e587d62412a$export$535bd6ca7f90a273);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We must avoid a circular dependency with @react-aria/utils, and this useLayoutEffect is
// guarded by a check that it only runs on the client side.
// eslint-disable-next-line rulesdir/useLayoutEffectRule

// Default context value to use in case there is no SSRProvider. This is fine for
// client-only apps. In order to support multiple copies of React Aria potentially
// being on the page at once, the prefix is set to a random number. SSRProvider
// will reset this to zero for consistency between server and client, so in the
// SSR case multiple copies of React Aria is not supported.
const $29383e587d62412a$var$defaultContext = {
    prefix: String(Math.round(Math.random() * 10000000000)),
    current: 0,
    isSSR: false
};
const $29383e587d62412a$var$SSRContext = /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createContext($29383e587d62412a$var$defaultContext);
// This is only used in React < 18.
function $29383e587d62412a$var$LegacySSRProvider(props) {
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let counter = $29383e587d62412a$var$useCounter(cur === $29383e587d62412a$var$defaultContext);
    let [isSSR, setIsSSR] = (0, $4hxXn$react.useState)(true);
    let value = (0, $4hxXn$react.useMemo)(()=>({
            // If this is the first SSRProvider, start with an empty string prefix, otherwise
            // append and increment the counter.
            prefix: cur === $29383e587d62412a$var$defaultContext ? "" : `${cur.prefix}-${counter}`,
            current: 0,
            isSSR: isSSR
        }), [
        cur,
        counter,
        isSSR
    ]);
    // If on the client, and the component was initially server rendered,
    // then schedule a layout effect to update the component after hydration.
    if (typeof window !== "undefined") // This if statement technically breaks the rules of hooks, but is safe
    // because the condition never changes after mounting.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, $4hxXn$react.useLayoutEffect)(()=>{
        setIsSSR(false);
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$SSRContext.Provider, {
        value: value
    }, props.children);
}
let $29383e587d62412a$var$warnedAboutSSRProvider = false;
function $29383e587d62412a$export$9f8ac96af4b1b2ae(props) {
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function") {
        if (!$29383e587d62412a$var$warnedAboutSSRProvider) {
            console.warn("In React 18, SSRProvider is not necessary and is a noop. You can remove it from your app.");
            $29383e587d62412a$var$warnedAboutSSRProvider = true;
        }
        return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement((0, ($parcel$interopDefault($4hxXn$react))).Fragment, null, props.children);
    }
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$LegacySSRProvider, props);
}
let $29383e587d62412a$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
let $29383e587d62412a$var$componentIds = new WeakMap();
function $29383e587d62412a$var$useCounter(isDisabled = false) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let ref = (0, $4hxXn$react.useRef)(null);
    // eslint-disable-next-line rulesdir/pure-render
    if (ref.current === null && !isDisabled) {
        var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner;
        // In strict mode, React renders components twice, and the ref will be reset to null on the second render.
        // This means our id counter will be incremented twice instead of once. This is a problem because on the
        // server, components are only rendered once and so ids generated on the server won't match the client.
        // In React 18, useId was introduced to solve this, but it is not available in older versions. So to solve this
        // we need to use some React internals to access the underlying Fiber instance, which is stable between renders.
        // This is exposed as ReactCurrentOwner in development, which is all we need since StrictMode only runs in development.
        // To ensure that we only increment the global counter once, we store the starting id for this component in
        // a weak map associated with the Fiber. On the second render, we reset the global counter to this value.
        // Since React runs the second render immediately after the first, this is safe.
        // @ts-ignore
        let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, ($parcel$interopDefault($4hxXn$react))).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;
        if (currentOwner) {
            let prevComponentValue = $29383e587d62412a$var$componentIds.get(currentOwner);
            if (prevComponentValue == null) // On the first render, and first call to useId, store the id and state in our weak map.
            $29383e587d62412a$var$componentIds.set(currentOwner, {
                id: ctx.current,
                state: currentOwner.memoizedState
            });
            else if (currentOwner.memoizedState !== prevComponentValue.state) {
                // On the second render, the memoizedState gets reset by React.
                // Reset the counter, and remove from the weak map so we don't
                // do this for subsequent useId calls.
                ctx.current = prevComponentValue.id;
                $29383e587d62412a$var$componentIds.delete(currentOwner);
            }
        }
        // eslint-disable-next-line rulesdir/pure-render
        ref.current = ++ctx.current;
    }
    // eslint-disable-next-line rulesdir/pure-render
    return ref.current;
}
function $29383e587d62412a$var$useLegacySSRSafeId(defaultId) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    // If we are rendering in a non-DOM environment, and there's no SSRProvider,
    // provide a warning to hint to the developer to add one.
    if (ctx === $29383e587d62412a$var$defaultContext && !$29383e587d62412a$var$canUseDOM) console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
    let counter = $29383e587d62412a$var$useCounter(!!defaultId);
    return defaultId || `react-aria${ctx.prefix}-${counter}`;
}
function $29383e587d62412a$var$useModernSSRSafeId(defaultId) {
    // @ts-ignore
    let id = (0, ($parcel$interopDefault($4hxXn$react))).useId();
    let [didSSR] = (0, $4hxXn$react.useState)($29383e587d62412a$export$535bd6ca7f90a273());
    let prefix = didSSR ? "react-aria" : `react-aria${$29383e587d62412a$var$defaultContext.prefix}`;
    return defaultId || `${prefix}-${id}`;
}
const $29383e587d62412a$export$619500959fc48b26 = typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function" ? $29383e587d62412a$var$useModernSSRSafeId : $29383e587d62412a$var$useLegacySSRSafeId;
function $29383e587d62412a$var$getSnapshot() {
    return false;
}
function $29383e587d62412a$var$getServerSnapshot() {
    return true;
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function $29383e587d62412a$var$subscribe(onStoreChange) {
    // noop
    return ()=>{};
}
function $29383e587d62412a$export$535bd6ca7f90a273() {
    // In React 18, we can use useSyncExternalStore to detect if we're server rendering or hydrating.
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"] === "function") return (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"]($29383e587d62412a$var$subscribe, $29383e587d62412a$var$getSnapshot, $29383e587d62412a$var$getServerSnapshot);
    // eslint-disable-next-line react-hooks/rules-of-hooks
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    return cur.isSSR;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 78659:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $1Yh1N$reactstatelyutils = __webpack_require__(12259);
var $1Yh1N$react = __webpack_require__(18038);
var $1Yh1N$reactariassr = __webpack_require__(17141);
var $1Yh1N$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useId", () => $8c61827343eed941$export$f680877a34711e37);
$parcel$export(module.exports, "mergeIds", () => $8c61827343eed941$export$cd8c9cb68f842629);
$parcel$export(module.exports, "useSlotId", () => $8c61827343eed941$export$b4cc09c592e8fdb8);
$parcel$export(module.exports, "chain", () => $1e2191638e54f613$export$e08e3b67e392101e);
$parcel$export(module.exports, "mergeProps", () => $f847cd1382ea7cd4$export$9d1611c77c2fe928);
$parcel$export(module.exports, "mergeRefs", () => $f05dc24eafaeb7e2$export$c9058316764c140e);
$parcel$export(module.exports, "filterDOMProps", () => $8d15d0e1797d4238$export$457c3d6518dd4c6f);
$parcel$export(module.exports, "focusWithoutScrolling", () => $1117b6c0d4c4c164$export$de79e2c695e052f3);
$parcel$export(module.exports, "getOffset", () => $16ec41ef3e36c19c$export$622cea445a1c5b7d);
$parcel$export(module.exports, "runAfterTransition", () => $e8117ebcab55be6a$export$24490316f764c430);
$parcel$export(module.exports, "useDrag1D", () => $28ed3fb20343b78b$export$7bbed75feba39706);
$parcel$export(module.exports, "useGlobalListeners", () => $4571ff54ac709100$export$4eaf04e54aa8eed6);
$parcel$export(module.exports, "useLabels", () => $6ec78bde395c477d$export$d6875122194c7b44);
$parcel$export(module.exports, "useObjectRef", () => $475b35fe72ba49b3$export$4338b53315abf666);
$parcel$export(module.exports, "useUpdateEffect", () => $29293a6f5c75b37e$export$496315a1608d9602);
$parcel$export(module.exports, "useLayoutEffect", () => $78605a5d7424e31b$export$e5c5a5f917a5871c);
$parcel$export(module.exports, "useResizeObserver", () => $37733e1652f47193$export$683480f191c0e3ea);
$parcel$export(module.exports, "useSyncRef", () => $6fc733991a9f977c$export$4debdb1a3f0fa79e);
$parcel$export(module.exports, "getScrollParent", () => $d796e7157ac96470$export$cfa2225e87938781);
$parcel$export(module.exports, "isScrollable", () => $d796e7157ac96470$export$2bb74740c4e19def);
$parcel$export(module.exports, "useViewportSize", () => $8b24bab62f5c65ad$export$d699905dd57c73ca);
$parcel$export(module.exports, "useDescription", () => $34da4502ea8120db$export$f8aeda7b10753fa1);
$parcel$export(module.exports, "isMac", () => $9e20cff0af27e8cc$export$9ac100e40613ea10);
$parcel$export(module.exports, "isIPhone", () => $9e20cff0af27e8cc$export$186c6964ca17d99);
$parcel$export(module.exports, "isIPad", () => $9e20cff0af27e8cc$export$7bef049ce92e4224);
$parcel$export(module.exports, "isIOS", () => $9e20cff0af27e8cc$export$fedb369cb70207f1);
$parcel$export(module.exports, "isAppleDevice", () => $9e20cff0af27e8cc$export$e1865c3bedcd822b);
$parcel$export(module.exports, "isWebKit", () => $9e20cff0af27e8cc$export$78551043582a6a98);
$parcel$export(module.exports, "isChrome", () => $9e20cff0af27e8cc$export$6446a186d09e379e);
$parcel$export(module.exports, "isAndroid", () => $9e20cff0af27e8cc$export$a11b0059900ceec8);
$parcel$export(module.exports, "useEvent", () => $2a8c0bb1629926c8$export$90fc3a17d93f704c);
$parcel$export(module.exports, "useValueEffect", () => $19a2307bfabafaf1$export$14d238f342723f25);
$parcel$export(module.exports, "scrollIntoView", () => $449412113267a1fe$export$53a0910f038337bd);
$parcel$export(module.exports, "scrollIntoViewport", () => $449412113267a1fe$export$c826860796309d1b);
$parcel$export(module.exports, "clamp", () => $1Yh1N$reactstatelyutils.clamp);
$parcel$export(module.exports, "snapValueToStep", () => $1Yh1N$reactstatelyutils.snapValueToStep);
$parcel$export(module.exports, "isVirtualClick", () => $577e795361f19be9$export$60278871457622de);
$parcel$export(module.exports, "isVirtualPointerEvent", () => $577e795361f19be9$export$29bf1b5f2c56cf63);
$parcel$export(module.exports, "useEffectEvent", () => $1254e5bb94ac8761$export$7f54fc3180508a52);
$parcel$export(module.exports, "useDeepMemo", () => $20e6e72fbf5dc81e$export$722debc0e56fea39);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $78605a5d7424e31b$export$e5c5a5f917a5871c = typeof window !== "undefined" ? (0, ($parcel$interopDefault($1Yh1N$react))).useLayoutEffect : ()=>{};



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $19a2307bfabafaf1$export$14d238f342723f25(defaultValue) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultValue);
    let valueRef = (0, $1Yh1N$react.useRef)(value);
    let effect = (0, $1Yh1N$react.useRef)(null);
    // Must be stable so that `queue` is stable.
    let nextIter = (0, $1Yh1N$react.useCallback)(()=>{
        // Run the generator to the next yield.
        let newValue = effect.current.next();
        while(!newValue.done && valueRef.current === newValue.value)// If the value is the same as the current value,
        // then continue to the next yield. Otherwise,
        // set the value in state and wait for the next layout effect.
        newValue = effect.current.next();
        // If the generator is done, reset the effect.
        if (newValue.done) {
            effect.current = null;
            return;
        }
        // Always update valueRef when setting the state.
        // This is needed because the function is not regenerated with the new state value since
        // they must be stable across renders. Instead, it gets carried in the ref, but the setState
        // is also needed in order to cause a rerender.
        setValue(newValue.value);
        valueRef.current = newValue.value;
    // this list of dependencies is stable, setState and refs never change after first render.
    }, [
        setValue,
        valueRef,
        effect
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        // If there is an effect currently running, continue to the next yield.
        if (effect.current) nextIter();
    });
    // queue must be a stable function, much like setState.
    let queue = (0, $1Yh1N$react.useCallback)((fn)=>{
        effect.current = fn(valueRef.current);
        nextIter();
    // this list of dependencies is stable, setState and refs never change after first render.
    // in addition, nextIter is stable as outlined above
    }, [
        nextIter,
        effect,
        valueRef
    ]);
    return [
        value,
        queue
    ];
}


let $8c61827343eed941$var$idsUpdaterMap = new Map();
function $8c61827343eed941$export$f680877a34711e37(defaultId) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultId);
    let nextId = (0, $1Yh1N$react.useRef)(null);
    let res = (0, $1Yh1N$reactariassr.useSSRSafeId)(value);
    let updateValue = (0, $1Yh1N$react.useCallback)((val)=>{
        nextId.current = val;
    }, []);
    $8c61827343eed941$var$idsUpdaterMap.set(res, updateValue);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        let r = res;
        return ()=>{
            $8c61827343eed941$var$idsUpdaterMap.delete(r);
        };
    }, [
        res
    ]);
    // This cannot cause an infinite loop because the ref is updated first.
    // eslint-disable-next-line
    (0, $1Yh1N$react.useEffect)(()=>{
        let newId = nextId.current;
        if (newId) {
            nextId.current = null;
            setValue(newId);
        }
    });
    return res;
}
function $8c61827343eed941$export$cd8c9cb68f842629(idA, idB) {
    if (idA === idB) return idA;
    let setIdA = $8c61827343eed941$var$idsUpdaterMap.get(idA);
    if (setIdA) {
        setIdA(idB);
        return idB;
    }
    let setIdB = $8c61827343eed941$var$idsUpdaterMap.get(idB);
    if (setIdB) {
        setIdB(idA);
        return idA;
    }
    return idB;
}
function $8c61827343eed941$export$b4cc09c592e8fdb8(depArray = []) {
    let id = $8c61827343eed941$export$f680877a34711e37();
    let [resolvedId, setResolvedId] = (0, $19a2307bfabafaf1$export$14d238f342723f25)(id);
    let updateId = (0, $1Yh1N$react.useCallback)(()=>{
        setResolvedId(function*() {
            yield id;
            yield document.getElementById(id) ? id : undefined;
        });
    }, [
        id,
        setResolvedId
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(updateId, [
        id,
        updateId,
        ...depArray
    ]);
    return resolvedId;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /**
 * Calls all functions in the order they were chained with the same arguments.
 */ function $1e2191638e54f613$export$e08e3b67e392101e(...callbacks) {
    return (...args)=>{
        for (let callback of callbacks)if (typeof callback === "function") callback(...args);
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $f847cd1382ea7cd4$export$9d1611c77c2fe928(...args) {
    // Start with a base clone of the first argument. This is a lot faster than starting
    // with an empty object and adding properties as we go.
    let result = {
        ...args[0]
    };
    for(let i = 1; i < args.length; i++){
        let props = args[i];
        for(let key in props){
            let a = result[key];
            let b = props[key];
            // Chain events
            if (typeof a === "function" && typeof b === "function" && // This is a lot faster than a regex.
            key[0] === "o" && key[1] === "n" && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = (0, $1e2191638e54f613$export$e08e3b67e392101e)(a, b);
            else if ((key === "className" || key === "UNSAFE_className") && typeof a === "string" && typeof b === "string") result[key] = (0, ($parcel$interopDefault($1Yh1N$clsx)))(a, b);
            else if (key === "id" && a && b) result.id = (0, $8c61827343eed941$export$cd8c9cb68f842629)(a, b);
            else result[key] = b !== undefined ? b : a;
        }
    }
    return result;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $f05dc24eafaeb7e2$export$c9058316764c140e(...refs) {
    if (refs.length === 1) return refs[0];
    return (value)=>{
        for (let ref of refs){
            if (typeof ref === "function") ref(value);
            else if (ref != null) ref.current = value;
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ const $8d15d0e1797d4238$var$DOMPropNames = new Set([
    "id"
]);
const $8d15d0e1797d4238$var$labelablePropNames = new Set([
    "aria-label",
    "aria-labelledby",
    "aria-describedby",
    "aria-details"
]);
const $8d15d0e1797d4238$var$propRe = /^(data-.*)$/;
function $8d15d0e1797d4238$export$457c3d6518dd4c6f(props, opts = {}) {
    let { labelable: labelable , propNames: propNames  } = opts;
    let filteredProps = {};
    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($8d15d0e1797d4238$var$DOMPropNames.has(prop) || labelable && $8d15d0e1797d4238$var$labelablePropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $8d15d0e1797d4238$var$propRe.test(prop))) filteredProps[prop] = props[prop];
    return filteredProps;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $1117b6c0d4c4c164$export$de79e2c695e052f3(element) {
    if ($1117b6c0d4c4c164$var$supportsPreventScroll()) element.focus({
        preventScroll: true
    });
    else {
        let scrollableElements = $1117b6c0d4c4c164$var$getScrollableElements(element);
        element.focus();
        $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements);
    }
}
let $1117b6c0d4c4c164$var$supportsPreventScrollCached = null;
function $1117b6c0d4c4c164$var$supportsPreventScroll() {
    if ($1117b6c0d4c4c164$var$supportsPreventScrollCached == null) {
        $1117b6c0d4c4c164$var$supportsPreventScrollCached = false;
        try {
            var focusElem = document.createElement("div");
            focusElem.focus({
                get preventScroll () {
                    $1117b6c0d4c4c164$var$supportsPreventScrollCached = true;
                    return true;
                }
            });
        } catch (e) {
        // Ignore
        }
    }
    return $1117b6c0d4c4c164$var$supportsPreventScrollCached;
}
function $1117b6c0d4c4c164$var$getScrollableElements(element) {
    var parent = element.parentNode;
    var scrollableElements = [];
    var rootScrollingElement = document.scrollingElement || document.documentElement;
    while(parent instanceof HTMLElement && parent !== rootScrollingElement){
        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({
            element: parent,
            scrollTop: parent.scrollTop,
            scrollLeft: parent.scrollLeft
        });
        parent = parent.parentNode;
    }
    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
        element: rootScrollingElement,
        scrollTop: rootScrollingElement.scrollTop,
        scrollLeft: rootScrollingElement.scrollLeft
    });
    return scrollableElements;
}
function $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements) {
    for (let { element: element , scrollTop: scrollTop , scrollLeft: scrollLeft  } of scrollableElements){
        element.scrollTop = scrollTop;
        element.scrollLeft = scrollLeft;
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $16ec41ef3e36c19c$export$622cea445a1c5b7d(element, reverse, orientation = "horizontal") {
    let rect = element.getBoundingClientRect();
    if (reverse) return orientation === "horizontal" ? rect.right : rect.bottom;
    return orientation === "horizontal" ? rect.left : rect.top;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We store a global list of elements that are currently transitioning,
// mapped to a set of CSS properties that are transitioning for that element.
// This is necessary rather than a simple count of transitions because of browser
// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather
// than one or the other. So we need to track what's actually transitioning so that
// we can ignore these duplicate events.
let $e8117ebcab55be6a$var$transitionsByElement = new Map();
// A list of callbacks to call once there are no transitioning elements.
let $e8117ebcab55be6a$var$transitionCallbacks = new Set();
function $e8117ebcab55be6a$var$setupGlobalEvents() {
    if (typeof window === "undefined") return;
    let onTransitionStart = (e)=>{
        // Add the transitioning property to the list for this element.
        let transitions = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!transitions) {
            transitions = new Set();
            $e8117ebcab55be6a$var$transitionsByElement.set(e.target, transitions);
            // The transitioncancel event must be registered on the element itself, rather than as a global
            // event. This enables us to handle when the node is deleted from the document while it is transitioning.
            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.
            e.target.addEventListener("transitioncancel", onTransitionEnd);
        }
        transitions.add(e.propertyName);
    };
    let onTransitionEnd = (e)=>{
        // Remove property from list of transitioning properties.
        let properties = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!properties) return;
        properties.delete(e.propertyName);
        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.
        if (properties.size === 0) {
            e.target.removeEventListener("transitioncancel", onTransitionEnd);
            $e8117ebcab55be6a$var$transitionsByElement.delete(e.target);
        }
        // If no transitioning elements, call all of the queued callbacks.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) {
            for (let cb of $e8117ebcab55be6a$var$transitionCallbacks)cb();
            $e8117ebcab55be6a$var$transitionCallbacks.clear();
        }
    };
    document.body.addEventListener("transitionrun", onTransitionStart);
    document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e8117ebcab55be6a$var$setupGlobalEvents();
    else document.addEventListener("DOMContentLoaded", $e8117ebcab55be6a$var$setupGlobalEvents);
}
function $e8117ebcab55be6a$export$24490316f764c430(fn) {
    // Wait one frame to see if an animation starts, e.g. a transition on mount.
    requestAnimationFrame(()=>{
        // If no transitions are running, call the function immediately.
        // Otherwise, add it to a list of callbacks to run at the end of the animation.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) fn();
        else $e8117ebcab55be6a$var$transitionCallbacks.add(fn);
    });
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 

// Keep track of elements that we are currently handling dragging for via useDrag1D.
// If there's an ancestor and a descendant both using useDrag1D(), and the user starts
// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.
const $28ed3fb20343b78b$var$draggingElements = [];
function $28ed3fb20343b78b$export$7bbed75feba39706(props) {
    console.warn("useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html");
    let { containerRef: containerRef , reverse: reverse , orientation: orientation , onHover: onHover , onDrag: onDrag , onPositionChange: onPositionChange , onIncrement: onIncrement , onDecrement: onDecrement , onIncrementToMax: onIncrementToMax , onDecrementToMin: onDecrementToMin , onCollapseToggle: onCollapseToggle  } = props;
    let getPosition = (e)=>orientation === "horizontal" ? e.clientX : e.clientY;
    let getNextOffset = (e)=>{
        let containerOffset = (0, $16ec41ef3e36c19c$export$622cea445a1c5b7d)(containerRef.current, reverse, orientation);
        let mouseOffset = getPosition(e);
        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;
        return nextOffset;
    };
    let dragging = (0, $1Yh1N$react.useRef)(false);
    let prevPosition = (0, $1Yh1N$react.useRef)(0);
    // Keep track of the current handlers in a ref so that the events can access them.
    let handlers = (0, $1Yh1N$react.useRef)({
        onPositionChange: onPositionChange,
        onDrag: onDrag
    });
    handlers.current.onDrag = onDrag;
    handlers.current.onPositionChange = onPositionChange;
    let onMouseDragged = (e)=>{
        e.preventDefault();
        let nextOffset = getNextOffset(e);
        if (!dragging.current) {
            dragging.current = true;
            if (handlers.current.onDrag) handlers.current.onDrag(true);
            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        }
        if (prevPosition.current === nextOffset) return;
        prevPosition.current = nextOffset;
        if (onPositionChange) onPositionChange(nextOffset);
    };
    let onMouseUp = (e)=>{
        const target = e.target;
        dragging.current = false;
        let nextOffset = getNextOffset(e);
        if (handlers.current.onDrag) handlers.current.onDrag(false);
        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        $28ed3fb20343b78b$var$draggingElements.splice($28ed3fb20343b78b$var$draggingElements.indexOf(target), 1);
        window.removeEventListener("mouseup", onMouseUp, false);
        window.removeEventListener("mousemove", onMouseDragged, false);
    };
    let onMouseDown = (e)=>{
        const target = e.currentTarget;
        // If we're already handling dragging on a descendant with useDrag1D, then
        // we don't want to handle the drag motion on this target as well.
        if ($28ed3fb20343b78b$var$draggingElements.some((elt)=>target.contains(elt))) return;
        $28ed3fb20343b78b$var$draggingElements.push(target);
        window.addEventListener("mousemove", onMouseDragged, false);
        window.addEventListener("mouseup", onMouseUp, false);
    };
    let onMouseEnter = ()=>{
        if (onHover) onHover(true);
    };
    let onMouseOut = ()=>{
        if (onHover) onHover(false);
    };
    let onKeyDown = (e)=>{
        switch(e.key){
            case "Left":
            case "ArrowLeft":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Up":
            case "ArrowUp":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Right":
            case "ArrowRight":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Down":
            case "ArrowDown":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Home":
                e.preventDefault();
                if (onDecrementToMin) onDecrementToMin();
                break;
            case "End":
                e.preventDefault();
                if (onIncrementToMax) onIncrementToMax();
                break;
            case "Enter":
                e.preventDefault();
                if (onCollapseToggle) onCollapseToggle();
                break;
        }
    };
    return {
        onMouseDown: onMouseDown,
        onMouseEnter: onMouseEnter,
        onMouseOut: onMouseOut,
        onKeyDown: onKeyDown
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $4571ff54ac709100$export$4eaf04e54aa8eed6() {
    let globalListeners = (0, $1Yh1N$react.useRef)(new Map());
    let addGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        // Make sure we remove the listener after it is called with the `once` option.
        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{
            globalListeners.current.delete(listener);
            listener(...args);
        } : listener;
        globalListeners.current.set(listener, {
            type: type,
            eventTarget: eventTarget,
            fn: fn,
            options: options
        });
        eventTarget.addEventListener(type, listener, options);
    }, []);
    let removeGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        var _globalListeners_current_get;
        let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
        eventTarget.removeEventListener(type, fn, options);
        globalListeners.current.delete(listener);
    }, []);
    let removeAllGlobalListeners = (0, $1Yh1N$react.useCallback)(()=>{
        globalListeners.current.forEach((value, key)=>{
            removeGlobalListener(value.eventTarget, value.type, key, value.options);
        });
    }, [
        removeGlobalListener
    ]);
    // eslint-disable-next-line arrow-body-style
    (0, $1Yh1N$react.useEffect)(()=>{
        return removeAllGlobalListeners;
    }, [
        removeAllGlobalListeners
    ]);
    return {
        addGlobalListener: addGlobalListener,
        removeGlobalListener: removeGlobalListener,
        removeAllGlobalListeners: removeAllGlobalListeners
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6ec78bde395c477d$export$d6875122194c7b44(props, defaultLabel) {
    let { id: id , "aria-label": label , "aria-labelledby": labelledBy  } = props;
    // If there is both an aria-label and aria-labelledby,
    // combine them by pointing to the element itself.
    id = (0, $8c61827343eed941$export$f680877a34711e37)(id);
    if (labelledBy && label) {
        let ids = new Set([
            id,
            ...labelledBy.trim().split(/\s+/)
        ]);
        labelledBy = [
            ...ids
        ].join(" ");
    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\s+/).join(" ");
    // If no labels are provided, use the default
    if (!label && !labelledBy && defaultLabel) label = defaultLabel;
    return {
        id: id,
        "aria-label": label,
        "aria-labelledby": labelledBy
    };
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $475b35fe72ba49b3$export$4338b53315abf666(forwardedRef) {
    const objRef = (0, $1Yh1N$react.useRef)();
    return (0, $1Yh1N$react.useMemo)(()=>({
            get current () {
                return objRef.current;
            },
            set current (value){
                objRef.current = value;
                if (typeof forwardedRef === "function") forwardedRef(value);
                else if (forwardedRef) forwardedRef.current = value;
            }
        }), [
        forwardedRef
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $29293a6f5c75b37e$export$496315a1608d9602(effect, dependencies) {
    const isInitialMount = (0, $1Yh1N$react.useRef)(true);
    const lastDeps = (0, $1Yh1N$react.useRef)(null);
    (0, $1Yh1N$react.useEffect)(()=>{
        isInitialMount.current = true;
        return ()=>{
            isInitialMount.current = false;
        };
    }, []);
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isInitialMount.current) isInitialMount.current = false;
        else if (!lastDeps.current || dependencies.some((dep, i)=>!Object.is(dep, lastDeps[i]))) effect();
        lastDeps.current = dependencies;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencies);
}




function $37733e1652f47193$var$hasResizeObserver() {
    return typeof window.ResizeObserver !== "undefined";
}
function $37733e1652f47193$export$683480f191c0e3ea(options) {
    const { ref: ref , onResize: onResize  } = options;
    (0, $1Yh1N$react.useEffect)(()=>{
        let element = ref === null || ref === void 0 ? void 0 : ref.current;
        if (!element) return;
        if (!$37733e1652f47193$var$hasResizeObserver()) {
            window.addEventListener("resize", onResize, false);
            return ()=>{
                window.removeEventListener("resize", onResize, false);
            };
        } else {
            const resizeObserverInstance = new window.ResizeObserver((entries)=>{
                if (!entries.length) return;
                onResize();
            });
            resizeObserverInstance.observe(element);
            return ()=>{
                if (element) resizeObserverInstance.unobserve(element);
            };
        }
    }, [
        onResize,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6fc733991a9f977c$export$4debdb1a3f0fa79e(context, ref) {
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (context && context.ref && ref) {
            context.ref.current = ref.current;
            return ()=>{
                context.ref.current = null;
            };
        }
    }, [
        context,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d796e7157ac96470$export$cfa2225e87938781(node) {
    if ($d796e7157ac96470$export$2bb74740c4e19def(node)) node = node.parentElement;
    while(node && !$d796e7157ac96470$export$2bb74740c4e19def(node))node = node.parentElement;
    return node || document.scrollingElement || document.documentElement;
}
function $d796e7157ac96470$export$2bb74740c4e19def(node) {
    let style = window.getComputedStyle(node);
    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// @ts-ignore
let $8b24bab62f5c65ad$var$visualViewport = typeof window !== "undefined" && window.visualViewport;
function $8b24bab62f5c65ad$export$d699905dd57c73ca() {
    let [size, setSize] = (0, $1Yh1N$react.useState)(()=>$8b24bab62f5c65ad$var$getViewportSize());
    (0, $1Yh1N$react.useEffect)(()=>{
        // Use visualViewport api to track available height even on iOS virtual keyboard opening
        let onResize = ()=>{
            setSize((size)=>{
                let newSize = $8b24bab62f5c65ad$var$getViewportSize();
                if (newSize.width === size.width && newSize.height === size.height) return size;
                return newSize;
            });
        };
        if (!$8b24bab62f5c65ad$var$visualViewport) window.addEventListener("resize", onResize);
        else $8b24bab62f5c65ad$var$visualViewport.addEventListener("resize", onResize);
        return ()=>{
            if (!$8b24bab62f5c65ad$var$visualViewport) window.removeEventListener("resize", onResize);
            else $8b24bab62f5c65ad$var$visualViewport.removeEventListener("resize", onResize);
        };
    }, []);
    return size;
}
function $8b24bab62f5c65ad$var$getViewportSize() {
    return {
        width: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.width) || window.innerWidth,
        height: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.height) || window.innerHeight
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

let $34da4502ea8120db$var$descriptionId = 0;
const $34da4502ea8120db$var$descriptionNodes = new Map();
function $34da4502ea8120db$export$f8aeda7b10753fa1(description) {
    let [id, setId] = (0, $1Yh1N$react.useState)(undefined);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (!description) return;
        let desc = $34da4502ea8120db$var$descriptionNodes.get(description);
        if (!desc) {
            let id = `react-aria-description-${$34da4502ea8120db$var$descriptionId++}`;
            setId(id);
            let node = document.createElement("div");
            node.id = id;
            node.style.display = "none";
            node.textContent = description;
            document.body.appendChild(node);
            desc = {
                refCount: 0,
                element: node
            };
            $34da4502ea8120db$var$descriptionNodes.set(description, desc);
        } else setId(desc.element.id);
        desc.refCount++;
        return ()=>{
            if (--desc.refCount === 0) {
                desc.element.remove();
                $34da4502ea8120db$var$descriptionNodes.delete(description);
            }
        };
    }, [
        description
    ]);
    return {
        "aria-describedby": description ? id : undefined
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $9e20cff0af27e8cc$var$testUserAgent(re) {
    var _window_navigator_userAgentData;
    if (typeof window === "undefined" || window.navigator == null) return false;
    return ((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand)=>re.test(brand.brand))) || re.test(window.navigator.userAgent);
}
function $9e20cff0af27e8cc$var$testPlatform(re) {
    var _window_navigator_userAgentData;
    return typeof window !== "undefined" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $9e20cff0af27e8cc$export$9ac100e40613ea10() {
    return $9e20cff0af27e8cc$var$testPlatform(/^Mac/i);
}
function $9e20cff0af27e8cc$export$186c6964ca17d99() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPhone/i);
}
function $9e20cff0af27e8cc$export$7bef049ce92e4224() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
    $9e20cff0af27e8cc$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
}
function $9e20cff0af27e8cc$export$fedb369cb70207f1() {
    return $9e20cff0af27e8cc$export$186c6964ca17d99() || $9e20cff0af27e8cc$export$7bef049ce92e4224();
}
function $9e20cff0af27e8cc$export$e1865c3bedcd822b() {
    return $9e20cff0af27e8cc$export$9ac100e40613ea10() || $9e20cff0af27e8cc$export$fedb369cb70207f1();
}
function $9e20cff0af27e8cc$export$78551043582a6a98() {
    return $9e20cff0af27e8cc$var$testUserAgent(/AppleWebKit/i) && !$9e20cff0af27e8cc$export$6446a186d09e379e();
}
function $9e20cff0af27e8cc$export$6446a186d09e379e() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Chrome/i);
}
function $9e20cff0af27e8cc$export$a11b0059900ceec8() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Android/i);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1254e5bb94ac8761$export$7f54fc3180508a52(fn) {
    const ref = (0, $1Yh1N$react.useRef)(null);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        ref.current = fn;
    }, [
        fn
    ]);
    return (0, $1Yh1N$react.useCallback)((...args)=>{
        const f = ref.current;
        return f(...args);
    }, []);
}


function $2a8c0bb1629926c8$export$90fc3a17d93f704c(ref, event, handler, options) {
    let handleEvent = (0, $1254e5bb94ac8761$export$7f54fc3180508a52)(handler);
    let isDisabled = handler == null;
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isDisabled) return;
        let element = ref.current;
        element.addEventListener(event, handleEvent, options);
        return ()=>{
            element.removeEventListener(event, handleEvent, options);
        };
    }, [
        ref,
        event,
        options,
        isDisabled,
        handleEvent
    ]);
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $449412113267a1fe$export$53a0910f038337bd(scrollView, element) {
    let offsetX = $449412113267a1fe$var$relativeOffset(scrollView, element, "left");
    let offsetY = $449412113267a1fe$var$relativeOffset(scrollView, element, "top");
    let width = element.offsetWidth;
    let height = element.offsetHeight;
    let x = scrollView.scrollLeft;
    let y = scrollView.scrollTop;
    // Account for top/left border offsetting the scroll top/Left
    let { borderTopWidth: borderTopWidth , borderLeftWidth: borderLeftWidth  } = getComputedStyle(scrollView);
    let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);
    let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);
    // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width
    let maxX = borderAdjustedX + scrollView.clientWidth;
    let maxY = borderAdjustedY + scrollView.clientHeight;
    if (offsetX <= x) x = offsetX - parseInt(borderLeftWidth, 10);
    else if (offsetX + width > maxX) x += offsetX + width - maxX;
    if (offsetY <= borderAdjustedY) y = offsetY - parseInt(borderTopWidth, 10);
    else if (offsetY + height > maxY) y += offsetY + height - maxY;
    scrollView.scrollLeft = x;
    scrollView.scrollTop = y;
}
/**
 * Computes the offset left or top from child to ancestor by accumulating
 * offsetLeft or offsetTop through intervening offsetParents.
 */ function $449412113267a1fe$var$relativeOffset(ancestor, child, axis) {
    const prop = axis === "left" ? "offsetLeft" : "offsetTop";
    let sum = 0;
    while(child.offsetParent){
        sum += child[prop];
        if (child.offsetParent === ancestor) break;
        else if (child.offsetParent.contains(ancestor)) {
            // If the ancestor is not `position:relative`, then we stop at
            // _its_ offset parent, and we subtract off _its_ offset, so that
            // we end up with the proper offset from child to ancestor.
            sum -= ancestor[prop];
            break;
        }
        child = child.offsetParent;
    }
    return sum;
}
function $449412113267a1fe$export$c826860796309d1b(targetElement, opts) {
    if (document.contains(targetElement)) {
        let root = document.scrollingElement || document.documentElement;
        let isScrollPrevented = window.getComputedStyle(root).overflow === "hidden";
        // If scrolling is not currently prevented then we aren’t in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view
        if (!isScrollPrevented) {
            var // use scrollIntoView({block: 'nearest'}) instead of .focus to check if the element is fully in view or not since .focus()
            // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically
            _targetElement_scrollIntoView;
            let { left: originalLeft , top: originalTop  } = targetElement.getBoundingClientRect();
            targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {
                block: "nearest"
            });
            let { left: newLeft , top: newTop  } = targetElement.getBoundingClientRect();
            // Account for sub pixel differences from rounding
            if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {
                var _opts_containingElement, _opts_containingElement_scrollIntoView, _targetElement_scrollIntoView1;
                opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {
                    block: "center",
                    inline: "center"
                });
                (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {
                    block: "nearest"
                });
            }
        } else {
            let scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.
            while(targetElement && scrollParent && targetElement !== root && scrollParent !== root){
                $449412113267a1fe$export$53a0910f038337bd(scrollParent, targetElement);
                targetElement = scrollParent;
                scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            }
        }
    }
}



/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $577e795361f19be9$export$60278871457622de(event) {
    // JAWS/NVDA with Firefox.
    if (event.mozInputSource === 0 && event.isTrusted) return true;
    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead
    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check
    // to detect TalkBack virtual clicks.
    if ((0, $9e20cff0af27e8cc$export$a11b0059900ceec8)() && event.pointerType) return event.type === "click" && event.buttons === 1;
    return event.detail === 0 && !event.pointerType;
}
function $577e795361f19be9$export$29bf1b5f2c56cf63(event) {
    // If the pointer size is zero, then we assume it's from a screen reader.
    // Android TalkBack double tap will sometimes return a event with width and height of 1
    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.
    // Cannot use "event.pressure === 0" as the sole check due to Safari pointer events always returning pressure === 0
    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush
    // Talkback double tap from Windows Firefox touch screen press
    return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse";
}



/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 
function $20e6e72fbf5dc81e$export$722debc0e56fea39(value, isEqual) {
    // Using a ref during render is ok here because it's only an optimization – both values are equivalent.
    // If a render is thrown away, it'll still work the same no matter if the next render is the same or not.
    let lastValue = (0, $1Yh1N$react.useRef)(null);
    if (value && lastValue.current && isEqual(value, lastValue.current)) value = lastValue.current;
    lastValue.current = value;
    return value;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 94135:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $aB6Cp$react = __webpack_require__(18038);
var $aB6Cp$reactariautils = __webpack_require__(77335);
var $aB6Cp$reactariainteractions = __webpack_require__(34353);
var $aB6Cp$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "FocusScope", () => $a7a032acae3ddda9$export$20e40289641fbbb6);
$parcel$export(module.exports, "useFocusManager", () => $a7a032acae3ddda9$export$10c5169755ce7bd7);
$parcel$export(module.exports, "getFocusableTreeWalker", () => $a7a032acae3ddda9$export$2d6ec8fc375ceafa);
$parcel$export(module.exports, "createFocusManager", () => $a7a032acae3ddda9$export$c5251b9e124bf29);
$parcel$export(module.exports, "FocusRing", () => $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d);
$parcel$export(module.exports, "FocusableProvider", () => $fb504d83237fd6ac$export$13f3202a3e5ddd5);
$parcel$export(module.exports, "useFocusable", () => $fb504d83237fd6ac$export$4c014de7c8940b4c);
$parcel$export(module.exports, "useFocusRing", () => $581a96d6eb128c1b$export$4e328f61c538687f);
$parcel$export(module.exports, "focusSafely", () => $1c7f9157d722357d$export$80f3e147d781571c);


function $1c7f9157d722357d$export$80f3e147d781571c(element) {
    // If the user is interacting with a virtual cursor, e.g. screen reader, then
    // wait until after any animated transitions that are currently occurring on
    // the page before shifting focus. This avoids issues with VoiceOver on iOS
    // causing the page to scroll when moving focus if the element is transitioning
    // from off the screen.
    if ($aB6Cp$reactariainteractions.getInteractionModality() === 'virtual') {
        let lastFocusedElement = document.activeElement;
        $aB6Cp$reactariautils.runAfterTransition(()=>{
            // If focus did not move and the element is still in the document, focus it.
            if (document.activeElement === lastFocusedElement && document.contains(element)) $aB6Cp$reactariautils.focusWithoutScrolling(element);
        });
    } else $aB6Cp$reactariautils.focusWithoutScrolling(element);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d5156037ad898a4d$var$isStyleVisible(element) {
    if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) return false;
    let { display: display , visibility: visibility  } = element.style;
    let isVisible = display !== 'none' && visibility !== 'hidden' && visibility !== 'collapse';
    if (isVisible) {
        const { getComputedStyle: getComputedStyle  } = element.ownerDocument.defaultView;
        let { display: computedDisplay , visibility: computedVisibility  } = getComputedStyle(element);
        isVisible = computedDisplay !== 'none' && computedVisibility !== 'hidden' && computedVisibility !== 'collapse';
    }
    return isVisible;
}
function $d5156037ad898a4d$var$isAttributeVisible(element, childElement) {
    return !element.hasAttribute('hidden') && (element.nodeName === 'DETAILS' && childElement && childElement.nodeName !== 'SUMMARY' ? element.hasAttribute('open') : true);
}
function $d5156037ad898a4d$export$e989c0fffaa6b27a(element, childElement) {
    return element.nodeName !== '#comment' && $d5156037ad898a4d$var$isStyleVisible(element) && $d5156037ad898a4d$var$isAttributeVisible(element, childElement) && (!element.parentElement || $d5156037ad898a4d$export$e989c0fffaa6b27a(element.parentElement, element));
}




const $a7a032acae3ddda9$var$FocusContext = /*#__PURE__*/ ($parcel$interopDefault($aB6Cp$react)).createContext(null);
let $a7a032acae3ddda9$var$activeScope = null;
let $a7a032acae3ddda9$var$scopes = new Map();
function $a7a032acae3ddda9$export$20e40289641fbbb6(props) {
    let { children: children , contain: contain , restoreFocus: restoreFocus , autoFocus: autoFocus  } = props;
    let startRef = $aB6Cp$react.useRef();
    let endRef = $aB6Cp$react.useRef();
    let scopeRef = $aB6Cp$react.useRef([]);
    let ctx = $aB6Cp$react.useContext($a7a032acae3ddda9$var$FocusContext);
    let parentScope = ctx === null || ctx === void 0 ? void 0 : ctx.scopeRef;
    $aB6Cp$reactariautils.useLayoutEffect(()=>{
        // Find all rendered nodes between the sentinels and add them to the scope.
        let node = startRef.current.nextSibling;
        let nodes = [];
        while(node && node !== endRef.current){
            nodes.push(node);
            node = node.nextSibling;
        }
        scopeRef.current = nodes;
    }, [
        children,
        parentScope
    ]);
    $aB6Cp$reactariautils.useLayoutEffect(()=>{
        $a7a032acae3ddda9$var$scopes.set(scopeRef, parentScope);
        return ()=>{
            // Restore the active scope on unmount if this scope or a descendant scope is active.
            // Parent effect cleanups run before children, so we need to check if the
            // parent scope actually still exists before restoring the active scope to it.
            if ((scopeRef === $a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope(scopeRef, $a7a032acae3ddda9$var$activeScope)) && (!parentScope || $a7a032acae3ddda9$var$scopes.has(parentScope))) $a7a032acae3ddda9$var$activeScope = parentScope;
            $a7a032acae3ddda9$var$scopes.delete(scopeRef);
        };
    }, [
        scopeRef,
        parentScope
    ]);
    $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain);
    $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus);
    let focusManager = $a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef);
    return(/*#__PURE__*/ ($parcel$interopDefault($aB6Cp$react)).createElement($a7a032acae3ddda9$var$FocusContext.Provider, {
        value: {
            scopeRef: scopeRef,
            focusManager: focusManager
        }
    }, /*#__PURE__*/ ($parcel$interopDefault($aB6Cp$react)).createElement("span", {
        "data-focus-scope-start": true,
        hidden: true,
        ref: startRef
    }), children, /*#__PURE__*/ ($parcel$interopDefault($aB6Cp$react)).createElement("span", {
        "data-focus-scope-end": true,
        hidden: true,
        ref: endRef
    })));
}
function $a7a032acae3ddda9$export$10c5169755ce7bd7() {
    var ref;
    return (ref = $aB6Cp$react.useContext($a7a032acae3ddda9$var$FocusContext)) === null || ref === void 0 ? void 0 : ref.focusManager;
}
function $a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef) {
    return {
        focusNext (opts = {
        }) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[0].previousElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = sentinel;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = {
        }) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[scope.length - 1].nextElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = sentinel;
                previousNode = walker.previousNode();
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = {
        }) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[0].previousElementSibling;
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = {
        }) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[scope.length - 1].nextElementSibling;
            let previousNode = walker.previousNode();
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        }
    };
}
const $a7a032acae3ddda9$var$focusableElements = [
    'input:not([disabled]):not([type=hidden])',
    'select:not([disabled])',
    'textarea:not([disabled])',
    'button:not([disabled])',
    'a[href]',
    'area[href]',
    'summary',
    'iframe',
    'object',
    'embed',
    'audio[controls]',
    'video[controls]',
    '[contenteditable]'
];
const $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(':not([hidden]),') + ',[tabindex]:not([disabled]):not([hidden])';
$a7a032acae3ddda9$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(':not([hidden]):not([tabindex="-1"]),');
function $a7a032acae3ddda9$var$getScopeRoot(scope) {
    return scope[0].parentElement;
}
function $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain) {
    let focusedNode = $aB6Cp$react.useRef();
    let raf = $aB6Cp$react.useRef(null);
    $aB6Cp$reactariautils.useLayoutEffect(()=>{
        let scope1 = scopeRef.current;
        if (!contain) {
            // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment
            if (raf.current) {
                cancelAnimationFrame(raf.current);
                raf.current = null;
            }
            return;
        }
        // Handle the Tab key to contain focus within the scope
        let onKeyDown = (e)=>{
            if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || scopeRef !== $a7a032acae3ddda9$var$activeScope) return;
            let focusedElement = document.activeElement;
            let scope = scopeRef.current;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scope)) return;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: true
            }, scope);
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!nextElement) {
                walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;
                nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            }
            e.preventDefault();
            if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
        };
        let onFocus = (e)=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if (!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) {
                $a7a032acae3ddda9$var$activeScope = scopeRef;
                focusedNode.current = e.target;
            } else if (scopeRef === $a7a032acae3ddda9$var$activeScope && !$a7a032acae3ddda9$var$isElementInChildScope(e.target, scopeRef)) {
                // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),
                // restore focus to the previously focused node or the first tabbable element in the active scope.
                if (focusedNode.current) focusedNode.current.focus();
                else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
            } else if (scopeRef === $a7a032acae3ddda9$var$activeScope) focusedNode.current = e.target;
        };
        let onBlur = (e)=>{
            // Firefox doesn't shift focus back to the Dialog properly without this
            raf.current = requestAnimationFrame(()=>{
                // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe
                if (scopeRef === $a7a032acae3ddda9$var$activeScope && !$a7a032acae3ddda9$var$isElementInChildScope(document.activeElement, scopeRef)) {
                    $a7a032acae3ddda9$var$activeScope = scopeRef;
                    focusedNode.current = e.target;
                    focusedNode.current.focus();
                }
            });
        };
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('focusin', onFocus, false);
        scope1.forEach((element)=>element.addEventListener('focusin', onFocus, false)
        );
        scope1.forEach((element)=>element.addEventListener('focusout', onBlur, false)
        );
        return ()=>{
            document.removeEventListener('keydown', onKeyDown, false);
            document.removeEventListener('focusin', onFocus, false);
            scope1.forEach((element)=>element.removeEventListener('focusin', onFocus, false)
            );
            scope1.forEach((element)=>element.removeEventListener('focusout', onBlur, false)
            );
        };
    }, [
        scopeRef,
        contain
    ]);
    // eslint-disable-next-line arrow-body-style
    $aB6Cp$react.useEffect(()=>{
        return ()=>{
            if (raf.current) cancelAnimationFrame(raf.current);
        };
    }, [
        raf
    ]);
}
function $a7a032acae3ddda9$var$isElementInAnyScope(element) {
    for (let scope of $a7a032acae3ddda9$var$scopes.keys()){
        if ($a7a032acae3ddda9$var$isElementInScope(element, scope.current)) return true;
    }
    return false;
}
function $a7a032acae3ddda9$var$isElementInScope(element, scope) {
    return scope.some((node)=>node.contains(element)
    );
}
function $a7a032acae3ddda9$var$isElementInChildScope(element, scope) {
    // node.contains in isElementInScope covers child scopes that are also DOM children,
    // but does not cover child scopes in portals.
    for (let s of $a7a032acae3ddda9$var$scopes.keys()){
        if ((s === scope || $a7a032acae3ddda9$var$isAncestorScope(scope, s)) && $a7a032acae3ddda9$var$isElementInScope(element, s.current)) return true;
    }
    return false;
}
function $a7a032acae3ddda9$var$isAncestorScope(ancestor, scope) {
    let parent = $a7a032acae3ddda9$var$scopes.get(scope);
    if (!parent) return false;
    if (parent === ancestor) return true;
    return $a7a032acae3ddda9$var$isAncestorScope(ancestor, parent);
}
function $a7a032acae3ddda9$var$focusElement(element, scroll = false) {
    if (element != null && !scroll) try {
        $1c7f9157d722357d$export$80f3e147d781571c(element);
    } catch (err) {
    // ignore
    }
    else if (element != null) try {
        element.focus();
    } catch (err1) {
    // ignore
    }
}
function $a7a032acae3ddda9$var$focusFirstInScope(scope) {
    let sentinel = scope[0].previousElementSibling;
    let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
        tabbable: true
    }, scope);
    walker.currentNode = sentinel;
    $a7a032acae3ddda9$var$focusElement(walker.nextNode());
}
function $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus) {
    const autoFocusRef = ($parcel$interopDefault($aB6Cp$react)).useRef(autoFocus);
    $aB6Cp$react.useEffect(()=>{
        if (autoFocusRef.current) {
            $a7a032acae3ddda9$var$activeScope = scopeRef;
            if (!$a7a032acae3ddda9$var$isElementInScope(document.activeElement, $a7a032acae3ddda9$var$activeScope.current)) $a7a032acae3ddda9$var$focusFirstInScope(scopeRef.current);
        }
        autoFocusRef.current = false;
    }, []);
}
function $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
    // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.
    const nodeToRestoreRef = $aB6Cp$react.useRef(typeof document !== 'undefined' ? document.activeElement : null);
    // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
    $aB6Cp$reactariautils.useLayoutEffect(()=>{
        let nodeToRestore = nodeToRestoreRef.current;
        if (!restoreFocus) return;
        // Handle the Tab key so that tabbing out of the scope goes to the next element
        // after the node that had focus when the scope mounted. This is important when
        // using portals for overlays, so that focus goes to the expected element when
        // tabbing out of the overlay.
        let onKeyDown = (e)=>{
            if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey) return;
            let focusedElement = document.activeElement;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scopeRef.current)) return;
            // Create a DOM tree walker that matches all tabbable elements
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(document.body, {
                tabbable: true
            });
            // Find the next tabbable element after the currently focused element
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!document.body.contains(nodeToRestore) || nodeToRestore === document.body) nodeToRestore = null;
            // If there is no next element, or it is outside the current scope, move focus to the
            // next element after the node to restore to instead.
            if ((!nextElement || !$a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {
                walker.currentNode = nodeToRestore;
                // Skip over elements within the scope, in case the scope immediately follows the node to restore.
                do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
                while ($a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current))
                e.preventDefault();
                e.stopPropagation();
                if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
                else // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)
                // then move focus to the body.
                // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)
                if (!$a7a032acae3ddda9$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();
                else $a7a032acae3ddda9$var$focusElement(nodeToRestore, true);
            }
        };
        if (!contain) document.addEventListener('keydown', onKeyDown, true);
        return ()=>{
            if (!contain) document.removeEventListener('keydown', onKeyDown, true);
            if (restoreFocus && nodeToRestore && $a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current)) requestAnimationFrame(()=>{
                // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere
                if (document.body.contains(nodeToRestore) && document.activeElement === document.body) $a7a032acae3ddda9$var$focusElement(nodeToRestore);
            });
        };
    }, [
        scopeRef,
        restoreFocus,
        contain
    ]);
}
function $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, opts, scope) {
    let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR : $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR;
    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode (node) {
            var ref;
            // Skip nodes inside the starting node.
            if (opts === null || opts === void 0 ? void 0 : (ref = opts.from) === null || ref === void 0 ? void 0 : ref.contains(node)) return NodeFilter.FILTER_REJECT;
            if (node.matches(selector) && $d5156037ad898a4d$export$e989c0fffaa6b27a(node) && (!scope || $a7a032acae3ddda9$var$isElementInScope(node, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node))) return NodeFilter.FILTER_ACCEPT;
            return NodeFilter.FILTER_SKIP;
        }
    });
    if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;
    return walker;
}
function $a7a032acae3ddda9$export$c5251b9e124bf29(ref, defaultOptions = {
}) {
    return {
        focusNext (opts = {
        }) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = root;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            else {
                let next = $a7a032acae3ddda9$var$last(walker);
                if (next) $a7a032acae3ddda9$var$focusElement(next, true);
                return next;
            }
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = root;
                previousNode = $a7a032acae3ddda9$var$last(walker);
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let next = $a7a032acae3ddda9$var$last(walker);
            if (next) $a7a032acae3ddda9$var$focusElement(next, true);
            return next;
        }
    };
}
function $a7a032acae3ddda9$var$last(walker) {
    let next;
    let last;
    do {
        last = walker.lastChild();
        if (last) next = last;
    }while (last)
    return next;
}








function $581a96d6eb128c1b$export$4e328f61c538687f(props = {
}) {
    let { autoFocus: autoFocus = false , isTextInput: isTextInput , within: within  } = props;
    let state = $aB6Cp$react.useRef({
        isFocused: false,
        isFocusVisible: autoFocus || $aB6Cp$reactariainteractions.isFocusVisible()
    });
    let [isFocused1, setFocused] = $aB6Cp$react.useState(false);
    let [isFocusVisibleState, setFocusVisible] = $aB6Cp$react.useState(()=>state.current.isFocused && state.current.isFocusVisible
    );
    let updateState = $aB6Cp$react.useCallback(()=>setFocusVisible(state.current.isFocused && state.current.isFocusVisible)
    , []);
    let onFocusChange = $aB6Cp$react.useCallback((isFocused)=>{
        state.current.isFocused = isFocused;
        setFocused(isFocused);
        updateState();
    }, [
        updateState
    ]);
    $aB6Cp$reactariainteractions.useFocusVisibleListener((isFocusVisible)=>{
        state.current.isFocusVisible = isFocusVisible;
        updateState();
    }, [], {
        isTextInput: isTextInput
    });
    let { focusProps: focusProps  } = $aB6Cp$reactariainteractions.useFocus({
        isDisabled: within,
        onFocusChange: onFocusChange
    });
    let { focusWithinProps: focusWithinProps  } = $aB6Cp$reactariainteractions.useFocusWithin({
        isDisabled: !within,
        onFocusWithinChange: onFocusChange
    });
    return {
        isFocused: isFocused1,
        isFocusVisible: state.current.isFocused && isFocusVisibleState,
        focusProps: within ? focusWithinProps : focusProps
    };
}


function $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d(props) {
    let { children: children , focusClass: focusClass , focusRingClass: focusRingClass  } = props;
    let { isFocused: isFocused , isFocusVisible: isFocusVisible , focusProps: focusProps  } = $581a96d6eb128c1b$export$4e328f61c538687f(props);
    let child = ($parcel$interopDefault($aB6Cp$react)).Children.only(children);
    return(/*#__PURE__*/ ($parcel$interopDefault($aB6Cp$react)).cloneElement(child, $aB6Cp$reactariautils.mergeProps(child.props, {
        ...focusProps,
        className: ($parcel$interopDefault($aB6Cp$clsx))({
            [focusClass || '']: isFocused,
            [focusRingClass || '']: isFocusVisible
        })
    })));
}






let $fb504d83237fd6ac$var$FocusableContext = /*#__PURE__*/ ($parcel$interopDefault($aB6Cp$react)).createContext(null);
function $fb504d83237fd6ac$var$useFocusableContext(ref) {
    let context = $aB6Cp$react.useContext($fb504d83237fd6ac$var$FocusableContext) || {
    };
    $aB6Cp$reactariautils.useSyncRef(context, ref);
    // eslint-disable-next-line
    let { ref: _ , ...otherProps } = context;
    return otherProps;
}
/**
 * Provides DOM props to the nearest focusable child.
 */ function $fb504d83237fd6ac$var$FocusableProvider(props, ref) {
    let { children: children , ...otherProps } = props;
    let context = {
        ...otherProps,
        ref: ref
    };
    return(/*#__PURE__*/ ($parcel$interopDefault($aB6Cp$react)).createElement($fb504d83237fd6ac$var$FocusableContext.Provider, {
        value: context
    }, children));
}
let $fb504d83237fd6ac$export$13f3202a3e5ddd5 = /*#__PURE__*/ ($parcel$interopDefault($aB6Cp$react)).forwardRef($fb504d83237fd6ac$var$FocusableProvider);
function $fb504d83237fd6ac$export$4c014de7c8940b4c(props, domRef) {
    let { focusProps: focusProps  } = $aB6Cp$reactariainteractions.useFocus(props);
    let { keyboardProps: keyboardProps  } = $aB6Cp$reactariainteractions.useKeyboard(props);
    let interactions = $aB6Cp$reactariautils.mergeProps(focusProps, keyboardProps);
    let domProps = $fb504d83237fd6ac$var$useFocusableContext(domRef);
    let interactionProps = props.isDisabled ? {
    } : domProps;
    let autoFocusRef = $aB6Cp$react.useRef(props.autoFocus);
    $aB6Cp$react.useEffect(()=>{
        if (autoFocusRef.current && domRef.current) $1c7f9157d722357d$export$80f3e147d781571c(domRef.current);
        autoFocusRef.current = false;
    }, [
        domRef
    ]);
    return {
        focusableProps: $aB6Cp$reactariautils.mergeProps({
            ...interactions,
            tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined
        }, interactionProps)
    };
}






//# sourceMappingURL=main.js.map


/***/ }),

/***/ 61523:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $2oePb$reactstatelycollections = __webpack_require__(48690);
var $2oePb$reactstatelyvirtualizer = __webpack_require__(35958);
var $2oePb$reactariautils = __webpack_require__(58277);
var $2oePb$react = __webpack_require__(18038);
var $2oePb$reactariai18n = __webpack_require__(45851);
var $2oePb$reactariafocus = __webpack_require__(65731);
var $2oePb$reactariaselection = __webpack_require__(14422);
var $2oePb$reactarialiveannouncer = __webpack_require__(72356);
var $2oePb$reactariainteractions = __webpack_require__(11519);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "GridKeyboardDelegate", () => $3187c0e19200cb16$export$de9feff04fda126e);
$parcel$export(module.exports, "useGrid", () => $11d770dfabe45077$export$f6b86a04e5d66d90);
$parcel$export(module.exports, "useGridRowGroup", () => $c7def85a57100898$export$d3037f5d3f3e51bf);
$parcel$export(module.exports, "useGridRow", () => $eed398987c639831$export$96357d5a73f686fa);
$parcel$export(module.exports, "useGridCell", () => $cf2021be63b01ef4$export$c7e10bfc0c59f67c);
$parcel$export(module.exports, "useGridSelectionCheckbox", () => $d8385f73d3701365$export$70e2eed1a92976ad);
$parcel$export(module.exports, "useHighlightSelectionDescription", () => $340f2fcd0ef9ce8d$export$be42ebdab07ae4c2);
$parcel$export(module.exports, "useGridSelectionAnnouncement", () => $1eb174acfe8a0f16$export$137e594ef3218a10);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

class $3187c0e19200cb16$export$de9feff04fda126e {
    isCell(node) {
        return node.type === "cell";
    }
    isRow(node) {
        return node.type === "row" || node.type === "item";
    }
    findPreviousKey(fromKey, pred) {
        let key = fromKey != null ? this.collection.getKeyBefore(fromKey) : this.collection.getLastKey();
        while(key != null){
            let item = this.collection.getItem(key);
            if (!this.disabledKeys.has(key) && (!pred || pred(item))) return key;
            key = this.collection.getKeyBefore(key);
        }
    }
    findNextKey(fromKey, pred) {
        let key = fromKey != null ? this.collection.getKeyAfter(fromKey) : this.collection.getFirstKey();
        while(key != null){
            let item = this.collection.getItem(key);
            if (!this.disabledKeys.has(key) && (!pred || pred(item))) return key;
            key = this.collection.getKeyAfter(key);
        }
    }
    getKeyBelow(key) {
        let startItem = this.collection.getItem(key);
        if (!startItem) return;
        // If focus was on a cell, start searching from the parent row
        if (this.isCell(startItem)) key = startItem.parentKey;
        // Find the next item
        key = this.findNextKey(key);
        if (key != null) {
            // If focus was on a cell, focus the cell with the same index in the next row.
            if (this.isCell(startItem)) {
                let item = this.collection.getItem(key);
                return (0, $2oePb$reactstatelycollections.getNthItem)((0, $2oePb$reactstatelycollections.getChildNodes)(item, this.collection), startItem.index).key;
            }
            // Otherwise, focus the next row
            if (this.focusMode === "row") return key;
        }
    }
    getKeyAbove(key) {
        let startItem = this.collection.getItem(key);
        if (!startItem) return;
        // If focus is on a cell, start searching from the parent row
        if (this.isCell(startItem)) key = startItem.parentKey;
        // Find the previous item
        key = this.findPreviousKey(key);
        if (key != null) {
            // If focus was on a cell, focus the cell with the same index in the previous row.
            if (this.isCell(startItem)) {
                let item = this.collection.getItem(key);
                return (0, $2oePb$reactstatelycollections.getNthItem)((0, $2oePb$reactstatelycollections.getChildNodes)(item, this.collection), startItem.index).key;
            }
            // Otherwise, focus the previous row
            if (this.focusMode === "row") return key;
        }
    }
    getKeyRightOf(key) {
        let item = this.collection.getItem(key);
        if (!item) return;
        // If focus is on a row, focus the first child cell.
        if (this.isRow(item)) {
            let children = (0, $2oePb$reactstatelycollections.getChildNodes)(item, this.collection);
            return this.direction === "rtl" ? (0, $2oePb$reactstatelycollections.getLastItem)(children).key : (0, $2oePb$reactstatelycollections.getFirstItem)(children).key;
        }
        // If focus is on a cell, focus the next cell if any,
        // otherwise focus the parent row.
        if (this.isCell(item)) {
            let parent = this.collection.getItem(item.parentKey);
            let children = (0, $2oePb$reactstatelycollections.getChildNodes)(parent, this.collection);
            let next = this.direction === "rtl" ? (0, $2oePb$reactstatelycollections.getNthItem)(children, item.index - 1) : (0, $2oePb$reactstatelycollections.getNthItem)(children, item.index + 1);
            if (next) return next.key;
            // focus row only if focusMode is set to row
            if (this.focusMode === "row") return item.parentKey;
            return this.direction === "rtl" ? this.getFirstKey(key) : this.getLastKey(key);
        }
    }
    getKeyLeftOf(key) {
        let item = this.collection.getItem(key);
        if (!item) return;
        // If focus is on a row, focus the last child cell.
        if (this.isRow(item)) {
            let children = (0, $2oePb$reactstatelycollections.getChildNodes)(item, this.collection);
            return this.direction === "rtl" ? (0, $2oePb$reactstatelycollections.getFirstItem)(children).key : (0, $2oePb$reactstatelycollections.getLastItem)(children).key;
        }
        // If focus is on a cell, focus the previous cell if any,
        // otherwise focus the parent row.
        if (this.isCell(item)) {
            let parent = this.collection.getItem(item.parentKey);
            let children = (0, $2oePb$reactstatelycollections.getChildNodes)(parent, this.collection);
            let prev = this.direction === "rtl" ? (0, $2oePb$reactstatelycollections.getNthItem)(children, item.index + 1) : (0, $2oePb$reactstatelycollections.getNthItem)(children, item.index - 1);
            if (prev) return prev.key;
            // focus row only if focusMode is set to row
            if (this.focusMode === "row") return item.parentKey;
            return this.direction === "rtl" ? this.getLastKey(key) : this.getFirstKey(key);
        }
    }
    getFirstKey(key, global) {
        let item;
        if (key != null) {
            item = this.collection.getItem(key);
            if (!item) return;
            // If global flag is not set, and a cell is currently focused,
            // move focus to the first cell in the parent row.
            if (this.isCell(item) && !global) {
                let parent = this.collection.getItem(item.parentKey);
                return (0, $2oePb$reactstatelycollections.getFirstItem)((0, $2oePb$reactstatelycollections.getChildNodes)(parent, this.collection)).key;
            }
        }
        // Find the first row
        key = this.findNextKey();
        // If global flag is set (or if focus mode is cell), focus the first cell in the first row.
        if (key != null && item && this.isCell(item) && global || this.focusMode === "cell") {
            let item = this.collection.getItem(key);
            key = (0, $2oePb$reactstatelycollections.getFirstItem)((0, $2oePb$reactstatelycollections.getChildNodes)(item, this.collection)).key;
        }
        // Otherwise, focus the row itself.
        return key;
    }
    getLastKey(key, global) {
        let item;
        if (key != null) {
            item = this.collection.getItem(key);
            if (!item) return;
            // If global flag is not set, and a cell is currently focused,
            // move focus to the last cell in the parent row.
            if (this.isCell(item) && !global) {
                let parent = this.collection.getItem(item.parentKey);
                let children = (0, $2oePb$reactstatelycollections.getChildNodes)(parent, this.collection);
                return (0, $2oePb$reactstatelycollections.getLastItem)(children).key;
            }
        }
        // Find the last row
        key = this.findPreviousKey();
        // If global flag is set (or if focus mode is cell), focus the last cell in the last row.
        if (key != null && item && this.isCell(item) && global || this.focusMode === "cell") {
            let item = this.collection.getItem(key);
            let children = (0, $2oePb$reactstatelycollections.getChildNodes)(item, this.collection);
            key = (0, $2oePb$reactstatelycollections.getLastItem)(children).key;
        }
        // Otherwise, focus the row itself.
        return key;
    }
    getItem(key) {
        return this.ref.current.querySelector(`[data-key="${key}"]`);
    }
    getItemRect(key) {
        var _this_layout_getLayoutInfo;
        if (this.layout) return (_this_layout_getLayoutInfo = this.layout.getLayoutInfo(key)) === null || _this_layout_getLayoutInfo === void 0 ? void 0 : _this_layout_getLayoutInfo.rect;
        let item = this.getItem(key);
        if (item) return new (0, $2oePb$reactstatelyvirtualizer.Rect)(item.offsetLeft, item.offsetTop, item.offsetWidth, item.offsetHeight);
    }
    getPageHeight() {
        var _this_layout_virtualizer, _this_ref, _this_ref_current;
        if (this.layout) return (_this_layout_virtualizer = this.layout.virtualizer) === null || _this_layout_virtualizer === void 0 ? void 0 : _this_layout_virtualizer.visibleRect.height;
        return (_this_ref = this.ref) === null || _this_ref === void 0 ? void 0 : (_this_ref_current = _this_ref.current) === null || _this_ref_current === void 0 ? void 0 : _this_ref_current.offsetHeight;
    }
    getContentHeight() {
        var _this_ref, _this_ref_current;
        if (this.layout) return this.layout.getContentSize().height;
        return (_this_ref = this.ref) === null || _this_ref === void 0 ? void 0 : (_this_ref_current = _this_ref.current) === null || _this_ref_current === void 0 ? void 0 : _this_ref_current.scrollHeight;
    }
    getKeyPageAbove(key) {
        let itemRect = this.getItemRect(key);
        if (!itemRect) return null;
        let pageY = Math.max(0, itemRect.maxY - this.getPageHeight());
        while(itemRect && itemRect.y > pageY){
            key = this.getKeyAbove(key);
            itemRect = this.getItemRect(key);
        }
        return key;
    }
    getKeyPageBelow(key) {
        let itemRect = this.getItemRect(key);
        if (!itemRect) return null;
        let pageHeight = this.getPageHeight();
        let pageY = Math.min(this.getContentHeight(), itemRect.y + pageHeight);
        while(itemRect && itemRect.maxY < pageY){
            let nextKey = this.getKeyBelow(key);
            itemRect = this.getItemRect(nextKey);
            // Guard against case where maxY of the last key is barely less than pageY due to rounding
            // and thus it attempts to set key to null
            if (nextKey != null) key = nextKey;
        }
        return key;
    }
    getKeyForSearch(search, fromKey) {
        if (!this.collator) return null;
        let collection = this.collection;
        let key = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();
        // If the starting key is a cell, search from its parent row.
        let startItem = collection.getItem(key);
        if (startItem.type === "cell") key = startItem.parentKey;
        let hasWrapped = false;
        while(key != null){
            let item = collection.getItem(key);
            // check row text value for match
            if (item.textValue) {
                let substring = item.textValue.slice(0, search.length);
                if (this.collator.compare(substring, search) === 0) {
                    if (this.isRow(item) && this.focusMode === "cell") return (0, $2oePb$reactstatelycollections.getFirstItem)((0, $2oePb$reactstatelycollections.getChildNodes)(item, this.collection)).key;
                    return item.key;
                }
            }
            key = this.findNextKey(key);
            // Wrap around when reaching the end of the collection
            if (key == null && !hasWrapped) {
                key = this.getFirstKey();
                hasWrapped = true;
            }
        }
        return null;
    }
    constructor(options){
        this.collection = options.collection;
        this.disabledKeys = options.disabledKeys;
        this.ref = options.ref;
        this.direction = options.direction;
        this.collator = options.collator;
        this.layout = options.layout;
        this.focusMode = options.focusMode || "row";
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ const $8ee34951196858d0$export$e6235c0d09b995d0 = new WeakMap();




/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
var $085250522aa37816$exports = {};
var $6f42661ae0214332$exports = {};
$6f42661ae0214332$exports = {
    "deselectedItem": (args)=>`${args.item} غير المحدد`,
    "longPressToSelect": `اضغط مطولًا للدخول إلى وضع التحديد.`,
    "select": `تحديد`,
    "selectedAll": `جميع العناصر المحددة.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `لم يتم تحديد عناصر`,
            one: ()=>`${formatter.number(args.count)} عنصر محدد`,
            other: ()=>`${formatter.number(args.count)} عنصر محدد`
        })}.`,
    "selectedItem": (args)=>`${args.item} المحدد`
};


var $3e5d289b19f0fad9$exports = {};
$3e5d289b19f0fad9$exports = {
    "deselectedItem": (args)=>`${args.item} не е избран.`,
    "longPressToSelect": `Натиснете и задръжте за да влезете в избирателен режим.`,
    "select": `Изберете`,
    "selectedAll": `Всички елементи са избрани.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Няма избрани елементи`,
            one: ()=>`${formatter.number(args.count)} избран елемент`,
            other: ()=>`${formatter.number(args.count)} избрани елементи`
        })}.`,
    "selectedItem": (args)=>`${args.item} избран.`
};


var $786c35956e916979$exports = {};
$786c35956e916979$exports = {
    "deselectedItem": (args)=>`Položka ${args.item} není vybrána.`,
    "longPressToSelect": `Dlouhým stisknutím přejdete do režimu výběru.`,
    "select": `Vybrat`,
    "selectedAll": `Vybrány všechny položky.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Nevybrány žádné položky`,
            one: ()=>`Vybrána ${formatter.number(args.count)} položka`,
            other: ()=>`Vybráno ${formatter.number(args.count)} položek`
        })}.`,
    "selectedItem": (args)=>`Vybrána položka ${args.item}.`
};


var $7166f564b8fa3e8a$exports = {};
$7166f564b8fa3e8a$exports = {
    "deselectedItem": (args)=>`${args.item} ikke valgt.`,
    "longPressToSelect": `Lav et langt tryk for at aktivere valgtilstand.`,
    "select": `Vælg`,
    "selectedAll": `Alle elementer valgt.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Ingen elementer valgt`,
            one: ()=>`${formatter.number(args.count)} element valgt`,
            other: ()=>`${formatter.number(args.count)} elementer valgt`
        })}.`,
    "selectedItem": (args)=>`${args.item} valgt.`
};


var $12fc5e32bb482de0$exports = {};
$12fc5e32bb482de0$exports = {
    "deselectedItem": (args)=>`${args.item} nicht ausgewählt.`,
    "longPressToSelect": `Gedrückt halten, um Auswahlmodus zu öffnen.`,
    "select": `Auswählen`,
    "selectedAll": `Alle Elemente ausgewählt.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Keine Elemente ausgewählt`,
            one: ()=>`${formatter.number(args.count)} Element ausgewählt`,
            other: ()=>`${formatter.number(args.count)} Elemente ausgewählt`
        })}.`,
    "selectedItem": (args)=>`${args.item} ausgewählt.`
};


var $84b67ad15c785b2c$exports = {};
$84b67ad15c785b2c$exports = {
    "deselectedItem": (args)=>`Δεν επιλέχθηκε το στοιχείο ${args.item}.`,
    "longPressToSelect": `Πατήστε παρατεταμένα για να μπείτε σε λειτουργία επιλογής.`,
    "select": `Επιλογή`,
    "selectedAll": `Επιλέχθηκαν όλα τα στοιχεία.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Δεν επιλέχθηκαν στοιχεία`,
            one: ()=>`Επιλέχθηκε ${formatter.number(args.count)} στοιχείο`,
            other: ()=>`Επιλέχθηκαν ${formatter.number(args.count)} στοιχεία`
        })}.`,
    "selectedItem": (args)=>`Επιλέχθηκε το στοιχείο ${args.item}.`
};


var $86f7e6ba2423a35d$exports = {};
$86f7e6ba2423a35d$exports = {
    "deselectedItem": (args)=>`${args.item} not selected.`,
    "select": `Select`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `No items selected`,
            one: ()=>`${formatter.number(args.count)} item selected`,
            other: ()=>`${formatter.number(args.count)} items selected`
        })}.`,
    "selectedAll": `All items selected.`,
    "selectedItem": (args)=>`${args.item} selected.`,
    "longPressToSelect": `Long press to enter selection mode.`
};


var $67f524d2f2545d56$exports = {};
$67f524d2f2545d56$exports = {
    "deselectedItem": (args)=>`${args.item} no seleccionado.`,
    "longPressToSelect": `Mantenga pulsado para abrir el modo de selección.`,
    "select": `Seleccionar`,
    "selectedAll": `Todos los elementos seleccionados.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Ningún elemento seleccionado`,
            one: ()=>`${formatter.number(args.count)} elemento seleccionado`,
            other: ()=>`${formatter.number(args.count)} elementos seleccionados`
        })}.`,
    "selectedItem": (args)=>`${args.item} seleccionado.`
};


var $d8df13f1dbf6e0c4$exports = {};
$d8df13f1dbf6e0c4$exports = {
    "deselectedItem": (args)=>`${args.item} pole valitud.`,
    "longPressToSelect": `Valikurežiimi sisenemiseks vajutage pikalt.`,
    "select": `Vali`,
    "selectedAll": `Kõik üksused valitud.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Üksusi pole valitud`,
            one: ()=>`${formatter.number(args.count)} üksus valitud`,
            other: ()=>`${formatter.number(args.count)} üksust valitud`
        })}.`,
    "selectedItem": (args)=>`${args.item} valitud.`
};


var $e2b4dfe2d4d55739$exports = {};
$e2b4dfe2d4d55739$exports = {
    "deselectedItem": (args)=>`Kohdetta ${args.item} ei valittu.`,
    "longPressToSelect": `Siirry valintatilaan painamalla pitkään.`,
    "select": `Valitse`,
    "selectedAll": `Kaikki kohteet valittu.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Ei yhtään kohdetta valittu`,
            one: ()=>`${formatter.number(args.count)} kohde valittu`,
            other: ()=>`${formatter.number(args.count)} kohdetta valittu`
        })}.`,
    "selectedItem": (args)=>`${args.item} valittu.`
};


var $c06d6698d30993e7$exports = {};
$c06d6698d30993e7$exports = {
    "deselectedItem": (args)=>`${args.item} non sélectionné.`,
    "longPressToSelect": `Appuyez de manière prolongée pour passer en mode de sélection.`,
    "select": `Sélectionner`,
    "selectedAll": `Tous les éléments sélectionnés.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Aucun élément sélectionné`,
            one: ()=>`${formatter.number(args.count)} élément sélectionné`,
            other: ()=>`${formatter.number(args.count)} éléments sélectionnés`
        })}.`,
    "selectedItem": (args)=>`${args.item} sélectionné.`
};


var $e775713aa5566057$exports = {};
$e775713aa5566057$exports = {
    "deselectedItem": (args)=>`${args.item} לא נבחר.`,
    "longPressToSelect": `הקשה ארוכה לכניסה למצב בחירה.`,
    "select": `בחר`,
    "selectedAll": `כל הפריטים נבחרו.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `לא נבחרו פריטים`,
            one: ()=>`פריט ${formatter.number(args.count)} נבחר`,
            other: ()=>`${formatter.number(args.count)} פריטים נבחרו`
        })}.`,
    "selectedItem": (args)=>`${args.item} נבחר.`
};


var $a972cfeb69a51f5b$exports = {};
$a972cfeb69a51f5b$exports = {
    "deselectedItem": (args)=>`Stavka ${args.item} nije odabrana.`,
    "longPressToSelect": `Dugo pritisnite za ulazak u način odabira.`,
    "select": `Odaberite`,
    "selectedAll": `Odabrane su sve stavke.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Nije odabrana nijedna stavka`,
            one: ()=>`Odabrana je ${formatter.number(args.count)} stavka`,
            other: ()=>`Odabrano je ${formatter.number(args.count)} stavki`
        })}.`,
    "selectedItem": (args)=>`Stavka ${args.item} je odabrana.`
};


var $a471da6bb87e6cd1$exports = {};
$a471da6bb87e6cd1$exports = {
    "deselectedItem": (args)=>`${args.item} nincs kijelölve.`,
    "longPressToSelect": `Nyomja hosszan a kijelöléshez.`,
    "select": `Kijelölés`,
    "selectedAll": `Az összes elem kijelölve.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Egy elem sincs kijelölve`,
            one: ()=>`${formatter.number(args.count)} elem kijelölve`,
            other: ()=>`${formatter.number(args.count)} elem kijelölve`
        })}.`,
    "selectedItem": (args)=>`${args.item} kijelölve.`
};


var $47879155027d6c95$exports = {};
$47879155027d6c95$exports = {
    "deselectedItem": (args)=>`${args.item} non selezionato.`,
    "longPressToSelect": `Premi a lungo per passare alla modalità di selezione.`,
    "select": `Seleziona`,
    "selectedAll": `Tutti gli elementi selezionati.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Nessun elemento selezionato`,
            one: ()=>`${formatter.number(args.count)} elemento selezionato`,
            other: ()=>`${formatter.number(args.count)} elementi selezionati`
        })}.`,
    "selectedItem": (args)=>`${args.item} selezionato.`
};


var $9cd8dc003c2209e6$exports = {};
$9cd8dc003c2209e6$exports = {
    "deselectedItem": (args)=>`${args.item} が選択されていません。`,
    "longPressToSelect": `長押しして選択モードを開きます。`,
    "select": `選択`,
    "selectedAll": `すべての項目を選択しました。`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `項目が選択されていません`,
            one: ()=>`${formatter.number(args.count)} 項目を選択しました`,
            other: ()=>`${formatter.number(args.count)} 項目を選択しました`
        })}。`,
    "selectedItem": (args)=>`${args.item} を選択しました。`
};


var $a490b9448c5f2ded$exports = {};
$a490b9448c5f2ded$exports = {
    "deselectedItem": (args)=>`${args.item}이(가) 선택되지 않았습니다.`,
    "longPressToSelect": `선택 모드로 들어가려면 길게 누르십시오.`,
    "select": `선택`,
    "selectedAll": `모든 항목이 선택되었습니다.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `선택된 항목이 없습니다`,
            one: ()=>`${formatter.number(args.count)}개 항목이 선택되었습니다`,
            other: ()=>`${formatter.number(args.count)}개 항목이 선택되었습니다`
        })}.`,
    "selectedItem": (args)=>`${args.item}이(가) 선택되었습니다.`
};


var $99f69e0597841328$exports = {};
$99f69e0597841328$exports = {
    "deselectedItem": (args)=>`${args.item} nepasirinkta.`,
    "longPressToSelect": `Norėdami įjungti pasirinkimo režimą, paspauskite ir palaikykite.`,
    "select": `Pasirinkti`,
    "selectedAll": `Pasirinkti visi elementai.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Nepasirinktas nė vienas elementas`,
            one: ()=>`Pasirinktas ${formatter.number(args.count)} elementas`,
            other: ()=>`Pasirinkta elementų: ${formatter.number(args.count)}`
        })}.`,
    "selectedItem": (args)=>`Pasirinkta: ${args.item}.`
};


var $28ac5b31e47d46d4$exports = {};
$28ac5b31e47d46d4$exports = {
    "deselectedItem": (args)=>`Vienums ${args.item} nav atlasīts.`,
    "longPressToSelect": `Ilgi turiet nospiestu. lai ieslēgtu atlases režīmu.`,
    "select": `Atlasīt`,
    "selectedAll": `Atlasīti visi vienumi.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Nav atlasīts neviens vienums`,
            one: ()=>`Atlasīto vienumu skaits: ${formatter.number(args.count)}`,
            other: ()=>`Atlasīto vienumu skaits: ${formatter.number(args.count)}`
        })}.`,
    "selectedItem": (args)=>`Atlasīts vienums ${args.item}.`
};


var $d0ae97c9412add8b$exports = {};
$d0ae97c9412add8b$exports = {
    "deselectedItem": (args)=>`${args.item} er ikke valgt.`,
    "longPressToSelect": `Bruk et langt trykk for å gå inn i valgmodus.`,
    "select": `Velg`,
    "selectedAll": `Alle elementer er valgt.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Ingen elementer er valgt`,
            one: ()=>`${formatter.number(args.count)} element er valgt`,
            other: ()=>`${formatter.number(args.count)} elementer er valgt`
        })}.`,
    "selectedItem": (args)=>`${args.item} er valgt.`
};


var $7e5335510891b8c3$exports = {};
$7e5335510891b8c3$exports = {
    "deselectedItem": (args)=>`${args.item} niet geselecteerd.`,
    "longPressToSelect": `Druk lang om de selectiemodus te openen.`,
    "select": `Selecteren`,
    "selectedAll": `Alle items geselecteerd.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Geen items geselecteerd`,
            one: ()=>`${formatter.number(args.count)} item geselecteerd`,
            other: ()=>`${formatter.number(args.count)} items geselecteerd`
        })}.`,
    "selectedItem": (args)=>`${args.item} geselecteerd.`
};


var $455cb5ebd5f6c27d$exports = {};
$455cb5ebd5f6c27d$exports = {
    "deselectedItem": (args)=>`Nie zaznaczono ${args.item}.`,
    "longPressToSelect": `Naciśnij i przytrzymaj, aby wejść do trybu wyboru.`,
    "select": `Zaznacz`,
    "selectedAll": `Wszystkie zaznaczone elementy.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Nie zaznaczono żadnych elementów`,
            one: ()=>`${formatter.number(args.count)} zaznaczony element`,
            other: ()=>`${formatter.number(args.count)} zaznaczonych elementów`
        })}.`,
    "selectedItem": (args)=>`Zaznaczono ${args.item}.`
};


var $55020c522ee676a2$exports = {};
$55020c522ee676a2$exports = {
    "deselectedItem": (args)=>`${args.item} não selecionado.`,
    "longPressToSelect": `Mantenha pressionado para entrar no modo de seleção.`,
    "select": `Selecionar`,
    "selectedAll": `Todos os itens selecionados.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Nenhum item selecionado`,
            one: ()=>`${formatter.number(args.count)} item selecionado`,
            other: ()=>`${formatter.number(args.count)} itens selecionados`
        })}.`,
    "selectedItem": (args)=>`${args.item} selecionado.`
};


var $cc691e0f35e41c7f$exports = {};
$cc691e0f35e41c7f$exports = {
    "deselectedItem": (args)=>`${args.item} não selecionado.`,
    "longPressToSelect": `Prima continuamente para entrar no modo de seleção.`,
    "select": `Selecionar`,
    "selectedAll": `Todos os itens selecionados.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Nenhum item selecionado`,
            one: ()=>`${formatter.number(args.count)} item selecionado`,
            other: ()=>`${formatter.number(args.count)} itens selecionados`
        })}.`,
    "selectedItem": (args)=>`${args.item} selecionado.`
};


var $712b70af9d7e11e9$exports = {};
$712b70af9d7e11e9$exports = {
    "deselectedItem": (args)=>`${args.item} neselectat.`,
    "longPressToSelect": `Apăsați lung pentru a intra în modul de selectare.`,
    "select": `Selectare`,
    "selectedAll": `Toate elementele selectate.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Niciun element selectat`,
            one: ()=>`${formatter.number(args.count)} element selectat`,
            other: ()=>`${formatter.number(args.count)} elemente selectate`
        })}.`,
    "selectedItem": (args)=>`${args.item} selectat.`
};


var $c483d9d6d4bcff75$exports = {};
$c483d9d6d4bcff75$exports = {
    "deselectedItem": (args)=>`${args.item} не выбрано.`,
    "longPressToSelect": `Нажмите и удерживайте для входа в режим выбора.`,
    "select": `Выбрать`,
    "selectedAll": `Выбраны все элементы.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Нет выбранных элементов`,
            one: ()=>`${formatter.number(args.count)} элемент выбран`,
            other: ()=>`${formatter.number(args.count)} элементов выбрано`
        })}.`,
    "selectedItem": (args)=>`${args.item} выбрано.`
};


var $35bc9f18e7cf9157$exports = {};
$35bc9f18e7cf9157$exports = {
    "deselectedItem": (args)=>`Nevybraté položky: ${args.item}.`,
    "longPressToSelect": `Dlhším stlačením prejdite do režimu výberu.`,
    "select": `Vybrať`,
    "selectedAll": `Všetky vybraté položky.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Žiadne vybraté položky`,
            one: ()=>`${formatter.number(args.count)} vybratá položka`,
            other: ()=>`Počet vybratých položiek:${formatter.number(args.count)}`
        })}.`,
    "selectedItem": (args)=>`Vybraté položky: ${args.item}.`
};


var $e933d1373d8e91e0$exports = {};
$e933d1373d8e91e0$exports = {
    "deselectedItem": (args)=>`Element ${args.item} ni izbran.`,
    "longPressToSelect": `Za izbirni način pritisnite in dlje časa držite.`,
    "select": `Izberite`,
    "selectedAll": `Vsi elementi so izbrani.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Noben element ni izbran`,
            one: ()=>`${formatter.number(args.count)} element je izbran`,
            other: ()=>`${formatter.number(args.count)} elementov je izbranih`
        })}.`,
    "selectedItem": (args)=>`Element ${args.item} je izbran.`
};


var $77463d6521c72512$exports = {};
$77463d6521c72512$exports = {
    "deselectedItem": (args)=>`${args.item} nije izabrano.`,
    "longPressToSelect": `Dugo pritisnite za ulazak u režim biranja.`,
    "select": `Izaberite`,
    "selectedAll": `Izabrane su sve stavke.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Nije izabrana nijedna stavka`,
            one: ()=>`Izabrana je ${formatter.number(args.count)} stavka`,
            other: ()=>`Izabrano je ${formatter.number(args.count)} stavki`
        })}.`,
    "selectedItem": (args)=>`${args.item} je izabrano.`
};


var $6380ab044222ca52$exports = {};
$6380ab044222ca52$exports = {
    "deselectedItem": (args)=>`${args.item} ej markerat.`,
    "longPressToSelect": `Tryck länge när du vill öppna väljarläge.`,
    "select": `Markera`,
    "selectedAll": `Alla markerade objekt.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Inga markerade objekt`,
            one: ()=>`${formatter.number(args.count)} markerat objekt`,
            other: ()=>`${formatter.number(args.count)} markerade objekt`
        })}.`,
    "selectedItem": (args)=>`${args.item} markerat.`
};


var $9cb854f23a6ff322$exports = {};
$9cb854f23a6ff322$exports = {
    "deselectedItem": (args)=>`${args.item} seçilmedi.`,
    "longPressToSelect": `Seçim moduna girmek için uzun basın.`,
    "select": `Seç`,
    "selectedAll": `Tüm ögeler seçildi.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Hiçbir öge seçilmedi`,
            one: ()=>`${formatter.number(args.count)} öge seçildi`,
            other: ()=>`${formatter.number(args.count)} öge seçildi`
        })}.`,
    "selectedItem": (args)=>`${args.item} seçildi.`
};


var $912862d79e063c74$exports = {};
$912862d79e063c74$exports = {
    "deselectedItem": (args)=>`${args.item} не вибрано.`,
    "longPressToSelect": `Виконайте довге натиснення, щоб перейти в режим вибору.`,
    "select": `Вибрати`,
    "selectedAll": `Усі елементи вибрано.`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `Жодних елементів не вибрано`,
            one: ()=>`${formatter.number(args.count)} елемент вибрано`,
            other: ()=>`Вибрано елементів: ${formatter.number(args.count)}`
        })}.`,
    "selectedItem": (args)=>`${args.item} вибрано.`
};


var $91bb887772fd7ad4$exports = {};
$91bb887772fd7ad4$exports = {
    "deselectedItem": (args)=>`未选择 ${args.item}。`,
    "longPressToSelect": `长按以进入选择模式。`,
    "select": `选择`,
    "selectedAll": `已选择所有项目。`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `未选择项目`,
            one: ()=>`已选择 ${formatter.number(args.count)} 个项目`,
            other: ()=>`已选择 ${formatter.number(args.count)} 个项目`
        })}。`,
    "selectedItem": (args)=>`已选择 ${args.item}。`
};


var $a33ce76c4b030d83$exports = {};
$a33ce76c4b030d83$exports = {
    "deselectedItem": (args)=>`未選取「${args.item}」。`,
    "longPressToSelect": `長按以進入選擇模式。`,
    "select": `選取`,
    "selectedAll": `已選取所有項目。`,
    "selectedCount": (args, formatter)=>`${formatter.plural(args.count, {
            "=0": `未選取任何項目`,
            one: ()=>`已選取 ${formatter.number(args.count)} 個項目`,
            other: ()=>`已選取 ${formatter.number(args.count)} 個項目`
        })}。`,
    "selectedItem": (args)=>`已選取「${args.item}」。`
};


$085250522aa37816$exports = {
    "ar-AE": $6f42661ae0214332$exports,
    "bg-BG": $3e5d289b19f0fad9$exports,
    "cs-CZ": $786c35956e916979$exports,
    "da-DK": $7166f564b8fa3e8a$exports,
    "de-DE": $12fc5e32bb482de0$exports,
    "el-GR": $84b67ad15c785b2c$exports,
    "en-US": $86f7e6ba2423a35d$exports,
    "es-ES": $67f524d2f2545d56$exports,
    "et-EE": $d8df13f1dbf6e0c4$exports,
    "fi-FI": $e2b4dfe2d4d55739$exports,
    "fr-FR": $c06d6698d30993e7$exports,
    "he-IL": $e775713aa5566057$exports,
    "hr-HR": $a972cfeb69a51f5b$exports,
    "hu-HU": $a471da6bb87e6cd1$exports,
    "it-IT": $47879155027d6c95$exports,
    "ja-JP": $9cd8dc003c2209e6$exports,
    "ko-KR": $a490b9448c5f2ded$exports,
    "lt-LT": $99f69e0597841328$exports,
    "lv-LV": $28ac5b31e47d46d4$exports,
    "nb-NO": $d0ae97c9412add8b$exports,
    "nl-NL": $7e5335510891b8c3$exports,
    "pl-PL": $455cb5ebd5f6c27d$exports,
    "pt-BR": $55020c522ee676a2$exports,
    "pt-PT": $cc691e0f35e41c7f$exports,
    "ro-RO": $712b70af9d7e11e9$exports,
    "ru-RU": $c483d9d6d4bcff75$exports,
    "sk-SK": $35bc9f18e7cf9157$exports,
    "sl-SI": $e933d1373d8e91e0$exports,
    "sr-SP": $77463d6521c72512$exports,
    "sv-SE": $6380ab044222ca52$exports,
    "tr-TR": $9cb854f23a6ff322$exports,
    "uk-UA": $912862d79e063c74$exports,
    "zh-CN": $91bb887772fd7ad4$exports,
    "zh-TW": $a33ce76c4b030d83$exports
};





function $1eb174acfe8a0f16$export$137e594ef3218a10(props, state) {
    var _state_collection_getTextValue;
    let { getRowText: getRowText = (key)=>{
        var _state_collection, _state_collection_getTextValue1, _state_collection_getItem;
        return (_state_collection_getTextValue = (_state_collection_getTextValue1 = (_state_collection = state.collection).getTextValue) === null || _state_collection_getTextValue1 === void 0 ? void 0 : _state_collection_getTextValue1.call(_state_collection, key)) !== null && _state_collection_getTextValue !== void 0 ? _state_collection_getTextValue : (_state_collection_getItem = state.collection.getItem(key)) === null || _state_collection_getItem === void 0 ? void 0 : _state_collection_getItem.textValue;
    }  } = props;
    let stringFormatter = (0, $2oePb$reactariai18n.useLocalizedStringFormatter)((0, (/*@__PURE__*/$parcel$interopDefault($085250522aa37816$exports))));
    // Many screen readers do not announce when items in a grid are selected/deselected.
    // We do this using an ARIA live region.
    let selection = state.selectionManager.rawSelection;
    let lastSelection = (0, $2oePb$react.useRef)(selection);
    (0, $2oePb$reactariautils.useUpdateEffect)(()=>{
        var _lastSelection_current;
        if (!state.selectionManager.isFocused) {
            lastSelection.current = selection;
            return;
        }
        let addedKeys = $1eb174acfe8a0f16$var$diffSelection(selection, lastSelection.current);
        let removedKeys = $1eb174acfe8a0f16$var$diffSelection(lastSelection.current, selection);
        // If adding or removing a single row from the selection, announce the name of that item.
        let isReplace = state.selectionManager.selectionBehavior === "replace";
        let messages = [];
        if (state.selectionManager.selectedKeys.size === 1 && isReplace) {
            if (state.collection.getItem(state.selectionManager.selectedKeys.keys().next().value)) {
                let currentSelectionText = getRowText(state.selectionManager.selectedKeys.keys().next().value);
                if (currentSelectionText) messages.push(stringFormatter.format("selectedItem", {
                    item: currentSelectionText
                }));
            }
        } else if (addedKeys.size === 1 && removedKeys.size === 0) {
            let addedText = getRowText(addedKeys.keys().next().value);
            if (addedText) messages.push(stringFormatter.format("selectedItem", {
                item: addedText
            }));
        } else if (removedKeys.size === 1 && addedKeys.size === 0) {
            if (state.collection.getItem(removedKeys.keys().next().value)) {
                let removedText = getRowText(removedKeys.keys().next().value);
                if (removedText) messages.push(stringFormatter.format("deselectedItem", {
                    item: removedText
                }));
            }
        }
        // Announce how many items are selected, except when selecting the first item.
        if (state.selectionManager.selectionMode === "multiple") {
            if (messages.length === 0 || selection === "all" || selection.size > 1 || lastSelection.current === "all" || ((_lastSelection_current = lastSelection.current) === null || _lastSelection_current === void 0 ? void 0 : _lastSelection_current.size) > 1) messages.push(selection === "all" ? stringFormatter.format("selectedAll") : stringFormatter.format("selectedCount", {
                count: selection.size
            }));
        }
        if (messages.length > 0) (0, $2oePb$reactarialiveannouncer.announce)(messages.join(" "));
        lastSelection.current = selection;
    }, [
        selection
    ]);
}
function $1eb174acfe8a0f16$var$diffSelection(a, b) {
    let res = new Set();
    if (a === "all" || b === "all") return res;
    for (let key of a.keys())if (!b.has(key)) res.add(key);
    return res;
}



/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 




function $340f2fcd0ef9ce8d$export$be42ebdab07ae4c2(props) {
    let stringFormatter = (0, $2oePb$reactariai18n.useLocalizedStringFormatter)((0, (/*@__PURE__*/$parcel$interopDefault($085250522aa37816$exports))));
    let modality = (0, $2oePb$reactariainteractions.useInteractionModality)();
    // null is the default if the user hasn't interacted with the table at all yet or the rest of the page
    let shouldLongPress = (modality === "pointer" || modality === "virtual" || modality == null) && typeof window !== "undefined" && "ontouchstart" in window;
    let interactionDescription = (0, $2oePb$react.useMemo)(()=>{
        let selectionMode = props.selectionManager.selectionMode;
        let selectionBehavior = props.selectionManager.selectionBehavior;
        let message = undefined;
        if (shouldLongPress) message = stringFormatter.format("longPressToSelect");
        return selectionBehavior === "replace" && selectionMode !== "none" && props.hasItemActions ? message : undefined;
    }, [
        props.selectionManager.selectionMode,
        props.selectionManager.selectionBehavior,
        props.hasItemActions,
        stringFormatter,
        shouldLongPress
    ]);
    let descriptionProps = (0, $2oePb$reactariautils.useDescription)(interactionDescription);
    return descriptionProps;
}



function $11d770dfabe45077$export$f6b86a04e5d66d90(props, state, ref) {
    let { isVirtualized: isVirtualized , keyboardDelegate: keyboardDelegate , focusMode: focusMode , scrollRef: scrollRef , getRowText: getRowText , onRowAction: onRowAction , onCellAction: onCellAction  } = props;
    let { selectionManager: manager  } = state;
    if (!props["aria-label"] && !props["aria-labelledby"]) console.warn("An aria-label or aria-labelledby prop is required for accessibility.");
    // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
    // When virtualized, the layout object will be passed in as a prop and override this.
    let collator = (0, $2oePb$reactariai18n.useCollator)({
        usage: "search",
        sensitivity: "base"
    });
    let { direction: direction  } = (0, $2oePb$reactariai18n.useLocale)();
    let disabledBehavior = state.selectionManager.disabledBehavior;
    let delegate = (0, $2oePb$react.useMemo)(()=>keyboardDelegate || new (0, $3187c0e19200cb16$export$de9feff04fda126e)({
            collection: state.collection,
            disabledKeys: disabledBehavior === "selection" ? new Set() : state.disabledKeys,
            ref: ref,
            direction: direction,
            collator: collator,
            focusMode: focusMode
        }), [
        keyboardDelegate,
        state.collection,
        state.disabledKeys,
        disabledBehavior,
        ref,
        direction,
        collator,
        focusMode
    ]);
    let { collectionProps: collectionProps  } = (0, $2oePb$reactariaselection.useSelectableCollection)({
        ref: ref,
        selectionManager: manager,
        keyboardDelegate: delegate,
        isVirtualized: isVirtualized,
        scrollRef: scrollRef
    });
    let id = (0, $2oePb$reactariautils.useId)(props.id);
    (0, $8ee34951196858d0$export$e6235c0d09b995d0).set(state, {
        keyboardDelegate: delegate,
        actions: {
            onRowAction: onRowAction,
            onCellAction: onCellAction
        }
    });
    let descriptionProps = (0, $340f2fcd0ef9ce8d$export$be42ebdab07ae4c2)({
        selectionManager: manager,
        hasItemActions: !!(onRowAction || onCellAction)
    });
    let domProps = (0, $2oePb$reactariautils.filterDOMProps)(props, {
        labelable: true
    });
    let onFocus = (0, $2oePb$react.useCallback)((e)=>{
        if (manager.isFocused) {
            // If a focus event bubbled through a portal, reset focus state.
            if (!e.currentTarget.contains(e.target)) manager.setFocused(false);
            return;
        }
        // Focus events can bubble through portals. Ignore these events.
        if (!e.currentTarget.contains(e.target)) return;
        manager.setFocused(true);
    }, [
        manager
    ]);
    // Continue to track collection focused state even if keyboard navigation is disabled
    let navDisabledHandlers = (0, $2oePb$react.useMemo)(()=>({
            onBlur: collectionProps.onBlur,
            onFocus: onFocus
        }), [
        onFocus,
        collectionProps.onBlur
    ]);
    let hasTabbableChild = (0, $2oePb$reactariafocus.useHasTabbableChild)(ref, {
        isDisabled: state.collection.size !== 0
    });
    let gridProps = (0, $2oePb$reactariautils.mergeProps)(domProps, {
        role: "grid",
        id: id,
        "aria-multiselectable": manager.selectionMode === "multiple" ? "true" : undefined
    }, state.isKeyboardNavigationDisabled ? navDisabledHandlers : collectionProps, // If collection is empty, make sure the grid is tabbable unless there is a child tabbable element.
    state.collection.size === 0 && {
        tabIndex: hasTabbableChild ? -1 : 0
    }, descriptionProps);
    if (isVirtualized) {
        gridProps["aria-rowcount"] = state.collection.size;
        gridProps["aria-colcount"] = state.collection.columnCount;
    }
    (0, $1eb174acfe8a0f16$export$137e594ef3218a10)({
        getRowText: getRowText
    }, state);
    return {
        gridProps: gridProps
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $c7def85a57100898$export$d3037f5d3f3e51bf() {
    return {
        rowGroupProps: {
            role: "rowgroup"
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $eed398987c639831$export$96357d5a73f686fa(props, state, ref) {
    let { node: node , isVirtualized: isVirtualized , shouldSelectOnPressUp: shouldSelectOnPressUp , onAction: onAction  } = props;
    let { actions: { onRowAction: onRowAction  }  } = (0, $8ee34951196858d0$export$e6235c0d09b995d0).get(state);
    let { itemProps: itemProps , ...states } = (0, $2oePb$reactariaselection.useSelectableItem)({
        selectionManager: state.selectionManager,
        key: node.key,
        ref: ref,
        isVirtualized: isVirtualized,
        shouldSelectOnPressUp: shouldSelectOnPressUp,
        onAction: onRowAction ? ()=>onRowAction(node.key) : onAction,
        isDisabled: state.collection.size === 0
    });
    let isSelected = state.selectionManager.isSelected(node.key);
    let rowProps = {
        role: "row",
        "aria-selected": state.selectionManager.selectionMode !== "none" ? isSelected : undefined,
        "aria-disabled": states.isDisabled || undefined,
        ...itemProps
    };
    if (isVirtualized) rowProps["aria-rowindex"] = node.index + 1; // aria-rowindex is 1 based
    return {
        rowProps: rowProps,
        ...states
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 






function $cf2021be63b01ef4$export$c7e10bfc0c59f67c(props, state, ref) {
    let { node: node , isVirtualized: isVirtualized , focusMode: focusMode = "child" , shouldSelectOnPressUp: shouldSelectOnPressUp , onAction: onAction  } = props;
    let { direction: direction  } = (0, $2oePb$reactariai18n.useLocale)();
    let { keyboardDelegate: keyboardDelegate , actions: { onCellAction: onCellAction  }  } = (0, $8ee34951196858d0$export$e6235c0d09b995d0).get(state);
    // We need to track the key of the item at the time it was last focused so that we force
    // focus to go to the item when the DOM node is reused for a different item in a virtualizer.
    let keyWhenFocused = (0, $2oePb$react.useRef)(null);
    // Handles focusing the cell. If there is a focusable child,
    // it is focused, otherwise the cell itself is focused.
    let focus = ()=>{
        let treeWalker = (0, $2oePb$reactariafocus.getFocusableTreeWalker)(ref.current);
        if (focusMode === "child") {
            // If focus is already on a focusable child within the cell, early return so we don't shift focus
            if (ref.current.contains(document.activeElement) && ref.current !== document.activeElement) return;
            let focusable = state.selectionManager.childFocusStrategy === "last" ? $cf2021be63b01ef4$var$last(treeWalker) : treeWalker.firstChild();
            if (focusable) {
                (0, $2oePb$reactariafocus.focusSafely)(focusable);
                return;
            }
        }
        if (keyWhenFocused.current != null && node.key !== keyWhenFocused.current || !ref.current.contains(document.activeElement)) (0, $2oePb$reactariafocus.focusSafely)(ref.current);
    };
    let { itemProps: itemProps , isPressed: isPressed  } = (0, $2oePb$reactariaselection.useSelectableItem)({
        selectionManager: state.selectionManager,
        key: node.key,
        ref: ref,
        isVirtualized: isVirtualized,
        focus: focus,
        shouldSelectOnPressUp: shouldSelectOnPressUp,
        onAction: onCellAction ? ()=>onCellAction(node.key) : onAction,
        isDisabled: state.collection.size === 0
    });
    let onKeyDownCapture = (e)=>{
        if (!e.currentTarget.contains(e.target) || state.isKeyboardNavigationDisabled) return;
        let walker = (0, $2oePb$reactariafocus.getFocusableTreeWalker)(ref.current);
        walker.currentNode = document.activeElement;
        switch(e.key){
            case "ArrowLeft":
                {
                    // Find the next focusable element within the cell.
                    let focusable = direction === "rtl" ? walker.nextNode() : walker.previousNode();
                    // Don't focus the cell itself if focusMode is "child"
                    if (focusMode === "child" && focusable === ref.current) focusable = null;
                    if (focusable) {
                        e.preventDefault();
                        e.stopPropagation();
                        (0, $2oePb$reactariafocus.focusSafely)(focusable);
                        (0, $2oePb$reactariautils.scrollIntoViewport)(focusable, {
                            containingElement: (0, $2oePb$reactariautils.getScrollParent)(ref.current)
                        });
                    } else {
                        // If there is no next focusable child, then move to the next cell to the left of this one.
                        // This will be handled by useSelectableCollection. However, if there is no cell to the left
                        // of this one, only one column, and the grid doesn't focus rows, then the next key will be the
                        // same as this one. In that case we need to handle focusing either the cell or the first/last
                        // child, depending on the focus mode.
                        let prev = keyboardDelegate.getKeyLeftOf(node.key);
                        if (prev !== node.key) break;
                        e.preventDefault();
                        e.stopPropagation();
                        if (focusMode === "cell" && direction === "rtl") {
                            (0, $2oePb$reactariafocus.focusSafely)(ref.current);
                            (0, $2oePb$reactariautils.scrollIntoViewport)(ref.current, {
                                containingElement: (0, $2oePb$reactariautils.getScrollParent)(ref.current)
                            });
                        } else {
                            walker.currentNode = ref.current;
                            focusable = direction === "rtl" ? walker.firstChild() : $cf2021be63b01ef4$var$last(walker);
                            if (focusable) {
                                (0, $2oePb$reactariafocus.focusSafely)(focusable);
                                (0, $2oePb$reactariautils.scrollIntoViewport)(focusable, {
                                    containingElement: (0, $2oePb$reactariautils.getScrollParent)(ref.current)
                                });
                            }
                        }
                    }
                    break;
                }
            case "ArrowRight":
                {
                    let focusable = direction === "rtl" ? walker.previousNode() : walker.nextNode();
                    if (focusMode === "child" && focusable === ref.current) focusable = null;
                    if (focusable) {
                        e.preventDefault();
                        e.stopPropagation();
                        (0, $2oePb$reactariafocus.focusSafely)(focusable);
                        (0, $2oePb$reactariautils.scrollIntoViewport)(focusable, {
                            containingElement: (0, $2oePb$reactariautils.getScrollParent)(ref.current)
                        });
                    } else {
                        let next = keyboardDelegate.getKeyRightOf(node.key);
                        if (next !== node.key) break;
                        e.preventDefault();
                        e.stopPropagation();
                        if (focusMode === "cell" && direction === "ltr") {
                            (0, $2oePb$reactariafocus.focusSafely)(ref.current);
                            (0, $2oePb$reactariautils.scrollIntoViewport)(ref.current, {
                                containingElement: (0, $2oePb$reactariautils.getScrollParent)(ref.current)
                            });
                        } else {
                            walker.currentNode = ref.current;
                            focusable = direction === "rtl" ? $cf2021be63b01ef4$var$last(walker) : walker.firstChild();
                            if (focusable) {
                                (0, $2oePb$reactariafocus.focusSafely)(focusable);
                                (0, $2oePb$reactariautils.scrollIntoViewport)(focusable, {
                                    containingElement: (0, $2oePb$reactariautils.getScrollParent)(ref.current)
                                });
                            }
                        }
                    }
                    break;
                }
            case "ArrowUp":
            case "ArrowDown":
                // Prevent this event from reaching cell children, e.g. menu buttons. We want arrow keys to navigate
                // to the cell above/below instead. We need to re-dispatch the event from a higher parent so it still
                // bubbles and gets handled by useSelectableCollection.
                if (!e.altKey && ref.current.contains(e.target)) {
                    e.stopPropagation();
                    e.preventDefault();
                    ref.current.parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));
                }
                break;
        }
    };
    // Grid cells can have focusable elements inside them. In this case, focus should
    // be marshalled to that element rather than focusing the cell itself.
    let onFocus = (e)=>{
        keyWhenFocused.current = node.key;
        if (e.target !== ref.current) {
            // useSelectableItem only handles setting the focused key when
            // the focused element is the gridcell itself. We also want to
            // set the focused key when a child element receives focus.
            // If focus is currently visible (e.g. the user is navigating with the keyboard),
            // then skip this. We want to restore focus to the previously focused row/cell
            // in that case since the table should act like a single tab stop.
            if (!(0, $2oePb$reactariainteractions.isFocusVisible)()) state.selectionManager.setFocusedKey(node.key);
            return;
        }
        // If the cell itself is focused, wait a frame so that focus finishes propagatating
        // up to the tree, and move focus to a focusable child if possible.
        requestAnimationFrame(()=>{
            if (focusMode === "child" && document.activeElement === ref.current) focus();
        });
    };
    let gridCellProps = (0, $2oePb$reactariautils.mergeProps)(itemProps, {
        role: "gridcell",
        onKeyDownCapture: onKeyDownCapture,
        onFocus: onFocus
    });
    var _node_colIndex;
    if (isVirtualized) gridCellProps["aria-colindex"] = ((_node_colIndex = node.colIndex) !== null && _node_colIndex !== void 0 ? _node_colIndex : node.index) + 1; // aria-colindex is 1-based
    // When pressing with a pointer and cell selection is not enabled, usePress will be applied to the
    // row rather than the cell. However, when the row is draggable, usePress cannot preventDefault
    // on pointer down, so the browser will try to focus the cell which has a tabIndex applied.
    // To avoid this, remove the tabIndex from the cell briefly on pointer down.
    if (shouldSelectOnPressUp && gridCellProps.tabIndex != null && gridCellProps.onPointerDown == null) gridCellProps.onPointerDown = (e)=>{
        let el = e.currentTarget;
        let tabindex = el.getAttribute("tabindex");
        el.removeAttribute("tabindex");
        requestAnimationFrame(()=>{
            el.setAttribute("tabindex", tabindex);
        });
    };
    return {
        gridCellProps: gridCellProps,
        isPressed: isPressed
    };
}
function $cf2021be63b01ef4$var$last(walker) {
    let next;
    let last;
    do {
        last = walker.lastChild();
        if (last) next = last;
    }while (last);
    return next;
}





function $d8385f73d3701365$export$70e2eed1a92976ad(props, state) {
    let { key: key  } = props;
    let manager = state.selectionManager;
    let checkboxId = (0, $2oePb$reactariautils.useId)();
    let isDisabled = !state.selectionManager.canSelectItem(key);
    let isSelected = state.selectionManager.isSelected(key);
    let onChange = ()=>manager.select(key);
    const stringFormatter = (0, $2oePb$reactariai18n.useLocalizedStringFormatter)((0, (/*@__PURE__*/$parcel$interopDefault($085250522aa37816$exports))));
    return {
        checkboxProps: {
            id: checkboxId,
            "aria-label": stringFormatter.format("select"),
            isSelected: isSelected,
            isDisabled: isDisabled,
            onChange: onChange
        }
    };
}






//# sourceMappingURL=main.js.map


/***/ }),

/***/ 65731:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $aB6Cp$react = __webpack_require__(18038);
var $aB6Cp$reactariautils = __webpack_require__(58277);
var $aB6Cp$reactariainteractions = __webpack_require__(11519);
var $aB6Cp$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "FocusScope", () => $a7a032acae3ddda9$export$20e40289641fbbb6);
$parcel$export(module.exports, "useFocusManager", () => $a7a032acae3ddda9$export$10c5169755ce7bd7);
$parcel$export(module.exports, "getFocusableTreeWalker", () => $a7a032acae3ddda9$export$2d6ec8fc375ceafa);
$parcel$export(module.exports, "createFocusManager", () => $a7a032acae3ddda9$export$c5251b9e124bf29);
$parcel$export(module.exports, "isElementInChildOfActiveScope", () => $a7a032acae3ddda9$export$1258395f99bf9cbf);
$parcel$export(module.exports, "FocusRing", () => $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d);
$parcel$export(module.exports, "FocusableProvider", () => $fb504d83237fd6ac$export$13f3202a3e5ddd5);
$parcel$export(module.exports, "useFocusable", () => $fb504d83237fd6ac$export$4c014de7c8940b4c);
$parcel$export(module.exports, "useFocusRing", () => $581a96d6eb128c1b$export$4e328f61c538687f);
$parcel$export(module.exports, "focusSafely", () => $1c7f9157d722357d$export$80f3e147d781571c);
$parcel$export(module.exports, "useHasTabbableChild", () => $259c6413a286f2e6$export$eac1895992b9f3d6);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1c7f9157d722357d$export$80f3e147d781571c(element) {
    // If the user is interacting with a virtual cursor, e.g. screen reader, then
    // wait until after any animated transitions that are currently occurring on
    // the page before shifting focus. This avoids issues with VoiceOver on iOS
    // causing the page to scroll when moving focus if the element is transitioning
    // from off the screen.
    if ((0, $aB6Cp$reactariainteractions.getInteractionModality)() === "virtual") {
        let lastFocusedElement = document.activeElement;
        (0, $aB6Cp$reactariautils.runAfterTransition)(()=>{
            // If focus did not move and the element is still in the document, focus it.
            if (document.activeElement === lastFocusedElement && document.contains(element)) (0, $aB6Cp$reactariautils.focusWithoutScrolling)(element);
        });
    } else (0, $aB6Cp$reactariautils.focusWithoutScrolling)(element);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d5156037ad898a4d$var$isStyleVisible(element) {
    if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) return false;
    let { display: display , visibility: visibility  } = element.style;
    let isVisible = display !== "none" && visibility !== "hidden" && visibility !== "collapse";
    if (isVisible) {
        const { getComputedStyle: getComputedStyle  } = element.ownerDocument.defaultView;
        let { display: computedDisplay , visibility: computedVisibility  } = getComputedStyle(element);
        isVisible = computedDisplay !== "none" && computedVisibility !== "hidden" && computedVisibility !== "collapse";
    }
    return isVisible;
}
function $d5156037ad898a4d$var$isAttributeVisible(element, childElement) {
    return !element.hasAttribute("hidden") && (element.nodeName === "DETAILS" && childElement && childElement.nodeName !== "SUMMARY" ? element.hasAttribute("open") : true);
}
function $d5156037ad898a4d$export$e989c0fffaa6b27a(element, childElement) {
    return element.nodeName !== "#comment" && $d5156037ad898a4d$var$isStyleVisible(element) && $d5156037ad898a4d$var$isAttributeVisible(element, childElement) && (!element.parentElement || $d5156037ad898a4d$export$e989c0fffaa6b27a(element.parentElement, element));
}




const $a7a032acae3ddda9$var$FocusContext = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createContext(null);
let $a7a032acae3ddda9$var$activeScope = null;
function $a7a032acae3ddda9$export$20e40289641fbbb6(props) {
    let { children: children , contain: contain , restoreFocus: restoreFocus , autoFocus: autoFocus  } = props;
    let startRef = (0, $aB6Cp$react.useRef)();
    let endRef = (0, $aB6Cp$react.useRef)();
    let scopeRef = (0, $aB6Cp$react.useRef)([]);
    let { parentNode: parentNode  } = (0, $aB6Cp$react.useContext)($a7a032acae3ddda9$var$FocusContext) || {};
    // Create a tree node here so we can add children to it even before it is added to the tree.
    let node = (0, $aB6Cp$react.useMemo)(()=>new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: scopeRef
        }), [
        scopeRef
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),
        // use the active scope as the parent instead of the parent from context. Layout effects run bottom
        // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope
        // that is being added should get the activeScope as its parent.
        let parent = parentNode || $a7a032acae3ddda9$export$d06fae2ee68b101e.root;
        if ($a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(parent.scopeRef) && $a7a032acae3ddda9$var$activeScope && !$a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, parent.scopeRef)) {
            let activeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
            if (activeNode) parent = activeNode;
        }
        // Add the node to the parent, and to the tree.
        parent.addChild(node);
        $a7a032acae3ddda9$export$d06fae2ee68b101e.addNode(node);
    }, [
        node,
        parentNode
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let node = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef);
        node.contain = contain;
    }, [
        contain
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        // Find all rendered nodes between the sentinels and add them to the scope.
        let node = startRef.current.nextSibling;
        let nodes = [];
        while(node && node !== endRef.current){
            nodes.push(node);
            node = node.nextSibling;
        }
        scopeRef.current = nodes;
    }, [
        children
    ]);
    $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain);
    $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus);
    // this layout effect needs to run last so that focusScopeTree cleanup happens at the last moment possible
    (0, $aB6Cp$react.useEffect)(()=>{
        if (scopeRef) {
            let activeElement = document.activeElement;
            let scope = null;
            // In strict mode, active scope is incorrectly updated since cleanup will run even though scope hasn't unmounted.
            // To fix this, we need to update the actual activeScope here
            if ($a7a032acae3ddda9$var$isElementInScope(activeElement, scopeRef.current)) {
                // Since useLayoutEffect runs for children first, we need to traverse the focusScope tree and find the bottom most scope that
                // contains the active element and set that as the activeScope
                for (let node of $a7a032acae3ddda9$export$d06fae2ee68b101e.traverse())if ($a7a032acae3ddda9$var$isElementInScope(activeElement, node.scopeRef.current)) scope = node;
                if (scope === $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef)) $a7a032acae3ddda9$var$activeScope = scope.scopeRef;
            }
            return ()=>{
                // Scope may have been re-parented.
                let parentScope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).parent.scopeRef;
                // Restore the active scope on unmount if this scope or a descendant scope is active.
                // Parent effect cleanups run before children, so we need to check if the
                // parent scope actually still exists before restoring the active scope to it.
                if ((scopeRef === $a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope(scopeRef, $a7a032acae3ddda9$var$activeScope)) && (!parentScope || $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(parentScope))) $a7a032acae3ddda9$var$activeScope = parentScope;
                $a7a032acae3ddda9$export$d06fae2ee68b101e.removeTreeNode(scopeRef);
            };
        }
    }, [
        scopeRef
    ]);
    let focusManager = (0, $aB6Cp$react.useMemo)(()=>$a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef), []);
    let value = (0, $aB6Cp$react.useMemo)(()=>({
            focusManager: focusManager,
            parentNode: node
        }), [
        node,
        focusManager
    ]);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement($a7a032acae3ddda9$var$FocusContext.Provider, {
        value: value
    }, /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement("span", {
        "data-focus-scope-start": true,
        hidden: true,
        ref: startRef
    }), children, /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement("span", {
        "data-focus-scope-end": true,
        hidden: true,
        ref: endRef
    }));
}
function $a7a032acae3ddda9$export$10c5169755ce7bd7() {
    var _useContext;
    return (_useContext = (0, $aB6Cp$react.useContext)($a7a032acae3ddda9$var$FocusContext)) === null || _useContext === void 0 ? void 0 : _useContext.focusManager;
}
function $a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef) {
    return {
        focusNext (opts = {}) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[0].previousElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = sentinel;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = {}) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[scope.length - 1].nextElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = sentinel;
                previousNode = walker.previousNode();
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = {}) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[0].previousElementSibling;
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = {}) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[scope.length - 1].nextElementSibling;
            let previousNode = walker.previousNode();
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        }
    };
}
const $a7a032acae3ddda9$var$focusableElements = [
    "input:not([disabled]):not([type=hidden])",
    "select:not([disabled])",
    "textarea:not([disabled])",
    "button:not([disabled])",
    "a[href]",
    "area[href]",
    "summary",
    "iframe",
    "object",
    "embed",
    "audio[controls]",
    "video[controls]",
    "[contenteditable]"
];
const $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
$a7a032acae3ddda9$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(':not([hidden]):not([tabindex="-1"]),');
function $a7a032acae3ddda9$var$getScopeRoot(scope) {
    return scope[0].parentElement;
}
function $a7a032acae3ddda9$var$shouldContainFocus(scopeRef) {
    let scope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
    while(scope && scope.scopeRef !== scopeRef){
        if (scope.contain) return false;
        scope = scope.parent;
    }
    return true;
}
function $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain) {
    let focusedNode = (0, $aB6Cp$react.useRef)();
    let raf = (0, $aB6Cp$react.useRef)(null);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let scope = scopeRef.current;
        if (!contain) {
            // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment
            if (raf.current) {
                cancelAnimationFrame(raf.current);
                raf.current = null;
            }
            return;
        }
        // Handle the Tab key to contain focus within the scope
        let onKeyDown = (e)=>{
            if (e.key !== "Tab" || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) return;
            let focusedElement = document.activeElement;
            let scope = scopeRef.current;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scope)) return;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: true
            }, scope);
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!nextElement) {
                walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;
                nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            }
            e.preventDefault();
            if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
        };
        let onFocus = (e)=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if ((!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) && $a7a032acae3ddda9$var$isElementInScope(e.target, scopeRef.current)) {
                $a7a032acae3ddda9$var$activeScope = scopeRef;
                focusedNode.current = e.target;
            } else if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(e.target, scopeRef)) {
                // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),
                // restore focus to the previously focused node or the first tabbable element in the active scope.
                if (focusedNode.current) focusedNode.current.focus();
                else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
            } else if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) focusedNode.current = e.target;
        };
        let onBlur = (e)=>{
            // Firefox doesn't shift focus back to the Dialog properly without this
            if (raf.current) cancelAnimationFrame(raf.current);
            raf.current = requestAnimationFrame(()=>{
                // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe
                if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(document.activeElement, scopeRef)) {
                    $a7a032acae3ddda9$var$activeScope = scopeRef;
                    if (document.body.contains(e.target)) {
                        focusedNode.current = e.target;
                        focusedNode.current.focus();
                    } else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
                }
            });
        };
        document.addEventListener("keydown", onKeyDown, false);
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        scope.forEach((element)=>element.addEventListener("focusout", onBlur, false));
        return ()=>{
            document.removeEventListener("keydown", onKeyDown, false);
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
            scope.forEach((element)=>element.removeEventListener("focusout", onBlur, false));
        };
    }, [
        scopeRef,
        contain
    ]);
    // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur
    // eslint-disable-next-line arrow-body-style
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        return ()=>{
            if (raf.current) cancelAnimationFrame(raf.current);
        };
    }, [
        raf
    ]);
}
function $a7a032acae3ddda9$var$isElementInAnyScope(element) {
    return $a7a032acae3ddda9$var$isElementInChildScope(element);
}
function $a7a032acae3ddda9$var$isElementInScope(element, scope) {
    return scope.some((node)=>node.contains(element));
}
function $a7a032acae3ddda9$var$isElementInChildScope(element, scope = null) {
    // If the element is within a top layer element (e.g. toasts), always allow moving focus there.
    if (element instanceof Element && element.closest("[data-react-aria-top-layer]")) return true;
    // node.contains in isElementInScope covers child scopes that are also DOM children,
    // but does not cover child scopes in portals.
    for (let { scopeRef: s  } of $a7a032acae3ddda9$export$d06fae2ee68b101e.traverse($a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scope))){
        if ($a7a032acae3ddda9$var$isElementInScope(element, s.current)) return true;
    }
    return false;
}
function $a7a032acae3ddda9$export$1258395f99bf9cbf(element) {
    return $a7a032acae3ddda9$var$isElementInChildScope(element, $a7a032acae3ddda9$var$activeScope);
}
function $a7a032acae3ddda9$var$isAncestorScope(ancestor, scope) {
    var _focusScopeTree_getTreeNode;
    let parent = (_focusScopeTree_getTreeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scope)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : _focusScopeTree_getTreeNode.parent;
    while(parent){
        if (parent.scopeRef === ancestor) return true;
        parent = parent.parent;
    }
    return false;
}
function $a7a032acae3ddda9$var$focusElement(element, scroll = false) {
    if (element != null && !scroll) try {
        (0, $1c7f9157d722357d$export$80f3e147d781571c)(element);
    } catch (err) {
    // ignore
    }
    else if (element != null) try {
        element.focus();
    } catch (err) {
    // ignore
    }
}
function $a7a032acae3ddda9$var$focusFirstInScope(scope, tabbable = true) {
    let sentinel = scope[0].previousElementSibling;
    let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
        tabbable: tabbable
    }, scope);
    walker.currentNode = sentinel;
    let nextNode = walker.nextNode();
    // If the scope does not contain a tabbable element, use the first focusable element.
    if (tabbable && !nextNode) {
        walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
            tabbable: false
        }, scope);
        walker.currentNode = sentinel;
        nextNode = walker.nextNode();
    }
    $a7a032acae3ddda9$var$focusElement(nextNode);
}
function $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus) {
    const autoFocusRef = (0, ($parcel$interopDefault($aB6Cp$react))).useRef(autoFocus);
    (0, $aB6Cp$react.useEffect)(()=>{
        if (autoFocusRef.current) {
            $a7a032acae3ddda9$var$activeScope = scopeRef;
            if (!$a7a032acae3ddda9$var$isElementInScope(document.activeElement, $a7a032acae3ddda9$var$activeScope.current)) $a7a032acae3ddda9$var$focusFirstInScope(scopeRef.current);
        }
        autoFocusRef.current = false;
    }, [
        scopeRef
    ]);
}
function $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restore, contain) {
    // tracks the active scope, in case restore and contain are both false.
    // if either are true, this is tracked in useRestoreFocus or useFocusContainment.
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if (restore || contain) return;
        let scope = scopeRef.current;
        let onFocus = (e)=>{
            let target = e.target;
            if ($a7a032acae3ddda9$var$isElementInScope(target, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
            else if (!$a7a032acae3ddda9$var$isElementInAnyScope(target)) $a7a032acae3ddda9$var$activeScope = null;
        };
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        return ()=>{
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
        };
    }, [
        scopeRef,
        restore,
        contain
    ]);
}
function $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef) {
    let scope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
    while(scope && scope.scopeRef !== scopeRef){
        if (scope.nodeToRestore) return false;
        scope = scope.parent;
    }
    return (scope === null || scope === void 0 ? void 0 : scope.scopeRef) === scopeRef;
}
function $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
    // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.
    const nodeToRestoreRef = (0, $aB6Cp$react.useRef)(typeof document !== "undefined" ? document.activeElement : null);
    // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus
    // restoring-non-containing scopes should only care if they become active so they can perform the restore
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let scope = scopeRef.current;
        if (!restoreFocus || contain) return;
        let onFocus = ()=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if ((!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) && $a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
        };
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        return ()=>{
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        scopeRef,
        contain
    ]);
    // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if (!restoreFocus) return;
        $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = nodeToRestoreRef.current;
        // Handle the Tab key so that tabbing out of the scope goes to the next element
        // after the node that had focus when the scope mounted. This is important when
        // using portals for overlays, so that focus goes to the expected element when
        // tabbing out of the overlay.
        let onKeyDown = (e)=>{
            if (e.key !== "Tab" || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) return;
            let focusedElement = document.activeElement;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scopeRef.current)) return;
            let nodeToRestore = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;
            // Create a DOM tree walker that matches all tabbable elements
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(document.body, {
                tabbable: true
            });
            // Find the next tabbable element after the currently focused element
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!document.body.contains(nodeToRestore) || nodeToRestore === document.body) {
                nodeToRestore = null;
                $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = null;
            }
            // If there is no next element, or it is outside the current scope, move focus to the
            // next element after the node to restore to instead.
            if ((!nextElement || !$a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {
                walker.currentNode = nodeToRestore;
                // Skip over elements within the scope, in case the scope immediately follows the node to restore.
                do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
                while ($a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current));
                e.preventDefault();
                e.stopPropagation();
                if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
                else // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)
                // then move focus to the body.
                // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)
                if (!$a7a032acae3ddda9$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();
                else $a7a032acae3ddda9$var$focusElement(nodeToRestore, true);
            }
        };
        if (!contain) document.addEventListener("keydown", onKeyDown, true);
        return ()=>{
            if (!contain) document.removeEventListener("keydown", onKeyDown, true);
            let nodeToRestore = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;
            // if we already lost focus to the body and this was the active scope, then we should attempt to restore
            if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps
            ($a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current) || document.activeElement === document.body && $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef))) {
                // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it
                let clonedTree = $a7a032acae3ddda9$export$d06fae2ee68b101e.clone();
                requestAnimationFrame(()=>{
                    // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere
                    if (document.activeElement === document.body) {
                        // look up the tree starting with our scope to find a nodeToRestore still in the DOM
                        let treeNode = clonedTree.getTreeNode(scopeRef);
                        while(treeNode){
                            if (treeNode.nodeToRestore && document.body.contains(treeNode.nodeToRestore)) {
                                $a7a032acae3ddda9$var$focusElement(treeNode.nodeToRestore);
                                return;
                            }
                            treeNode = treeNode.parent;
                        }
                        // If no nodeToRestore was found, focus the first element in the nearest
                        // ancestor scope that is still in the tree.
                        treeNode = clonedTree.getTreeNode(scopeRef);
                        while(treeNode){
                            if (treeNode.scopeRef && $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(treeNode.scopeRef)) {
                                $a7a032acae3ddda9$var$focusFirstInScope(treeNode.scopeRef.current, true);
                                return;
                            }
                            treeNode = treeNode.parent;
                        }
                    }
                });
            }
        };
    }, [
        scopeRef,
        restoreFocus,
        contain
    ]);
}
function $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, opts, scope) {
    let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR : $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR;
    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode (node) {
            var _opts_from;
            // Skip nodes inside the starting node.
            if (opts === null || opts === void 0 ? void 0 : (_opts_from = opts.from) === null || _opts_from === void 0 ? void 0 : _opts_from.contains(node)) return NodeFilter.FILTER_REJECT;
            if (node.matches(selector) && (0, $d5156037ad898a4d$export$e989c0fffaa6b27a)(node) && (!scope || $a7a032acae3ddda9$var$isElementInScope(node, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node))) return NodeFilter.FILTER_ACCEPT;
            return NodeFilter.FILTER_SKIP;
        }
    });
    if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;
    return walker;
}
function $a7a032acae3ddda9$export$c5251b9e124bf29(ref, defaultOptions = {}) {
    return {
        focusNext (opts = {}) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = root;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            else {
                let next = $a7a032acae3ddda9$var$last(walker);
                if (next) $a7a032acae3ddda9$var$focusElement(next, true);
                return next;
            }
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = root;
                previousNode = $a7a032acae3ddda9$var$last(walker);
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let next = $a7a032acae3ddda9$var$last(walker);
            if (next) $a7a032acae3ddda9$var$focusElement(next, true);
            return next;
        }
    };
}
function $a7a032acae3ddda9$var$last(walker) {
    let next;
    let last;
    do {
        last = walker.lastChild();
        if (last) next = last;
    }while (last);
    return next;
}
class $a7a032acae3ddda9$var$Tree {
    get size() {
        return this.fastMap.size;
    }
    getTreeNode(data) {
        return this.fastMap.get(data);
    }
    addTreeNode(scopeRef, parent, nodeToRestore) {
        let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);
        let node = new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: scopeRef
        });
        parentNode.addChild(node);
        node.parent = parentNode;
        this.fastMap.set(scopeRef, node);
        if (nodeToRestore) node.nodeToRestore = nodeToRestore;
    }
    addNode(node) {
        this.fastMap.set(node.scopeRef, node);
    }
    removeTreeNode(scopeRef) {
        // never remove the root
        if (scopeRef === null) return;
        let node = this.fastMap.get(scopeRef);
        let parentNode = node.parent;
        // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing
        // if we are, then replace the siblings restore with the restore from the scope we're removing
        for (let current of this.traverse())if (current !== node && node.nodeToRestore && current.nodeToRestore && node.scopeRef.current && $a7a032acae3ddda9$var$isElementInScope(current.nodeToRestore, node.scopeRef.current)) current.nodeToRestore = node.nodeToRestore;
        let children = node.children;
        parentNode.removeChild(node);
        if (children.size > 0) children.forEach((child)=>parentNode.addChild(child));
        this.fastMap.delete(node.scopeRef);
    }
    // Pre Order Depth First
    *traverse(node = this.root) {
        if (node.scopeRef != null) yield node;
        if (node.children.size > 0) for (let child of node.children)yield* this.traverse(child);
    }
    clone() {
        let newTree = new $a7a032acae3ddda9$var$Tree();
        for (let node of this.traverse())newTree.addTreeNode(node.scopeRef, node.parent.scopeRef, node.nodeToRestore);
        return newTree;
    }
    constructor(){
        this.fastMap = new Map();
        this.root = new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: null
        });
        this.fastMap.set(null, this.root);
    }
}
class $a7a032acae3ddda9$var$TreeNode {
    addChild(node) {
        this.children.add(node);
        node.parent = this;
    }
    removeChild(node) {
        this.children.delete(node);
        node.parent = undefined;
    }
    constructor(props){
        this.children = new Set();
        this.contain = false;
        this.scopeRef = props.scopeRef;
    }
}
let $a7a032acae3ddda9$export$d06fae2ee68b101e = new $a7a032acae3ddda9$var$Tree();


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 




function $581a96d6eb128c1b$export$4e328f61c538687f(props = {}) {
    let { autoFocus: autoFocus = false , isTextInput: isTextInput , within: within  } = props;
    let state = (0, $aB6Cp$react.useRef)({
        isFocused: false,
        isFocusVisible: autoFocus || (0, $aB6Cp$reactariainteractions.isFocusVisible)()
    });
    let [isFocused, setFocused] = (0, $aB6Cp$react.useState)(false);
    let [isFocusVisibleState, setFocusVisible] = (0, $aB6Cp$react.useState)(()=>state.current.isFocused && state.current.isFocusVisible);
    let updateState = (0, $aB6Cp$react.useCallback)(()=>setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
    let onFocusChange = (0, $aB6Cp$react.useCallback)((isFocused)=>{
        state.current.isFocused = isFocused;
        setFocused(isFocused);
        updateState();
    }, [
        updateState
    ]);
    (0, $aB6Cp$reactariainteractions.useFocusVisibleListener)((isFocusVisible)=>{
        state.current.isFocusVisible = isFocusVisible;
        updateState();
    }, [], {
        isTextInput: isTextInput
    });
    let { focusProps: focusProps  } = (0, $aB6Cp$reactariainteractions.useFocus)({
        isDisabled: within,
        onFocusChange: onFocusChange
    });
    let { focusWithinProps: focusWithinProps  } = (0, $aB6Cp$reactariainteractions.useFocusWithin)({
        isDisabled: !within,
        onFocusWithinChange: onFocusChange
    });
    return {
        isFocused: isFocused,
        isFocusVisible: isFocusVisibleState,
        focusProps: within ? focusWithinProps : focusProps
    };
}


function $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d(props) {
    let { children: children , focusClass: focusClass , focusRingClass: focusRingClass  } = props;
    let { isFocused: isFocused , isFocusVisible: isFocusVisible , focusProps: focusProps  } = (0, $581a96d6eb128c1b$export$4e328f61c538687f)(props);
    let child = (0, ($parcel$interopDefault($aB6Cp$react))).Children.only(children);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).cloneElement(child, (0, $aB6Cp$reactariautils.mergeProps)(child.props, {
        ...focusProps,
        className: (0, ($parcel$interopDefault($aB6Cp$clsx)))({
            [focusClass || ""]: isFocused,
            [focusRingClass || ""]: isFocusVisible
        })
    }));
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



let $fb504d83237fd6ac$var$FocusableContext = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createContext(null);
function $fb504d83237fd6ac$var$useFocusableContext(ref) {
    let context = (0, $aB6Cp$react.useContext)($fb504d83237fd6ac$var$FocusableContext) || {};
    (0, $aB6Cp$reactariautils.useSyncRef)(context, ref);
    // eslint-disable-next-line
    let { ref: _ , ...otherProps } = context;
    return otherProps;
}
/**
 * Provides DOM props to the nearest focusable child.
 */ function $fb504d83237fd6ac$var$FocusableProvider(props, ref) {
    let { children: children , ...otherProps } = props;
    let context = {
        ...otherProps,
        ref: ref
    };
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement($fb504d83237fd6ac$var$FocusableContext.Provider, {
        value: context
    }, children);
}
let $fb504d83237fd6ac$export$13f3202a3e5ddd5 = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).forwardRef($fb504d83237fd6ac$var$FocusableProvider);
function $fb504d83237fd6ac$export$4c014de7c8940b4c(props, domRef) {
    let { focusProps: focusProps  } = (0, $aB6Cp$reactariainteractions.useFocus)(props);
    let { keyboardProps: keyboardProps  } = (0, $aB6Cp$reactariainteractions.useKeyboard)(props);
    let interactions = (0, $aB6Cp$reactariautils.mergeProps)(focusProps, keyboardProps);
    let domProps = $fb504d83237fd6ac$var$useFocusableContext(domRef);
    let interactionProps = props.isDisabled ? {} : domProps;
    let autoFocusRef = (0, $aB6Cp$react.useRef)(props.autoFocus);
    (0, $aB6Cp$react.useEffect)(()=>{
        if (autoFocusRef.current && domRef.current) (0, $1c7f9157d722357d$export$80f3e147d781571c)(domRef.current);
        autoFocusRef.current = false;
    }, [
        domRef
    ]);
    return {
        focusableProps: (0, $aB6Cp$reactariautils.mergeProps)({
            ...interactions,
            tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined
        }, interactionProps)
    };
}




/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $259c6413a286f2e6$export$eac1895992b9f3d6(ref, options) {
    let isDisabled = options === null || options === void 0 ? void 0 : options.isDisabled;
    let [hasTabbableChild, setHasTabbableChild] = (0, $aB6Cp$react.useState)(false);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if ((ref === null || ref === void 0 ? void 0 : ref.current) && !isDisabled) {
            let update = ()=>{
                if (ref.current) {
                    let walker = (0, $a7a032acae3ddda9$export$2d6ec8fc375ceafa)(ref.current, {
                        tabbable: true
                    });
                    setHasTabbableChild(!!walker.nextNode());
                }
            };
            update();
            // Update when new elements are inserted, or the tabIndex/disabled attribute updates.
            let observer = new MutationObserver(update);
            observer.observe(ref.current, {
                subtree: true,
                childList: true,
                attributes: true,
                attributeFilter: [
                    "tabIndex",
                    "disabled"
                ]
            });
            return ()=>{
                // Disconnect mutation observer when a React update occurs on the top-level component
                // so we update synchronously after re-rendering. Otherwise React will emit act warnings
                // in tests since mutation observers fire asynchronously. The mutation observer is necessary
                // so we also update if a child component re-renders and adds/removes something tabbable.
                observer.disconnect();
            };
        }
    });
    return isDisabled ? false : hasTabbableChild;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 45851:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// useMessageFormatter is deprecated, but has a large dependency on intl-messageformat
// that we want to avoid. If it is built into the same file as the rest of the package,
// it deopts tree shaking in Parcel even when unused. Instead, it is split into a separate
// file and re-exported here, which allows tree shaking to work properly.
module.exports = __webpack_require__(45616);
Object.defineProperties(module.exports, Object.getOwnPropertyDescriptors(__webpack_require__(70806)));


/***/ }),

/***/ 45616:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $87SwK$react = __webpack_require__(18038);
var $87SwK$reactariassr = __webpack_require__(47292);
var $87SwK$internationalizedstring = __webpack_require__(36058);
var $87SwK$internationalizeddate = __webpack_require__(50031);
var $87SwK$reactariautils = __webpack_require__(58277);
var $87SwK$internationalizednumber = __webpack_require__(8483);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "I18nProvider", () => $47fa5ec5ff482271$export$a54013f0d02a8f82);
$parcel$export(module.exports, "useLocale", () => $47fa5ec5ff482271$export$43bb16f9c6d9e3f7);
$parcel$export(module.exports, "useMessageFormatter", () => $227f31f0c647c5fc$exports.useMessageFormatter);
$parcel$export(module.exports, "useLocalizedStringFormatter", () => $fc53663969a3d00a$export$f12b703ca79dfbb1);
$parcel$export(module.exports, "useListFormatter", () => $cb6a3e7d490e97a4$export$a2f47a3d2973640);
$parcel$export(module.exports, "useDateFormatter", () => $b80c530ff2e20243$export$85fd5fdf27bacc79);
$parcel$export(module.exports, "useNumberFormatter", () => $fea93c5b7c90d9f4$export$b7a616150fdb9f44);
$parcel$export(module.exports, "useCollator", () => $27a5ce66022270ad$export$a16aca283550c30d);
$parcel$export(module.exports, "useFilter", () => $832d079b867c7223$export$3274cf84b703fff);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // https://en.wikipedia.org/wiki/Right-to-left
const $4d65847630a056a8$var$RTL_SCRIPTS = new Set([
    "Arab",
    "Syrc",
    "Samr",
    "Mand",
    "Thaa",
    "Mend",
    "Nkoo",
    "Adlm",
    "Rohg",
    "Hebr"
]);
const $4d65847630a056a8$var$RTL_LANGS = new Set([
    "ae",
    "ar",
    "arc",
    "bcc",
    "bqi",
    "ckb",
    "dv",
    "fa",
    "glk",
    "he",
    "ku",
    "mzn",
    "nqo",
    "pnb",
    "ps",
    "sd",
    "ug",
    "ur",
    "yi"
]);
function $4d65847630a056a8$export$702d680b21cbd764(locale) {
    // If the Intl.Locale API is available, use it to get the script for the locale.
    // This is more accurate than guessing by language, since languages can be written in multiple scripts.
    // @ts-ignore
    if (Intl.Locale) {
        // @ts-ignore
        let script = new Intl.Locale(locale).maximize().script;
        return $4d65847630a056a8$var$RTL_SCRIPTS.has(script);
    }
    // If not, just guess by the language (first part of the locale)
    let lang = locale.split("-")[0];
    return $4d65847630a056a8$var$RTL_LANGS.has(lang);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $2919bdec75484e64$export$f09106e7c6677ec5() {
    // @ts-ignore
    let locale = typeof navigator !== "undefined" && (navigator.language || navigator.userLanguage) || "en-US";
    try {
        // @ts-ignore
        Intl.DateTimeFormat.supportedLocalesOf([
            locale
        ]);
    } catch (_err) {
        locale = "en-US";
    }
    return {
        locale: locale,
        direction: (0, $4d65847630a056a8$export$702d680b21cbd764)(locale) ? "rtl" : "ltr"
    };
}
let $2919bdec75484e64$var$currentLocale = $2919bdec75484e64$export$f09106e7c6677ec5();
let $2919bdec75484e64$var$listeners = new Set();
function $2919bdec75484e64$var$updateLocale() {
    $2919bdec75484e64$var$currentLocale = $2919bdec75484e64$export$f09106e7c6677ec5();
    for (let listener of $2919bdec75484e64$var$listeners)listener($2919bdec75484e64$var$currentLocale);
}
function $2919bdec75484e64$export$188ec29ebc2bdc3a() {
    let isSSR = (0, $87SwK$reactariassr.useIsSSR)();
    let [defaultLocale, setDefaultLocale] = (0, $87SwK$react.useState)($2919bdec75484e64$var$currentLocale);
    (0, $87SwK$react.useEffect)(()=>{
        if ($2919bdec75484e64$var$listeners.size === 0) window.addEventListener("languagechange", $2919bdec75484e64$var$updateLocale);
        $2919bdec75484e64$var$listeners.add(setDefaultLocale);
        return ()=>{
            $2919bdec75484e64$var$listeners.delete(setDefaultLocale);
            if ($2919bdec75484e64$var$listeners.size === 0) window.removeEventListener("languagechange", $2919bdec75484e64$var$updateLocale);
        };
    }, []);
    // We cannot determine the browser's language on the server, so default to
    // en-US. This will be updated after hydration on the client to the correct value.
    if (isSSR) return {
        locale: "en-US",
        direction: "ltr"
    };
    return defaultLocale;
}



const $47fa5ec5ff482271$var$I18nContext = /*#__PURE__*/ (0, ($parcel$interopDefault($87SwK$react))).createContext(null);
function $47fa5ec5ff482271$export$a54013f0d02a8f82(props) {
    let { locale: locale , children: children  } = props;
    let defaultLocale = (0, $2919bdec75484e64$export$188ec29ebc2bdc3a)();
    let value = locale ? {
        locale: locale,
        direction: (0, $4d65847630a056a8$export$702d680b21cbd764)(locale) ? "rtl" : "ltr"
    } : defaultLocale;
    return /*#__PURE__*/ (0, ($parcel$interopDefault($87SwK$react))).createElement($47fa5ec5ff482271$var$I18nContext.Provider, {
        value: value
    }, children);
}
function $47fa5ec5ff482271$export$43bb16f9c6d9e3f7() {
    let defaultLocale = (0, $2919bdec75484e64$export$188ec29ebc2bdc3a)();
    let context = (0, $87SwK$react.useContext)($47fa5ec5ff482271$var$I18nContext);
    return context || defaultLocale;
}


var $227f31f0c647c5fc$exports = {};
"use strict";


/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $fc53663969a3d00a$var$cache = new WeakMap();
function $fc53663969a3d00a$var$getCachedDictionary(strings) {
    let dictionary = $fc53663969a3d00a$var$cache.get(strings);
    if (!dictionary) {
        dictionary = new (0, $87SwK$internationalizedstring.LocalizedStringDictionary)(strings);
        $fc53663969a3d00a$var$cache.set(strings, dictionary);
    }
    return dictionary;
}
function $fc53663969a3d00a$export$f12b703ca79dfbb1(strings) {
    let { locale: locale  } = (0, $47fa5ec5ff482271$export$43bb16f9c6d9e3f7)();
    let dictionary = (0, $87SwK$react.useMemo)(()=>$fc53663969a3d00a$var$getCachedDictionary(strings), [
        strings
    ]);
    return (0, $87SwK$react.useMemo)(()=>new (0, $87SwK$internationalizedstring.LocalizedStringFormatter)(locale, dictionary), [
        locale,
        dictionary
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $cb6a3e7d490e97a4$export$a2f47a3d2973640(options = {}) {
    let { locale: locale  } = (0, $47fa5ec5ff482271$export$43bb16f9c6d9e3f7)();
    // @ts-ignore
    return (0, $87SwK$react.useMemo)(()=>new Intl.ListFormat(locale, options), [
        locale,
        options
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



function $b80c530ff2e20243$export$85fd5fdf27bacc79(options) {
    // Reuse last options object if it is shallowly equal, which allows the useMemo result to also be reused.
    options = (0, $87SwK$reactariautils.useDeepMemo)(options, $b80c530ff2e20243$var$isEqual);
    let { locale: locale  } = (0, $47fa5ec5ff482271$export$43bb16f9c6d9e3f7)();
    return (0, $87SwK$react.useMemo)(()=>new (0, $87SwK$internationalizeddate.DateFormatter)(locale, options), [
        locale,
        options
    ]);
}
function $b80c530ff2e20243$var$isEqual(a, b) {
    if (a === b) return true;
    let aKeys = Object.keys(a);
    let bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) return false;
    for (let key of aKeys){
        if (b[key] !== a[key]) return false;
    }
    return true;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $fea93c5b7c90d9f4$export$b7a616150fdb9f44(options = {}) {
    let { locale: locale  } = (0, $47fa5ec5ff482271$export$43bb16f9c6d9e3f7)();
    return (0, $87SwK$react.useMemo)(()=>new (0, $87SwK$internationalizednumber.NumberFormatter)(locale, options), [
        locale,
        options
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
let $27a5ce66022270ad$var$cache = new Map();
function $27a5ce66022270ad$export$a16aca283550c30d(options) {
    let { locale: locale  } = (0, $47fa5ec5ff482271$export$43bb16f9c6d9e3f7)();
    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : "");
    if ($27a5ce66022270ad$var$cache.has(cacheKey)) return $27a5ce66022270ad$var$cache.get(cacheKey);
    let formatter = new Intl.Collator(locale, options);
    $27a5ce66022270ad$var$cache.set(cacheKey, formatter);
    return formatter;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $832d079b867c7223$export$3274cf84b703fff(options) {
    let collator = (0, $27a5ce66022270ad$export$a16aca283550c30d)({
        usage: "search",
        ...options
    });
    // TODO(later): these methods don't currently support the ignorePunctuation option.
    let startsWith = (0, $87SwK$react.useCallback)((string, substring)=>{
        if (substring.length === 0) return true;
        // Normalize both strings so we can slice safely
        // TODO: take into account the ignorePunctuation option as well...
        string = string.normalize("NFC");
        substring = substring.normalize("NFC");
        return collator.compare(string.slice(0, substring.length), substring) === 0;
    }, [
        collator
    ]);
    let endsWith = (0, $87SwK$react.useCallback)((string, substring)=>{
        if (substring.length === 0) return true;
        string = string.normalize("NFC");
        substring = substring.normalize("NFC");
        return collator.compare(string.slice(-substring.length), substring) === 0;
    }, [
        collator
    ]);
    let contains = (0, $87SwK$react.useCallback)((string, substring)=>{
        if (substring.length === 0) return true;
        string = string.normalize("NFC");
        substring = substring.normalize("NFC");
        let scan = 0;
        let sliceLen = substring.length;
        for(; scan + sliceLen <= string.length; scan++){
            let slice = string.slice(scan, scan + sliceLen);
            if (collator.compare(substring, slice) === 0) return true;
        }
        return false;
    }, [
        collator
    ]);
    return (0, $87SwK$react.useMemo)(()=>({
            startsWith: startsWith,
            endsWith: endsWith,
            contains: contains
        }), [
        startsWith,
        endsWith,
        contains
    ]);
}




//# sourceMappingURL=real-main.js.map


/***/ }),

/***/ 70806:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.useMessageFormatter = useMessageFormatter;

var _message = __webpack_require__(81020);

var _react = __webpack_require__(18038);

var _i18n = __webpack_require__(45851);

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
const cache = new WeakMap();

function getCachedDictionary(strings) {
  let dictionary = cache.get(strings);

  if (!dictionary) {
    dictionary = new _message.MessageDictionary(strings);
    cache.set(strings, dictionary);
  }

  return dictionary;
}
/**
 * Handles formatting ICU Message strings to create localized strings for the current locale.
 * Automatically updates when the locale changes, and handles caching of messages for performance.
 * @param strings - A mapping of languages to strings by key.
 * @deprecated - use useLocalizedStringFormatter instead.
 */


function useMessageFormatter(strings) {
  let {
    locale
  } = (0, _i18n.useLocale)();
  let dictionary = (0, _react.useMemo)(() => getCachedDictionary(strings), [strings]);
  let formatter = (0, _react.useMemo)(() => new _message.MessageFormatter(locale, dictionary), [locale, dictionary]);
  return (0, _react.useCallback)((key, variables) => formatter.format(key, variables), [formatter]);
}


/***/ }),

/***/ 11519:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $goTMa$reactariautils = __webpack_require__(58277);
var $goTMa$react = __webpack_require__(18038);
var $goTMa$reactariassr = __webpack_require__(47292);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "Pressable", () => $e1dbec26039c051d$export$27c701ed9e449e99);
$parcel$export(module.exports, "PressResponder", () => $3596bae48579386f$export$3351871ee4b288b8);
$parcel$export(module.exports, "useFocus", () => $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6);
$parcel$export(module.exports, "isFocusVisible", () => $e77252a287ef94ab$export$b9b3dfddab17db27);
$parcel$export(module.exports, "getInteractionModality", () => $e77252a287ef94ab$export$630ff653c5ada6a9);
$parcel$export(module.exports, "setInteractionModality", () => $e77252a287ef94ab$export$8397ddfc504fdb9a);
$parcel$export(module.exports, "useInteractionModality", () => $e77252a287ef94ab$export$98e20ec92f614cfe);
$parcel$export(module.exports, "useFocusVisible", () => $e77252a287ef94ab$export$ffd9e5021c1fb2d6);
$parcel$export(module.exports, "useFocusVisibleListener", () => $e77252a287ef94ab$export$ec71b4b83ac08ec3);
$parcel$export(module.exports, "useFocusWithin", () => $d16842bbd0359d1b$export$420e68273165f4ec);
$parcel$export(module.exports, "useHover", () => $ffbc150311c75f01$export$ae780daf29e6d456);
$parcel$export(module.exports, "useInteractOutside", () => $edcfa848c42f94f4$export$872b660ac5a1ff98);
$parcel$export(module.exports, "useKeyboard", () => $892d64db2a3c53b0$export$8f71654801c2f7cd);
$parcel$export(module.exports, "useMove", () => $c09386fc48fa427d$export$36da96379f79f245);
$parcel$export(module.exports, "usePress", () => $0294ea432cd92340$export$45712eceda6fad21);
$parcel$export(module.exports, "useScrollWheel", () => $a3dbce0aed7087e2$export$2123ff2b87c81ca);
$parcel$export(module.exports, "useLongPress", () => $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element
// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually
let $f7e14e656343df57$var$state = "default";
let $f7e14e656343df57$var$savedUserSelect = "";
let $f7e14e656343df57$var$modifiedElementMap = new WeakMap();
function $f7e14e656343df57$export$16a4697467175487(target) {
    if ((0, $goTMa$reactariautils.isIOS)()) {
        if ($f7e14e656343df57$var$state === "default") {
            $f7e14e656343df57$var$savedUserSelect = document.documentElement.style.webkitUserSelect;
            document.documentElement.style.webkitUserSelect = "none";
        }
        $f7e14e656343df57$var$state = "disabled";
    } else if (target instanceof HTMLElement || target instanceof SVGElement) {
        // If not iOS, store the target's original user-select and change to user-select: none
        // Ignore state since it doesn't apply for non iOS
        $f7e14e656343df57$var$modifiedElementMap.set(target, target.style.userSelect);
        target.style.userSelect = "none";
    }
}
function $f7e14e656343df57$export$b0d6fa1ab32e3295(target) {
    if ((0, $goTMa$reactariautils.isIOS)()) {
        // If the state is already default, there's nothing to do.
        // If it is restoring, then there's no need to queue a second restore.
        if ($f7e14e656343df57$var$state !== "disabled") return;
        $f7e14e656343df57$var$state = "restoring";
        // There appears to be a delay on iOS where selection still might occur
        // after pointer up, so wait a bit before removing user-select.
        setTimeout(()=>{
            // Wait for any CSS transitions to complete so we don't recompute style
            // for the whole page in the middle of the animation and cause jank.
            (0, $goTMa$reactariautils.runAfterTransition)(()=>{
                // Avoid race conditions
                if ($f7e14e656343df57$var$state === "restoring") {
                    if (document.documentElement.style.webkitUserSelect === "none") document.documentElement.style.webkitUserSelect = $f7e14e656343df57$var$savedUserSelect || "";
                    $f7e14e656343df57$var$savedUserSelect = "";
                    $f7e14e656343df57$var$state = "default";
                }
            });
        }, 300);
    } else if (target instanceof HTMLElement || target instanceof SVGElement) // If not iOS, restore the target's original user-select if any
    // Ignore state since it doesn't apply for non iOS
    {
        if (target && $f7e14e656343df57$var$modifiedElementMap.has(target)) {
            let targetOldUserSelect = $f7e14e656343df57$var$modifiedElementMap.get(target);
            if (target.style.userSelect === "none") target.style.userSelect = targetOldUserSelect;
            if (target.getAttribute("style") === "") target.removeAttribute("style");
            $f7e14e656343df57$var$modifiedElementMap.delete(target);
        }
    }
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $01d3f539e91688c8$export$5165eccb35aaadb5 = (0, ($parcel$interopDefault($goTMa$react))).createContext(null);
$01d3f539e91688c8$export$5165eccb35aaadb5.displayName = "PressResponderContext";



function $0294ea432cd92340$var$usePressResponderContext(props) {
    // Consume context from <PressResponder> and merge with props.
    let context = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));
    if (context) {
        let { register: register , ...contextProps } = context;
        props = (0, $goTMa$reactariautils.mergeProps)(contextProps, props);
        register();
    }
    (0, $goTMa$reactariautils.useSyncRef)(context, props.ref);
    return props;
}
function $0294ea432cd92340$export$45712eceda6fad21(props) {
    let { onPress: onPress , onPressChange: onPressChange , onPressStart: onPressStart , onPressEnd: onPressEnd , onPressUp: onPressUp , isDisabled: isDisabled , isPressed: isPressedProp , preventFocusOnPress: preventFocusOnPress , shouldCancelOnPointerExit: shouldCancelOnPointerExit , allowTextSelectionOnPress: allowTextSelectionOnPress , // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: _ , ...domProps } = $0294ea432cd92340$var$usePressResponderContext(props);
    let [isPressed, setPressed] = (0, $goTMa$react.useState)(false);
    let ref = (0, $goTMa$react.useRef)({
        isPressed: false,
        ignoreEmulatedMouseEvents: false,
        ignoreClickAfterPress: false,
        didFirePressStart: false,
        activePointerId: null,
        target: null,
        isOverTarget: false,
        pointerType: null
    });
    let { addGlobalListener: addGlobalListener , removeAllGlobalListeners: removeAllGlobalListeners  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let triggerPressStart = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        let state = ref.current;
        if (isDisabled || state.didFirePressStart) return;
        if (onPressStart) onPressStart({
            type: "pressstart",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
        if (onPressChange) onPressChange(true);
        state.didFirePressStart = true;
        setPressed(true);
    });
    let triggerPressEnd = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType, wasPressed = true)=>{
        let state = ref.current;
        if (!state.didFirePressStart) return;
        state.ignoreClickAfterPress = true;
        state.didFirePressStart = false;
        if (onPressEnd) onPressEnd({
            type: "pressend",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
        if (onPressChange) onPressChange(false);
        setPressed(false);
        if (onPress && wasPressed && !isDisabled) onPress({
            type: "press",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let triggerPressUp = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        if (isDisabled) return;
        if (onPressUp) onPressUp({
            type: "pressup",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let cancel = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        let state = ref.current;
        if (state.isPressed) {
            if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
            state.isPressed = false;
            state.isOverTarget = false;
            state.activePointerId = null;
            state.pointerType = null;
            removeAllGlobalListeners();
            if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
        }
    });
    let cancelOnPointerExit = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (shouldCancelOnPointerExit) cancel(e);
    });
    let pressProps = (0, $goTMa$react.useMemo)(()=>{
        let state = ref.current;
        let pressProps = {
            onKeyDown (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {
                    if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                    e.stopPropagation();
                    // If the event is repeating, it may have started on a different element
                    // after which focus moved to the current element. Ignore these events and
                    // only handle the first key down event.
                    if (!state.isPressed && !e.repeat) {
                        state.target = e.currentTarget;
                        state.isPressed = true;
                        triggerPressStart(e, "keyboard");
                        // Focus may move before the key up event, so register the event on the document
                        // instead of the same element where the key down event occurred.
                        addGlobalListener(document, "keyup", onKeyUp, false);
                    }
                } else if (e.key === "Enter" && $0294ea432cd92340$var$isHTMLAnchorLink(e.currentTarget)) // If the target is a link, we won't have handled this above because we want the default
                // browser behavior to open the link when pressing Enter. But we still need to prevent
                // default so that elements above do not also handle it (e.g. table row).
                e.stopPropagation();
            },
            onKeyUp (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target)) triggerPressUp($0294ea432cd92340$var$createEvent(state.target, e), "keyboard");
            },
            onClick (e) {
                if (e && !e.currentTarget.contains(e.target)) return;
                if (e && e.button === 0) {
                    e.stopPropagation();
                    if (isDisabled) e.preventDefault();
                    // If triggered from a screen reader or by using element.click(),
                    // trigger as if it were a keyboard click.
                    if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && (state.pointerType === "virtual" || (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent))) {
                        // Ensure the element receives focus (VoiceOver on iOS does not do this)
                        if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                        triggerPressStart(e, "virtual");
                        triggerPressUp(e, "virtual");
                        triggerPressEnd(e, "virtual");
                    }
                    state.ignoreEmulatedMouseEvents = false;
                    state.ignoreClickAfterPress = false;
                }
            }
        };
        let onKeyUp = (e)=>{
            if (state.isPressed && $0294ea432cd92340$var$isValidKeyboardEvent(e, state.target)) {
                if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                e.stopPropagation();
                state.isPressed = false;
                let target = e.target;
                triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), "keyboard", state.target.contains(target));
                removeAllGlobalListeners();
                // If the target is a link, trigger the click method to open the URL,
                // but defer triggering pressEnd until onClick event handler.
                if (state.target instanceof HTMLElement && state.target.contains(target) && ($0294ea432cd92340$var$isHTMLAnchorLink(state.target) || state.target.getAttribute("role") === "link")) state.target.click();
            }
        };
        if (typeof PointerEvent !== "undefined") {
            pressProps.onPointerDown = (e)=>{
                // Only handle left clicks, and ignore events that bubbled through portals.
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.
                // Ignore and let the onClick handler take care of it instead.
                // https://bugs.webkit.org/show_bug.cgi?id=222627
                // https://bugs.webkit.org/show_bug.cgi?id=223202
                if ((0, $goTMa$reactariautils.isVirtualPointerEvent)(e.nativeEvent)) {
                    state.pointerType = "virtual";
                    return;
                }
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on pointer down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                state.pointerType = e.pointerType;
                e.stopPropagation();
                if (!state.isPressed) {
                    state.isPressed = true;
                    state.isOverTarget = true;
                    state.activePointerId = e.pointerId;
                    state.target = e.currentTarget;
                    if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                    if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);
                    triggerPressStart(e, state.pointerType);
                    addGlobalListener(document, "pointermove", onPointerMove, false);
                    addGlobalListener(document, "pointerup", onPointerUp, false);
                    addGlobalListener(document, "pointercancel", onPointerCancel, false);
                }
            };
            pressProps.onMouseDown = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (e.button === 0) {
                    // Chrome and Firefox on touch Windows devices require mouse down events
                    // to be canceled in addition to pointer events, or an extra asynchronous
                    // focus event will be fired.
                    if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                    e.stopPropagation();
                }
            };
            pressProps.onPointerUp = (e)=>{
                // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.
                if (!e.currentTarget.contains(e.target) || state.pointerType === "virtual") return;
                // Only handle left clicks
                // Safari on iOS sometimes fires pointerup events, even
                // when the touch isn't over the target, so double check.
                if (e.button === 0 && $0294ea432cd92340$var$isOverTarget(e, e.currentTarget)) triggerPressUp(e, state.pointerType || e.pointerType);
            };
            // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.
            // Use pointer move events instead to implement our own hit testing.
            // See https://bugs.webkit.org/show_bug.cgi?id=199803
            let onPointerMove = (e)=>{
                if (e.pointerId !== state.activePointerId) return;
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0) {
                    if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    state.isPressed = false;
                    state.isOverTarget = false;
                    state.activePointerId = null;
                    state.pointerType = null;
                    removeAllGlobalListeners();
                    if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
                }
            };
            let onPointerCancel = (e)=>{
                cancel(e);
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.
                cancel(e);
            };
        } else {
            pressProps.onMouseDown = (e)=>{
                // Only handle left clicks
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on mouse down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                e.stopPropagation();
                if (state.ignoreEmulatedMouseEvents) return;
                state.isPressed = true;
                state.isOverTarget = true;
                state.target = e.currentTarget;
                state.pointerType = (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent) ? "virtual" : "mouse";
                if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(document, "mouseup", onMouseUp, false);
            };
            pressProps.onMouseEnter = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = true;
                    triggerPressStart(e, state.pointerType);
                }
            };
            pressProps.onMouseLeave = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            pressProps.onMouseUp = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType);
            };
            let onMouseUp = (e)=>{
                // Only handle left clicks
                if (e.button !== 0) return;
                state.isPressed = false;
                removeAllGlobalListeners();
                if (state.ignoreEmulatedMouseEvents) {
                    state.ignoreEmulatedMouseEvents = false;
                    return;
                }
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                state.isOverTarget = false;
            };
            pressProps.onTouchStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                let touch = $0294ea432cd92340$var$getTouchFromEvent(e.nativeEvent);
                if (!touch) return;
                state.activePointerId = touch.identifier;
                state.ignoreEmulatedMouseEvents = true;
                state.isOverTarget = true;
                state.isPressed = true;
                state.target = e.currentTarget;
                state.pointerType = "touch";
                // Due to browser inconsistencies, especially on mobile browsers, we prevent default
                // on the emulated mouse event and handle focusing the pressable element ourselves.
                if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(window, "scroll", onScroll, true);
            };
            pressProps.onTouchMove = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart(e, state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            pressProps.onTouchEnd = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    triggerPressUp(e, state.pointerType);
                    triggerPressEnd(e, state.pointerType);
                } else if (state.isOverTarget) triggerPressEnd(e, state.pointerType, false);
                state.isPressed = false;
                state.activePointerId = null;
                state.isOverTarget = false;
                state.ignoreEmulatedMouseEvents = true;
                if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
                removeAllGlobalListeners();
            };
            pressProps.onTouchCancel = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed) cancel(e);
            };
            let onScroll = (e)=>{
                if (state.isPressed && e.target.contains(state.target)) cancel({
                    currentTarget: state.target,
                    shiftKey: false,
                    ctrlKey: false,
                    metaKey: false,
                    altKey: false
                });
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                cancel(e);
            };
        }
        return pressProps;
    }, [
        addGlobalListener,
        isDisabled,
        preventFocusOnPress,
        removeAllGlobalListeners,
        allowTextSelectionOnPress,
        cancel,
        cancelOnPointerExit,
        triggerPressEnd,
        triggerPressStart,
        triggerPressUp
    ]);
    // Remove user-select: none in case component unmounts immediately after pressStart
    // eslint-disable-next-line arrow-body-style
    (0, $goTMa$react.useEffect)(()=>{
        return ()=>{
            if (!allowTextSelectionOnPress) // eslint-disable-next-line react-hooks/exhaustive-deps
            (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(ref.current.target);
        };
    }, [
        allowTextSelectionOnPress
    ]);
    return {
        isPressed: isPressedProp || isPressed,
        pressProps: (0, $goTMa$reactariautils.mergeProps)(domProps, pressProps)
    };
}
function $0294ea432cd92340$var$isHTMLAnchorLink(target) {
    return target.tagName === "A" && target.hasAttribute("href");
}
function $0294ea432cd92340$var$isValidKeyboardEvent(event, currentTarget) {
    const { key: key , code: code  } = event;
    const element = currentTarget;
    const role = element.getAttribute("role");
    // Accessibility for keyboards. Space and Enter only.
    // "Spacebar" is for IE 11
    return (key === "Enter" || key === " " || key === "Spacebar" || code === "Space") && !(element instanceof HTMLInputElement && !$0294ea432cd92340$var$isValidInputKey(element, key) || element instanceof HTMLTextAreaElement || element.isContentEditable) && // A link with a valid href should be handled natively,
    // unless it also has role='button' and was triggered using Space.
    (!$0294ea432cd92340$var$isHTMLAnchorLink(element) || role === "button" && key !== "Enter") && // An element with role='link' should only trigger with Enter key
    !(role === "link" && key !== "Enter");
}
function $0294ea432cd92340$var$getTouchFromEvent(event) {
    const { targetTouches: targetTouches  } = event;
    if (targetTouches.length > 0) return targetTouches[0];
    return null;
}
function $0294ea432cd92340$var$getTouchById(event, pointerId) {
    const changedTouches = event.changedTouches;
    for(let i = 0; i < changedTouches.length; i++){
        const touch = changedTouches[i];
        if (touch.identifier === pointerId) return touch;
    }
    return null;
}
function $0294ea432cd92340$var$createEvent(target, e) {
    return {
        currentTarget: target,
        shiftKey: e.shiftKey,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey
    };
}
function $0294ea432cd92340$var$getPointClientRect(point) {
    let offsetX = point.width / 2 || point.radiusX || 0;
    let offsetY = point.height / 2 || point.radiusY || 0;
    return {
        top: point.clientY - offsetY,
        right: point.clientX + offsetX,
        bottom: point.clientY + offsetY,
        left: point.clientX - offsetX
    };
}
function $0294ea432cd92340$var$areRectanglesOverlapping(a, b) {
    // check if they cannot overlap on x axis
    if (a.left > b.right || b.left > a.right) return false;
    // check if they cannot overlap on y axis
    if (a.top > b.bottom || b.top > a.bottom) return false;
    return true;
}
function $0294ea432cd92340$var$isOverTarget(point, target) {
    let rect = target.getBoundingClientRect();
    let pointRect = $0294ea432cd92340$var$getPointClientRect(point);
    return $0294ea432cd92340$var$areRectanglesOverlapping(rect, pointRect);
}
function $0294ea432cd92340$var$shouldPreventDefault(target) {
    // We cannot prevent default if the target is a draggable element.
    return !(target instanceof HTMLElement) || !target.draggable;
}
function $0294ea432cd92340$var$shouldPreventDefaultKeyboard(target, key) {
    if (target instanceof HTMLInputElement) return !$0294ea432cd92340$var$isValidInputKey(target, key);
    if (target instanceof HTMLButtonElement) return target.type !== "submit";
    return true;
}
const $0294ea432cd92340$var$nonTextInputTypes = new Set([
    "checkbox",
    "radio",
    "range",
    "color",
    "file",
    "image",
    "button",
    "submit",
    "reset"
]);
function $0294ea432cd92340$var$isValidInputKey(target, key) {
    // Only space should toggle checkboxes and radios, not enter.
    return target.type === "checkbox" || target.type === "radio" ? key === " " : $0294ea432cd92340$var$nonTextInputTypes.has(target.type);
}



const $e1dbec26039c051d$export$27c701ed9e449e99 = /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).forwardRef(({ children: children , ...props }, ref)=>{
    let newRef = (0, $goTMa$react.useRef)();
    ref = ref !== null && ref !== void 0 ? ref : newRef;
    let { pressProps: pressProps  } = (0, $0294ea432cd92340$export$45712eceda6fad21)({
        ...props,
        ref: ref
    });
    let child = (0, ($parcel$interopDefault($goTMa$react))).Children.only(children);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).cloneElement(child, // @ts-ignore
    {
        ref: ref,
        ...(0, $goTMa$reactariautils.mergeProps)(child.props, pressProps)
    });
});


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $3596bae48579386f$export$3351871ee4b288b8 = /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).forwardRef(({ children: children , ...props }, ref)=>{
    let isRegistered = (0, $goTMa$react.useRef)(false);
    let prevContext = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));
    let context = (0, $goTMa$reactariautils.mergeProps)(prevContext || {}, {
        ...props,
        ref: ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref),
        register () {
            isRegistered.current = true;
            if (prevContext) prevContext.register();
        }
    });
    (0, $goTMa$reactariautils.useSyncRef)(prevContext, ref);
    (0, $goTMa$react.useEffect)(()=>{
        if (!isRegistered.current) {
            console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.");
            isRegistered.current = true; // only warn once in strict mode.
        }
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).createElement((0, $01d3f539e91688c8$export$5165eccb35aaadb5).Provider, {
        value: context
    }, children);
});


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

class $625cf83917e112ad$export$905e7fc544a71f36 {
    isDefaultPrevented() {
        return this.nativeEvent.defaultPrevented;
    }
    preventDefault() {
        this.defaultPrevented = true;
        this.nativeEvent.preventDefault();
    }
    stopPropagation() {
        this.nativeEvent.stopPropagation();
        this.isPropagationStopped = ()=>true;
    }
    isPropagationStopped() {
        return false;
    }
    persist() {}
    constructor(type, nativeEvent){
        this.nativeEvent = nativeEvent;
        this.target = nativeEvent.target;
        this.currentTarget = nativeEvent.currentTarget;
        this.relatedTarget = nativeEvent.relatedTarget;
        this.bubbles = nativeEvent.bubbles;
        this.cancelable = nativeEvent.cancelable;
        this.defaultPrevented = nativeEvent.defaultPrevented;
        this.eventPhase = nativeEvent.eventPhase;
        this.isTrusted = nativeEvent.isTrusted;
        this.timeStamp = nativeEvent.timeStamp;
        this.type = type;
    }
}
function $625cf83917e112ad$export$715c682d09d639cc(onBlur) {
    let stateRef = (0, $goTMa$react.useRef)({
        isFocused: false,
        observer: null
    });
    // Clean up MutationObserver on unmount. See below.
    // eslint-disable-next-line arrow-body-style
    (0, $goTMa$reactariautils.useLayoutEffect)(()=>{
        const state = stateRef.current;
        return ()=>{
            if (state.observer) {
                state.observer.disconnect();
                state.observer = null;
            }
        };
    }, []);
    let dispatchBlur = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
    });
    // This function is called during a React onFocus event.
    return (0, $goTMa$react.useCallback)((e)=>{
        // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142
        // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a
        // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.
        // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.
        if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {
            stateRef.current.isFocused = true;
            let target = e.target;
            let onBlurHandler = (e)=>{
                stateRef.current.isFocused = false;
                if (target.disabled) // For backward compatibility, dispatch a (fake) React synthetic event.
                dispatchBlur(new $625cf83917e112ad$export$905e7fc544a71f36("blur", e));
                // We no longer need the MutationObserver once the target is blurred.
                if (stateRef.current.observer) {
                    stateRef.current.observer.disconnect();
                    stateRef.current.observer = null;
                }
            };
            target.addEventListener("focusout", onBlurHandler, {
                once: true
            });
            stateRef.current.observer = new MutationObserver(()=>{
                if (stateRef.current.isFocused && target.disabled) {
                    stateRef.current.observer.disconnect();
                    let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
                    target.dispatchEvent(new FocusEvent("blur", {
                        relatedTarget: relatedTargetEl
                    }));
                    target.dispatchEvent(new FocusEvent("focusout", {
                        bubbles: true,
                        relatedTarget: relatedTargetEl
                    }));
                }
            });
            stateRef.current.observer.observe(target, {
                attributes: true,
                attributeFilter: [
                    "disabled"
                ]
            });
        }
    }, [
        dispatchBlur
    ]);
}


function $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6(props) {
    let { isDisabled: isDisabled , onFocus: onFocusProp , onBlur: onBlurProp , onFocusChange: onFocusChange  } = props;
    const onBlur = (0, $goTMa$react.useCallback)((e)=>{
        if (e.target === e.currentTarget) {
            if (onBlurProp) onBlurProp(e);
            if (onFocusChange) onFocusChange(false);
            return true;
        }
    }, [
        onBlurProp,
        onFocusChange
    ]);
    const onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);
    const onFocus = (0, $goTMa$react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (e.target === e.currentTarget && document.activeElement === e.target) {
            if (onFocusProp) onFocusProp(e);
            if (onFocusChange) onFocusChange(true);
            onSyntheticFocus(e);
        }
    }, [
        onFocusChange,
        onFocusProp,
        onSyntheticFocus
    ]);
    return {
        focusProps: {
            onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,
            onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : undefined
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions



let $e77252a287ef94ab$var$currentModality = null;
let $e77252a287ef94ab$var$changeHandlers = new Set();
let $e77252a287ef94ab$var$hasSetupGlobalListeners = false;
let $e77252a287ef94ab$var$hasEventBeforeFocus = false;
let $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
// Only Tab or Esc keys will make focus visible on text input elements
const $e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS = {
    Tab: true,
    Escape: true
};
function $e77252a287ef94ab$var$triggerChangeHandlers(modality, e) {
    for (let handler of $e77252a287ef94ab$var$changeHandlers)handler(modality, e);
}
/**
 * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.
 */ function $e77252a287ef94ab$var$isValidKey(e) {
    // Control and Shift keys trigger when navigating back to the tab with keyboard.
    return !(e.metaKey || !(0, $goTMa$reactariautils.isMac)() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
function $e77252a287ef94ab$var$handleKeyboardEvent(e) {
    $e77252a287ef94ab$var$hasEventBeforeFocus = true;
    if ($e77252a287ef94ab$var$isValidKey(e)) {
        $e77252a287ef94ab$var$currentModality = "keyboard";
        $e77252a287ef94ab$var$triggerChangeHandlers("keyboard", e);
    }
}
function $e77252a287ef94ab$var$handlePointerEvent(e) {
    $e77252a287ef94ab$var$currentModality = "pointer";
    if (e.type === "mousedown" || e.type === "pointerdown") {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$triggerChangeHandlers("pointer", e);
    }
}
function $e77252a287ef94ab$var$handleClickEvent(e) {
    if ((0, $goTMa$reactariautils.isVirtualClick)(e)) {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$currentModality = "virtual";
    }
}
function $e77252a287ef94ab$var$handleFocusEvent(e) {
    // Firefox fires two extra focus events when the user first clicks into an iframe:
    // first on the window, then on the document. We ignore these events so they don't
    // cause keyboard focus rings to appear.
    if (e.target === window || e.target === document) return;
    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.
    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.
    if (!$e77252a287ef94ab$var$hasEventBeforeFocus && !$e77252a287ef94ab$var$hasBlurredWindowRecently) {
        $e77252a287ef94ab$var$currentModality = "virtual";
        $e77252a287ef94ab$var$triggerChangeHandlers("virtual", e);
    }
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
}
function $e77252a287ef94ab$var$handleWindowBlur() {
    // When the window is blurred, reset state. This is necessary when tabbing out of the window,
    // for example, since a subsequent focus event won't be fired.
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = true;
}
/**
 * Setup global event listeners to control when keyboard focus style should be visible.
 */ function $e77252a287ef94ab$var$setupGlobalFocusEvents() {
    if (typeof window === "undefined" || $e77252a287ef94ab$var$hasSetupGlobalListeners) return;
    // Programmatic focus() calls shouldn't affect the current input modality.
    // However, we need to detect other cases when a focus event occurs without
    // a preceding user event (e.g. screen reader focus). Overriding the focus
    // method on HTMLElement.prototype is a bit hacky, but works.
    let focus = HTMLElement.prototype.focus;
    HTMLElement.prototype.focus = function() {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        focus.apply(this, arguments);
    };
    document.addEventListener("keydown", $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener("keyup", $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener("click", $e77252a287ef94ab$var$handleClickEvent, true);
    // Register focus events on the window so they are sure to happen
    // before React's event listeners (registered on the document).
    window.addEventListener("focus", $e77252a287ef94ab$var$handleFocusEvent, true);
    window.addEventListener("blur", $e77252a287ef94ab$var$handleWindowBlur, false);
    if (typeof PointerEvent !== "undefined") {
        document.addEventListener("pointerdown", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("pointermove", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("pointerup", $e77252a287ef94ab$var$handlePointerEvent, true);
    } else {
        document.addEventListener("mousedown", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("mousemove", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("mouseup", $e77252a287ef94ab$var$handlePointerEvent, true);
    }
    $e77252a287ef94ab$var$hasSetupGlobalListeners = true;
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e77252a287ef94ab$var$setupGlobalFocusEvents();
    else document.addEventListener("DOMContentLoaded", $e77252a287ef94ab$var$setupGlobalFocusEvents);
}
function $e77252a287ef94ab$export$b9b3dfddab17db27() {
    return $e77252a287ef94ab$var$currentModality !== "pointer";
}
function $e77252a287ef94ab$export$630ff653c5ada6a9() {
    return $e77252a287ef94ab$var$currentModality;
}
function $e77252a287ef94ab$export$8397ddfc504fdb9a(modality) {
    $e77252a287ef94ab$var$currentModality = modality;
    $e77252a287ef94ab$var$triggerChangeHandlers(modality, null);
}
function $e77252a287ef94ab$export$98e20ec92f614cfe() {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    let [modality, setModality] = (0, $goTMa$react.useState)($e77252a287ef94ab$var$currentModality);
    (0, $goTMa$react.useEffect)(()=>{
        let handler = ()=>{
            setModality($e77252a287ef94ab$var$currentModality);
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    }, []);
    return (0, $goTMa$reactariassr.useIsSSR)() ? null : modality;
}
/**
 * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that
 * focus visible style can be properly set.
 */ function $e77252a287ef94ab$var$isKeyboardFocusEvent(isTextInput, modality, e) {
    return !(isTextInput && modality === "keyboard" && e instanceof KeyboardEvent && !$e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);
}
function $e77252a287ef94ab$export$ffd9e5021c1fb2d6(props = {}) {
    let { isTextInput: isTextInput , autoFocus: autoFocus  } = props;
    let [isFocusVisibleState, setFocusVisible] = (0, $goTMa$react.useState)(autoFocus || $e77252a287ef94ab$export$b9b3dfddab17db27());
    $e77252a287ef94ab$export$ec71b4b83ac08ec3((isFocusVisible)=>{
        setFocusVisible(isFocusVisible);
    }, [
        isTextInput
    ], {
        isTextInput: isTextInput
    });
    return {
        isFocusVisible: isFocusVisibleState
    };
}
function $e77252a287ef94ab$export$ec71b4b83ac08ec3(fn, deps, opts) {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    (0, $goTMa$react.useEffect)(()=>{
        let handler = (modality, e)=>{
            if (!$e77252a287ef94ab$var$isKeyboardFocusEvent(opts === null || opts === void 0 ? void 0 : opts.isTextInput, modality, e)) return;
            fn($e77252a287ef94ab$export$b9b3dfddab17db27());
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, deps);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $d16842bbd0359d1b$export$420e68273165f4ec(props) {
    let { isDisabled: isDisabled , onBlurWithin: onBlurWithin , onFocusWithin: onFocusWithin , onFocusWithinChange: onFocusWithinChange  } = props;
    let state = (0, $goTMa$react.useRef)({
        isFocusWithin: false
    });
    let onBlur = (0, $goTMa$react.useCallback)((e)=>{
        // We don't want to trigger onBlurWithin and then immediately onFocusWithin again
        // when moving focus inside the element. Only trigger if the currentTarget doesn't
        // include the relatedTarget (where focus is moving).
        if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {
            state.current.isFocusWithin = false;
            if (onBlurWithin) onBlurWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(false);
        }
    }, [
        onBlurWithin,
        onFocusWithinChange,
        state
    ]);
    let onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);
    let onFocus = (0, $goTMa$react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (!state.current.isFocusWithin && document.activeElement === e.target) {
            if (onFocusWithin) onFocusWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(true);
            state.current.isFocusWithin = true;
            onSyntheticFocus(e);
        }
    }, [
        onFocusWithin,
        onFocusWithinChange,
        onSyntheticFocus
    ]);
    if (isDisabled) return {
        focusWithinProps: {
            onFocus: null,
            onBlur: null
        }
    };
    return {
        focusWithinProps: {
            onFocus: onFocus,
            onBlur: onBlur
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

// iOS fires onPointerEnter twice: once with pointerType="touch" and again with pointerType="mouse".
// We want to ignore these emulated events so they do not trigger hover behavior.
// See https://bugs.webkit.org/show_bug.cgi?id=214609.
let $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
let $ffbc150311c75f01$var$hoverCount = 0;
function $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents() {
    $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = true;
    // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter
    // with pointerType="mouse" immediately after onPointerUp and before onFocus. On other
    // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in
    // the distant future because a user previously touched the element.
    setTimeout(()=>{
        $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
    }, 50);
}
function $ffbc150311c75f01$var$handleGlobalPointerEvent(e) {
    if (e.pointerType === "touch") $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $ffbc150311c75f01$var$setupGlobalTouchEvents() {
    if (typeof document === "undefined") return;
    if (typeof PointerEvent !== "undefined") document.addEventListener("pointerup", $ffbc150311c75f01$var$handleGlobalPointerEvent);
    else document.addEventListener("touchend", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    $ffbc150311c75f01$var$hoverCount++;
    return ()=>{
        $ffbc150311c75f01$var$hoverCount--;
        if ($ffbc150311c75f01$var$hoverCount > 0) return;
        if (typeof PointerEvent !== "undefined") document.removeEventListener("pointerup", $ffbc150311c75f01$var$handleGlobalPointerEvent);
        else document.removeEventListener("touchend", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    };
}
function $ffbc150311c75f01$export$ae780daf29e6d456(props) {
    let { onHoverStart: onHoverStart , onHoverChange: onHoverChange , onHoverEnd: onHoverEnd , isDisabled: isDisabled  } = props;
    let [isHovered, setHovered] = (0, $goTMa$react.useState)(false);
    let state = (0, $goTMa$react.useRef)({
        isHovered: false,
        ignoreEmulatedMouseEvents: false,
        pointerType: "",
        target: null
    }).current;
    (0, $goTMa$react.useEffect)($ffbc150311c75f01$var$setupGlobalTouchEvents, []);
    let { hoverProps: hoverProps , triggerHoverEnd: triggerHoverEnd  } = (0, $goTMa$react.useMemo)(()=>{
        let triggerHoverStart = (event, pointerType)=>{
            state.pointerType = pointerType;
            if (isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target)) return;
            state.isHovered = true;
            let target = event.currentTarget;
            state.target = target;
            if (onHoverStart) onHoverStart({
                type: "hoverstart",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(true);
            setHovered(true);
        };
        let triggerHoverEnd = (event, pointerType)=>{
            state.pointerType = "";
            state.target = null;
            if (pointerType === "touch" || !state.isHovered) return;
            state.isHovered = false;
            let target = event.currentTarget;
            if (onHoverEnd) onHoverEnd({
                type: "hoverend",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(false);
            setHovered(false);
        };
        let hoverProps = {};
        if (typeof PointerEvent !== "undefined") {
            hoverProps.onPointerEnter = (e)=>{
                if ($ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents && e.pointerType === "mouse") return;
                triggerHoverStart(e, e.pointerType);
            };
            hoverProps.onPointerLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);
            };
        } else {
            hoverProps.onTouchStart = ()=>{
                state.ignoreEmulatedMouseEvents = true;
            };
            hoverProps.onMouseEnter = (e)=>{
                if (!state.ignoreEmulatedMouseEvents && !$ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, "mouse");
                state.ignoreEmulatedMouseEvents = false;
            };
            hoverProps.onMouseLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, "mouse");
            };
        }
        return {
            hoverProps: hoverProps,
            triggerHoverEnd: triggerHoverEnd
        };
    }, [
        onHoverStart,
        onHoverChange,
        onHoverEnd,
        isDisabled,
        state
    ]);
    (0, $goTMa$react.useEffect)(()=>{
        // Call the triggerHoverEnd as soon as isDisabled changes to true
        // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering
        if (isDisabled) triggerHoverEnd({
            currentTarget: state.target
        }, state.pointerType);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        isDisabled
    ]);
    return {
        hoverProps: hoverProps,
        isHovered: isHovered
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $edcfa848c42f94f4$export$872b660ac5a1ff98(props) {
    let { ref: ref , onInteractOutside: onInteractOutside , isDisabled: isDisabled , onInteractOutsideStart: onInteractOutsideStart  } = props;
    let stateRef = (0, $goTMa$react.useRef)({
        isPointerDown: false,
        ignoreEmulatedMouseEvents: false
    });
    let onPointerDown = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (onInteractOutside && $edcfa848c42f94f4$var$isValidEvent(e, ref)) {
            if (onInteractOutsideStart) onInteractOutsideStart(e);
            stateRef.current.isPointerDown = true;
        }
    });
    let triggerInteractOutside = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (onInteractOutside) onInteractOutside(e);
    });
    (0, $goTMa$react.useEffect)(()=>{
        let state = stateRef.current;
        if (isDisabled) return;
        // Use pointer events if available. Otherwise, fall back to mouse and touch events.
        if (typeof PointerEvent !== "undefined") {
            let onPointerUp = (e)=>{
                if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            // changing these to capture phase fixed combobox
            document.addEventListener("pointerdown", onPointerDown, true);
            document.addEventListener("pointerup", onPointerUp, true);
            return ()=>{
                document.removeEventListener("pointerdown", onPointerDown, true);
                document.removeEventListener("pointerup", onPointerUp, true);
            };
        } else {
            let onMouseUp = (e)=>{
                if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;
                else if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            let onTouchEnd = (e)=>{
                state.ignoreEmulatedMouseEvents = true;
                if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            document.addEventListener("mousedown", onPointerDown, true);
            document.addEventListener("mouseup", onMouseUp, true);
            document.addEventListener("touchstart", onPointerDown, true);
            document.addEventListener("touchend", onTouchEnd, true);
            return ()=>{
                document.removeEventListener("mousedown", onPointerDown, true);
                document.removeEventListener("mouseup", onMouseUp, true);
                document.removeEventListener("touchstart", onPointerDown, true);
                document.removeEventListener("touchend", onTouchEnd, true);
            };
        }
    }, [
        ref,
        isDisabled,
        onPointerDown,
        triggerInteractOutside
    ]);
}
function $edcfa848c42f94f4$var$isValidEvent(event, ref) {
    if (event.button > 0) return false;
    if (event.target) {
        // if the event target is no longer in the document, ignore
        const ownerDocument = event.target.ownerDocument;
        if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;
        // If the target is within a top layer element (e.g. toasts), ignore.
        if (event.target.closest("[data-react-aria-top-layer]")) return false;
    }
    return ref.current && !ref.current.contains(event.target);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $951fbcbbca8db6ce$export$48d1ea6320830260(handler) {
    if (!handler) return;
    let shouldStopPropagation = true;
    return (e)=>{
        let event = {
            ...e,
            preventDefault () {
                e.preventDefault();
            },
            isDefaultPrevented () {
                return e.isDefaultPrevented();
            },
            stopPropagation () {
                console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
            },
            continuePropagation () {
                shouldStopPropagation = false;
            }
        };
        handler(event);
        if (shouldStopPropagation) e.stopPropagation();
    };
}


function $892d64db2a3c53b0$export$8f71654801c2f7cd(props) {
    return {
        keyboardProps: props.isDisabled ? {} : {
            onKeyDown: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyDown),
            onKeyUp: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyUp)
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $c09386fc48fa427d$export$36da96379f79f245(props) {
    let { onMoveStart: onMoveStart , onMove: onMove , onMoveEnd: onMoveEnd  } = props;
    let state = (0, $goTMa$react.useRef)({
        didMove: false,
        lastPosition: null,
        id: null
    });
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let move = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType, deltaX, deltaY)=>{
        if (deltaX === 0 && deltaY === 0) return;
        if (!state.current.didMove) {
            state.current.didMove = true;
            onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart({
                type: "movestart",
                pointerType: pointerType,
                shiftKey: originalEvent.shiftKey,
                metaKey: originalEvent.metaKey,
                ctrlKey: originalEvent.ctrlKey,
                altKey: originalEvent.altKey
            });
        }
        onMove({
            type: "move",
            pointerType: pointerType,
            deltaX: deltaX,
            deltaY: deltaY,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let end = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)();
        if (state.current.didMove) onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd({
            type: "moveend",
            pointerType: pointerType,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let moveProps = (0, $goTMa$react.useMemo)(()=>{
        let moveProps = {};
        let start = ()=>{
            (0, $f7e14e656343df57$export$16a4697467175487)();
            state.current.didMove = false;
        };
        if (typeof PointerEvent === "undefined") {
            let onMouseMove = (e)=>{
                if (e.button === 0) {
                    move(e, "mouse", e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onMouseUp = (e)=>{
                if (e.button === 0) {
                    end(e, "mouse");
                    removeGlobalListener(window, "mousemove", onMouseMove, false);
                    removeGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            moveProps.onMouseDown = (e)=>{
                if (e.button === 0) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    addGlobalListener(window, "mousemove", onMouseMove, false);
                    addGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            let onTouchMove = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id);
                if (touch >= 0) {
                    let { pageX: pageX , pageY: pageY  } = e.changedTouches[touch];
                    move(e, "touch", pageX - state.current.lastPosition.pageX, pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: pageX,
                        pageY: pageY
                    };
                }
            };
            let onTouchEnd = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id);
                if (touch >= 0) {
                    end(e, "touch");
                    state.current.id = null;
                    removeGlobalListener(window, "touchmove", onTouchMove);
                    removeGlobalListener(window, "touchend", onTouchEnd);
                    removeGlobalListener(window, "touchcancel", onTouchEnd);
                }
            };
            moveProps.onTouchStart = (e)=>{
                if (e.changedTouches.length === 0 || state.current.id != null) return;
                let { pageX: pageX , pageY: pageY , identifier: identifier  } = e.changedTouches[0];
                start();
                e.stopPropagation();
                e.preventDefault();
                state.current.lastPosition = {
                    pageX: pageX,
                    pageY: pageY
                };
                state.current.id = identifier;
                addGlobalListener(window, "touchmove", onTouchMove, false);
                addGlobalListener(window, "touchend", onTouchEnd, false);
                addGlobalListener(window, "touchcancel", onTouchEnd, false);
            };
        } else {
            let onPointerMove = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    // Problems with PointerEvent#movementX/movementY:
                    // 1. it is always 0 on macOS Safari.
                    // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS
                    move(e, pointerType, e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    end(e, pointerType);
                    state.current.id = null;
                    removeGlobalListener(window, "pointermove", onPointerMove, false);
                    removeGlobalListener(window, "pointerup", onPointerUp, false);
                    removeGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
            moveProps.onPointerDown = (e)=>{
                if (e.button === 0 && state.current.id == null) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    state.current.id = e.pointerId;
                    addGlobalListener(window, "pointermove", onPointerMove, false);
                    addGlobalListener(window, "pointerup", onPointerUp, false);
                    addGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
        }
        let triggerKeyboardMove = (e, deltaX, deltaY)=>{
            start();
            move(e, "keyboard", deltaX, deltaY);
            end(e, "keyboard");
        };
        moveProps.onKeyDown = (e)=>{
            switch(e.key){
                case "Left":
                case "ArrowLeft":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, -1, 0);
                    break;
                case "Right":
                case "ArrowRight":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 1, 0);
                    break;
                case "Up":
                case "ArrowUp":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, -1);
                    break;
                case "Down":
                case "ArrowDown":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, 1);
                    break;
            }
        };
        return moveProps;
    }, [
        state,
        addGlobalListener,
        removeGlobalListener,
        move,
        end
    ]);
    return {
        moveProps: moveProps
    };
}



/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $a3dbce0aed7087e2$export$2123ff2b87c81ca(props, ref) {
    let { onScroll: onScroll , isDisabled: isDisabled  } = props;
    let onScrollHandler = (0, $goTMa$react.useCallback)((e)=>{
        // If the ctrlKey is pressed, this is a zoom event, do nothing.
        if (e.ctrlKey) return;
        // stop scrolling the page
        e.preventDefault();
        e.stopPropagation();
        if (onScroll) onScroll({
            deltaX: e.deltaX,
            deltaY: e.deltaY
        });
    }, [
        onScroll
    ]);
    (0, $goTMa$reactariautils.useEvent)(ref, "wheel", isDisabled ? null : onScrollHandler);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD = 500;
function $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9(props) {
    let { isDisabled: isDisabled , onLongPressStart: onLongPressStart , onLongPressEnd: onLongPressEnd , onLongPress: onLongPress , threshold: threshold = $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD , accessibilityDescription: accessibilityDescription  } = props;
    const timeRef = (0, $goTMa$react.useRef)(null);
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let { pressProps: pressProps  } = (0, $0294ea432cd92340$export$45712eceda6fad21)({
        isDisabled: isDisabled,
        onPressStart (e) {
            if (e.pointerType === "mouse" || e.pointerType === "touch") {
                if (onLongPressStart) onLongPressStart({
                    ...e,
                    type: "longpressstart"
                });
                timeRef.current = setTimeout(()=>{
                    // Prevent other usePress handlers from also handling this event.
                    e.target.dispatchEvent(new PointerEvent("pointercancel", {
                        bubbles: true
                    }));
                    if (onLongPress) onLongPress({
                        ...e,
                        type: "longpress"
                    });
                    timeRef.current = null;
                }, threshold);
                // Prevent context menu, which may be opened on long press on touch devices
                if (e.pointerType === "touch") {
                    let onContextMenu = (e)=>{
                        e.preventDefault();
                    };
                    addGlobalListener(e.target, "contextmenu", onContextMenu, {
                        once: true
                    });
                    addGlobalListener(window, "pointerup", ()=>{
                        // If no contextmenu event is fired quickly after pointerup, remove the handler
                        // so future context menu events outside a long press are not prevented.
                        setTimeout(()=>{
                            removeGlobalListener(e.target, "contextmenu", onContextMenu);
                        }, 30);
                    }, {
                        once: true
                    });
                }
            }
        },
        onPressEnd (e) {
            if (timeRef.current) clearTimeout(timeRef.current);
            if (onLongPressEnd && (e.pointerType === "mouse" || e.pointerType === "touch")) onLongPressEnd({
                ...e,
                type: "longpressend"
            });
        }
    });
    let descriptionProps = (0, $goTMa$reactariautils.useDescription)(onLongPress && !isDisabled ? accessibilityDescription : null);
    return {
        longPressProps: (0, $goTMa$reactariautils.mergeProps)(pressProps, descriptionProps)
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 47292:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $4hxXn$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "SSRProvider", () => $29383e587d62412a$export$9f8ac96af4b1b2ae);
$parcel$export(module.exports, "useSSRSafeId", () => $29383e587d62412a$export$619500959fc48b26);
$parcel$export(module.exports, "useIsSSR", () => $29383e587d62412a$export$535bd6ca7f90a273);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We must avoid a circular dependency with @react-aria/utils, and this useLayoutEffect is
// guarded by a check that it only runs on the client side.
// eslint-disable-next-line rulesdir/useLayoutEffectRule

// Default context value to use in case there is no SSRProvider. This is fine for
// client-only apps. In order to support multiple copies of React Aria potentially
// being on the page at once, the prefix is set to a random number. SSRProvider
// will reset this to zero for consistency between server and client, so in the
// SSR case multiple copies of React Aria is not supported.
const $29383e587d62412a$var$defaultContext = {
    prefix: String(Math.round(Math.random() * 10000000000)),
    current: 0,
    isSSR: false
};
const $29383e587d62412a$var$SSRContext = /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createContext($29383e587d62412a$var$defaultContext);
// This is only used in React < 18.
function $29383e587d62412a$var$LegacySSRProvider(props) {
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let counter = $29383e587d62412a$var$useCounter(cur === $29383e587d62412a$var$defaultContext);
    let [isSSR, setIsSSR] = (0, $4hxXn$react.useState)(true);
    let value = (0, $4hxXn$react.useMemo)(()=>({
            // If this is the first SSRProvider, start with an empty string prefix, otherwise
            // append and increment the counter.
            prefix: cur === $29383e587d62412a$var$defaultContext ? "" : `${cur.prefix}-${counter}`,
            current: 0,
            isSSR: isSSR
        }), [
        cur,
        counter,
        isSSR
    ]);
    // If on the client, and the component was initially server rendered,
    // then schedule a layout effect to update the component after hydration.
    if (typeof window !== "undefined") // This if statement technically breaks the rules of hooks, but is safe
    // because the condition never changes after mounting.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, $4hxXn$react.useLayoutEffect)(()=>{
        setIsSSR(false);
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$SSRContext.Provider, {
        value: value
    }, props.children);
}
let $29383e587d62412a$var$warnedAboutSSRProvider = false;
function $29383e587d62412a$export$9f8ac96af4b1b2ae(props) {
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function") {
        if (!$29383e587d62412a$var$warnedAboutSSRProvider) {
            console.warn("In React 18, SSRProvider is not necessary and is a noop. You can remove it from your app.");
            $29383e587d62412a$var$warnedAboutSSRProvider = true;
        }
        return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement((0, ($parcel$interopDefault($4hxXn$react))).Fragment, null, props.children);
    }
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$LegacySSRProvider, props);
}
let $29383e587d62412a$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
let $29383e587d62412a$var$componentIds = new WeakMap();
function $29383e587d62412a$var$useCounter(isDisabled = false) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let ref = (0, $4hxXn$react.useRef)(null);
    // eslint-disable-next-line rulesdir/pure-render
    if (ref.current === null && !isDisabled) {
        var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner;
        // In strict mode, React renders components twice, and the ref will be reset to null on the second render.
        // This means our id counter will be incremented twice instead of once. This is a problem because on the
        // server, components are only rendered once and so ids generated on the server won't match the client.
        // In React 18, useId was introduced to solve this, but it is not available in older versions. So to solve this
        // we need to use some React internals to access the underlying Fiber instance, which is stable between renders.
        // This is exposed as ReactCurrentOwner in development, which is all we need since StrictMode only runs in development.
        // To ensure that we only increment the global counter once, we store the starting id for this component in
        // a weak map associated with the Fiber. On the second render, we reset the global counter to this value.
        // Since React runs the second render immediately after the first, this is safe.
        // @ts-ignore
        let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, ($parcel$interopDefault($4hxXn$react))).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;
        if (currentOwner) {
            let prevComponentValue = $29383e587d62412a$var$componentIds.get(currentOwner);
            if (prevComponentValue == null) // On the first render, and first call to useId, store the id and state in our weak map.
            $29383e587d62412a$var$componentIds.set(currentOwner, {
                id: ctx.current,
                state: currentOwner.memoizedState
            });
            else if (currentOwner.memoizedState !== prevComponentValue.state) {
                // On the second render, the memoizedState gets reset by React.
                // Reset the counter, and remove from the weak map so we don't
                // do this for subsequent useId calls.
                ctx.current = prevComponentValue.id;
                $29383e587d62412a$var$componentIds.delete(currentOwner);
            }
        }
        // eslint-disable-next-line rulesdir/pure-render
        ref.current = ++ctx.current;
    }
    // eslint-disable-next-line rulesdir/pure-render
    return ref.current;
}
function $29383e587d62412a$var$useLegacySSRSafeId(defaultId) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    // If we are rendering in a non-DOM environment, and there's no SSRProvider,
    // provide a warning to hint to the developer to add one.
    if (ctx === $29383e587d62412a$var$defaultContext && !$29383e587d62412a$var$canUseDOM) console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
    let counter = $29383e587d62412a$var$useCounter(!!defaultId);
    return defaultId || `react-aria${ctx.prefix}-${counter}`;
}
function $29383e587d62412a$var$useModernSSRSafeId(defaultId) {
    // @ts-ignore
    let id = (0, ($parcel$interopDefault($4hxXn$react))).useId();
    let [didSSR] = (0, $4hxXn$react.useState)($29383e587d62412a$export$535bd6ca7f90a273());
    let prefix = didSSR ? "react-aria" : `react-aria${$29383e587d62412a$var$defaultContext.prefix}`;
    return defaultId || `${prefix}-${id}`;
}
const $29383e587d62412a$export$619500959fc48b26 = typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function" ? $29383e587d62412a$var$useModernSSRSafeId : $29383e587d62412a$var$useLegacySSRSafeId;
function $29383e587d62412a$var$getSnapshot() {
    return false;
}
function $29383e587d62412a$var$getServerSnapshot() {
    return true;
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function $29383e587d62412a$var$subscribe(onStoreChange) {
    // noop
    return ()=>{};
}
function $29383e587d62412a$export$535bd6ca7f90a273() {
    // In React 18, we can use useSyncExternalStore to detect if we're server rendering or hydrating.
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"] === "function") return (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"]($29383e587d62412a$var$subscribe, $29383e587d62412a$var$getSnapshot, $29383e587d62412a$var$getServerSnapshot);
    // eslint-disable-next-line react-hooks/rules-of-hooks
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    return cur.isSSR;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 58277:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $1Yh1N$reactstatelyutils = __webpack_require__(12259);
var $1Yh1N$react = __webpack_require__(18038);
var $1Yh1N$reactariassr = __webpack_require__(47292);
var $1Yh1N$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useId", () => $8c61827343eed941$export$f680877a34711e37);
$parcel$export(module.exports, "mergeIds", () => $8c61827343eed941$export$cd8c9cb68f842629);
$parcel$export(module.exports, "useSlotId", () => $8c61827343eed941$export$b4cc09c592e8fdb8);
$parcel$export(module.exports, "chain", () => $1e2191638e54f613$export$e08e3b67e392101e);
$parcel$export(module.exports, "mergeProps", () => $f847cd1382ea7cd4$export$9d1611c77c2fe928);
$parcel$export(module.exports, "mergeRefs", () => $f05dc24eafaeb7e2$export$c9058316764c140e);
$parcel$export(module.exports, "filterDOMProps", () => $8d15d0e1797d4238$export$457c3d6518dd4c6f);
$parcel$export(module.exports, "focusWithoutScrolling", () => $1117b6c0d4c4c164$export$de79e2c695e052f3);
$parcel$export(module.exports, "getOffset", () => $16ec41ef3e36c19c$export$622cea445a1c5b7d);
$parcel$export(module.exports, "runAfterTransition", () => $e8117ebcab55be6a$export$24490316f764c430);
$parcel$export(module.exports, "useDrag1D", () => $28ed3fb20343b78b$export$7bbed75feba39706);
$parcel$export(module.exports, "useGlobalListeners", () => $4571ff54ac709100$export$4eaf04e54aa8eed6);
$parcel$export(module.exports, "useLabels", () => $6ec78bde395c477d$export$d6875122194c7b44);
$parcel$export(module.exports, "useObjectRef", () => $475b35fe72ba49b3$export$4338b53315abf666);
$parcel$export(module.exports, "useUpdateEffect", () => $29293a6f5c75b37e$export$496315a1608d9602);
$parcel$export(module.exports, "useLayoutEffect", () => $78605a5d7424e31b$export$e5c5a5f917a5871c);
$parcel$export(module.exports, "useResizeObserver", () => $37733e1652f47193$export$683480f191c0e3ea);
$parcel$export(module.exports, "useSyncRef", () => $6fc733991a9f977c$export$4debdb1a3f0fa79e);
$parcel$export(module.exports, "getScrollParent", () => $d796e7157ac96470$export$cfa2225e87938781);
$parcel$export(module.exports, "isScrollable", () => $d796e7157ac96470$export$2bb74740c4e19def);
$parcel$export(module.exports, "useViewportSize", () => $8b24bab62f5c65ad$export$d699905dd57c73ca);
$parcel$export(module.exports, "useDescription", () => $34da4502ea8120db$export$f8aeda7b10753fa1);
$parcel$export(module.exports, "isMac", () => $9e20cff0af27e8cc$export$9ac100e40613ea10);
$parcel$export(module.exports, "isIPhone", () => $9e20cff0af27e8cc$export$186c6964ca17d99);
$parcel$export(module.exports, "isIPad", () => $9e20cff0af27e8cc$export$7bef049ce92e4224);
$parcel$export(module.exports, "isIOS", () => $9e20cff0af27e8cc$export$fedb369cb70207f1);
$parcel$export(module.exports, "isAppleDevice", () => $9e20cff0af27e8cc$export$e1865c3bedcd822b);
$parcel$export(module.exports, "isWebKit", () => $9e20cff0af27e8cc$export$78551043582a6a98);
$parcel$export(module.exports, "isChrome", () => $9e20cff0af27e8cc$export$6446a186d09e379e);
$parcel$export(module.exports, "isAndroid", () => $9e20cff0af27e8cc$export$a11b0059900ceec8);
$parcel$export(module.exports, "useEvent", () => $2a8c0bb1629926c8$export$90fc3a17d93f704c);
$parcel$export(module.exports, "useValueEffect", () => $19a2307bfabafaf1$export$14d238f342723f25);
$parcel$export(module.exports, "scrollIntoView", () => $449412113267a1fe$export$53a0910f038337bd);
$parcel$export(module.exports, "scrollIntoViewport", () => $449412113267a1fe$export$c826860796309d1b);
$parcel$export(module.exports, "clamp", () => $1Yh1N$reactstatelyutils.clamp);
$parcel$export(module.exports, "snapValueToStep", () => $1Yh1N$reactstatelyutils.snapValueToStep);
$parcel$export(module.exports, "isVirtualClick", () => $577e795361f19be9$export$60278871457622de);
$parcel$export(module.exports, "isVirtualPointerEvent", () => $577e795361f19be9$export$29bf1b5f2c56cf63);
$parcel$export(module.exports, "useEffectEvent", () => $1254e5bb94ac8761$export$7f54fc3180508a52);
$parcel$export(module.exports, "useDeepMemo", () => $20e6e72fbf5dc81e$export$722debc0e56fea39);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $78605a5d7424e31b$export$e5c5a5f917a5871c = typeof window !== "undefined" ? (0, ($parcel$interopDefault($1Yh1N$react))).useLayoutEffect : ()=>{};



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $19a2307bfabafaf1$export$14d238f342723f25(defaultValue) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultValue);
    let valueRef = (0, $1Yh1N$react.useRef)(value);
    let effect = (0, $1Yh1N$react.useRef)(null);
    // Must be stable so that `queue` is stable.
    let nextIter = (0, $1Yh1N$react.useCallback)(()=>{
        // Run the generator to the next yield.
        let newValue = effect.current.next();
        while(!newValue.done && valueRef.current === newValue.value)// If the value is the same as the current value,
        // then continue to the next yield. Otherwise,
        // set the value in state and wait for the next layout effect.
        newValue = effect.current.next();
        // If the generator is done, reset the effect.
        if (newValue.done) {
            effect.current = null;
            return;
        }
        // Always update valueRef when setting the state.
        // This is needed because the function is not regenerated with the new state value since
        // they must be stable across renders. Instead, it gets carried in the ref, but the setState
        // is also needed in order to cause a rerender.
        setValue(newValue.value);
        valueRef.current = newValue.value;
    // this list of dependencies is stable, setState and refs never change after first render.
    }, [
        setValue,
        valueRef,
        effect
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        // If there is an effect currently running, continue to the next yield.
        if (effect.current) nextIter();
    });
    // queue must be a stable function, much like setState.
    let queue = (0, $1Yh1N$react.useCallback)((fn)=>{
        effect.current = fn(valueRef.current);
        nextIter();
    // this list of dependencies is stable, setState and refs never change after first render.
    // in addition, nextIter is stable as outlined above
    }, [
        nextIter,
        effect,
        valueRef
    ]);
    return [
        value,
        queue
    ];
}


let $8c61827343eed941$var$idsUpdaterMap = new Map();
function $8c61827343eed941$export$f680877a34711e37(defaultId) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultId);
    let nextId = (0, $1Yh1N$react.useRef)(null);
    let res = (0, $1Yh1N$reactariassr.useSSRSafeId)(value);
    let updateValue = (0, $1Yh1N$react.useCallback)((val)=>{
        nextId.current = val;
    }, []);
    $8c61827343eed941$var$idsUpdaterMap.set(res, updateValue);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        let r = res;
        return ()=>{
            $8c61827343eed941$var$idsUpdaterMap.delete(r);
        };
    }, [
        res
    ]);
    // This cannot cause an infinite loop because the ref is updated first.
    // eslint-disable-next-line
    (0, $1Yh1N$react.useEffect)(()=>{
        let newId = nextId.current;
        if (newId) {
            nextId.current = null;
            setValue(newId);
        }
    });
    return res;
}
function $8c61827343eed941$export$cd8c9cb68f842629(idA, idB) {
    if (idA === idB) return idA;
    let setIdA = $8c61827343eed941$var$idsUpdaterMap.get(idA);
    if (setIdA) {
        setIdA(idB);
        return idB;
    }
    let setIdB = $8c61827343eed941$var$idsUpdaterMap.get(idB);
    if (setIdB) {
        setIdB(idA);
        return idA;
    }
    return idB;
}
function $8c61827343eed941$export$b4cc09c592e8fdb8(depArray = []) {
    let id = $8c61827343eed941$export$f680877a34711e37();
    let [resolvedId, setResolvedId] = (0, $19a2307bfabafaf1$export$14d238f342723f25)(id);
    let updateId = (0, $1Yh1N$react.useCallback)(()=>{
        setResolvedId(function*() {
            yield id;
            yield document.getElementById(id) ? id : undefined;
        });
    }, [
        id,
        setResolvedId
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(updateId, [
        id,
        updateId,
        ...depArray
    ]);
    return resolvedId;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /**
 * Calls all functions in the order they were chained with the same arguments.
 */ function $1e2191638e54f613$export$e08e3b67e392101e(...callbacks) {
    return (...args)=>{
        for (let callback of callbacks)if (typeof callback === "function") callback(...args);
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $f847cd1382ea7cd4$export$9d1611c77c2fe928(...args) {
    // Start with a base clone of the first argument. This is a lot faster than starting
    // with an empty object and adding properties as we go.
    let result = {
        ...args[0]
    };
    for(let i = 1; i < args.length; i++){
        let props = args[i];
        for(let key in props){
            let a = result[key];
            let b = props[key];
            // Chain events
            if (typeof a === "function" && typeof b === "function" && // This is a lot faster than a regex.
            key[0] === "o" && key[1] === "n" && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = (0, $1e2191638e54f613$export$e08e3b67e392101e)(a, b);
            else if ((key === "className" || key === "UNSAFE_className") && typeof a === "string" && typeof b === "string") result[key] = (0, ($parcel$interopDefault($1Yh1N$clsx)))(a, b);
            else if (key === "id" && a && b) result.id = (0, $8c61827343eed941$export$cd8c9cb68f842629)(a, b);
            else result[key] = b !== undefined ? b : a;
        }
    }
    return result;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $f05dc24eafaeb7e2$export$c9058316764c140e(...refs) {
    if (refs.length === 1) return refs[0];
    return (value)=>{
        for (let ref of refs){
            if (typeof ref === "function") ref(value);
            else if (ref != null) ref.current = value;
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ const $8d15d0e1797d4238$var$DOMPropNames = new Set([
    "id"
]);
const $8d15d0e1797d4238$var$labelablePropNames = new Set([
    "aria-label",
    "aria-labelledby",
    "aria-describedby",
    "aria-details"
]);
const $8d15d0e1797d4238$var$propRe = /^(data-.*)$/;
function $8d15d0e1797d4238$export$457c3d6518dd4c6f(props, opts = {}) {
    let { labelable: labelable , propNames: propNames  } = opts;
    let filteredProps = {};
    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($8d15d0e1797d4238$var$DOMPropNames.has(prop) || labelable && $8d15d0e1797d4238$var$labelablePropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $8d15d0e1797d4238$var$propRe.test(prop))) filteredProps[prop] = props[prop];
    return filteredProps;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $1117b6c0d4c4c164$export$de79e2c695e052f3(element) {
    if ($1117b6c0d4c4c164$var$supportsPreventScroll()) element.focus({
        preventScroll: true
    });
    else {
        let scrollableElements = $1117b6c0d4c4c164$var$getScrollableElements(element);
        element.focus();
        $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements);
    }
}
let $1117b6c0d4c4c164$var$supportsPreventScrollCached = null;
function $1117b6c0d4c4c164$var$supportsPreventScroll() {
    if ($1117b6c0d4c4c164$var$supportsPreventScrollCached == null) {
        $1117b6c0d4c4c164$var$supportsPreventScrollCached = false;
        try {
            var focusElem = document.createElement("div");
            focusElem.focus({
                get preventScroll () {
                    $1117b6c0d4c4c164$var$supportsPreventScrollCached = true;
                    return true;
                }
            });
        } catch (e) {
        // Ignore
        }
    }
    return $1117b6c0d4c4c164$var$supportsPreventScrollCached;
}
function $1117b6c0d4c4c164$var$getScrollableElements(element) {
    var parent = element.parentNode;
    var scrollableElements = [];
    var rootScrollingElement = document.scrollingElement || document.documentElement;
    while(parent instanceof HTMLElement && parent !== rootScrollingElement){
        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({
            element: parent,
            scrollTop: parent.scrollTop,
            scrollLeft: parent.scrollLeft
        });
        parent = parent.parentNode;
    }
    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
        element: rootScrollingElement,
        scrollTop: rootScrollingElement.scrollTop,
        scrollLeft: rootScrollingElement.scrollLeft
    });
    return scrollableElements;
}
function $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements) {
    for (let { element: element , scrollTop: scrollTop , scrollLeft: scrollLeft  } of scrollableElements){
        element.scrollTop = scrollTop;
        element.scrollLeft = scrollLeft;
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $16ec41ef3e36c19c$export$622cea445a1c5b7d(element, reverse, orientation = "horizontal") {
    let rect = element.getBoundingClientRect();
    if (reverse) return orientation === "horizontal" ? rect.right : rect.bottom;
    return orientation === "horizontal" ? rect.left : rect.top;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We store a global list of elements that are currently transitioning,
// mapped to a set of CSS properties that are transitioning for that element.
// This is necessary rather than a simple count of transitions because of browser
// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather
// than one or the other. So we need to track what's actually transitioning so that
// we can ignore these duplicate events.
let $e8117ebcab55be6a$var$transitionsByElement = new Map();
// A list of callbacks to call once there are no transitioning elements.
let $e8117ebcab55be6a$var$transitionCallbacks = new Set();
function $e8117ebcab55be6a$var$setupGlobalEvents() {
    if (typeof window === "undefined") return;
    let onTransitionStart = (e)=>{
        // Add the transitioning property to the list for this element.
        let transitions = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!transitions) {
            transitions = new Set();
            $e8117ebcab55be6a$var$transitionsByElement.set(e.target, transitions);
            // The transitioncancel event must be registered on the element itself, rather than as a global
            // event. This enables us to handle when the node is deleted from the document while it is transitioning.
            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.
            e.target.addEventListener("transitioncancel", onTransitionEnd);
        }
        transitions.add(e.propertyName);
    };
    let onTransitionEnd = (e)=>{
        // Remove property from list of transitioning properties.
        let properties = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!properties) return;
        properties.delete(e.propertyName);
        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.
        if (properties.size === 0) {
            e.target.removeEventListener("transitioncancel", onTransitionEnd);
            $e8117ebcab55be6a$var$transitionsByElement.delete(e.target);
        }
        // If no transitioning elements, call all of the queued callbacks.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) {
            for (let cb of $e8117ebcab55be6a$var$transitionCallbacks)cb();
            $e8117ebcab55be6a$var$transitionCallbacks.clear();
        }
    };
    document.body.addEventListener("transitionrun", onTransitionStart);
    document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e8117ebcab55be6a$var$setupGlobalEvents();
    else document.addEventListener("DOMContentLoaded", $e8117ebcab55be6a$var$setupGlobalEvents);
}
function $e8117ebcab55be6a$export$24490316f764c430(fn) {
    // Wait one frame to see if an animation starts, e.g. a transition on mount.
    requestAnimationFrame(()=>{
        // If no transitions are running, call the function immediately.
        // Otherwise, add it to a list of callbacks to run at the end of the animation.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) fn();
        else $e8117ebcab55be6a$var$transitionCallbacks.add(fn);
    });
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 

// Keep track of elements that we are currently handling dragging for via useDrag1D.
// If there's an ancestor and a descendant both using useDrag1D(), and the user starts
// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.
const $28ed3fb20343b78b$var$draggingElements = [];
function $28ed3fb20343b78b$export$7bbed75feba39706(props) {
    console.warn("useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html");
    let { containerRef: containerRef , reverse: reverse , orientation: orientation , onHover: onHover , onDrag: onDrag , onPositionChange: onPositionChange , onIncrement: onIncrement , onDecrement: onDecrement , onIncrementToMax: onIncrementToMax , onDecrementToMin: onDecrementToMin , onCollapseToggle: onCollapseToggle  } = props;
    let getPosition = (e)=>orientation === "horizontal" ? e.clientX : e.clientY;
    let getNextOffset = (e)=>{
        let containerOffset = (0, $16ec41ef3e36c19c$export$622cea445a1c5b7d)(containerRef.current, reverse, orientation);
        let mouseOffset = getPosition(e);
        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;
        return nextOffset;
    };
    let dragging = (0, $1Yh1N$react.useRef)(false);
    let prevPosition = (0, $1Yh1N$react.useRef)(0);
    // Keep track of the current handlers in a ref so that the events can access them.
    let handlers = (0, $1Yh1N$react.useRef)({
        onPositionChange: onPositionChange,
        onDrag: onDrag
    });
    handlers.current.onDrag = onDrag;
    handlers.current.onPositionChange = onPositionChange;
    let onMouseDragged = (e)=>{
        e.preventDefault();
        let nextOffset = getNextOffset(e);
        if (!dragging.current) {
            dragging.current = true;
            if (handlers.current.onDrag) handlers.current.onDrag(true);
            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        }
        if (prevPosition.current === nextOffset) return;
        prevPosition.current = nextOffset;
        if (onPositionChange) onPositionChange(nextOffset);
    };
    let onMouseUp = (e)=>{
        const target = e.target;
        dragging.current = false;
        let nextOffset = getNextOffset(e);
        if (handlers.current.onDrag) handlers.current.onDrag(false);
        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        $28ed3fb20343b78b$var$draggingElements.splice($28ed3fb20343b78b$var$draggingElements.indexOf(target), 1);
        window.removeEventListener("mouseup", onMouseUp, false);
        window.removeEventListener("mousemove", onMouseDragged, false);
    };
    let onMouseDown = (e)=>{
        const target = e.currentTarget;
        // If we're already handling dragging on a descendant with useDrag1D, then
        // we don't want to handle the drag motion on this target as well.
        if ($28ed3fb20343b78b$var$draggingElements.some((elt)=>target.contains(elt))) return;
        $28ed3fb20343b78b$var$draggingElements.push(target);
        window.addEventListener("mousemove", onMouseDragged, false);
        window.addEventListener("mouseup", onMouseUp, false);
    };
    let onMouseEnter = ()=>{
        if (onHover) onHover(true);
    };
    let onMouseOut = ()=>{
        if (onHover) onHover(false);
    };
    let onKeyDown = (e)=>{
        switch(e.key){
            case "Left":
            case "ArrowLeft":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Up":
            case "ArrowUp":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Right":
            case "ArrowRight":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Down":
            case "ArrowDown":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Home":
                e.preventDefault();
                if (onDecrementToMin) onDecrementToMin();
                break;
            case "End":
                e.preventDefault();
                if (onIncrementToMax) onIncrementToMax();
                break;
            case "Enter":
                e.preventDefault();
                if (onCollapseToggle) onCollapseToggle();
                break;
        }
    };
    return {
        onMouseDown: onMouseDown,
        onMouseEnter: onMouseEnter,
        onMouseOut: onMouseOut,
        onKeyDown: onKeyDown
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $4571ff54ac709100$export$4eaf04e54aa8eed6() {
    let globalListeners = (0, $1Yh1N$react.useRef)(new Map());
    let addGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        // Make sure we remove the listener after it is called with the `once` option.
        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{
            globalListeners.current.delete(listener);
            listener(...args);
        } : listener;
        globalListeners.current.set(listener, {
            type: type,
            eventTarget: eventTarget,
            fn: fn,
            options: options
        });
        eventTarget.addEventListener(type, listener, options);
    }, []);
    let removeGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        var _globalListeners_current_get;
        let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
        eventTarget.removeEventListener(type, fn, options);
        globalListeners.current.delete(listener);
    }, []);
    let removeAllGlobalListeners = (0, $1Yh1N$react.useCallback)(()=>{
        globalListeners.current.forEach((value, key)=>{
            removeGlobalListener(value.eventTarget, value.type, key, value.options);
        });
    }, [
        removeGlobalListener
    ]);
    // eslint-disable-next-line arrow-body-style
    (0, $1Yh1N$react.useEffect)(()=>{
        return removeAllGlobalListeners;
    }, [
        removeAllGlobalListeners
    ]);
    return {
        addGlobalListener: addGlobalListener,
        removeGlobalListener: removeGlobalListener,
        removeAllGlobalListeners: removeAllGlobalListeners
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6ec78bde395c477d$export$d6875122194c7b44(props, defaultLabel) {
    let { id: id , "aria-label": label , "aria-labelledby": labelledBy  } = props;
    // If there is both an aria-label and aria-labelledby,
    // combine them by pointing to the element itself.
    id = (0, $8c61827343eed941$export$f680877a34711e37)(id);
    if (labelledBy && label) {
        let ids = new Set([
            id,
            ...labelledBy.trim().split(/\s+/)
        ]);
        labelledBy = [
            ...ids
        ].join(" ");
    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\s+/).join(" ");
    // If no labels are provided, use the default
    if (!label && !labelledBy && defaultLabel) label = defaultLabel;
    return {
        id: id,
        "aria-label": label,
        "aria-labelledby": labelledBy
    };
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $475b35fe72ba49b3$export$4338b53315abf666(forwardedRef) {
    const objRef = (0, $1Yh1N$react.useRef)();
    return (0, $1Yh1N$react.useMemo)(()=>({
            get current () {
                return objRef.current;
            },
            set current (value){
                objRef.current = value;
                if (typeof forwardedRef === "function") forwardedRef(value);
                else if (forwardedRef) forwardedRef.current = value;
            }
        }), [
        forwardedRef
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $29293a6f5c75b37e$export$496315a1608d9602(effect, dependencies) {
    const isInitialMount = (0, $1Yh1N$react.useRef)(true);
    const lastDeps = (0, $1Yh1N$react.useRef)(null);
    (0, $1Yh1N$react.useEffect)(()=>{
        isInitialMount.current = true;
        return ()=>{
            isInitialMount.current = false;
        };
    }, []);
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isInitialMount.current) isInitialMount.current = false;
        else if (!lastDeps.current || dependencies.some((dep, i)=>!Object.is(dep, lastDeps[i]))) effect();
        lastDeps.current = dependencies;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencies);
}




function $37733e1652f47193$var$hasResizeObserver() {
    return typeof window.ResizeObserver !== "undefined";
}
function $37733e1652f47193$export$683480f191c0e3ea(options) {
    const { ref: ref , onResize: onResize  } = options;
    (0, $1Yh1N$react.useEffect)(()=>{
        let element = ref === null || ref === void 0 ? void 0 : ref.current;
        if (!element) return;
        if (!$37733e1652f47193$var$hasResizeObserver()) {
            window.addEventListener("resize", onResize, false);
            return ()=>{
                window.removeEventListener("resize", onResize, false);
            };
        } else {
            const resizeObserverInstance = new window.ResizeObserver((entries)=>{
                if (!entries.length) return;
                onResize();
            });
            resizeObserverInstance.observe(element);
            return ()=>{
                if (element) resizeObserverInstance.unobserve(element);
            };
        }
    }, [
        onResize,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6fc733991a9f977c$export$4debdb1a3f0fa79e(context, ref) {
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (context && context.ref && ref) {
            context.ref.current = ref.current;
            return ()=>{
                context.ref.current = null;
            };
        }
    }, [
        context,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d796e7157ac96470$export$cfa2225e87938781(node) {
    if ($d796e7157ac96470$export$2bb74740c4e19def(node)) node = node.parentElement;
    while(node && !$d796e7157ac96470$export$2bb74740c4e19def(node))node = node.parentElement;
    return node || document.scrollingElement || document.documentElement;
}
function $d796e7157ac96470$export$2bb74740c4e19def(node) {
    let style = window.getComputedStyle(node);
    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// @ts-ignore
let $8b24bab62f5c65ad$var$visualViewport = typeof window !== "undefined" && window.visualViewport;
function $8b24bab62f5c65ad$export$d699905dd57c73ca() {
    let [size, setSize] = (0, $1Yh1N$react.useState)(()=>$8b24bab62f5c65ad$var$getViewportSize());
    (0, $1Yh1N$react.useEffect)(()=>{
        // Use visualViewport api to track available height even on iOS virtual keyboard opening
        let onResize = ()=>{
            setSize((size)=>{
                let newSize = $8b24bab62f5c65ad$var$getViewportSize();
                if (newSize.width === size.width && newSize.height === size.height) return size;
                return newSize;
            });
        };
        if (!$8b24bab62f5c65ad$var$visualViewport) window.addEventListener("resize", onResize);
        else $8b24bab62f5c65ad$var$visualViewport.addEventListener("resize", onResize);
        return ()=>{
            if (!$8b24bab62f5c65ad$var$visualViewport) window.removeEventListener("resize", onResize);
            else $8b24bab62f5c65ad$var$visualViewport.removeEventListener("resize", onResize);
        };
    }, []);
    return size;
}
function $8b24bab62f5c65ad$var$getViewportSize() {
    return {
        width: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.width) || window.innerWidth,
        height: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.height) || window.innerHeight
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

let $34da4502ea8120db$var$descriptionId = 0;
const $34da4502ea8120db$var$descriptionNodes = new Map();
function $34da4502ea8120db$export$f8aeda7b10753fa1(description) {
    let [id, setId] = (0, $1Yh1N$react.useState)(undefined);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (!description) return;
        let desc = $34da4502ea8120db$var$descriptionNodes.get(description);
        if (!desc) {
            let id = `react-aria-description-${$34da4502ea8120db$var$descriptionId++}`;
            setId(id);
            let node = document.createElement("div");
            node.id = id;
            node.style.display = "none";
            node.textContent = description;
            document.body.appendChild(node);
            desc = {
                refCount: 0,
                element: node
            };
            $34da4502ea8120db$var$descriptionNodes.set(description, desc);
        } else setId(desc.element.id);
        desc.refCount++;
        return ()=>{
            if (--desc.refCount === 0) {
                desc.element.remove();
                $34da4502ea8120db$var$descriptionNodes.delete(description);
            }
        };
    }, [
        description
    ]);
    return {
        "aria-describedby": description ? id : undefined
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $9e20cff0af27e8cc$var$testUserAgent(re) {
    var _window_navigator_userAgentData;
    if (typeof window === "undefined" || window.navigator == null) return false;
    return ((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand)=>re.test(brand.brand))) || re.test(window.navigator.userAgent);
}
function $9e20cff0af27e8cc$var$testPlatform(re) {
    var _window_navigator_userAgentData;
    return typeof window !== "undefined" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $9e20cff0af27e8cc$export$9ac100e40613ea10() {
    return $9e20cff0af27e8cc$var$testPlatform(/^Mac/i);
}
function $9e20cff0af27e8cc$export$186c6964ca17d99() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPhone/i);
}
function $9e20cff0af27e8cc$export$7bef049ce92e4224() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
    $9e20cff0af27e8cc$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
}
function $9e20cff0af27e8cc$export$fedb369cb70207f1() {
    return $9e20cff0af27e8cc$export$186c6964ca17d99() || $9e20cff0af27e8cc$export$7bef049ce92e4224();
}
function $9e20cff0af27e8cc$export$e1865c3bedcd822b() {
    return $9e20cff0af27e8cc$export$9ac100e40613ea10() || $9e20cff0af27e8cc$export$fedb369cb70207f1();
}
function $9e20cff0af27e8cc$export$78551043582a6a98() {
    return $9e20cff0af27e8cc$var$testUserAgent(/AppleWebKit/i) && !$9e20cff0af27e8cc$export$6446a186d09e379e();
}
function $9e20cff0af27e8cc$export$6446a186d09e379e() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Chrome/i);
}
function $9e20cff0af27e8cc$export$a11b0059900ceec8() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Android/i);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1254e5bb94ac8761$export$7f54fc3180508a52(fn) {
    const ref = (0, $1Yh1N$react.useRef)(null);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        ref.current = fn;
    }, [
        fn
    ]);
    return (0, $1Yh1N$react.useCallback)((...args)=>{
        const f = ref.current;
        return f(...args);
    }, []);
}


function $2a8c0bb1629926c8$export$90fc3a17d93f704c(ref, event, handler, options) {
    let handleEvent = (0, $1254e5bb94ac8761$export$7f54fc3180508a52)(handler);
    let isDisabled = handler == null;
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isDisabled) return;
        let element = ref.current;
        element.addEventListener(event, handleEvent, options);
        return ()=>{
            element.removeEventListener(event, handleEvent, options);
        };
    }, [
        ref,
        event,
        options,
        isDisabled,
        handleEvent
    ]);
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $449412113267a1fe$export$53a0910f038337bd(scrollView, element) {
    let offsetX = $449412113267a1fe$var$relativeOffset(scrollView, element, "left");
    let offsetY = $449412113267a1fe$var$relativeOffset(scrollView, element, "top");
    let width = element.offsetWidth;
    let height = element.offsetHeight;
    let x = scrollView.scrollLeft;
    let y = scrollView.scrollTop;
    // Account for top/left border offsetting the scroll top/Left
    let { borderTopWidth: borderTopWidth , borderLeftWidth: borderLeftWidth  } = getComputedStyle(scrollView);
    let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);
    let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);
    // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width
    let maxX = borderAdjustedX + scrollView.clientWidth;
    let maxY = borderAdjustedY + scrollView.clientHeight;
    if (offsetX <= x) x = offsetX - parseInt(borderLeftWidth, 10);
    else if (offsetX + width > maxX) x += offsetX + width - maxX;
    if (offsetY <= borderAdjustedY) y = offsetY - parseInt(borderTopWidth, 10);
    else if (offsetY + height > maxY) y += offsetY + height - maxY;
    scrollView.scrollLeft = x;
    scrollView.scrollTop = y;
}
/**
 * Computes the offset left or top from child to ancestor by accumulating
 * offsetLeft or offsetTop through intervening offsetParents.
 */ function $449412113267a1fe$var$relativeOffset(ancestor, child, axis) {
    const prop = axis === "left" ? "offsetLeft" : "offsetTop";
    let sum = 0;
    while(child.offsetParent){
        sum += child[prop];
        if (child.offsetParent === ancestor) break;
        else if (child.offsetParent.contains(ancestor)) {
            // If the ancestor is not `position:relative`, then we stop at
            // _its_ offset parent, and we subtract off _its_ offset, so that
            // we end up with the proper offset from child to ancestor.
            sum -= ancestor[prop];
            break;
        }
        child = child.offsetParent;
    }
    return sum;
}
function $449412113267a1fe$export$c826860796309d1b(targetElement, opts) {
    if (document.contains(targetElement)) {
        let root = document.scrollingElement || document.documentElement;
        let isScrollPrevented = window.getComputedStyle(root).overflow === "hidden";
        // If scrolling is not currently prevented then we aren’t in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view
        if (!isScrollPrevented) {
            var // use scrollIntoView({block: 'nearest'}) instead of .focus to check if the element is fully in view or not since .focus()
            // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically
            _targetElement_scrollIntoView;
            let { left: originalLeft , top: originalTop  } = targetElement.getBoundingClientRect();
            targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {
                block: "nearest"
            });
            let { left: newLeft , top: newTop  } = targetElement.getBoundingClientRect();
            // Account for sub pixel differences from rounding
            if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {
                var _opts_containingElement, _opts_containingElement_scrollIntoView, _targetElement_scrollIntoView1;
                opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {
                    block: "center",
                    inline: "center"
                });
                (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {
                    block: "nearest"
                });
            }
        } else {
            let scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.
            while(targetElement && scrollParent && targetElement !== root && scrollParent !== root){
                $449412113267a1fe$export$53a0910f038337bd(scrollParent, targetElement);
                targetElement = scrollParent;
                scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            }
        }
    }
}



/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $577e795361f19be9$export$60278871457622de(event) {
    // JAWS/NVDA with Firefox.
    if (event.mozInputSource === 0 && event.isTrusted) return true;
    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead
    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check
    // to detect TalkBack virtual clicks.
    if ((0, $9e20cff0af27e8cc$export$a11b0059900ceec8)() && event.pointerType) return event.type === "click" && event.buttons === 1;
    return event.detail === 0 && !event.pointerType;
}
function $577e795361f19be9$export$29bf1b5f2c56cf63(event) {
    // If the pointer size is zero, then we assume it's from a screen reader.
    // Android TalkBack double tap will sometimes return a event with width and height of 1
    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.
    // Cannot use "event.pressure === 0" as the sole check due to Safari pointer events always returning pressure === 0
    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush
    // Talkback double tap from Windows Firefox touch screen press
    return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse";
}



/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 
function $20e6e72fbf5dc81e$export$722debc0e56fea39(value, isEqual) {
    // Using a ref during render is ok here because it's only an optimization – both values are equivalent.
    // If a render is thrown away, it'll still work the same no matter if the next render is the same or not.
    let lastValue = (0, $1Yh1N$react.useRef)(null);
    if (value && lastValue.current && isEqual(value, lastValue.current)) value = lastValue.current;
    lastValue.current = value;
    return value;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 48690:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $4aZkW$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "Item", () => $c870f3b549c61b6b$export$6d08773d2e66f8f2);
$parcel$export(module.exports, "Section", () => $350f13aa4d8b327c$export$6e2c8f0811a474ce);
$parcel$export(module.exports, "useCollection", () => $98fc0fafaca75b6a$export$6cd28814d92fa9c9);
$parcel$export(module.exports, "getItemCount", () => $e749fe52977fe2c2$export$77d5aafae4e095b2);
$parcel$export(module.exports, "getChildNodes", () => $7a155683b0d79a6a$export$1005530eda016c13);
$parcel$export(module.exports, "getFirstItem", () => $7a155683b0d79a6a$export$fbdeaa6a76694f71);
$parcel$export(module.exports, "getLastItem", () => $7a155683b0d79a6a$export$7475b2c64539e4cf);
$parcel$export(module.exports, "getNthItem", () => $7a155683b0d79a6a$export$5f3398f8733f90e2);
$parcel$export(module.exports, "compareNodeOrder", () => $7a155683b0d79a6a$export$8c434b3a7a4dad6);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $c870f3b549c61b6b$var$Item(props) {
    return null;
}
$c870f3b549c61b6b$var$Item.getCollectionNode = function* getCollectionNode(props, context) {
    let { childItems: childItems , title: title , children: children  } = props;
    let rendered = props.title || props.children;
    let textValue = props.textValue || (typeof rendered === "string" ? rendered : "") || props["aria-label"] || "";
    // suppressTextValueWarning is used in components like Tabs, which don't have type to select support.
    if (!textValue && !(context === null || context === void 0 ? void 0 : context.suppressTextValueWarning)) console.warn("<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.");
    yield {
        type: "item",
        props: props,
        rendered: rendered,
        textValue: textValue,
        "aria-label": props["aria-label"],
        hasChildNodes: $c870f3b549c61b6b$var$hasChildItems(props),
        *childNodes () {
            if (childItems) for (let child of childItems)yield {
                type: "item",
                value: child
            };
            else if (title) {
                let items = [];
                (0, ($parcel$interopDefault($4aZkW$react))).Children.forEach(children, (child)=>{
                    items.push({
                        type: "item",
                        element: child
                    });
                });
                yield* items;
            }
        }
    };
};
function $c870f3b549c61b6b$var$hasChildItems(props) {
    if (props.hasChildItems != null) return props.hasChildItems;
    if (props.childItems) return true;
    if (props.title && (0, ($parcel$interopDefault($4aZkW$react))).Children.count(props.children) > 0) return true;
    return false;
}
// We don't want getCollectionNode to show up in the type definition
let $c870f3b549c61b6b$export$6d08773d2e66f8f2 = $c870f3b549c61b6b$var$Item;


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $350f13aa4d8b327c$var$Section(props) {
    return null;
}
$350f13aa4d8b327c$var$Section.getCollectionNode = function* getCollectionNode(props) {
    let { children: children , title: title , items: items  } = props;
    yield {
        type: "section",
        props: props,
        hasChildNodes: true,
        rendered: title,
        "aria-label": props["aria-label"],
        *childNodes () {
            if (typeof children === "function") {
                if (!items) throw new Error("props.children was a function but props.items is missing");
                for (let item of items)yield {
                    type: "item",
                    value: item,
                    renderer: children
                };
            } else {
                let items = [];
                (0, ($parcel$interopDefault($4aZkW$react))).Children.forEach(children, (child)=>{
                    items.push({
                        type: "item",
                        element: child
                    });
                });
                yield* items;
            }
        }
    };
};
// We don't want getCollectionNode to show up in the type definition
let $350f13aa4d8b327c$export$6e2c8f0811a474ce = $350f13aa4d8b327c$var$Section;


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
class $51588fd411aace25$export$bf788dd355e3a401 {
    build(props, context) {
        this.context = context;
        return $51588fd411aace25$var$iterable(()=>this.iterateCollection(props));
    }
    *iterateCollection(props) {
        let { children: children , items: items  } = props;
        if (typeof children === "function") {
            if (!items) throw new Error("props.children was a function but props.items is missing");
            for (let item of props.items)yield* this.getFullNode({
                value: item
            }, {
                renderer: children
            });
        } else {
            let items = [];
            (0, ($parcel$interopDefault($4aZkW$react))).Children.forEach(children, (child)=>{
                items.push(child);
            });
            let index = 0;
            for (let item of items){
                let nodes = this.getFullNode({
                    element: item,
                    index: index
                }, {});
                for (let node of nodes){
                    index++;
                    yield node;
                }
            }
        }
    }
    getKey(item, partialNode, state, parentKey) {
        if (item.key != null) return item.key;
        if (partialNode.type === "cell" && partialNode.key != null) return `${parentKey}${partialNode.key}`;
        let v = partialNode.value;
        if (v != null) {
            var _v_key;
            let key = (_v_key = v.key) !== null && _v_key !== void 0 ? _v_key : v.id;
            if (key == null) throw new Error("No key found for item");
            return key;
        }
        return parentKey ? `${parentKey}.${partialNode.index}` : `$.${partialNode.index}`;
    }
    getChildState(state, partialNode) {
        return {
            renderer: partialNode.renderer || state.renderer
        };
    }
    *getFullNode(partialNode, state, parentKey, parentNode) {
        // If there's a value instead of an element on the node, and a parent renderer function is available,
        // use it to render an element for the value.
        let element = partialNode.element;
        if (!element && partialNode.value && state && state.renderer) {
            let cached = this.cache.get(partialNode.value);
            if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {
                cached.index = partialNode.index;
                cached.parentKey = parentNode ? parentNode.key : null;
                yield cached;
                return;
            }
            element = state.renderer(partialNode.value);
        }
        // If there's an element with a getCollectionNode function on its type, then it's a supported component.
        // Call this function to get a partial node, and recursively build a full node from there.
        if ((0, ($parcel$interopDefault($4aZkW$react))).isValidElement(element)) {
            let type = element.type;
            if (typeof type !== "function" && typeof type.getCollectionNode !== "function") {
                let name = typeof element.type === "function" ? element.type.name : element.type;
                throw new Error(`Unknown element <${name}> in collection.`);
            }
            let childNodes = type.getCollectionNode(element.props, this.context);
            let index = partialNode.index;
            let result = childNodes.next();
            while(!result.done && result.value){
                let childNode = result.value;
                partialNode.index = index;
                let nodeKey = childNode.key;
                if (!nodeKey) nodeKey = childNode.element ? null : this.getKey(element, partialNode, state, parentKey);
                let nodes = this.getFullNode({
                    ...childNode,
                    key: nodeKey,
                    index: index,
                    wrapper: $51588fd411aace25$var$compose(partialNode.wrapper, childNode.wrapper)
                }, this.getChildState(state, childNode), parentKey ? `${parentKey}${element.key}` : element.key, parentNode);
                let children = [
                    ...nodes
                ];
                for (let node of children){
                    // Cache the node based on its value
                    node.value = childNode.value || partialNode.value;
                    if (node.value) this.cache.set(node.value, node);
                    // The partial node may have specified a type for the child in order to specify a constraint.
                    // Verify that the full node that was built recursively matches this type.
                    if (partialNode.type && node.type !== partialNode.type) throw new Error(`Unsupported type <${$51588fd411aace25$var$capitalize(node.type)}> in <${$51588fd411aace25$var$capitalize(parentNode.type)}>. Only <${$51588fd411aace25$var$capitalize(partialNode.type)}> is supported.`);
                    index++;
                    yield node;
                }
                result = childNodes.next(children);
            }
            return;
        }
        // Ignore invalid elements
        if (partialNode.key == null) return;
        // Create full node
        let builder = this;
        let node = {
            type: partialNode.type,
            props: partialNode.props,
            key: partialNode.key,
            parentKey: parentNode ? parentNode.key : null,
            value: partialNode.value,
            level: parentNode ? parentNode.level + 1 : 0,
            index: partialNode.index,
            rendered: partialNode.rendered,
            textValue: partialNode.textValue,
            "aria-label": partialNode["aria-label"],
            wrapper: partialNode.wrapper,
            shouldInvalidate: partialNode.shouldInvalidate,
            hasChildNodes: partialNode.hasChildNodes,
            childNodes: $51588fd411aace25$var$iterable(function*() {
                if (!partialNode.hasChildNodes) return;
                let index = 0;
                for (let child of partialNode.childNodes()){
                    // Ensure child keys are globally unique by prepending the parent node's key
                    if (child.key != null) // TODO: Remove this line entirely and enforce that users always provide unique keys.
                    // Currently this line will have issues when a parent has a key `a` and a child with key `bc`
                    // but another parent has key `ab` and its child has a key `c`. The combined keys would result in both
                    // children having a key of `abc`.
                    child.key = `${node.key}${child.key}`;
                    child.index = index;
                    let nodes = builder.getFullNode(child, builder.getChildState(state, child), node.key, node);
                    for (let node of nodes){
                        index++;
                        yield node;
                    }
                }
            })
        };
        yield node;
    }
    constructor(){
        this.cache = new WeakMap();
    }
}
// Wraps an iterator function as an iterable object, and caches the results.
function $51588fd411aace25$var$iterable(iterator) {
    let cache = [];
    let iterable = null;
    return {
        *[Symbol.iterator] () {
            for (let item of cache)yield item;
            if (!iterable) iterable = iterator();
            for (let item of iterable){
                cache.push(item);
                yield item;
            }
        }
    };
}
function $51588fd411aace25$var$compose(outer, inner) {
    if (outer && inner) return (element)=>outer(inner(element));
    if (outer) return outer;
    if (inner) return inner;
}
function $51588fd411aace25$var$capitalize(str) {
    return str[0].toUpperCase() + str.slice(1);
}



function $98fc0fafaca75b6a$export$6cd28814d92fa9c9(props, factory, context) {
    let builder = (0, $4aZkW$react.useMemo)(()=>new (0, $51588fd411aace25$export$bf788dd355e3a401)(), []);
    let { children: children , items: items , collection: collection  } = props;
    let result = (0, $4aZkW$react.useMemo)(()=>{
        if (collection) return collection;
        let nodes = builder.build({
            children: children,
            items: items
        }, context);
        return factory(nodes);
    }, [
        builder,
        children,
        items,
        collection,
        context,
        factory
    ]);
    return result;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $7a155683b0d79a6a$export$1005530eda016c13(node, collection) {
    // New API: call collection.getChildren with the node key.
    if (typeof collection.getChildren === "function") return collection.getChildren(node.key);
    // Old API: access childNodes directly.
    return node.childNodes;
}
function $7a155683b0d79a6a$export$fbdeaa6a76694f71(iterable) {
    return $7a155683b0d79a6a$export$5f3398f8733f90e2(iterable, 0);
}
function $7a155683b0d79a6a$export$5f3398f8733f90e2(iterable, index) {
    if (index < 0) return undefined;
    let i = 0;
    for (let item of iterable){
        if (i === index) return item;
        i++;
    }
}
function $7a155683b0d79a6a$export$7475b2c64539e4cf(iterable) {
    let lastItem = undefined;
    for (let value of iterable)lastItem = value;
    return lastItem;
}
function $7a155683b0d79a6a$export$8c434b3a7a4dad6(collection, a, b) {
    // If the two nodes have the same parent, compare their indices.
    if (a.parentKey === b.parentKey) return a.index - b.index;
    // Otherwise, collect all of the ancestors from each node, and find the first one that doesn't match starting from the root.
    let aAncestors = $7a155683b0d79a6a$var$getAncestors(collection, a);
    let bAncestors = $7a155683b0d79a6a$var$getAncestors(collection, b);
    let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a, i)=>a !== bAncestors[i]);
    if (firstNonMatchingAncestor !== -1) {
        // Compare the indices of two children within the common ancestor.
        a = aAncestors[firstNonMatchingAncestor];
        b = bAncestors[firstNonMatchingAncestor];
        return a.index - b.index;
    }
    // 🤷
    return -1;
}
function $7a155683b0d79a6a$var$getAncestors(collection, node) {
    let parents = [];
    while((node === null || node === void 0 ? void 0 : node.parentKey) != null){
        node = collection.getItem(node.parentKey);
        parents.unshift(node);
    }
    return parents;
}


const $e749fe52977fe2c2$var$cache = new WeakMap();
function $e749fe52977fe2c2$export$77d5aafae4e095b2(collection) {
    let count = $e749fe52977fe2c2$var$cache.get(collection);
    if (count != null) return count;
    count = 0;
    let countItems = (items)=>{
        for (let item of items)if (item.type === "section") countItems((0, $7a155683b0d79a6a$export$1005530eda016c13)(item, collection));
        else count++;
    };
    countItems(collection);
    $e749fe52977fe2c2$var$cache.set(collection, count);
    return count;
}





//# sourceMappingURL=main.js.map


/***/ }),

/***/ 2211:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// useMessageFormatter is deprecated, but has a large dependency on intl-messageformat
// that we want to avoid. If it is built into the same file as the rest of the package,
// it deopts tree shaking in Parcel even when unused. Instead, it is split into a separate
// file and re-exported here, which allows tree shaking to work properly.
module.exports = __webpack_require__(96393);
Object.defineProperties(module.exports, Object.getOwnPropertyDescriptors(__webpack_require__(51135)));


/***/ }),

/***/ 96393:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $87SwK$react = __webpack_require__(18038);
var $87SwK$reactariassr = __webpack_require__(65444);
var $87SwK$internationalizedstring = __webpack_require__(36058);
var $87SwK$internationalizeddate = __webpack_require__(50031);
var $87SwK$internationalizednumber = __webpack_require__(8483);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "I18nProvider", () => $47fa5ec5ff482271$export$a54013f0d02a8f82);
$parcel$export(module.exports, "useLocale", () => $47fa5ec5ff482271$export$43bb16f9c6d9e3f7);
$parcel$export(module.exports, "useMessageFormatter", () => $227f31f0c647c5fc$exports.useMessageFormatter);
$parcel$export(module.exports, "useLocalizedStringFormatter", () => $fc53663969a3d00a$export$f12b703ca79dfbb1);
$parcel$export(module.exports, "useListFormatter", () => $cb6a3e7d490e97a4$export$a2f47a3d2973640);
$parcel$export(module.exports, "useDateFormatter", () => $b80c530ff2e20243$export$85fd5fdf27bacc79);
$parcel$export(module.exports, "useNumberFormatter", () => $fea93c5b7c90d9f4$export$b7a616150fdb9f44);
$parcel$export(module.exports, "useCollator", () => $27a5ce66022270ad$export$a16aca283550c30d);
$parcel$export(module.exports, "useFilter", () => $832d079b867c7223$export$3274cf84b703fff);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // https://en.wikipedia.org/wiki/Right-to-left
const $4d65847630a056a8$var$RTL_SCRIPTS = new Set([
    'Arab',
    'Syrc',
    'Samr',
    'Mand',
    'Thaa',
    'Mend',
    'Nkoo',
    'Adlm',
    'Rohg',
    'Hebr'
]);
const $4d65847630a056a8$var$RTL_LANGS = new Set([
    'ae',
    'ar',
    'arc',
    'bcc',
    'bqi',
    'ckb',
    'dv',
    'fa',
    'glk',
    'he',
    'ku',
    'mzn',
    'nqo',
    'pnb',
    'ps',
    'sd',
    'ug',
    'ur',
    'yi'
]);
function $4d65847630a056a8$export$702d680b21cbd764(locale) {
    // If the Intl.Locale API is available, use it to get the script for the locale.
    // This is more accurate than guessing by language, since languages can be written in multiple scripts.
    // @ts-ignore
    if (Intl.Locale) {
        // @ts-ignore
        let script = new Intl.Locale(locale).maximize().script;
        return $4d65847630a056a8$var$RTL_SCRIPTS.has(script);
    }
    // If not, just guess by the language (first part of the locale)
    let lang = locale.split('-')[0];
    return $4d65847630a056a8$var$RTL_LANGS.has(lang);
}





function $2919bdec75484e64$export$f09106e7c6677ec5() {
    // @ts-ignore
    let locale = typeof navigator !== 'undefined' && (navigator.language || navigator.userLanguage) || 'en-US';
    try {
        // @ts-ignore
        Intl.DateTimeFormat.supportedLocalesOf([
            locale
        ]);
    } catch (_err) {
        locale = 'en-US';
    }
    return {
        locale: locale,
        direction: $4d65847630a056a8$export$702d680b21cbd764(locale) ? 'rtl' : 'ltr'
    };
}
let $2919bdec75484e64$var$currentLocale = $2919bdec75484e64$export$f09106e7c6677ec5();
let $2919bdec75484e64$var$listeners = new Set();
function $2919bdec75484e64$var$updateLocale() {
    $2919bdec75484e64$var$currentLocale = $2919bdec75484e64$export$f09106e7c6677ec5();
    for (let listener of $2919bdec75484e64$var$listeners)listener($2919bdec75484e64$var$currentLocale);
}
function $2919bdec75484e64$export$188ec29ebc2bdc3a() {
    let isSSR = $87SwK$reactariassr.useIsSSR();
    let [defaultLocale, setDefaultLocale] = $87SwK$react.useState($2919bdec75484e64$var$currentLocale);
    $87SwK$react.useEffect(()=>{
        if ($2919bdec75484e64$var$listeners.size === 0) window.addEventListener('languagechange', $2919bdec75484e64$var$updateLocale);
        $2919bdec75484e64$var$listeners.add(setDefaultLocale);
        return ()=>{
            $2919bdec75484e64$var$listeners.delete(setDefaultLocale);
            if ($2919bdec75484e64$var$listeners.size === 0) window.removeEventListener('languagechange', $2919bdec75484e64$var$updateLocale);
        };
    }, []);
    // We cannot determine the browser's language on the server, so default to
    // en-US. This will be updated after hydration on the client to the correct value.
    if (isSSR) return {
        locale: 'en-US',
        direction: 'ltr'
    };
    return defaultLocale;
}



const $47fa5ec5ff482271$var$I18nContext = /*#__PURE__*/ ($parcel$interopDefault($87SwK$react)).createContext(null);
function $47fa5ec5ff482271$export$a54013f0d02a8f82(props) {
    let { locale: locale , children: children  } = props;
    let defaultLocale = $2919bdec75484e64$export$188ec29ebc2bdc3a();
    let value = locale ? {
        locale: locale,
        direction: $4d65847630a056a8$export$702d680b21cbd764(locale) ? 'rtl' : 'ltr'
    } : defaultLocale;
    return(/*#__PURE__*/ ($parcel$interopDefault($87SwK$react)).createElement($47fa5ec5ff482271$var$I18nContext.Provider, {
        value: value
    }, children));
}
function $47fa5ec5ff482271$export$43bb16f9c6d9e3f7() {
    let defaultLocale = $2919bdec75484e64$export$188ec29ebc2bdc3a();
    let context = $87SwK$react.useContext($47fa5ec5ff482271$var$I18nContext);
    return context || defaultLocale;
}


var $227f31f0c647c5fc$exports = {};
"use strict";





const $fc53663969a3d00a$var$cache = new WeakMap();
function $fc53663969a3d00a$var$getCachedDictionary(strings) {
    let dictionary = $fc53663969a3d00a$var$cache.get(strings);
    if (!dictionary) {
        dictionary = new $87SwK$internationalizedstring.LocalizedStringDictionary(strings);
        $fc53663969a3d00a$var$cache.set(strings, dictionary);
    }
    return dictionary;
}
function $fc53663969a3d00a$export$f12b703ca79dfbb1(strings) {
    let { locale: locale  } = $47fa5ec5ff482271$export$43bb16f9c6d9e3f7();
    let dictionary = $87SwK$react.useMemo(()=>$fc53663969a3d00a$var$getCachedDictionary(strings)
    , [
        strings
    ]);
    return $87SwK$react.useMemo(()=>new $87SwK$internationalizedstring.LocalizedStringFormatter(locale, dictionary)
    , [
        locale,
        dictionary
    ]);
}




function $cb6a3e7d490e97a4$export$a2f47a3d2973640(options = {
}) {
    let { locale: locale  } = $47fa5ec5ff482271$export$43bb16f9c6d9e3f7();
    // @ts-ignore
    return $87SwK$react.useMemo(()=>new Intl.ListFormat(locale, options)
    , [
        locale,
        options
    ]);
}





function $b80c530ff2e20243$export$85fd5fdf27bacc79(options) {
    // Reuse last options object if it is shallowly equal, which allows the useMemo result to also be reused.
    let lastOptions = $87SwK$react.useRef(null);
    if (options && lastOptions.current && $b80c530ff2e20243$var$isEqual(options, lastOptions.current)) options = lastOptions.current;
    lastOptions.current = options;
    let { locale: locale  } = $47fa5ec5ff482271$export$43bb16f9c6d9e3f7();
    return $87SwK$react.useMemo(()=>new $87SwK$internationalizeddate.DateFormatter(locale, options)
    , [
        locale,
        options
    ]);
}
function $b80c530ff2e20243$var$isEqual(a, b) {
    if (a === b) return true;
    let aKeys = Object.keys(a);
    let bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) return false;
    for (let key of aKeys){
        if (b[key] !== a[key]) return false;
    }
    return true;
}





function $fea93c5b7c90d9f4$export$b7a616150fdb9f44(options = {
}) {
    let { locale: locale  } = $47fa5ec5ff482271$export$43bb16f9c6d9e3f7();
    return $87SwK$react.useMemo(()=>new $87SwK$internationalizednumber.NumberFormatter(locale, options)
    , [
        locale,
        options
    ]);
}



let $27a5ce66022270ad$var$cache = new Map();
function $27a5ce66022270ad$export$a16aca283550c30d(options) {
    let { locale: locale  } = $47fa5ec5ff482271$export$43bb16f9c6d9e3f7();
    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1
    ).join() : '');
    if ($27a5ce66022270ad$var$cache.has(cacheKey)) return $27a5ce66022270ad$var$cache.get(cacheKey);
    let formatter = new Intl.Collator(locale, options);
    $27a5ce66022270ad$var$cache.set(cacheKey, formatter);
    return formatter;
}



function $832d079b867c7223$export$3274cf84b703fff(options) {
    let collator = $27a5ce66022270ad$export$a16aca283550c30d({
        usage: 'search',
        ...options
    });
    // TODO(later): these methods don't currently support the ignorePunctuation option.
    return {
        startsWith (string, substring) {
            if (substring.length === 0) return true;
            // Normalize both strings so we can slice safely
            // TODO: take into account the ignorePunctuation option as well...
            string = string.normalize('NFC');
            substring = substring.normalize('NFC');
            return collator.compare(string.slice(0, substring.length), substring) === 0;
        },
        endsWith (string, substring) {
            if (substring.length === 0) return true;
            string = string.normalize('NFC');
            substring = substring.normalize('NFC');
            return collator.compare(string.slice(-substring.length), substring) === 0;
        },
        contains (string, substring) {
            if (substring.length === 0) return true;
            string = string.normalize('NFC');
            substring = substring.normalize('NFC');
            let scan = 0;
            let sliceLen = substring.length;
            for(; scan + sliceLen <= string.length; scan++){
                let slice = string.slice(scan, scan + sliceLen);
                if (collator.compare(substring, slice) === 0) return true;
            }
            return false;
        }
    };
}




//# sourceMappingURL=real-main.js.map


/***/ }),

/***/ 51135:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.useMessageFormatter = useMessageFormatter;

var _message = __webpack_require__(81020);

var _react = __webpack_require__(18038);

var _ = __webpack_require__(2211);

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
const cache = new WeakMap();

function getCachedDictionary(strings) {
  let dictionary = cache.get(strings);

  if (!dictionary) {
    dictionary = new _message.MessageDictionary(strings);
    cache.set(strings, dictionary);
  }

  return dictionary;
}
/**
 * Handles formatting ICU Message strings to create localized strings for the current locale.
 * Automatically updates when the locale changes, and handles caching of messages for performance.
 * @param strings - A mapping of languages to strings by key.
 * @deprecated - use useLocalizedStringFormatter instead.
 */


function useMessageFormatter(strings) {
  let {
    locale
  } = (0, _.useLocale)();
  let dictionary = (0, _react.useMemo)(() => getCachedDictionary(strings), [strings]);
  let formatter = (0, _react.useMemo)(() => new _message.MessageFormatter(locale, dictionary), [locale, dictionary]);
  return (0, _react.useCallback)((key, variables) => formatter.format(key, variables), [formatter]);
}


/***/ }),

/***/ 34353:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $goTMa$reactariautils = __webpack_require__(77335);
var $goTMa$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "Pressable", () => $e1dbec26039c051d$export$27c701ed9e449e99);
$parcel$export(module.exports, "PressResponder", () => $3596bae48579386f$export$3351871ee4b288b8);
$parcel$export(module.exports, "useFocus", () => $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6);
$parcel$export(module.exports, "isFocusVisible", () => $e77252a287ef94ab$export$b9b3dfddab17db27);
$parcel$export(module.exports, "getInteractionModality", () => $e77252a287ef94ab$export$630ff653c5ada6a9);
$parcel$export(module.exports, "setInteractionModality", () => $e77252a287ef94ab$export$8397ddfc504fdb9a);
$parcel$export(module.exports, "useInteractionModality", () => $e77252a287ef94ab$export$98e20ec92f614cfe);
$parcel$export(module.exports, "useFocusVisible", () => $e77252a287ef94ab$export$ffd9e5021c1fb2d6);
$parcel$export(module.exports, "useFocusVisibleListener", () => $e77252a287ef94ab$export$ec71b4b83ac08ec3);
$parcel$export(module.exports, "useFocusWithin", () => $d16842bbd0359d1b$export$420e68273165f4ec);
$parcel$export(module.exports, "useHover", () => $ffbc150311c75f01$export$ae780daf29e6d456);
$parcel$export(module.exports, "useInteractOutside", () => $edcfa848c42f94f4$export$872b660ac5a1ff98);
$parcel$export(module.exports, "useKeyboard", () => $892d64db2a3c53b0$export$8f71654801c2f7cd);
$parcel$export(module.exports, "useMove", () => $c09386fc48fa427d$export$36da96379f79f245);
$parcel$export(module.exports, "usePress", () => $0294ea432cd92340$export$45712eceda6fad21);
$parcel$export(module.exports, "useScrollWheel", () => $a3dbce0aed7087e2$export$2123ff2b87c81ca);
$parcel$export(module.exports, "useLongPress", () => $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9);


// Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element
// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually
let $f7e14e656343df57$var$state = 'default';
let $f7e14e656343df57$var$savedUserSelect = '';
let $f7e14e656343df57$var$modifiedElementMap = new WeakMap();
function $f7e14e656343df57$export$16a4697467175487(target) {
    if ($goTMa$reactariautils.isIOS()) {
        if ($f7e14e656343df57$var$state === 'default') {
            $f7e14e656343df57$var$savedUserSelect = document.documentElement.style.webkitUserSelect;
            document.documentElement.style.webkitUserSelect = 'none';
        }
        $f7e14e656343df57$var$state = 'disabled';
    } else if (target instanceof HTMLElement || target instanceof SVGElement) {
        // If not iOS, store the target's original user-select and change to user-select: none
        // Ignore state since it doesn't apply for non iOS
        $f7e14e656343df57$var$modifiedElementMap.set(target, target.style.userSelect);
        target.style.userSelect = 'none';
    }
}
function $f7e14e656343df57$export$b0d6fa1ab32e3295(target) {
    if ($goTMa$reactariautils.isIOS()) {
        // If the state is already default, there's nothing to do.
        // If it is restoring, then there's no need to queue a second restore.
        if ($f7e14e656343df57$var$state !== 'disabled') return;
        $f7e14e656343df57$var$state = 'restoring';
        // There appears to be a delay on iOS where selection still might occur
        // after pointer up, so wait a bit before removing user-select.
        setTimeout(()=>{
            // Wait for any CSS transitions to complete so we don't recompute style
            // for the whole page in the middle of the animation and cause jank.
            $goTMa$reactariautils.runAfterTransition(()=>{
                // Avoid race conditions
                if ($f7e14e656343df57$var$state === 'restoring') {
                    if (document.documentElement.style.webkitUserSelect === 'none') document.documentElement.style.webkitUserSelect = $f7e14e656343df57$var$savedUserSelect || '';
                    $f7e14e656343df57$var$savedUserSelect = '';
                    $f7e14e656343df57$var$state = 'default';
                }
            });
        }, 300);
    } else if (target instanceof HTMLElement || target instanceof SVGElement) // If not iOS, restore the target's original user-select if any
    // Ignore state since it doesn't apply for non iOS
    {
        if (target && $f7e14e656343df57$var$modifiedElementMap.has(target)) {
            let targetOldUserSelect = $f7e14e656343df57$var$modifiedElementMap.get(target);
            if (target.style.userSelect === 'none') target.style.userSelect = targetOldUserSelect;
            if (target.getAttribute('style') === '') target.removeAttribute('style');
            $f7e14e656343df57$var$modifiedElementMap.delete(target);
        }
    }
}




const $01d3f539e91688c8$export$5165eccb35aaadb5 = ($parcel$interopDefault($goTMa$react)).createContext(null);
$01d3f539e91688c8$export$5165eccb35aaadb5.displayName = 'PressResponderContext';



function $0294ea432cd92340$var$usePressResponderContext(props) {
    // Consume context from <PressResponder> and merge with props.
    let context = $goTMa$react.useContext($01d3f539e91688c8$export$5165eccb35aaadb5);
    if (context) {
        let { register: register , ...contextProps } = context;
        props = $goTMa$reactariautils.mergeProps(contextProps, props);
        register();
    }
    $goTMa$reactariautils.useSyncRef(context, props.ref);
    return props;
}
function $0294ea432cd92340$export$45712eceda6fad21(props) {
    let { onPress: onPress1 , onPressChange: onPressChange1 , onPressStart: onPressStart1 , onPressEnd: onPressEnd1 , onPressUp: onPressUp1 , isDisabled: isDisabled1 , isPressed: isPressedProp , preventFocusOnPress: preventFocusOnPress , shouldCancelOnPointerExit: shouldCancelOnPointerExit , allowTextSelectionOnPress: allowTextSelectionOnPress , // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: _ , ...domProps } = $0294ea432cd92340$var$usePressResponderContext(props);
    let propsRef = $goTMa$react.useRef(null);
    propsRef.current = {
        onPress: onPress1,
        onPressChange: onPressChange1,
        onPressStart: onPressStart1,
        onPressEnd: onPressEnd1,
        onPressUp: onPressUp1,
        isDisabled: isDisabled1,
        shouldCancelOnPointerExit: shouldCancelOnPointerExit
    };
    let [isPressed, setPressed] = $goTMa$react.useState(false);
    let ref = $goTMa$react.useRef({
        isPressed: false,
        ignoreEmulatedMouseEvents: false,
        ignoreClickAfterPress: false,
        didFirePressStart: false,
        activePointerId: null,
        target: null,
        isOverTarget: false,
        pointerType: null
    });
    let { addGlobalListener: addGlobalListener , removeAllGlobalListeners: removeAllGlobalListeners  } = $goTMa$reactariautils.useGlobalListeners();
    let pressProps1 = $goTMa$react.useMemo(()=>{
        let state = ref.current;
        let triggerPressStart = (originalEvent, pointerType)=>{
            let { onPressStart: onPressStart , onPressChange: onPressChange , isDisabled: isDisabled  } = propsRef.current;
            if (isDisabled || state.didFirePressStart) return;
            if (onPressStart) onPressStart({
                type: 'pressstart',
                pointerType: pointerType,
                target: originalEvent.currentTarget,
                shiftKey: originalEvent.shiftKey,
                metaKey: originalEvent.metaKey,
                ctrlKey: originalEvent.ctrlKey,
                altKey: originalEvent.altKey
            });
            if (onPressChange) onPressChange(true);
            state.didFirePressStart = true;
            setPressed(true);
        };
        let triggerPressEnd = (originalEvent, pointerType, wasPressed = true)=>{
            let { onPressEnd: onPressEnd , onPressChange: onPressChange , onPress: onPress , isDisabled: isDisabled  } = propsRef.current;
            if (!state.didFirePressStart) return;
            state.ignoreClickAfterPress = true;
            state.didFirePressStart = false;
            if (onPressEnd) onPressEnd({
                type: 'pressend',
                pointerType: pointerType,
                target: originalEvent.currentTarget,
                shiftKey: originalEvent.shiftKey,
                metaKey: originalEvent.metaKey,
                ctrlKey: originalEvent.ctrlKey,
                altKey: originalEvent.altKey
            });
            if (onPressChange) onPressChange(false);
            setPressed(false);
            if (onPress && wasPressed && !isDisabled) onPress({
                type: 'press',
                pointerType: pointerType,
                target: originalEvent.currentTarget,
                shiftKey: originalEvent.shiftKey,
                metaKey: originalEvent.metaKey,
                ctrlKey: originalEvent.ctrlKey,
                altKey: originalEvent.altKey
            });
        };
        let triggerPressUp = (originalEvent, pointerType)=>{
            let { onPressUp: onPressUp , isDisabled: isDisabled  } = propsRef.current;
            if (isDisabled) return;
            if (onPressUp) onPressUp({
                type: 'pressup',
                pointerType: pointerType,
                target: originalEvent.currentTarget,
                shiftKey: originalEvent.shiftKey,
                metaKey: originalEvent.metaKey,
                ctrlKey: originalEvent.ctrlKey,
                altKey: originalEvent.altKey
            });
        };
        let cancel = (e)=>{
            if (state.isPressed) {
                if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                state.isPressed = false;
                state.isOverTarget = false;
                state.activePointerId = null;
                state.pointerType = null;
                removeAllGlobalListeners();
                if (!allowTextSelectionOnPress) $f7e14e656343df57$export$b0d6fa1ab32e3295(state.target);
            }
        };
        let pressProps = {
            onKeyDown (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {
                    if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                    e.stopPropagation();
                    // If the event is repeating, it may have started on a different element
                    // after which focus moved to the current element. Ignore these events and
                    // only handle the first key down event.
                    if (!state.isPressed && !e.repeat) {
                        state.target = e.currentTarget;
                        state.isPressed = true;
                        triggerPressStart(e, 'keyboard');
                        // Focus may move before the key up event, so register the event on the document
                        // instead of the same element where the key down event occurred.
                        addGlobalListener(document, 'keyup', onKeyUp, false);
                    }
                } else if (e.key === 'Enter' && $0294ea432cd92340$var$isHTMLAnchorLink(e.currentTarget)) // If the target is a link, we won't have handled this above because we want the default
                // browser behavior to open the link when pressing Enter. But we still need to prevent
                // default so that elements above do not also handle it (e.g. table row).
                e.stopPropagation();
            },
            onKeyUp (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target)) triggerPressUp($0294ea432cd92340$var$createEvent(state.target, e), 'keyboard');
            },
            onClick (e) {
                if (e && !e.currentTarget.contains(e.target)) return;
                if (e && e.button === 0) {
                    e.stopPropagation();
                    if (isDisabled1) e.preventDefault();
                    // If triggered from a screen reader or by using element.click(),
                    // trigger as if it were a keyboard click.
                    if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && (state.pointerType === 'virtual' || $goTMa$reactariautils.isVirtualClick(e.nativeEvent))) {
                        // Ensure the element receives focus (VoiceOver on iOS does not do this)
                        if (!isDisabled1 && !preventFocusOnPress) $goTMa$reactariautils.focusWithoutScrolling(e.currentTarget);
                        triggerPressStart(e, 'virtual');
                        triggerPressUp(e, 'virtual');
                        triggerPressEnd(e, 'virtual');
                    }
                    state.ignoreEmulatedMouseEvents = false;
                    state.ignoreClickAfterPress = false;
                }
            }
        };
        let onKeyUp = (e)=>{
            if (state.isPressed && $0294ea432cd92340$var$isValidKeyboardEvent(e, state.target)) {
                if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                e.stopPropagation();
                state.isPressed = false;
                let target = e.target;
                triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), 'keyboard', state.target.contains(target));
                removeAllGlobalListeners();
                // If the target is a link, trigger the click method to open the URL,
                // but defer triggering pressEnd until onClick event handler.
                if (state.target instanceof HTMLElement && state.target.contains(target) && ($0294ea432cd92340$var$isHTMLAnchorLink(state.target) || state.target.getAttribute('role') === 'link')) state.target.click();
            }
        };
        if (typeof PointerEvent !== 'undefined') {
            pressProps.onPointerDown = (e)=>{
                // Only handle left clicks, and ignore events that bubbled through portals.
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.
                // Ignore and let the onClick handler take care of it instead.
                // https://bugs.webkit.org/show_bug.cgi?id=222627
                // https://bugs.webkit.org/show_bug.cgi?id=223202
                if ($goTMa$reactariautils.isVirtualPointerEvent(e.nativeEvent)) {
                    state.pointerType = 'virtual';
                    return;
                }
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on pointer down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                state.pointerType = e.pointerType;
                e.stopPropagation();
                if (!state.isPressed) {
                    state.isPressed = true;
                    state.isOverTarget = true;
                    state.activePointerId = e.pointerId;
                    state.target = e.currentTarget;
                    if (!isDisabled1 && !preventFocusOnPress) $goTMa$reactariautils.focusWithoutScrolling(e.currentTarget);
                    if (!allowTextSelectionOnPress) $f7e14e656343df57$export$16a4697467175487(state.target);
                    triggerPressStart(e, state.pointerType);
                    addGlobalListener(document, 'pointermove', onPointerMove, false);
                    addGlobalListener(document, 'pointerup', onPointerUp, false);
                    addGlobalListener(document, 'pointercancel', onPointerCancel, false);
                }
            };
            pressProps.onMouseDown = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (e.button === 0) {
                    // Chrome and Firefox on touch Windows devices require mouse down events
                    // to be canceled in addition to pointer events, or an extra asynchronous
                    // focus event will be fired.
                    if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                    e.stopPropagation();
                }
            };
            pressProps.onPointerUp = (e)=>{
                // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.
                if (!e.currentTarget.contains(e.target) || state.pointerType === 'virtual') return;
                // Only handle left clicks
                // Safari on iOS sometimes fires pointerup events, even
                // when the touch isn't over the target, so double check.
                if (e.button === 0 && $0294ea432cd92340$var$isOverTarget(e, e.currentTarget)) triggerPressUp(e, state.pointerType || e.pointerType);
            };
            // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.
            // Use pointer move events instead to implement our own hit testing.
            // See https://bugs.webkit.org/show_bug.cgi?id=199803
            let onPointerMove = (e)=>{
                if (e.pointerId !== state.activePointerId) return;
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    if (propsRef.current.shouldCancelOnPointerExit) cancel(e);
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0) {
                    if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    state.isPressed = false;
                    state.isOverTarget = false;
                    state.activePointerId = null;
                    state.pointerType = null;
                    removeAllGlobalListeners();
                    if (!allowTextSelectionOnPress) $f7e14e656343df57$export$b0d6fa1ab32e3295(state.target);
                }
            };
            let onPointerCancel = (e)=>{
                cancel(e);
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.
                cancel(e);
            };
        } else {
            pressProps.onMouseDown = (e)=>{
                // Only handle left clicks
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on mouse down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                e.stopPropagation();
                if (state.ignoreEmulatedMouseEvents) return;
                state.isPressed = true;
                state.isOverTarget = true;
                state.target = e.currentTarget;
                state.pointerType = $goTMa$reactariautils.isVirtualClick(e.nativeEvent) ? 'virtual' : 'mouse';
                if (!isDisabled1 && !preventFocusOnPress) $goTMa$reactariautils.focusWithoutScrolling(e.currentTarget);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(document, 'mouseup', onMouseUp, false);
            };
            pressProps.onMouseEnter = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = true;
                    triggerPressStart(e, state.pointerType);
                }
            };
            pressProps.onMouseLeave = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    if (propsRef.current.shouldCancelOnPointerExit) cancel(e);
                }
            };
            pressProps.onMouseUp = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType);
            };
            let onMouseUp = (e)=>{
                // Only handle left clicks
                if (e.button !== 0) return;
                state.isPressed = false;
                removeAllGlobalListeners();
                if (state.ignoreEmulatedMouseEvents) {
                    state.ignoreEmulatedMouseEvents = false;
                    return;
                }
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                state.isOverTarget = false;
            };
            pressProps.onTouchStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                let touch = $0294ea432cd92340$var$getTouchFromEvent(e.nativeEvent);
                if (!touch) return;
                state.activePointerId = touch.identifier;
                state.ignoreEmulatedMouseEvents = true;
                state.isOverTarget = true;
                state.isPressed = true;
                state.target = e.currentTarget;
                state.pointerType = 'touch';
                // Due to browser inconsistencies, especially on mobile browsers, we prevent default
                // on the emulated mouse event and handle focusing the pressable element ourselves.
                if (!isDisabled1 && !preventFocusOnPress) $goTMa$reactariautils.focusWithoutScrolling(e.currentTarget);
                if (!allowTextSelectionOnPress) $f7e14e656343df57$export$16a4697467175487(state.target);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(window, 'scroll', onScroll, true);
            };
            pressProps.onTouchMove = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart(e, state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    if (propsRef.current.shouldCancelOnPointerExit) cancel(e);
                }
            };
            pressProps.onTouchEnd = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    triggerPressUp(e, state.pointerType);
                    triggerPressEnd(e, state.pointerType);
                } else if (state.isOverTarget) triggerPressEnd(e, state.pointerType, false);
                state.isPressed = false;
                state.activePointerId = null;
                state.isOverTarget = false;
                state.ignoreEmulatedMouseEvents = true;
                if (!allowTextSelectionOnPress) $f7e14e656343df57$export$b0d6fa1ab32e3295(state.target);
                removeAllGlobalListeners();
            };
            pressProps.onTouchCancel = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed) cancel(e);
            };
            let onScroll = (e)=>{
                if (state.isPressed && e.target.contains(state.target)) cancel({
                    currentTarget: state.target,
                    shiftKey: false,
                    ctrlKey: false,
                    metaKey: false,
                    altKey: false
                });
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                cancel(e);
            };
        }
        return pressProps;
    }, [
        addGlobalListener,
        isDisabled1,
        preventFocusOnPress,
        removeAllGlobalListeners,
        allowTextSelectionOnPress
    ]);
    // Remove user-select: none in case component unmounts immediately after pressStart
    // eslint-disable-next-line arrow-body-style
    $goTMa$react.useEffect(()=>{
        return ()=>{
            if (!allowTextSelectionOnPress) $f7e14e656343df57$export$b0d6fa1ab32e3295(ref.current.target);
        };
    }, [
        allowTextSelectionOnPress
    ]);
    return {
        isPressed: isPressedProp || isPressed,
        pressProps: $goTMa$reactariautils.mergeProps(domProps, pressProps1)
    };
}
function $0294ea432cd92340$var$isHTMLAnchorLink(target) {
    return target.tagName === 'A' && target.hasAttribute('href');
}
function $0294ea432cd92340$var$isValidKeyboardEvent(event, currentTarget) {
    const { key: key , code: code  } = event;
    const element = currentTarget;
    const role = element.getAttribute('role');
    // Accessibility for keyboards. Space and Enter only.
    // "Spacebar" is for IE 11
    return (key === 'Enter' || key === ' ' || key === 'Spacebar' || code === 'Space') && !(element instanceof HTMLInputElement && !$0294ea432cd92340$var$isValidInputKey(element, key) || element instanceof HTMLTextAreaElement || element.isContentEditable) && (!$0294ea432cd92340$var$isHTMLAnchorLink(element) || role === 'button' && key !== 'Enter') && // An element with role='link' should only trigger with Enter key
    !(role === 'link' && key !== 'Enter');
}
function $0294ea432cd92340$var$getTouchFromEvent(event) {
    const { targetTouches: targetTouches  } = event;
    if (targetTouches.length > 0) return targetTouches[0];
    return null;
}
function $0294ea432cd92340$var$getTouchById(event, pointerId) {
    const changedTouches = event.changedTouches;
    for(let i = 0; i < changedTouches.length; i++){
        const touch = changedTouches[i];
        if (touch.identifier === pointerId) return touch;
    }
    return null;
}
function $0294ea432cd92340$var$createEvent(target, e) {
    return {
        currentTarget: target,
        shiftKey: e.shiftKey,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey
    };
}
function $0294ea432cd92340$var$getPointClientRect(point) {
    let offsetX = point.width / 2 || point.radiusX || 0;
    let offsetY = point.height / 2 || point.radiusY || 0;
    return {
        top: point.clientY - offsetY,
        right: point.clientX + offsetX,
        bottom: point.clientY + offsetY,
        left: point.clientX - offsetX
    };
}
function $0294ea432cd92340$var$areRectanglesOverlapping(a, b) {
    // check if they cannot overlap on x axis
    if (a.left > b.right || b.left > a.right) return false;
    // check if they cannot overlap on y axis
    if (a.top > b.bottom || b.top > a.bottom) return false;
    return true;
}
function $0294ea432cd92340$var$isOverTarget(point, target) {
    let rect = target.getBoundingClientRect();
    let pointRect = $0294ea432cd92340$var$getPointClientRect(point);
    return $0294ea432cd92340$var$areRectanglesOverlapping(rect, pointRect);
}
function $0294ea432cd92340$var$shouldPreventDefault(target) {
    // We cannot prevent default if the target is a draggable element.
    return !(target instanceof HTMLElement) || !target.draggable;
}
function $0294ea432cd92340$var$shouldPreventDefaultKeyboard(target, key) {
    if (target instanceof HTMLInputElement) return !$0294ea432cd92340$var$isValidInputKey(target, key);
    if (target instanceof HTMLButtonElement) return target.type !== 'submit';
    return true;
}
const $0294ea432cd92340$var$nonTextInputTypes = new Set([
    'checkbox',
    'radio',
    'range',
    'color',
    'file',
    'image',
    'button',
    'submit',
    'reset'
]);
function $0294ea432cd92340$var$isValidInputKey(target, key) {
    // Only space should toggle checkboxes and radios, not enter.
    return target.type === 'checkbox' || target.type === 'radio' ? key === ' ' : $0294ea432cd92340$var$nonTextInputTypes.has(target.type);
}



const $e1dbec26039c051d$export$27c701ed9e449e99 = /*#__PURE__*/ ($parcel$interopDefault($goTMa$react)).forwardRef(({ children: children , ...props }, ref)=>{
    let newRef = $goTMa$react.useRef();
    ref = ref !== null && ref !== void 0 ? ref : newRef;
    let { pressProps: pressProps  } = $0294ea432cd92340$export$45712eceda6fad21({
        ...props,
        ref: ref
    });
    let child = ($parcel$interopDefault($goTMa$react)).Children.only(children);
    return(/*#__PURE__*/ ($parcel$interopDefault($goTMa$react)).cloneElement(child, // @ts-ignore
    {
        ref: ref,
        ...$goTMa$reactariautils.mergeProps(child.props, pressProps)
    }));
});





const $3596bae48579386f$export$3351871ee4b288b8 = /*#__PURE__*/ ($parcel$interopDefault($goTMa$react)).forwardRef(({ children: children , ...props }, ref)=>{
    let isRegistered = $goTMa$react.useRef(false);
    let prevContext = $goTMa$react.useContext($01d3f539e91688c8$export$5165eccb35aaadb5);
    let context = $goTMa$reactariautils.mergeProps(prevContext || {
    }, {
        ...props,
        ref: ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref),
        register () {
            isRegistered.current = true;
            if (prevContext) prevContext.register();
        }
    });
    $goTMa$reactariautils.useSyncRef(prevContext, ref);
    $goTMa$react.useEffect(()=>{
        if (!isRegistered.current) console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.");
    }, []);
    return(/*#__PURE__*/ ($parcel$interopDefault($goTMa$react)).createElement($01d3f539e91688c8$export$5165eccb35aaadb5.Provider, {
        value: context
    }, children));
});





class $625cf83917e112ad$export$905e7fc544a71f36 {
    isDefaultPrevented() {
        return this.nativeEvent.defaultPrevented;
    }
    preventDefault() {
        this.defaultPrevented = true;
        this.nativeEvent.preventDefault();
    }
    stopPropagation() {
        this.nativeEvent.stopPropagation();
        this.isPropagationStopped = ()=>true
        ;
    }
    isPropagationStopped() {
        return false;
    }
    persist() {
    }
    constructor(type, nativeEvent){
        this.nativeEvent = nativeEvent;
        this.target = nativeEvent.target;
        this.currentTarget = nativeEvent.currentTarget;
        this.relatedTarget = nativeEvent.relatedTarget;
        this.bubbles = nativeEvent.bubbles;
        this.cancelable = nativeEvent.cancelable;
        this.defaultPrevented = nativeEvent.defaultPrevented;
        this.eventPhase = nativeEvent.eventPhase;
        this.isTrusted = nativeEvent.isTrusted;
        this.timeStamp = nativeEvent.timeStamp;
        this.type = type;
    }
}
function $625cf83917e112ad$export$715c682d09d639cc(onBlur) {
    let stateRef = $goTMa$react.useRef({
        isFocused: false,
        onBlur: onBlur,
        observer: null
    });
    stateRef.current.onBlur = onBlur;
    // Clean up MutationObserver on unmount. See below.
    // eslint-disable-next-line arrow-body-style
    $goTMa$reactariautils.useLayoutEffect(()=>{
        const state = stateRef.current;
        return ()=>{
            if (state.observer) {
                state.observer.disconnect();
                state.observer = null;
            }
        };
    }, []);
    // This function is called during a React onFocus event.
    return $goTMa$react.useCallback((e1)=>{
        // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142
        // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a
        // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.
        // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.
        if (e1.target instanceof HTMLButtonElement || e1.target instanceof HTMLInputElement || e1.target instanceof HTMLTextAreaElement || e1.target instanceof HTMLSelectElement) {
            stateRef.current.isFocused = true;
            let target = e1.target;
            let onBlurHandler = (e)=>{
                var // For backward compatibility, dispatch a (fake) React synthetic event.
                _current, ref;
                stateRef.current.isFocused = false;
                if (target.disabled) (ref = (_current = stateRef.current).onBlur) === null || ref === void 0 ? void 0 : ref.call(_current, new $625cf83917e112ad$export$905e7fc544a71f36('blur', e));
                // We no longer need the MutationObserver once the target is blurred.
                if (stateRef.current.observer) {
                    stateRef.current.observer.disconnect();
                    stateRef.current.observer = null;
                }
            };
            target.addEventListener('focusout', onBlurHandler, {
                once: true
            });
            stateRef.current.observer = new MutationObserver(()=>{
                if (stateRef.current.isFocused && target.disabled) {
                    stateRef.current.observer.disconnect();
                    target.dispatchEvent(new FocusEvent('blur'));
                    target.dispatchEvent(new FocusEvent('focusout', {
                        bubbles: true
                    }));
                }
            });
            stateRef.current.observer.observe(target, {
                attributes: true,
                attributeFilter: [
                    'disabled'
                ]
            });
        }
    }, []);
}


function $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6(props) {
    let { isDisabled: isDisabled , onFocus: onFocusProp , onBlur: onBlurProp , onFocusChange: onFocusChange  } = props;
    const onBlur = $goTMa$react.useCallback((e)=>{
        if (e.target === e.currentTarget) {
            if (onBlurProp) onBlurProp(e);
            if (onFocusChange) onFocusChange(false);
            return true;
        }
    }, [
        onBlurProp,
        onFocusChange
    ]);
    const onSyntheticFocus = $625cf83917e112ad$export$715c682d09d639cc(onBlur);
    const onFocus = $goTMa$react.useCallback((e)=>{
        if (e.target === e.currentTarget) {
            if (onFocusProp) onFocusProp(e);
            if (onFocusChange) onFocusChange(true);
            onSyntheticFocus(e);
        }
    }, [
        onFocusChange,
        onFocusProp,
        onSyntheticFocus
    ]);
    return {
        focusProps: {
            onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,
            onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : null
        }
    };
}




let $e77252a287ef94ab$var$currentModality = null;
let $e77252a287ef94ab$var$changeHandlers = new Set();
let $e77252a287ef94ab$var$hasSetupGlobalListeners = false;
let $e77252a287ef94ab$var$hasEventBeforeFocus = false;
let $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
// Only Tab or Esc keys will make focus visible on text input elements
const $e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS = {
    Tab: true,
    Escape: true
};
function $e77252a287ef94ab$var$triggerChangeHandlers(modality, e) {
    for (let handler of $e77252a287ef94ab$var$changeHandlers)handler(modality, e);
}
/**
 * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.
 */ function $e77252a287ef94ab$var$isValidKey(e) {
    // Control and Shift keys trigger when navigating back to the tab with keyboard.
    return !(e.metaKey || !$goTMa$reactariautils.isMac() && e.altKey || e.ctrlKey || e.key === 'Control' || e.key === 'Shift' || e.key === 'Meta');
}
function $e77252a287ef94ab$var$handleKeyboardEvent(e) {
    $e77252a287ef94ab$var$hasEventBeforeFocus = true;
    if ($e77252a287ef94ab$var$isValidKey(e)) {
        $e77252a287ef94ab$var$currentModality = 'keyboard';
        $e77252a287ef94ab$var$triggerChangeHandlers('keyboard', e);
    }
}
function $e77252a287ef94ab$var$handlePointerEvent(e) {
    $e77252a287ef94ab$var$currentModality = 'pointer';
    if (e.type === 'mousedown' || e.type === 'pointerdown') {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$triggerChangeHandlers('pointer', e);
    }
}
function $e77252a287ef94ab$var$handleClickEvent(e) {
    if ($goTMa$reactariautils.isVirtualClick(e)) {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$currentModality = 'virtual';
    }
}
function $e77252a287ef94ab$var$handleFocusEvent(e) {
    // Firefox fires two extra focus events when the user first clicks into an iframe:
    // first on the window, then on the document. We ignore these events so they don't
    // cause keyboard focus rings to appear.
    if (e.target === window || e.target === document) return;
    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.
    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.
    if (!$e77252a287ef94ab$var$hasEventBeforeFocus && !$e77252a287ef94ab$var$hasBlurredWindowRecently) {
        $e77252a287ef94ab$var$currentModality = 'virtual';
        $e77252a287ef94ab$var$triggerChangeHandlers('virtual', e);
    }
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
}
function $e77252a287ef94ab$var$handleWindowBlur() {
    // When the window is blurred, reset state. This is necessary when tabbing out of the window,
    // for example, since a subsequent focus event won't be fired.
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = true;
}
/**
 * Setup global event listeners to control when keyboard focus style should be visible.
 */ function $e77252a287ef94ab$var$setupGlobalFocusEvents() {
    if (typeof window === 'undefined' || $e77252a287ef94ab$var$hasSetupGlobalListeners) return;
    // Programmatic focus() calls shouldn't affect the current input modality.
    // However, we need to detect other cases when a focus event occurs without
    // a preceding user event (e.g. screen reader focus). Overriding the focus
    // method on HTMLElement.prototype is a bit hacky, but works.
    let focus = HTMLElement.prototype.focus;
    HTMLElement.prototype.focus = function() {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        focus.apply(this, arguments);
    };
    document.addEventListener('keydown', $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener('keyup', $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener('click', $e77252a287ef94ab$var$handleClickEvent, true);
    // Register focus events on the window so they are sure to happen
    // before React's event listeners (registered on the document).
    window.addEventListener('focus', $e77252a287ef94ab$var$handleFocusEvent, true);
    window.addEventListener('blur', $e77252a287ef94ab$var$handleWindowBlur, false);
    if (typeof PointerEvent !== 'undefined') {
        document.addEventListener('pointerdown', $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener('pointermove', $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener('pointerup', $e77252a287ef94ab$var$handlePointerEvent, true);
    } else {
        document.addEventListener('mousedown', $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener('mousemove', $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener('mouseup', $e77252a287ef94ab$var$handlePointerEvent, true);
    }
    $e77252a287ef94ab$var$hasSetupGlobalListeners = true;
}
if (typeof document !== 'undefined') {
    if (document.readyState !== 'loading') $e77252a287ef94ab$var$setupGlobalFocusEvents();
    else document.addEventListener('DOMContentLoaded', $e77252a287ef94ab$var$setupGlobalFocusEvents);
}
function $e77252a287ef94ab$export$b9b3dfddab17db27() {
    return $e77252a287ef94ab$var$currentModality !== 'pointer';
}
function $e77252a287ef94ab$export$630ff653c5ada6a9() {
    return $e77252a287ef94ab$var$currentModality;
}
function $e77252a287ef94ab$export$8397ddfc504fdb9a(modality) {
    $e77252a287ef94ab$var$currentModality = modality;
    $e77252a287ef94ab$var$triggerChangeHandlers(modality, null);
}
function $e77252a287ef94ab$export$98e20ec92f614cfe() {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    let [modality, setModality] = $goTMa$react.useState($e77252a287ef94ab$var$currentModality);
    $goTMa$react.useEffect(()=>{
        let handler = ()=>{
            setModality($e77252a287ef94ab$var$currentModality);
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    }, []);
    return modality;
}
/**
 * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that
 * focus visible style can be properly set.
 */ function $e77252a287ef94ab$var$isKeyboardFocusEvent(isTextInput, modality, e) {
    return !(isTextInput && modality === 'keyboard' && e instanceof KeyboardEvent && !$e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);
}
function $e77252a287ef94ab$export$ffd9e5021c1fb2d6(props = {
}) {
    let { isTextInput: isTextInput , autoFocus: autoFocus  } = props;
    let [isFocusVisibleState, setFocusVisible] = $goTMa$react.useState(autoFocus || $e77252a287ef94ab$export$b9b3dfddab17db27());
    $e77252a287ef94ab$export$ec71b4b83ac08ec3(($e77252a287ef94ab$export$b9b3dfddab17db27)=>{
        setFocusVisible($e77252a287ef94ab$export$b9b3dfddab17db27);
    }, [
        isTextInput
    ], {
        isTextInput: isTextInput
    });
    return {
        isFocusVisible: isFocusVisibleState
    };
}
function $e77252a287ef94ab$export$ec71b4b83ac08ec3(fn, deps, opts) {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    $goTMa$react.useEffect(()=>{
        let handler = (modality, e)=>{
            if (!$e77252a287ef94ab$var$isKeyboardFocusEvent(opts === null || opts === void 0 ? void 0 : opts.isTextInput, modality, e)) return;
            fn($e77252a287ef94ab$export$b9b3dfddab17db27());
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    }, deps);
}




function $d16842bbd0359d1b$export$420e68273165f4ec(props) {
    let { isDisabled: isDisabled , onBlurWithin: onBlurWithin , onFocusWithin: onFocusWithin , onFocusWithinChange: onFocusWithinChange  } = props;
    let state = $goTMa$react.useRef({
        isFocusWithin: false
    });
    let onBlur = $goTMa$react.useCallback((e)=>{
        // We don't want to trigger onBlurWithin and then immediately onFocusWithin again
        // when moving focus inside the element. Only trigger if the currentTarget doesn't
        // include the relatedTarget (where focus is moving).
        if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {
            state.current.isFocusWithin = false;
            if (onBlurWithin) onBlurWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(false);
        }
    }, [
        onBlurWithin,
        onFocusWithinChange,
        state
    ]);
    let onSyntheticFocus = $625cf83917e112ad$export$715c682d09d639cc(onBlur);
    let onFocus = $goTMa$react.useCallback((e)=>{
        if (!state.current.isFocusWithin) {
            if (onFocusWithin) onFocusWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(true);
            state.current.isFocusWithin = true;
            onSyntheticFocus(e);
        }
    }, [
        onFocusWithin,
        onFocusWithinChange,
        onSyntheticFocus
    ]);
    if (isDisabled) return {
        focusWithinProps: {
            onFocus: null,
            onBlur: null
        }
    };
    return {
        focusWithinProps: {
            onFocus: onFocus,
            onBlur: onBlur
        }
    };
}



// iOS fires onPointerEnter twice: once with pointerType="touch" and again with pointerType="mouse".
// We want to ignore these emulated events so they do not trigger hover behavior.
// See https://bugs.webkit.org/show_bug.cgi?id=214609.
let $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
let $ffbc150311c75f01$var$hoverCount = 0;
function $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents() {
    $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = true;
    // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter
    // with pointerType="mouse" immediately after onPointerUp and before onFocus. On other
    // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in
    // the distant future because a user previously touched the element.
    setTimeout(()=>{
        $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
    }, 50);
}
function $ffbc150311c75f01$var$handleGlobalPointerEvent(e) {
    if (e.pointerType === 'touch') $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $ffbc150311c75f01$var$setupGlobalTouchEvents() {
    if (typeof document === 'undefined') return;
    if (typeof PointerEvent !== 'undefined') document.addEventListener('pointerup', $ffbc150311c75f01$var$handleGlobalPointerEvent);
    else document.addEventListener('touchend', $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    $ffbc150311c75f01$var$hoverCount++;
    return ()=>{
        $ffbc150311c75f01$var$hoverCount--;
        if ($ffbc150311c75f01$var$hoverCount > 0) return;
        if (typeof PointerEvent !== 'undefined') document.removeEventListener('pointerup', $ffbc150311c75f01$var$handleGlobalPointerEvent);
        else document.removeEventListener('touchend', $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    };
}
function $ffbc150311c75f01$export$ae780daf29e6d456(props) {
    let { onHoverStart: onHoverStart , onHoverChange: onHoverChange , onHoverEnd: onHoverEnd , isDisabled: isDisabled  } = props;
    let [isHovered, setHovered] = $goTMa$react.useState(false);
    let state = $goTMa$react.useRef({
        isHovered: false,
        ignoreEmulatedMouseEvents: false,
        pointerType: '',
        target: null
    }).current;
    $goTMa$react.useEffect($ffbc150311c75f01$var$setupGlobalTouchEvents, []);
    let { hoverProps: hoverProps1 , triggerHoverEnd: triggerHoverEnd1  } = $goTMa$react.useMemo(()=>{
        let triggerHoverStart = (event, pointerType)=>{
            state.pointerType = pointerType;
            if (isDisabled || pointerType === 'touch' || state.isHovered || !event.currentTarget.contains(event.target)) return;
            state.isHovered = true;
            let target = event.currentTarget;
            state.target = target;
            if (onHoverStart) onHoverStart({
                type: 'hoverstart',
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(true);
            setHovered(true);
        };
        let triggerHoverEnd = (event, pointerType)=>{
            state.pointerType = '';
            state.target = null;
            if (pointerType === 'touch' || !state.isHovered) return;
            state.isHovered = false;
            let target = event.currentTarget;
            if (onHoverEnd) onHoverEnd({
                type: 'hoverend',
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(false);
            setHovered(false);
        };
        let hoverProps = {
        };
        if (typeof PointerEvent !== 'undefined') {
            hoverProps.onPointerEnter = (e)=>{
                if ($ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents && e.pointerType === 'mouse') return;
                triggerHoverStart(e, e.pointerType);
            };
            hoverProps.onPointerLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);
            };
        } else {
            hoverProps.onTouchStart = ()=>{
                state.ignoreEmulatedMouseEvents = true;
            };
            hoverProps.onMouseEnter = (e)=>{
                if (!state.ignoreEmulatedMouseEvents && !$ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, 'mouse');
                state.ignoreEmulatedMouseEvents = false;
            };
            hoverProps.onMouseLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, 'mouse');
            };
        }
        return {
            hoverProps: hoverProps,
            triggerHoverEnd: triggerHoverEnd
        };
    }, [
        onHoverStart,
        onHoverChange,
        onHoverEnd,
        isDisabled,
        state
    ]);
    $goTMa$react.useEffect(()=>{
        // Call the triggerHoverEnd as soon as isDisabled changes to true
        // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering
        if (isDisabled) triggerHoverEnd1({
            currentTarget: state.target
        }, state.pointerType);
    }, [
        isDisabled
    ]);
    return {
        hoverProps: hoverProps1,
        isHovered: isHovered
    };
}



function $edcfa848c42f94f4$export$872b660ac5a1ff98(props) {
    let { ref: ref , onInteractOutside: onInteractOutside , isDisabled: isDisabled , onInteractOutsideStart: onInteractOutsideStart  } = props;
    let stateRef = $goTMa$react.useRef({
        isPointerDown: false,
        ignoreEmulatedMouseEvents: false,
        onInteractOutside: onInteractOutside,
        onInteractOutsideStart: onInteractOutsideStart
    });
    let state = stateRef.current;
    state.onInteractOutside = onInteractOutside;
    state.onInteractOutsideStart = onInteractOutsideStart;
    $goTMa$react.useEffect(()=>{
        if (isDisabled) return;
        let onPointerDown = (e)=>{
            if ($edcfa848c42f94f4$var$isValidEvent(e, ref) && state.onInteractOutside) {
                if (state.onInteractOutsideStart) state.onInteractOutsideStart(e);
                state.isPointerDown = true;
            }
        };
        // Use pointer events if available. Otherwise, fall back to mouse and touch events.
        if (typeof PointerEvent !== 'undefined') {
            let onPointerUp = (e)=>{
                if (state.isPointerDown && state.onInteractOutside && $edcfa848c42f94f4$var$isValidEvent(e, ref)) {
                    state.isPointerDown = false;
                    state.onInteractOutside(e);
                }
            };
            // changing these to capture phase fixed combobox
            document.addEventListener('pointerdown', onPointerDown, true);
            document.addEventListener('pointerup', onPointerUp, true);
            return ()=>{
                document.removeEventListener('pointerdown', onPointerDown, true);
                document.removeEventListener('pointerup', onPointerUp, true);
            };
        } else {
            let onMouseUp = (e)=>{
                if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;
                else if (state.isPointerDown && state.onInteractOutside && $edcfa848c42f94f4$var$isValidEvent(e, ref)) {
                    state.isPointerDown = false;
                    state.onInteractOutside(e);
                }
            };
            let onTouchEnd = (e)=>{
                state.ignoreEmulatedMouseEvents = true;
                if (state.onInteractOutside && state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) {
                    state.isPointerDown = false;
                    state.onInteractOutside(e);
                }
            };
            document.addEventListener('mousedown', onPointerDown, true);
            document.addEventListener('mouseup', onMouseUp, true);
            document.addEventListener('touchstart', onPointerDown, true);
            document.addEventListener('touchend', onTouchEnd, true);
            return ()=>{
                document.removeEventListener('mousedown', onPointerDown, true);
                document.removeEventListener('mouseup', onMouseUp, true);
                document.removeEventListener('touchstart', onPointerDown, true);
                document.removeEventListener('touchend', onTouchEnd, true);
            };
        }
    }, [
        ref,
        state,
        isDisabled
    ]);
}
function $edcfa848c42f94f4$var$isValidEvent(event, ref) {
    if (event.button > 0) return false;
    // if the event target is no longer in the document
    if (event.target) {
        const ownerDocument = event.target.ownerDocument;
        if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;
    }
    return ref.current && !ref.current.contains(event.target);
}


function $951fbcbbca8db6ce$export$48d1ea6320830260(handler) {
    if (!handler) return;
    let shouldStopPropagation = true;
    return (e)=>{
        let event = {
            ...e,
            preventDefault () {
                e.preventDefault();
            },
            isDefaultPrevented () {
                return e.isDefaultPrevented();
            },
            stopPropagation () {
                console.error('stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.');
            },
            continuePropagation () {
                shouldStopPropagation = false;
            }
        };
        handler(event);
        if (shouldStopPropagation) e.stopPropagation();
    };
}


function $892d64db2a3c53b0$export$8f71654801c2f7cd(props) {
    return {
        keyboardProps: props.isDisabled ? {
        } : {
            onKeyDown: $951fbcbbca8db6ce$export$48d1ea6320830260(props.onKeyDown),
            onKeyUp: $951fbcbbca8db6ce$export$48d1ea6320830260(props.onKeyUp)
        }
    };
}





function $c09386fc48fa427d$export$36da96379f79f245(props) {
    let { onMoveStart: onMoveStart , onMove: onMove , onMoveEnd: onMoveEnd  } = props;
    let state = $goTMa$react.useRef({
        didMove: false,
        lastPosition: null,
        id: null
    });
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = $goTMa$reactariautils.useGlobalListeners();
    let moveProps1 = $goTMa$react.useMemo(()=>{
        let moveProps = {
        };
        let start = ()=>{
            $f7e14e656343df57$export$16a4697467175487();
            state.current.didMove = false;
        };
        let move = (originalEvent, pointerType, deltaX, deltaY)=>{
            if (deltaX === 0 && deltaY === 0) return;
            if (!state.current.didMove) {
                state.current.didMove = true;
                onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart({
                    type: 'movestart',
                    pointerType: pointerType,
                    shiftKey: originalEvent.shiftKey,
                    metaKey: originalEvent.metaKey,
                    ctrlKey: originalEvent.ctrlKey,
                    altKey: originalEvent.altKey
                });
            }
            onMove({
                type: 'move',
                pointerType: pointerType,
                deltaX: deltaX,
                deltaY: deltaY,
                shiftKey: originalEvent.shiftKey,
                metaKey: originalEvent.metaKey,
                ctrlKey: originalEvent.ctrlKey,
                altKey: originalEvent.altKey
            });
        };
        let end = (originalEvent, pointerType)=>{
            $f7e14e656343df57$export$b0d6fa1ab32e3295();
            if (state.current.didMove) onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd({
                type: 'moveend',
                pointerType: pointerType,
                shiftKey: originalEvent.shiftKey,
                metaKey: originalEvent.metaKey,
                ctrlKey: originalEvent.ctrlKey,
                altKey: originalEvent.altKey
            });
        };
        if (typeof PointerEvent === 'undefined') {
            let onMouseMove = (e)=>{
                if (e.button === 0) {
                    move(e, 'mouse', e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onMouseUp = (e)=>{
                if (e.button === 0) {
                    end(e, 'mouse');
                    removeGlobalListener(window, 'mousemove', onMouseMove, false);
                    removeGlobalListener(window, 'mouseup', onMouseUp, false);
                }
            };
            moveProps.onMouseDown = (e)=>{
                if (e.button === 0) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    addGlobalListener(window, 'mousemove', onMouseMove, false);
                    addGlobalListener(window, 'mouseup', onMouseUp, false);
                }
            };
            let onTouchMove = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id
                );
                if (touch >= 0) {
                    let { pageX: pageX , pageY: pageY  } = e.changedTouches[touch];
                    move(e, 'touch', pageX - state.current.lastPosition.pageX, pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: pageX,
                        pageY: pageY
                    };
                }
            };
            let onTouchEnd = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id
                );
                if (touch >= 0) {
                    end(e, 'touch');
                    state.current.id = null;
                    removeGlobalListener(window, 'touchmove', onTouchMove);
                    removeGlobalListener(window, 'touchend', onTouchEnd);
                    removeGlobalListener(window, 'touchcancel', onTouchEnd);
                }
            };
            moveProps.onTouchStart = (e)=>{
                if (e.changedTouches.length === 0 || state.current.id != null) return;
                let { pageX: pageX , pageY: pageY , identifier: identifier  } = e.changedTouches[0];
                start();
                e.stopPropagation();
                e.preventDefault();
                state.current.lastPosition = {
                    pageX: pageX,
                    pageY: pageY
                };
                state.current.id = identifier;
                addGlobalListener(window, 'touchmove', onTouchMove, false);
                addGlobalListener(window, 'touchend', onTouchEnd, false);
                addGlobalListener(window, 'touchcancel', onTouchEnd, false);
            };
        } else {
            let onPointerMove = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || 'mouse';
                    // Problems with PointerEvent#movementX/movementY:
                    // 1. it is always 0 on macOS Safari.
                    // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS
                    move(e, pointerType, e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || 'mouse';
                    end(e, pointerType);
                    state.current.id = null;
                    removeGlobalListener(window, 'pointermove', onPointerMove, false);
                    removeGlobalListener(window, 'pointerup', onPointerUp, false);
                    removeGlobalListener(window, 'pointercancel', onPointerUp, false);
                }
            };
            moveProps.onPointerDown = (e)=>{
                if (e.button === 0 && state.current.id == null) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    state.current.id = e.pointerId;
                    addGlobalListener(window, 'pointermove', onPointerMove, false);
                    addGlobalListener(window, 'pointerup', onPointerUp, false);
                    addGlobalListener(window, 'pointercancel', onPointerUp, false);
                }
            };
        }
        let triggerKeyboardMove = (e, deltaX, deltaY)=>{
            start();
            move(e, 'keyboard', deltaX, deltaY);
            end(e, 'keyboard');
        };
        moveProps.onKeyDown = (e)=>{
            switch(e.key){
                case 'Left':
                case 'ArrowLeft':
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, -1, 0);
                    break;
                case 'Right':
                case 'ArrowRight':
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 1, 0);
                    break;
                case 'Up':
                case 'ArrowUp':
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, -1);
                    break;
                case 'Down':
                case 'ArrowDown':
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, 1);
                    break;
            }
        };
        return moveProps;
    }, [
        state,
        onMoveStart,
        onMove,
        onMoveEnd,
        addGlobalListener,
        removeGlobalListener
    ]);
    return {
        moveProps: moveProps1
    };
}





function $a3dbce0aed7087e2$export$2123ff2b87c81ca(props, ref) {
    let { onScroll: onScroll , isDisabled: isDisabled  } = props;
    let onScrollHandler = $goTMa$react.useCallback((e)=>{
        // If the ctrlKey is pressed, this is a zoom event, do nothing.
        if (e.ctrlKey) return;
        // stop scrolling the page
        e.preventDefault();
        e.stopPropagation();
        if (onScroll) onScroll({
            deltaX: e.deltaX,
            deltaY: e.deltaY
        });
    }, [
        onScroll
    ]);
    $goTMa$reactariautils.useEvent(ref, 'wheel', isDisabled ? null : onScrollHandler);
}





const $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD = 500;
function $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9(props) {
    let { isDisabled: isDisabled , onLongPressStart: onLongPressStart , onLongPressEnd: onLongPressEnd , onLongPress: onLongPress , threshold: threshold = $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD , accessibilityDescription: accessibilityDescription  } = props;
    const timeRef = $goTMa$react.useRef(null);
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = $goTMa$reactariautils.useGlobalListeners();
    let { pressProps: pressProps  } = $0294ea432cd92340$export$45712eceda6fad21({
        isDisabled: isDisabled,
        onPressStart (e1) {
            if (e1.pointerType === 'mouse' || e1.pointerType === 'touch') {
                if (onLongPressStart) onLongPressStart({
                    ...e1,
                    type: 'longpressstart'
                });
                timeRef.current = setTimeout(()=>{
                    // Prevent other usePress handlers from also handling this event.
                    e1.target.dispatchEvent(new PointerEvent('pointercancel', {
                        bubbles: true
                    }));
                    if (onLongPress) onLongPress({
                        ...e1,
                        type: 'longpress'
                    });
                    timeRef.current = null;
                }, threshold);
                // Prevent context menu, which may be opened on long press on touch devices
                if (e1.pointerType === 'touch') {
                    let onContextMenu = (e)=>{
                        e.preventDefault();
                    };
                    addGlobalListener(e1.target, 'contextmenu', onContextMenu, {
                        once: true
                    });
                    addGlobalListener(window, 'pointerup', ()=>{
                        // If no contextmenu event is fired quickly after pointerup, remove the handler
                        // so future context menu events outside a long press are not prevented.
                        setTimeout(()=>{
                            removeGlobalListener(e1.target, 'contextmenu', onContextMenu);
                        }, 30);
                    }, {
                        once: true
                    });
                }
            }
        },
        onPressEnd (e) {
            if (timeRef.current) clearTimeout(timeRef.current);
            if (onLongPressEnd && (e.pointerType === 'mouse' || e.pointerType === 'touch')) onLongPressEnd({
                ...e,
                type: 'longpressend'
            });
        }
    });
    let descriptionProps = $goTMa$reactariautils.useDescription(onLongPress && !isDisabled ? accessibilityDescription : null);
    return {
        longPressProps: $goTMa$reactariautils.mergeProps(pressProps, descriptionProps)
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 26894:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $g2CPN$reactariautils = __webpack_require__(77335);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useField", () => $50e2f39368b9c636$export$294aa081a6c6f55d);
$parcel$export(module.exports, "useLabel", () => $ce7359c25a7dec1c$export$8467354a121f1b9f);

function $ce7359c25a7dec1c$export$8467354a121f1b9f(props) {
    let { id: id , label: label , 'aria-labelledby': ariaLabelledby , 'aria-label': ariaLabel , labelElementType: labelElementType = 'label'  } = props;
    id = $g2CPN$reactariautils.useId(id);
    let labelId = $g2CPN$reactariautils.useId();
    let labelProps = {
    };
    if (label) {
        ariaLabelledby = ariaLabelledby ? `${ariaLabelledby} ${labelId}` : labelId;
        labelProps = {
            id: labelId,
            htmlFor: labelElementType === 'label' ? id : undefined
        };
    } else if (!ariaLabelledby && !ariaLabel) console.warn('If you do not provide a visible label, you must specify an aria-label or aria-labelledby attribute for accessibility');
    let fieldProps = $g2CPN$reactariautils.useLabels({
        id: id,
        'aria-label': ariaLabel,
        'aria-labelledby': ariaLabelledby
    });
    return {
        labelProps: labelProps,
        fieldProps: fieldProps
    };
}



function $50e2f39368b9c636$export$294aa081a6c6f55d(props) {
    let { description: description , errorMessage: errorMessage , validationState: validationState  } = props;
    let { labelProps: labelProps , fieldProps: fieldProps  } = $ce7359c25a7dec1c$export$8467354a121f1b9f(props);
    let descriptionId = $g2CPN$reactariautils.useSlotId([
        Boolean(description),
        Boolean(errorMessage),
        validationState
    ]);
    let errorMessageId = $g2CPN$reactariautils.useSlotId([
        Boolean(description),
        Boolean(errorMessage),
        validationState
    ]);
    fieldProps = $g2CPN$reactariautils.mergeProps(fieldProps, {
        'aria-describedby': [
            descriptionId,
            // Use aria-describedby for error message because aria-errormessage is unsupported using VoiceOver or NVDA. See https://github.com/adobe/react-spectrum/issues/1346#issuecomment-740136268
            errorMessageId,
            props['aria-describedby']
        ].filter(Boolean).join(' ') || undefined
    });
    return {
        labelProps: labelProps,
        fieldProps: fieldProps,
        descriptionProps: {
            id: descriptionId
        },
        errorMessageProps: {
            id: errorMessageId
        }
    };
}





//# sourceMappingURL=main.js.map


/***/ }),

/***/ 38415:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $3NNeN$reactariautils = __webpack_require__(51044);
var $3NNeN$reactariafocus = __webpack_require__(88473);
var $3NNeN$reactariainteractions = __webpack_require__(98884);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useLink", () => $fbe6b19572273b2f$export$dcf14c9974fe2767);



function $fbe6b19572273b2f$export$dcf14c9974fe2767(props, ref) {
    let { elementType: elementType = 'a' , onPress: onPress , onPressStart: onPressStart , onPressEnd: onPressEnd , // @ts-ignore
    onClick: deprecatedOnClick , isDisabled: isDisabled , ...otherProps } = props;
    let linkProps;
    if (elementType !== 'a') linkProps = {
        role: 'link',
        tabIndex: !isDisabled ? 0 : undefined
    };
    let { focusableProps: focusableProps  } = $3NNeN$reactariafocus.useFocusable(props, ref);
    let { pressProps: pressProps , isPressed: isPressed  } = $3NNeN$reactariainteractions.usePress({
        onPress: onPress,
        onPressStart: onPressStart,
        onPressEnd: onPressEnd,
        isDisabled: isDisabled,
        ref: ref
    });
    let domProps = $3NNeN$reactariautils.filterDOMProps(otherProps, {
        labelable: true
    });
    let interactionHandlers = $3NNeN$reactariautils.mergeProps(focusableProps, pressProps);
    return {
        isPressed: isPressed,
        linkProps: $3NNeN$reactariautils.mergeProps(domProps, {
            ...interactionHandlers,
            ...linkProps,
            'aria-disabled': isDisabled || undefined,
            onClick: (e)=>{
                pressProps.onClick(e);
                if (deprecatedOnClick) {
                    deprecatedOnClick(e);
                    console.warn('onClick is deprecated, please use onPress');
                }
            }
        })
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 88473:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $aB6Cp$react = __webpack_require__(18038);
var $aB6Cp$reactariautils = __webpack_require__(51044);
var $aB6Cp$reactariainteractions = __webpack_require__(98884);
var $aB6Cp$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "FocusScope", () => $a7a032acae3ddda9$export$20e40289641fbbb6);
$parcel$export(module.exports, "useFocusManager", () => $a7a032acae3ddda9$export$10c5169755ce7bd7);
$parcel$export(module.exports, "getFocusableTreeWalker", () => $a7a032acae3ddda9$export$2d6ec8fc375ceafa);
$parcel$export(module.exports, "createFocusManager", () => $a7a032acae3ddda9$export$c5251b9e124bf29);
$parcel$export(module.exports, "isElementInChildOfActiveScope", () => $a7a032acae3ddda9$export$1258395f99bf9cbf);
$parcel$export(module.exports, "FocusRing", () => $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d);
$parcel$export(module.exports, "FocusableProvider", () => $fb504d83237fd6ac$export$13f3202a3e5ddd5);
$parcel$export(module.exports, "useFocusable", () => $fb504d83237fd6ac$export$4c014de7c8940b4c);
$parcel$export(module.exports, "useFocusRing", () => $581a96d6eb128c1b$export$4e328f61c538687f);
$parcel$export(module.exports, "focusSafely", () => $1c7f9157d722357d$export$80f3e147d781571c);
$parcel$export(module.exports, "useHasTabbableChild", () => $259c6413a286f2e6$export$eac1895992b9f3d6);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1c7f9157d722357d$export$80f3e147d781571c(element) {
    // If the user is interacting with a virtual cursor, e.g. screen reader, then
    // wait until after any animated transitions that are currently occurring on
    // the page before shifting focus. This avoids issues with VoiceOver on iOS
    // causing the page to scroll when moving focus if the element is transitioning
    // from off the screen.
    if ((0, $aB6Cp$reactariainteractions.getInteractionModality)() === "virtual") {
        let lastFocusedElement = document.activeElement;
        (0, $aB6Cp$reactariautils.runAfterTransition)(()=>{
            // If focus did not move and the element is still in the document, focus it.
            if (document.activeElement === lastFocusedElement && document.contains(element)) (0, $aB6Cp$reactariautils.focusWithoutScrolling)(element);
        });
    } else (0, $aB6Cp$reactariautils.focusWithoutScrolling)(element);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d5156037ad898a4d$var$isStyleVisible(element) {
    if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) return false;
    let { display: display , visibility: visibility  } = element.style;
    let isVisible = display !== "none" && visibility !== "hidden" && visibility !== "collapse";
    if (isVisible) {
        const { getComputedStyle: getComputedStyle  } = element.ownerDocument.defaultView;
        let { display: computedDisplay , visibility: computedVisibility  } = getComputedStyle(element);
        isVisible = computedDisplay !== "none" && computedVisibility !== "hidden" && computedVisibility !== "collapse";
    }
    return isVisible;
}
function $d5156037ad898a4d$var$isAttributeVisible(element, childElement) {
    return !element.hasAttribute("hidden") && (element.nodeName === "DETAILS" && childElement && childElement.nodeName !== "SUMMARY" ? element.hasAttribute("open") : true);
}
function $d5156037ad898a4d$export$e989c0fffaa6b27a(element, childElement) {
    return element.nodeName !== "#comment" && $d5156037ad898a4d$var$isStyleVisible(element) && $d5156037ad898a4d$var$isAttributeVisible(element, childElement) && (!element.parentElement || $d5156037ad898a4d$export$e989c0fffaa6b27a(element.parentElement, element));
}




const $a7a032acae3ddda9$var$FocusContext = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createContext(null);
let $a7a032acae3ddda9$var$activeScope = null;
function $a7a032acae3ddda9$export$20e40289641fbbb6(props) {
    let { children: children , contain: contain , restoreFocus: restoreFocus , autoFocus: autoFocus  } = props;
    let startRef = (0, $aB6Cp$react.useRef)();
    let endRef = (0, $aB6Cp$react.useRef)();
    let scopeRef = (0, $aB6Cp$react.useRef)([]);
    let { parentNode: parentNode  } = (0, $aB6Cp$react.useContext)($a7a032acae3ddda9$var$FocusContext) || {};
    // Create a tree node here so we can add children to it even before it is added to the tree.
    let node = (0, $aB6Cp$react.useMemo)(()=>new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: scopeRef
        }), [
        scopeRef
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),
        // use the active scope as the parent instead of the parent from context. Layout effects run bottom
        // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope
        // that is being added should get the activeScope as its parent.
        let parent = parentNode || $a7a032acae3ddda9$export$d06fae2ee68b101e.root;
        if ($a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(parent.scopeRef) && $a7a032acae3ddda9$var$activeScope && !$a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, parent.scopeRef)) {
            let activeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
            if (activeNode) parent = activeNode;
        }
        // Add the node to the parent, and to the tree.
        parent.addChild(node);
        $a7a032acae3ddda9$export$d06fae2ee68b101e.addNode(node);
    }, [
        node,
        parentNode
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let node = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef);
        node.contain = contain;
    }, [
        contain
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        // Find all rendered nodes between the sentinels and add them to the scope.
        let node = startRef.current.nextSibling;
        let nodes = [];
        while(node && node !== endRef.current){
            nodes.push(node);
            node = node.nextSibling;
        }
        scopeRef.current = nodes;
    }, [
        children
    ]);
    $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain);
    $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus);
    // this layout effect needs to run last so that focusScopeTree cleanup happens at the last moment possible
    (0, $aB6Cp$react.useEffect)(()=>{
        if (scopeRef) {
            let activeElement = document.activeElement;
            let scope = null;
            // In strict mode, active scope is incorrectly updated since cleanup will run even though scope hasn't unmounted.
            // To fix this, we need to update the actual activeScope here
            if ($a7a032acae3ddda9$var$isElementInScope(activeElement, scopeRef.current)) {
                // Since useLayoutEffect runs for children first, we need to traverse the focusScope tree and find the bottom most scope that
                // contains the active element and set that as the activeScope
                for (let node of $a7a032acae3ddda9$export$d06fae2ee68b101e.traverse())if ($a7a032acae3ddda9$var$isElementInScope(activeElement, node.scopeRef.current)) scope = node;
                if (scope === $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef)) $a7a032acae3ddda9$var$activeScope = scope.scopeRef;
            }
            return ()=>{
                // Scope may have been re-parented.
                let parentScope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).parent.scopeRef;
                // Restore the active scope on unmount if this scope or a descendant scope is active.
                // Parent effect cleanups run before children, so we need to check if the
                // parent scope actually still exists before restoring the active scope to it.
                if ((scopeRef === $a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope(scopeRef, $a7a032acae3ddda9$var$activeScope)) && (!parentScope || $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(parentScope))) $a7a032acae3ddda9$var$activeScope = parentScope;
                $a7a032acae3ddda9$export$d06fae2ee68b101e.removeTreeNode(scopeRef);
            };
        }
    }, [
        scopeRef
    ]);
    let focusManager = (0, $aB6Cp$react.useMemo)(()=>$a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef), []);
    let value = (0, $aB6Cp$react.useMemo)(()=>({
            focusManager: focusManager,
            parentNode: node
        }), [
        node,
        focusManager
    ]);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement($a7a032acae3ddda9$var$FocusContext.Provider, {
        value: value
    }, /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement("span", {
        "data-focus-scope-start": true,
        hidden: true,
        ref: startRef
    }), children, /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement("span", {
        "data-focus-scope-end": true,
        hidden: true,
        ref: endRef
    }));
}
function $a7a032acae3ddda9$export$10c5169755ce7bd7() {
    var _useContext;
    return (_useContext = (0, $aB6Cp$react.useContext)($a7a032acae3ddda9$var$FocusContext)) === null || _useContext === void 0 ? void 0 : _useContext.focusManager;
}
function $a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef) {
    return {
        focusNext (opts = {}) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[0].previousElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = sentinel;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = {}) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[scope.length - 1].nextElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = sentinel;
                previousNode = walker.previousNode();
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = {}) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[0].previousElementSibling;
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = {}) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[scope.length - 1].nextElementSibling;
            let previousNode = walker.previousNode();
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        }
    };
}
const $a7a032acae3ddda9$var$focusableElements = [
    "input:not([disabled]):not([type=hidden])",
    "select:not([disabled])",
    "textarea:not([disabled])",
    "button:not([disabled])",
    "a[href]",
    "area[href]",
    "summary",
    "iframe",
    "object",
    "embed",
    "audio[controls]",
    "video[controls]",
    "[contenteditable]"
];
const $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
$a7a032acae3ddda9$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(':not([hidden]):not([tabindex="-1"]),');
function $a7a032acae3ddda9$var$getScopeRoot(scope) {
    return scope[0].parentElement;
}
function $a7a032acae3ddda9$var$shouldContainFocus(scopeRef) {
    let scope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
    while(scope && scope.scopeRef !== scopeRef){
        if (scope.contain) return false;
        scope = scope.parent;
    }
    return true;
}
function $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain) {
    let focusedNode = (0, $aB6Cp$react.useRef)();
    let raf = (0, $aB6Cp$react.useRef)(null);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let scope = scopeRef.current;
        if (!contain) {
            // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment
            if (raf.current) {
                cancelAnimationFrame(raf.current);
                raf.current = null;
            }
            return;
        }
        // Handle the Tab key to contain focus within the scope
        let onKeyDown = (e)=>{
            if (e.key !== "Tab" || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) return;
            let focusedElement = document.activeElement;
            let scope = scopeRef.current;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scope)) return;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: true
            }, scope);
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!nextElement) {
                walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;
                nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            }
            e.preventDefault();
            if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
        };
        let onFocus = (e)=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if ((!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) && $a7a032acae3ddda9$var$isElementInScope(e.target, scopeRef.current)) {
                $a7a032acae3ddda9$var$activeScope = scopeRef;
                focusedNode.current = e.target;
            } else if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(e.target, scopeRef)) {
                // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),
                // restore focus to the previously focused node or the first tabbable element in the active scope.
                if (focusedNode.current) focusedNode.current.focus();
                else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
            } else if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) focusedNode.current = e.target;
        };
        let onBlur = (e)=>{
            // Firefox doesn't shift focus back to the Dialog properly without this
            if (raf.current) cancelAnimationFrame(raf.current);
            raf.current = requestAnimationFrame(()=>{
                // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe
                if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(document.activeElement, scopeRef)) {
                    $a7a032acae3ddda9$var$activeScope = scopeRef;
                    if (document.body.contains(e.target)) {
                        focusedNode.current = e.target;
                        focusedNode.current.focus();
                    } else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
                }
            });
        };
        document.addEventListener("keydown", onKeyDown, false);
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        scope.forEach((element)=>element.addEventListener("focusout", onBlur, false));
        return ()=>{
            document.removeEventListener("keydown", onKeyDown, false);
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
            scope.forEach((element)=>element.removeEventListener("focusout", onBlur, false));
        };
    }, [
        scopeRef,
        contain
    ]);
    // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur
    // eslint-disable-next-line arrow-body-style
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        return ()=>{
            if (raf.current) cancelAnimationFrame(raf.current);
        };
    }, [
        raf
    ]);
}
function $a7a032acae3ddda9$var$isElementInAnyScope(element) {
    return $a7a032acae3ddda9$var$isElementInChildScope(element);
}
function $a7a032acae3ddda9$var$isElementInScope(element, scope) {
    return scope.some((node)=>node.contains(element));
}
function $a7a032acae3ddda9$var$isElementInChildScope(element, scope = null) {
    // If the element is within a top layer element (e.g. toasts), always allow moving focus there.
    if (element instanceof Element && element.closest("[data-react-aria-top-layer]")) return true;
    // node.contains in isElementInScope covers child scopes that are also DOM children,
    // but does not cover child scopes in portals.
    for (let { scopeRef: s  } of $a7a032acae3ddda9$export$d06fae2ee68b101e.traverse($a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scope))){
        if ($a7a032acae3ddda9$var$isElementInScope(element, s.current)) return true;
    }
    return false;
}
function $a7a032acae3ddda9$export$1258395f99bf9cbf(element) {
    return $a7a032acae3ddda9$var$isElementInChildScope(element, $a7a032acae3ddda9$var$activeScope);
}
function $a7a032acae3ddda9$var$isAncestorScope(ancestor, scope) {
    var _focusScopeTree_getTreeNode;
    let parent = (_focusScopeTree_getTreeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scope)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : _focusScopeTree_getTreeNode.parent;
    while(parent){
        if (parent.scopeRef === ancestor) return true;
        parent = parent.parent;
    }
    return false;
}
function $a7a032acae3ddda9$var$focusElement(element, scroll = false) {
    if (element != null && !scroll) try {
        (0, $1c7f9157d722357d$export$80f3e147d781571c)(element);
    } catch (err) {
    // ignore
    }
    else if (element != null) try {
        element.focus();
    } catch (err) {
    // ignore
    }
}
function $a7a032acae3ddda9$var$focusFirstInScope(scope, tabbable = true) {
    let sentinel = scope[0].previousElementSibling;
    let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
        tabbable: tabbable
    }, scope);
    walker.currentNode = sentinel;
    let nextNode = walker.nextNode();
    // If the scope does not contain a tabbable element, use the first focusable element.
    if (tabbable && !nextNode) {
        walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
            tabbable: false
        }, scope);
        walker.currentNode = sentinel;
        nextNode = walker.nextNode();
    }
    $a7a032acae3ddda9$var$focusElement(nextNode);
}
function $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus) {
    const autoFocusRef = (0, ($parcel$interopDefault($aB6Cp$react))).useRef(autoFocus);
    (0, $aB6Cp$react.useEffect)(()=>{
        if (autoFocusRef.current) {
            $a7a032acae3ddda9$var$activeScope = scopeRef;
            if (!$a7a032acae3ddda9$var$isElementInScope(document.activeElement, $a7a032acae3ddda9$var$activeScope.current)) $a7a032acae3ddda9$var$focusFirstInScope(scopeRef.current);
        }
        autoFocusRef.current = false;
    }, [
        scopeRef
    ]);
}
function $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restore, contain) {
    // tracks the active scope, in case restore and contain are both false.
    // if either are true, this is tracked in useRestoreFocus or useFocusContainment.
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if (restore || contain) return;
        let scope = scopeRef.current;
        let onFocus = (e)=>{
            let target = e.target;
            if ($a7a032acae3ddda9$var$isElementInScope(target, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
            else if (!$a7a032acae3ddda9$var$isElementInAnyScope(target)) $a7a032acae3ddda9$var$activeScope = null;
        };
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        return ()=>{
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
        };
    }, [
        scopeRef,
        restore,
        contain
    ]);
}
function $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef) {
    let scope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
    while(scope && scope.scopeRef !== scopeRef){
        if (scope.nodeToRestore) return false;
        scope = scope.parent;
    }
    return (scope === null || scope === void 0 ? void 0 : scope.scopeRef) === scopeRef;
}
function $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
    // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.
    const nodeToRestoreRef = (0, $aB6Cp$react.useRef)(typeof document !== "undefined" ? document.activeElement : null);
    // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus
    // restoring-non-containing scopes should only care if they become active so they can perform the restore
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let scope = scopeRef.current;
        if (!restoreFocus || contain) return;
        let onFocus = ()=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if ((!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) && $a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
        };
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        return ()=>{
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        scopeRef,
        contain
    ]);
    // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if (!restoreFocus) return;
        $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = nodeToRestoreRef.current;
        // Handle the Tab key so that tabbing out of the scope goes to the next element
        // after the node that had focus when the scope mounted. This is important when
        // using portals for overlays, so that focus goes to the expected element when
        // tabbing out of the overlay.
        let onKeyDown = (e)=>{
            if (e.key !== "Tab" || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) return;
            let focusedElement = document.activeElement;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scopeRef.current)) return;
            let nodeToRestore = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;
            // Create a DOM tree walker that matches all tabbable elements
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(document.body, {
                tabbable: true
            });
            // Find the next tabbable element after the currently focused element
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!document.body.contains(nodeToRestore) || nodeToRestore === document.body) {
                nodeToRestore = null;
                $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = null;
            }
            // If there is no next element, or it is outside the current scope, move focus to the
            // next element after the node to restore to instead.
            if ((!nextElement || !$a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {
                walker.currentNode = nodeToRestore;
                // Skip over elements within the scope, in case the scope immediately follows the node to restore.
                do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
                while ($a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current));
                e.preventDefault();
                e.stopPropagation();
                if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
                else // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)
                // then move focus to the body.
                // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)
                if (!$a7a032acae3ddda9$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();
                else $a7a032acae3ddda9$var$focusElement(nodeToRestore, true);
            }
        };
        if (!contain) document.addEventListener("keydown", onKeyDown, true);
        return ()=>{
            if (!contain) document.removeEventListener("keydown", onKeyDown, true);
            let nodeToRestore = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;
            // if we already lost focus to the body and this was the active scope, then we should attempt to restore
            if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps
            ($a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current) || document.activeElement === document.body && $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef))) {
                // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it
                let clonedTree = $a7a032acae3ddda9$export$d06fae2ee68b101e.clone();
                requestAnimationFrame(()=>{
                    // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere
                    if (document.activeElement === document.body) {
                        // look up the tree starting with our scope to find a nodeToRestore still in the DOM
                        let treeNode = clonedTree.getTreeNode(scopeRef);
                        while(treeNode){
                            if (treeNode.nodeToRestore && document.body.contains(treeNode.nodeToRestore)) {
                                $a7a032acae3ddda9$var$focusElement(treeNode.nodeToRestore);
                                return;
                            }
                            treeNode = treeNode.parent;
                        }
                        // If no nodeToRestore was found, focus the first element in the nearest
                        // ancestor scope that is still in the tree.
                        treeNode = clonedTree.getTreeNode(scopeRef);
                        while(treeNode){
                            if (treeNode.scopeRef && $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(treeNode.scopeRef)) {
                                $a7a032acae3ddda9$var$focusFirstInScope(treeNode.scopeRef.current, true);
                                return;
                            }
                            treeNode = treeNode.parent;
                        }
                    }
                });
            }
        };
    }, [
        scopeRef,
        restoreFocus,
        contain
    ]);
}
function $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, opts, scope) {
    let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR : $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR;
    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode (node) {
            var _opts_from;
            // Skip nodes inside the starting node.
            if (opts === null || opts === void 0 ? void 0 : (_opts_from = opts.from) === null || _opts_from === void 0 ? void 0 : _opts_from.contains(node)) return NodeFilter.FILTER_REJECT;
            if (node.matches(selector) && (0, $d5156037ad898a4d$export$e989c0fffaa6b27a)(node) && (!scope || $a7a032acae3ddda9$var$isElementInScope(node, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node))) return NodeFilter.FILTER_ACCEPT;
            return NodeFilter.FILTER_SKIP;
        }
    });
    if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;
    return walker;
}
function $a7a032acae3ddda9$export$c5251b9e124bf29(ref, defaultOptions = {}) {
    return {
        focusNext (opts = {}) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = root;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            else {
                let next = $a7a032acae3ddda9$var$last(walker);
                if (next) $a7a032acae3ddda9$var$focusElement(next, true);
                return next;
            }
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = root;
                previousNode = $a7a032acae3ddda9$var$last(walker);
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let next = $a7a032acae3ddda9$var$last(walker);
            if (next) $a7a032acae3ddda9$var$focusElement(next, true);
            return next;
        }
    };
}
function $a7a032acae3ddda9$var$last(walker) {
    let next;
    let last;
    do {
        last = walker.lastChild();
        if (last) next = last;
    }while (last);
    return next;
}
class $a7a032acae3ddda9$var$Tree {
    get size() {
        return this.fastMap.size;
    }
    getTreeNode(data) {
        return this.fastMap.get(data);
    }
    addTreeNode(scopeRef, parent, nodeToRestore) {
        let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);
        let node = new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: scopeRef
        });
        parentNode.addChild(node);
        node.parent = parentNode;
        this.fastMap.set(scopeRef, node);
        if (nodeToRestore) node.nodeToRestore = nodeToRestore;
    }
    addNode(node) {
        this.fastMap.set(node.scopeRef, node);
    }
    removeTreeNode(scopeRef) {
        // never remove the root
        if (scopeRef === null) return;
        let node = this.fastMap.get(scopeRef);
        let parentNode = node.parent;
        // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing
        // if we are, then replace the siblings restore with the restore from the scope we're removing
        for (let current of this.traverse())if (current !== node && node.nodeToRestore && current.nodeToRestore && node.scopeRef.current && $a7a032acae3ddda9$var$isElementInScope(current.nodeToRestore, node.scopeRef.current)) current.nodeToRestore = node.nodeToRestore;
        let children = node.children;
        parentNode.removeChild(node);
        if (children.size > 0) children.forEach((child)=>parentNode.addChild(child));
        this.fastMap.delete(node.scopeRef);
    }
    // Pre Order Depth First
    *traverse(node = this.root) {
        if (node.scopeRef != null) yield node;
        if (node.children.size > 0) for (let child of node.children)yield* this.traverse(child);
    }
    clone() {
        let newTree = new $a7a032acae3ddda9$var$Tree();
        for (let node of this.traverse())newTree.addTreeNode(node.scopeRef, node.parent.scopeRef, node.nodeToRestore);
        return newTree;
    }
    constructor(){
        this.fastMap = new Map();
        this.root = new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: null
        });
        this.fastMap.set(null, this.root);
    }
}
class $a7a032acae3ddda9$var$TreeNode {
    addChild(node) {
        this.children.add(node);
        node.parent = this;
    }
    removeChild(node) {
        this.children.delete(node);
        node.parent = undefined;
    }
    constructor(props){
        this.children = new Set();
        this.contain = false;
        this.scopeRef = props.scopeRef;
    }
}
let $a7a032acae3ddda9$export$d06fae2ee68b101e = new $a7a032acae3ddda9$var$Tree();


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 




function $581a96d6eb128c1b$export$4e328f61c538687f(props = {}) {
    let { autoFocus: autoFocus = false , isTextInput: isTextInput , within: within  } = props;
    let state = (0, $aB6Cp$react.useRef)({
        isFocused: false,
        isFocusVisible: autoFocus || (0, $aB6Cp$reactariainteractions.isFocusVisible)()
    });
    let [isFocused, setFocused] = (0, $aB6Cp$react.useState)(false);
    let [isFocusVisibleState, setFocusVisible] = (0, $aB6Cp$react.useState)(()=>state.current.isFocused && state.current.isFocusVisible);
    let updateState = (0, $aB6Cp$react.useCallback)(()=>setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
    let onFocusChange = (0, $aB6Cp$react.useCallback)((isFocused)=>{
        state.current.isFocused = isFocused;
        setFocused(isFocused);
        updateState();
    }, [
        updateState
    ]);
    (0, $aB6Cp$reactariainteractions.useFocusVisibleListener)((isFocusVisible)=>{
        state.current.isFocusVisible = isFocusVisible;
        updateState();
    }, [], {
        isTextInput: isTextInput
    });
    let { focusProps: focusProps  } = (0, $aB6Cp$reactariainteractions.useFocus)({
        isDisabled: within,
        onFocusChange: onFocusChange
    });
    let { focusWithinProps: focusWithinProps  } = (0, $aB6Cp$reactariainteractions.useFocusWithin)({
        isDisabled: !within,
        onFocusWithinChange: onFocusChange
    });
    return {
        isFocused: isFocused,
        isFocusVisible: isFocusVisibleState,
        focusProps: within ? focusWithinProps : focusProps
    };
}


function $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d(props) {
    let { children: children , focusClass: focusClass , focusRingClass: focusRingClass  } = props;
    let { isFocused: isFocused , isFocusVisible: isFocusVisible , focusProps: focusProps  } = (0, $581a96d6eb128c1b$export$4e328f61c538687f)(props);
    let child = (0, ($parcel$interopDefault($aB6Cp$react))).Children.only(children);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).cloneElement(child, (0, $aB6Cp$reactariautils.mergeProps)(child.props, {
        ...focusProps,
        className: (0, ($parcel$interopDefault($aB6Cp$clsx)))({
            [focusClass || ""]: isFocused,
            [focusRingClass || ""]: isFocusVisible
        })
    }));
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



let $fb504d83237fd6ac$var$FocusableContext = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createContext(null);
function $fb504d83237fd6ac$var$useFocusableContext(ref) {
    let context = (0, $aB6Cp$react.useContext)($fb504d83237fd6ac$var$FocusableContext) || {};
    (0, $aB6Cp$reactariautils.useSyncRef)(context, ref);
    // eslint-disable-next-line
    let { ref: _ , ...otherProps } = context;
    return otherProps;
}
/**
 * Provides DOM props to the nearest focusable child.
 */ function $fb504d83237fd6ac$var$FocusableProvider(props, ref) {
    let { children: children , ...otherProps } = props;
    let context = {
        ...otherProps,
        ref: ref
    };
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement($fb504d83237fd6ac$var$FocusableContext.Provider, {
        value: context
    }, children);
}
let $fb504d83237fd6ac$export$13f3202a3e5ddd5 = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).forwardRef($fb504d83237fd6ac$var$FocusableProvider);
function $fb504d83237fd6ac$export$4c014de7c8940b4c(props, domRef) {
    let { focusProps: focusProps  } = (0, $aB6Cp$reactariainteractions.useFocus)(props);
    let { keyboardProps: keyboardProps  } = (0, $aB6Cp$reactariainteractions.useKeyboard)(props);
    let interactions = (0, $aB6Cp$reactariautils.mergeProps)(focusProps, keyboardProps);
    let domProps = $fb504d83237fd6ac$var$useFocusableContext(domRef);
    let interactionProps = props.isDisabled ? {} : domProps;
    let autoFocusRef = (0, $aB6Cp$react.useRef)(props.autoFocus);
    (0, $aB6Cp$react.useEffect)(()=>{
        if (autoFocusRef.current && domRef.current) (0, $1c7f9157d722357d$export$80f3e147d781571c)(domRef.current);
        autoFocusRef.current = false;
    }, [
        domRef
    ]);
    return {
        focusableProps: (0, $aB6Cp$reactariautils.mergeProps)({
            ...interactions,
            tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined
        }, interactionProps)
    };
}




/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $259c6413a286f2e6$export$eac1895992b9f3d6(ref, options) {
    let isDisabled = options === null || options === void 0 ? void 0 : options.isDisabled;
    let [hasTabbableChild, setHasTabbableChild] = (0, $aB6Cp$react.useState)(false);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if ((ref === null || ref === void 0 ? void 0 : ref.current) && !isDisabled) {
            let update = ()=>{
                if (ref.current) {
                    let walker = (0, $a7a032acae3ddda9$export$2d6ec8fc375ceafa)(ref.current, {
                        tabbable: true
                    });
                    setHasTabbableChild(!!walker.nextNode());
                }
            };
            update();
            // Update when new elements are inserted, or the tabIndex/disabled attribute updates.
            let observer = new MutationObserver(update);
            observer.observe(ref.current, {
                subtree: true,
                childList: true,
                attributes: true,
                attributeFilter: [
                    "tabIndex",
                    "disabled"
                ]
            });
            return ()=>{
                // Disconnect mutation observer when a React update occurs on the top-level component
                // so we update synchronously after re-rendering. Otherwise React will emit act warnings
                // in tests since mutation observers fire asynchronously. The mutation observer is necessary
                // so we also update if a child component re-renders and adds/removes something tabbable.
                observer.disconnect();
            };
        }
    });
    return isDisabled ? false : hasTabbableChild;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 98884:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $goTMa$reactariautils = __webpack_require__(51044);
var $goTMa$react = __webpack_require__(18038);
var $goTMa$reactariassr = __webpack_require__(95806);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "Pressable", () => $e1dbec26039c051d$export$27c701ed9e449e99);
$parcel$export(module.exports, "PressResponder", () => $3596bae48579386f$export$3351871ee4b288b8);
$parcel$export(module.exports, "useFocus", () => $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6);
$parcel$export(module.exports, "isFocusVisible", () => $e77252a287ef94ab$export$b9b3dfddab17db27);
$parcel$export(module.exports, "getInteractionModality", () => $e77252a287ef94ab$export$630ff653c5ada6a9);
$parcel$export(module.exports, "setInteractionModality", () => $e77252a287ef94ab$export$8397ddfc504fdb9a);
$parcel$export(module.exports, "useInteractionModality", () => $e77252a287ef94ab$export$98e20ec92f614cfe);
$parcel$export(module.exports, "useFocusVisible", () => $e77252a287ef94ab$export$ffd9e5021c1fb2d6);
$parcel$export(module.exports, "useFocusVisibleListener", () => $e77252a287ef94ab$export$ec71b4b83ac08ec3);
$parcel$export(module.exports, "useFocusWithin", () => $d16842bbd0359d1b$export$420e68273165f4ec);
$parcel$export(module.exports, "useHover", () => $ffbc150311c75f01$export$ae780daf29e6d456);
$parcel$export(module.exports, "useInteractOutside", () => $edcfa848c42f94f4$export$872b660ac5a1ff98);
$parcel$export(module.exports, "useKeyboard", () => $892d64db2a3c53b0$export$8f71654801c2f7cd);
$parcel$export(module.exports, "useMove", () => $c09386fc48fa427d$export$36da96379f79f245);
$parcel$export(module.exports, "usePress", () => $0294ea432cd92340$export$45712eceda6fad21);
$parcel$export(module.exports, "useScrollWheel", () => $a3dbce0aed7087e2$export$2123ff2b87c81ca);
$parcel$export(module.exports, "useLongPress", () => $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element
// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually
let $f7e14e656343df57$var$state = "default";
let $f7e14e656343df57$var$savedUserSelect = "";
let $f7e14e656343df57$var$modifiedElementMap = new WeakMap();
function $f7e14e656343df57$export$16a4697467175487(target) {
    if ((0, $goTMa$reactariautils.isIOS)()) {
        if ($f7e14e656343df57$var$state === "default") {
            $f7e14e656343df57$var$savedUserSelect = document.documentElement.style.webkitUserSelect;
            document.documentElement.style.webkitUserSelect = "none";
        }
        $f7e14e656343df57$var$state = "disabled";
    } else if (target instanceof HTMLElement || target instanceof SVGElement) {
        // If not iOS, store the target's original user-select and change to user-select: none
        // Ignore state since it doesn't apply for non iOS
        $f7e14e656343df57$var$modifiedElementMap.set(target, target.style.userSelect);
        target.style.userSelect = "none";
    }
}
function $f7e14e656343df57$export$b0d6fa1ab32e3295(target) {
    if ((0, $goTMa$reactariautils.isIOS)()) {
        // If the state is already default, there's nothing to do.
        // If it is restoring, then there's no need to queue a second restore.
        if ($f7e14e656343df57$var$state !== "disabled") return;
        $f7e14e656343df57$var$state = "restoring";
        // There appears to be a delay on iOS where selection still might occur
        // after pointer up, so wait a bit before removing user-select.
        setTimeout(()=>{
            // Wait for any CSS transitions to complete so we don't recompute style
            // for the whole page in the middle of the animation and cause jank.
            (0, $goTMa$reactariautils.runAfterTransition)(()=>{
                // Avoid race conditions
                if ($f7e14e656343df57$var$state === "restoring") {
                    if (document.documentElement.style.webkitUserSelect === "none") document.documentElement.style.webkitUserSelect = $f7e14e656343df57$var$savedUserSelect || "";
                    $f7e14e656343df57$var$savedUserSelect = "";
                    $f7e14e656343df57$var$state = "default";
                }
            });
        }, 300);
    } else if (target instanceof HTMLElement || target instanceof SVGElement) // If not iOS, restore the target's original user-select if any
    // Ignore state since it doesn't apply for non iOS
    {
        if (target && $f7e14e656343df57$var$modifiedElementMap.has(target)) {
            let targetOldUserSelect = $f7e14e656343df57$var$modifiedElementMap.get(target);
            if (target.style.userSelect === "none") target.style.userSelect = targetOldUserSelect;
            if (target.getAttribute("style") === "") target.removeAttribute("style");
            $f7e14e656343df57$var$modifiedElementMap.delete(target);
        }
    }
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $01d3f539e91688c8$export$5165eccb35aaadb5 = (0, ($parcel$interopDefault($goTMa$react))).createContext(null);
$01d3f539e91688c8$export$5165eccb35aaadb5.displayName = "PressResponderContext";



function $0294ea432cd92340$var$usePressResponderContext(props) {
    // Consume context from <PressResponder> and merge with props.
    let context = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));
    if (context) {
        let { register: register , ...contextProps } = context;
        props = (0, $goTMa$reactariautils.mergeProps)(contextProps, props);
        register();
    }
    (0, $goTMa$reactariautils.useSyncRef)(context, props.ref);
    return props;
}
function $0294ea432cd92340$export$45712eceda6fad21(props) {
    let { onPress: onPress , onPressChange: onPressChange , onPressStart: onPressStart , onPressEnd: onPressEnd , onPressUp: onPressUp , isDisabled: isDisabled , isPressed: isPressedProp , preventFocusOnPress: preventFocusOnPress , shouldCancelOnPointerExit: shouldCancelOnPointerExit , allowTextSelectionOnPress: allowTextSelectionOnPress , // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: _ , ...domProps } = $0294ea432cd92340$var$usePressResponderContext(props);
    let [isPressed, setPressed] = (0, $goTMa$react.useState)(false);
    let ref = (0, $goTMa$react.useRef)({
        isPressed: false,
        ignoreEmulatedMouseEvents: false,
        ignoreClickAfterPress: false,
        didFirePressStart: false,
        activePointerId: null,
        target: null,
        isOverTarget: false,
        pointerType: null
    });
    let { addGlobalListener: addGlobalListener , removeAllGlobalListeners: removeAllGlobalListeners  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let triggerPressStart = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        let state = ref.current;
        if (isDisabled || state.didFirePressStart) return;
        if (onPressStart) onPressStart({
            type: "pressstart",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
        if (onPressChange) onPressChange(true);
        state.didFirePressStart = true;
        setPressed(true);
    });
    let triggerPressEnd = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType, wasPressed = true)=>{
        let state = ref.current;
        if (!state.didFirePressStart) return;
        state.ignoreClickAfterPress = true;
        state.didFirePressStart = false;
        if (onPressEnd) onPressEnd({
            type: "pressend",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
        if (onPressChange) onPressChange(false);
        setPressed(false);
        if (onPress && wasPressed && !isDisabled) onPress({
            type: "press",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let triggerPressUp = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        if (isDisabled) return;
        if (onPressUp) onPressUp({
            type: "pressup",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let cancel = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        let state = ref.current;
        if (state.isPressed) {
            if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
            state.isPressed = false;
            state.isOverTarget = false;
            state.activePointerId = null;
            state.pointerType = null;
            removeAllGlobalListeners();
            if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
        }
    });
    let cancelOnPointerExit = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (shouldCancelOnPointerExit) cancel(e);
    });
    let pressProps = (0, $goTMa$react.useMemo)(()=>{
        let state = ref.current;
        let pressProps = {
            onKeyDown (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {
                    if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                    e.stopPropagation();
                    // If the event is repeating, it may have started on a different element
                    // after which focus moved to the current element. Ignore these events and
                    // only handle the first key down event.
                    if (!state.isPressed && !e.repeat) {
                        state.target = e.currentTarget;
                        state.isPressed = true;
                        triggerPressStart(e, "keyboard");
                        // Focus may move before the key up event, so register the event on the document
                        // instead of the same element where the key down event occurred.
                        addGlobalListener(document, "keyup", onKeyUp, false);
                    }
                } else if (e.key === "Enter" && $0294ea432cd92340$var$isHTMLAnchorLink(e.currentTarget)) // If the target is a link, we won't have handled this above because we want the default
                // browser behavior to open the link when pressing Enter. But we still need to prevent
                // default so that elements above do not also handle it (e.g. table row).
                e.stopPropagation();
            },
            onKeyUp (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target)) triggerPressUp($0294ea432cd92340$var$createEvent(state.target, e), "keyboard");
            },
            onClick (e) {
                if (e && !e.currentTarget.contains(e.target)) return;
                if (e && e.button === 0) {
                    e.stopPropagation();
                    if (isDisabled) e.preventDefault();
                    // If triggered from a screen reader or by using element.click(),
                    // trigger as if it were a keyboard click.
                    if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && (state.pointerType === "virtual" || (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent))) {
                        // Ensure the element receives focus (VoiceOver on iOS does not do this)
                        if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                        triggerPressStart(e, "virtual");
                        triggerPressUp(e, "virtual");
                        triggerPressEnd(e, "virtual");
                    }
                    state.ignoreEmulatedMouseEvents = false;
                    state.ignoreClickAfterPress = false;
                }
            }
        };
        let onKeyUp = (e)=>{
            if (state.isPressed && $0294ea432cd92340$var$isValidKeyboardEvent(e, state.target)) {
                if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                e.stopPropagation();
                state.isPressed = false;
                let target = e.target;
                triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), "keyboard", state.target.contains(target));
                removeAllGlobalListeners();
                // If the target is a link, trigger the click method to open the URL,
                // but defer triggering pressEnd until onClick event handler.
                if (state.target instanceof HTMLElement && state.target.contains(target) && ($0294ea432cd92340$var$isHTMLAnchorLink(state.target) || state.target.getAttribute("role") === "link")) state.target.click();
            }
        };
        if (typeof PointerEvent !== "undefined") {
            pressProps.onPointerDown = (e)=>{
                // Only handle left clicks, and ignore events that bubbled through portals.
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.
                // Ignore and let the onClick handler take care of it instead.
                // https://bugs.webkit.org/show_bug.cgi?id=222627
                // https://bugs.webkit.org/show_bug.cgi?id=223202
                if ((0, $goTMa$reactariautils.isVirtualPointerEvent)(e.nativeEvent)) {
                    state.pointerType = "virtual";
                    return;
                }
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on pointer down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                state.pointerType = e.pointerType;
                e.stopPropagation();
                if (!state.isPressed) {
                    state.isPressed = true;
                    state.isOverTarget = true;
                    state.activePointerId = e.pointerId;
                    state.target = e.currentTarget;
                    if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                    if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);
                    triggerPressStart(e, state.pointerType);
                    addGlobalListener(document, "pointermove", onPointerMove, false);
                    addGlobalListener(document, "pointerup", onPointerUp, false);
                    addGlobalListener(document, "pointercancel", onPointerCancel, false);
                }
            };
            pressProps.onMouseDown = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (e.button === 0) {
                    // Chrome and Firefox on touch Windows devices require mouse down events
                    // to be canceled in addition to pointer events, or an extra asynchronous
                    // focus event will be fired.
                    if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                    e.stopPropagation();
                }
            };
            pressProps.onPointerUp = (e)=>{
                // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.
                if (!e.currentTarget.contains(e.target) || state.pointerType === "virtual") return;
                // Only handle left clicks
                // Safari on iOS sometimes fires pointerup events, even
                // when the touch isn't over the target, so double check.
                if (e.button === 0 && $0294ea432cd92340$var$isOverTarget(e, e.currentTarget)) triggerPressUp(e, state.pointerType || e.pointerType);
            };
            // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.
            // Use pointer move events instead to implement our own hit testing.
            // See https://bugs.webkit.org/show_bug.cgi?id=199803
            let onPointerMove = (e)=>{
                if (e.pointerId !== state.activePointerId) return;
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0) {
                    if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    state.isPressed = false;
                    state.isOverTarget = false;
                    state.activePointerId = null;
                    state.pointerType = null;
                    removeAllGlobalListeners();
                    if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
                }
            };
            let onPointerCancel = (e)=>{
                cancel(e);
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.
                cancel(e);
            };
        } else {
            pressProps.onMouseDown = (e)=>{
                // Only handle left clicks
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on mouse down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                e.stopPropagation();
                if (state.ignoreEmulatedMouseEvents) return;
                state.isPressed = true;
                state.isOverTarget = true;
                state.target = e.currentTarget;
                state.pointerType = (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent) ? "virtual" : "mouse";
                if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(document, "mouseup", onMouseUp, false);
            };
            pressProps.onMouseEnter = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = true;
                    triggerPressStart(e, state.pointerType);
                }
            };
            pressProps.onMouseLeave = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            pressProps.onMouseUp = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType);
            };
            let onMouseUp = (e)=>{
                // Only handle left clicks
                if (e.button !== 0) return;
                state.isPressed = false;
                removeAllGlobalListeners();
                if (state.ignoreEmulatedMouseEvents) {
                    state.ignoreEmulatedMouseEvents = false;
                    return;
                }
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                state.isOverTarget = false;
            };
            pressProps.onTouchStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                let touch = $0294ea432cd92340$var$getTouchFromEvent(e.nativeEvent);
                if (!touch) return;
                state.activePointerId = touch.identifier;
                state.ignoreEmulatedMouseEvents = true;
                state.isOverTarget = true;
                state.isPressed = true;
                state.target = e.currentTarget;
                state.pointerType = "touch";
                // Due to browser inconsistencies, especially on mobile browsers, we prevent default
                // on the emulated mouse event and handle focusing the pressable element ourselves.
                if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(window, "scroll", onScroll, true);
            };
            pressProps.onTouchMove = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart(e, state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            pressProps.onTouchEnd = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    triggerPressUp(e, state.pointerType);
                    triggerPressEnd(e, state.pointerType);
                } else if (state.isOverTarget) triggerPressEnd(e, state.pointerType, false);
                state.isPressed = false;
                state.activePointerId = null;
                state.isOverTarget = false;
                state.ignoreEmulatedMouseEvents = true;
                if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
                removeAllGlobalListeners();
            };
            pressProps.onTouchCancel = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed) cancel(e);
            };
            let onScroll = (e)=>{
                if (state.isPressed && e.target.contains(state.target)) cancel({
                    currentTarget: state.target,
                    shiftKey: false,
                    ctrlKey: false,
                    metaKey: false,
                    altKey: false
                });
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                cancel(e);
            };
        }
        return pressProps;
    }, [
        addGlobalListener,
        isDisabled,
        preventFocusOnPress,
        removeAllGlobalListeners,
        allowTextSelectionOnPress,
        cancel,
        cancelOnPointerExit,
        triggerPressEnd,
        triggerPressStart,
        triggerPressUp
    ]);
    // Remove user-select: none in case component unmounts immediately after pressStart
    // eslint-disable-next-line arrow-body-style
    (0, $goTMa$react.useEffect)(()=>{
        return ()=>{
            if (!allowTextSelectionOnPress) // eslint-disable-next-line react-hooks/exhaustive-deps
            (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(ref.current.target);
        };
    }, [
        allowTextSelectionOnPress
    ]);
    return {
        isPressed: isPressedProp || isPressed,
        pressProps: (0, $goTMa$reactariautils.mergeProps)(domProps, pressProps)
    };
}
function $0294ea432cd92340$var$isHTMLAnchorLink(target) {
    return target.tagName === "A" && target.hasAttribute("href");
}
function $0294ea432cd92340$var$isValidKeyboardEvent(event, currentTarget) {
    const { key: key , code: code  } = event;
    const element = currentTarget;
    const role = element.getAttribute("role");
    // Accessibility for keyboards. Space and Enter only.
    // "Spacebar" is for IE 11
    return (key === "Enter" || key === " " || key === "Spacebar" || code === "Space") && !(element instanceof HTMLInputElement && !$0294ea432cd92340$var$isValidInputKey(element, key) || element instanceof HTMLTextAreaElement || element.isContentEditable) && // A link with a valid href should be handled natively,
    // unless it also has role='button' and was triggered using Space.
    (!$0294ea432cd92340$var$isHTMLAnchorLink(element) || role === "button" && key !== "Enter") && // An element with role='link' should only trigger with Enter key
    !(role === "link" && key !== "Enter");
}
function $0294ea432cd92340$var$getTouchFromEvent(event) {
    const { targetTouches: targetTouches  } = event;
    if (targetTouches.length > 0) return targetTouches[0];
    return null;
}
function $0294ea432cd92340$var$getTouchById(event, pointerId) {
    const changedTouches = event.changedTouches;
    for(let i = 0; i < changedTouches.length; i++){
        const touch = changedTouches[i];
        if (touch.identifier === pointerId) return touch;
    }
    return null;
}
function $0294ea432cd92340$var$createEvent(target, e) {
    return {
        currentTarget: target,
        shiftKey: e.shiftKey,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey
    };
}
function $0294ea432cd92340$var$getPointClientRect(point) {
    let offsetX = point.width / 2 || point.radiusX || 0;
    let offsetY = point.height / 2 || point.radiusY || 0;
    return {
        top: point.clientY - offsetY,
        right: point.clientX + offsetX,
        bottom: point.clientY + offsetY,
        left: point.clientX - offsetX
    };
}
function $0294ea432cd92340$var$areRectanglesOverlapping(a, b) {
    // check if they cannot overlap on x axis
    if (a.left > b.right || b.left > a.right) return false;
    // check if they cannot overlap on y axis
    if (a.top > b.bottom || b.top > a.bottom) return false;
    return true;
}
function $0294ea432cd92340$var$isOverTarget(point, target) {
    let rect = target.getBoundingClientRect();
    let pointRect = $0294ea432cd92340$var$getPointClientRect(point);
    return $0294ea432cd92340$var$areRectanglesOverlapping(rect, pointRect);
}
function $0294ea432cd92340$var$shouldPreventDefault(target) {
    // We cannot prevent default if the target is a draggable element.
    return !(target instanceof HTMLElement) || !target.draggable;
}
function $0294ea432cd92340$var$shouldPreventDefaultKeyboard(target, key) {
    if (target instanceof HTMLInputElement) return !$0294ea432cd92340$var$isValidInputKey(target, key);
    if (target instanceof HTMLButtonElement) return target.type !== "submit";
    return true;
}
const $0294ea432cd92340$var$nonTextInputTypes = new Set([
    "checkbox",
    "radio",
    "range",
    "color",
    "file",
    "image",
    "button",
    "submit",
    "reset"
]);
function $0294ea432cd92340$var$isValidInputKey(target, key) {
    // Only space should toggle checkboxes and radios, not enter.
    return target.type === "checkbox" || target.type === "radio" ? key === " " : $0294ea432cd92340$var$nonTextInputTypes.has(target.type);
}



const $e1dbec26039c051d$export$27c701ed9e449e99 = /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).forwardRef(({ children: children , ...props }, ref)=>{
    let newRef = (0, $goTMa$react.useRef)();
    ref = ref !== null && ref !== void 0 ? ref : newRef;
    let { pressProps: pressProps  } = (0, $0294ea432cd92340$export$45712eceda6fad21)({
        ...props,
        ref: ref
    });
    let child = (0, ($parcel$interopDefault($goTMa$react))).Children.only(children);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).cloneElement(child, // @ts-ignore
    {
        ref: ref,
        ...(0, $goTMa$reactariautils.mergeProps)(child.props, pressProps)
    });
});


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $3596bae48579386f$export$3351871ee4b288b8 = /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).forwardRef(({ children: children , ...props }, ref)=>{
    let isRegistered = (0, $goTMa$react.useRef)(false);
    let prevContext = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));
    let context = (0, $goTMa$reactariautils.mergeProps)(prevContext || {}, {
        ...props,
        ref: ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref),
        register () {
            isRegistered.current = true;
            if (prevContext) prevContext.register();
        }
    });
    (0, $goTMa$reactariautils.useSyncRef)(prevContext, ref);
    (0, $goTMa$react.useEffect)(()=>{
        if (!isRegistered.current) {
            console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.");
            isRegistered.current = true; // only warn once in strict mode.
        }
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).createElement((0, $01d3f539e91688c8$export$5165eccb35aaadb5).Provider, {
        value: context
    }, children);
});


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

class $625cf83917e112ad$export$905e7fc544a71f36 {
    isDefaultPrevented() {
        return this.nativeEvent.defaultPrevented;
    }
    preventDefault() {
        this.defaultPrevented = true;
        this.nativeEvent.preventDefault();
    }
    stopPropagation() {
        this.nativeEvent.stopPropagation();
        this.isPropagationStopped = ()=>true;
    }
    isPropagationStopped() {
        return false;
    }
    persist() {}
    constructor(type, nativeEvent){
        this.nativeEvent = nativeEvent;
        this.target = nativeEvent.target;
        this.currentTarget = nativeEvent.currentTarget;
        this.relatedTarget = nativeEvent.relatedTarget;
        this.bubbles = nativeEvent.bubbles;
        this.cancelable = nativeEvent.cancelable;
        this.defaultPrevented = nativeEvent.defaultPrevented;
        this.eventPhase = nativeEvent.eventPhase;
        this.isTrusted = nativeEvent.isTrusted;
        this.timeStamp = nativeEvent.timeStamp;
        this.type = type;
    }
}
function $625cf83917e112ad$export$715c682d09d639cc(onBlur) {
    let stateRef = (0, $goTMa$react.useRef)({
        isFocused: false,
        observer: null
    });
    // Clean up MutationObserver on unmount. See below.
    // eslint-disable-next-line arrow-body-style
    (0, $goTMa$reactariautils.useLayoutEffect)(()=>{
        const state = stateRef.current;
        return ()=>{
            if (state.observer) {
                state.observer.disconnect();
                state.observer = null;
            }
        };
    }, []);
    let dispatchBlur = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
    });
    // This function is called during a React onFocus event.
    return (0, $goTMa$react.useCallback)((e)=>{
        // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142
        // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a
        // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.
        // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.
        if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {
            stateRef.current.isFocused = true;
            let target = e.target;
            let onBlurHandler = (e)=>{
                stateRef.current.isFocused = false;
                if (target.disabled) // For backward compatibility, dispatch a (fake) React synthetic event.
                dispatchBlur(new $625cf83917e112ad$export$905e7fc544a71f36("blur", e));
                // We no longer need the MutationObserver once the target is blurred.
                if (stateRef.current.observer) {
                    stateRef.current.observer.disconnect();
                    stateRef.current.observer = null;
                }
            };
            target.addEventListener("focusout", onBlurHandler, {
                once: true
            });
            stateRef.current.observer = new MutationObserver(()=>{
                if (stateRef.current.isFocused && target.disabled) {
                    stateRef.current.observer.disconnect();
                    let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
                    target.dispatchEvent(new FocusEvent("blur", {
                        relatedTarget: relatedTargetEl
                    }));
                    target.dispatchEvent(new FocusEvent("focusout", {
                        bubbles: true,
                        relatedTarget: relatedTargetEl
                    }));
                }
            });
            stateRef.current.observer.observe(target, {
                attributes: true,
                attributeFilter: [
                    "disabled"
                ]
            });
        }
    }, [
        dispatchBlur
    ]);
}


function $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6(props) {
    let { isDisabled: isDisabled , onFocus: onFocusProp , onBlur: onBlurProp , onFocusChange: onFocusChange  } = props;
    const onBlur = (0, $goTMa$react.useCallback)((e)=>{
        if (e.target === e.currentTarget) {
            if (onBlurProp) onBlurProp(e);
            if (onFocusChange) onFocusChange(false);
            return true;
        }
    }, [
        onBlurProp,
        onFocusChange
    ]);
    const onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);
    const onFocus = (0, $goTMa$react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (e.target === e.currentTarget && document.activeElement === e.target) {
            if (onFocusProp) onFocusProp(e);
            if (onFocusChange) onFocusChange(true);
            onSyntheticFocus(e);
        }
    }, [
        onFocusChange,
        onFocusProp,
        onSyntheticFocus
    ]);
    return {
        focusProps: {
            onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,
            onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : undefined
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions



let $e77252a287ef94ab$var$currentModality = null;
let $e77252a287ef94ab$var$changeHandlers = new Set();
let $e77252a287ef94ab$var$hasSetupGlobalListeners = false;
let $e77252a287ef94ab$var$hasEventBeforeFocus = false;
let $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
// Only Tab or Esc keys will make focus visible on text input elements
const $e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS = {
    Tab: true,
    Escape: true
};
function $e77252a287ef94ab$var$triggerChangeHandlers(modality, e) {
    for (let handler of $e77252a287ef94ab$var$changeHandlers)handler(modality, e);
}
/**
 * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.
 */ function $e77252a287ef94ab$var$isValidKey(e) {
    // Control and Shift keys trigger when navigating back to the tab with keyboard.
    return !(e.metaKey || !(0, $goTMa$reactariautils.isMac)() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
function $e77252a287ef94ab$var$handleKeyboardEvent(e) {
    $e77252a287ef94ab$var$hasEventBeforeFocus = true;
    if ($e77252a287ef94ab$var$isValidKey(e)) {
        $e77252a287ef94ab$var$currentModality = "keyboard";
        $e77252a287ef94ab$var$triggerChangeHandlers("keyboard", e);
    }
}
function $e77252a287ef94ab$var$handlePointerEvent(e) {
    $e77252a287ef94ab$var$currentModality = "pointer";
    if (e.type === "mousedown" || e.type === "pointerdown") {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$triggerChangeHandlers("pointer", e);
    }
}
function $e77252a287ef94ab$var$handleClickEvent(e) {
    if ((0, $goTMa$reactariautils.isVirtualClick)(e)) {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$currentModality = "virtual";
    }
}
function $e77252a287ef94ab$var$handleFocusEvent(e) {
    // Firefox fires two extra focus events when the user first clicks into an iframe:
    // first on the window, then on the document. We ignore these events so they don't
    // cause keyboard focus rings to appear.
    if (e.target === window || e.target === document) return;
    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.
    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.
    if (!$e77252a287ef94ab$var$hasEventBeforeFocus && !$e77252a287ef94ab$var$hasBlurredWindowRecently) {
        $e77252a287ef94ab$var$currentModality = "virtual";
        $e77252a287ef94ab$var$triggerChangeHandlers("virtual", e);
    }
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
}
function $e77252a287ef94ab$var$handleWindowBlur() {
    // When the window is blurred, reset state. This is necessary when tabbing out of the window,
    // for example, since a subsequent focus event won't be fired.
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = true;
}
/**
 * Setup global event listeners to control when keyboard focus style should be visible.
 */ function $e77252a287ef94ab$var$setupGlobalFocusEvents() {
    if (typeof window === "undefined" || $e77252a287ef94ab$var$hasSetupGlobalListeners) return;
    // Programmatic focus() calls shouldn't affect the current input modality.
    // However, we need to detect other cases when a focus event occurs without
    // a preceding user event (e.g. screen reader focus). Overriding the focus
    // method on HTMLElement.prototype is a bit hacky, but works.
    let focus = HTMLElement.prototype.focus;
    HTMLElement.prototype.focus = function() {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        focus.apply(this, arguments);
    };
    document.addEventListener("keydown", $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener("keyup", $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener("click", $e77252a287ef94ab$var$handleClickEvent, true);
    // Register focus events on the window so they are sure to happen
    // before React's event listeners (registered on the document).
    window.addEventListener("focus", $e77252a287ef94ab$var$handleFocusEvent, true);
    window.addEventListener("blur", $e77252a287ef94ab$var$handleWindowBlur, false);
    if (typeof PointerEvent !== "undefined") {
        document.addEventListener("pointerdown", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("pointermove", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("pointerup", $e77252a287ef94ab$var$handlePointerEvent, true);
    } else {
        document.addEventListener("mousedown", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("mousemove", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("mouseup", $e77252a287ef94ab$var$handlePointerEvent, true);
    }
    $e77252a287ef94ab$var$hasSetupGlobalListeners = true;
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e77252a287ef94ab$var$setupGlobalFocusEvents();
    else document.addEventListener("DOMContentLoaded", $e77252a287ef94ab$var$setupGlobalFocusEvents);
}
function $e77252a287ef94ab$export$b9b3dfddab17db27() {
    return $e77252a287ef94ab$var$currentModality !== "pointer";
}
function $e77252a287ef94ab$export$630ff653c5ada6a9() {
    return $e77252a287ef94ab$var$currentModality;
}
function $e77252a287ef94ab$export$8397ddfc504fdb9a(modality) {
    $e77252a287ef94ab$var$currentModality = modality;
    $e77252a287ef94ab$var$triggerChangeHandlers(modality, null);
}
function $e77252a287ef94ab$export$98e20ec92f614cfe() {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    let [modality, setModality] = (0, $goTMa$react.useState)($e77252a287ef94ab$var$currentModality);
    (0, $goTMa$react.useEffect)(()=>{
        let handler = ()=>{
            setModality($e77252a287ef94ab$var$currentModality);
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    }, []);
    return (0, $goTMa$reactariassr.useIsSSR)() ? null : modality;
}
/**
 * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that
 * focus visible style can be properly set.
 */ function $e77252a287ef94ab$var$isKeyboardFocusEvent(isTextInput, modality, e) {
    return !(isTextInput && modality === "keyboard" && e instanceof KeyboardEvent && !$e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);
}
function $e77252a287ef94ab$export$ffd9e5021c1fb2d6(props = {}) {
    let { isTextInput: isTextInput , autoFocus: autoFocus  } = props;
    let [isFocusVisibleState, setFocusVisible] = (0, $goTMa$react.useState)(autoFocus || $e77252a287ef94ab$export$b9b3dfddab17db27());
    $e77252a287ef94ab$export$ec71b4b83ac08ec3((isFocusVisible)=>{
        setFocusVisible(isFocusVisible);
    }, [
        isTextInput
    ], {
        isTextInput: isTextInput
    });
    return {
        isFocusVisible: isFocusVisibleState
    };
}
function $e77252a287ef94ab$export$ec71b4b83ac08ec3(fn, deps, opts) {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    (0, $goTMa$react.useEffect)(()=>{
        let handler = (modality, e)=>{
            if (!$e77252a287ef94ab$var$isKeyboardFocusEvent(opts === null || opts === void 0 ? void 0 : opts.isTextInput, modality, e)) return;
            fn($e77252a287ef94ab$export$b9b3dfddab17db27());
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, deps);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $d16842bbd0359d1b$export$420e68273165f4ec(props) {
    let { isDisabled: isDisabled , onBlurWithin: onBlurWithin , onFocusWithin: onFocusWithin , onFocusWithinChange: onFocusWithinChange  } = props;
    let state = (0, $goTMa$react.useRef)({
        isFocusWithin: false
    });
    let onBlur = (0, $goTMa$react.useCallback)((e)=>{
        // We don't want to trigger onBlurWithin and then immediately onFocusWithin again
        // when moving focus inside the element. Only trigger if the currentTarget doesn't
        // include the relatedTarget (where focus is moving).
        if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {
            state.current.isFocusWithin = false;
            if (onBlurWithin) onBlurWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(false);
        }
    }, [
        onBlurWithin,
        onFocusWithinChange,
        state
    ]);
    let onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);
    let onFocus = (0, $goTMa$react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (!state.current.isFocusWithin && document.activeElement === e.target) {
            if (onFocusWithin) onFocusWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(true);
            state.current.isFocusWithin = true;
            onSyntheticFocus(e);
        }
    }, [
        onFocusWithin,
        onFocusWithinChange,
        onSyntheticFocus
    ]);
    if (isDisabled) return {
        focusWithinProps: {
            onFocus: null,
            onBlur: null
        }
    };
    return {
        focusWithinProps: {
            onFocus: onFocus,
            onBlur: onBlur
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

// iOS fires onPointerEnter twice: once with pointerType="touch" and again with pointerType="mouse".
// We want to ignore these emulated events so they do not trigger hover behavior.
// See https://bugs.webkit.org/show_bug.cgi?id=214609.
let $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
let $ffbc150311c75f01$var$hoverCount = 0;
function $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents() {
    $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = true;
    // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter
    // with pointerType="mouse" immediately after onPointerUp and before onFocus. On other
    // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in
    // the distant future because a user previously touched the element.
    setTimeout(()=>{
        $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
    }, 50);
}
function $ffbc150311c75f01$var$handleGlobalPointerEvent(e) {
    if (e.pointerType === "touch") $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $ffbc150311c75f01$var$setupGlobalTouchEvents() {
    if (typeof document === "undefined") return;
    if (typeof PointerEvent !== "undefined") document.addEventListener("pointerup", $ffbc150311c75f01$var$handleGlobalPointerEvent);
    else document.addEventListener("touchend", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    $ffbc150311c75f01$var$hoverCount++;
    return ()=>{
        $ffbc150311c75f01$var$hoverCount--;
        if ($ffbc150311c75f01$var$hoverCount > 0) return;
        if (typeof PointerEvent !== "undefined") document.removeEventListener("pointerup", $ffbc150311c75f01$var$handleGlobalPointerEvent);
        else document.removeEventListener("touchend", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    };
}
function $ffbc150311c75f01$export$ae780daf29e6d456(props) {
    let { onHoverStart: onHoverStart , onHoverChange: onHoverChange , onHoverEnd: onHoverEnd , isDisabled: isDisabled  } = props;
    let [isHovered, setHovered] = (0, $goTMa$react.useState)(false);
    let state = (0, $goTMa$react.useRef)({
        isHovered: false,
        ignoreEmulatedMouseEvents: false,
        pointerType: "",
        target: null
    }).current;
    (0, $goTMa$react.useEffect)($ffbc150311c75f01$var$setupGlobalTouchEvents, []);
    let { hoverProps: hoverProps , triggerHoverEnd: triggerHoverEnd  } = (0, $goTMa$react.useMemo)(()=>{
        let triggerHoverStart = (event, pointerType)=>{
            state.pointerType = pointerType;
            if (isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target)) return;
            state.isHovered = true;
            let target = event.currentTarget;
            state.target = target;
            if (onHoverStart) onHoverStart({
                type: "hoverstart",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(true);
            setHovered(true);
        };
        let triggerHoverEnd = (event, pointerType)=>{
            state.pointerType = "";
            state.target = null;
            if (pointerType === "touch" || !state.isHovered) return;
            state.isHovered = false;
            let target = event.currentTarget;
            if (onHoverEnd) onHoverEnd({
                type: "hoverend",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(false);
            setHovered(false);
        };
        let hoverProps = {};
        if (typeof PointerEvent !== "undefined") {
            hoverProps.onPointerEnter = (e)=>{
                if ($ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents && e.pointerType === "mouse") return;
                triggerHoverStart(e, e.pointerType);
            };
            hoverProps.onPointerLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);
            };
        } else {
            hoverProps.onTouchStart = ()=>{
                state.ignoreEmulatedMouseEvents = true;
            };
            hoverProps.onMouseEnter = (e)=>{
                if (!state.ignoreEmulatedMouseEvents && !$ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, "mouse");
                state.ignoreEmulatedMouseEvents = false;
            };
            hoverProps.onMouseLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, "mouse");
            };
        }
        return {
            hoverProps: hoverProps,
            triggerHoverEnd: triggerHoverEnd
        };
    }, [
        onHoverStart,
        onHoverChange,
        onHoverEnd,
        isDisabled,
        state
    ]);
    (0, $goTMa$react.useEffect)(()=>{
        // Call the triggerHoverEnd as soon as isDisabled changes to true
        // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering
        if (isDisabled) triggerHoverEnd({
            currentTarget: state.target
        }, state.pointerType);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        isDisabled
    ]);
    return {
        hoverProps: hoverProps,
        isHovered: isHovered
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $edcfa848c42f94f4$export$872b660ac5a1ff98(props) {
    let { ref: ref , onInteractOutside: onInteractOutside , isDisabled: isDisabled , onInteractOutsideStart: onInteractOutsideStart  } = props;
    let stateRef = (0, $goTMa$react.useRef)({
        isPointerDown: false,
        ignoreEmulatedMouseEvents: false
    });
    let onPointerDown = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (onInteractOutside && $edcfa848c42f94f4$var$isValidEvent(e, ref)) {
            if (onInteractOutsideStart) onInteractOutsideStart(e);
            stateRef.current.isPointerDown = true;
        }
    });
    let triggerInteractOutside = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (onInteractOutside) onInteractOutside(e);
    });
    (0, $goTMa$react.useEffect)(()=>{
        let state = stateRef.current;
        if (isDisabled) return;
        // Use pointer events if available. Otherwise, fall back to mouse and touch events.
        if (typeof PointerEvent !== "undefined") {
            let onPointerUp = (e)=>{
                if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            // changing these to capture phase fixed combobox
            document.addEventListener("pointerdown", onPointerDown, true);
            document.addEventListener("pointerup", onPointerUp, true);
            return ()=>{
                document.removeEventListener("pointerdown", onPointerDown, true);
                document.removeEventListener("pointerup", onPointerUp, true);
            };
        } else {
            let onMouseUp = (e)=>{
                if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;
                else if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            let onTouchEnd = (e)=>{
                state.ignoreEmulatedMouseEvents = true;
                if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            document.addEventListener("mousedown", onPointerDown, true);
            document.addEventListener("mouseup", onMouseUp, true);
            document.addEventListener("touchstart", onPointerDown, true);
            document.addEventListener("touchend", onTouchEnd, true);
            return ()=>{
                document.removeEventListener("mousedown", onPointerDown, true);
                document.removeEventListener("mouseup", onMouseUp, true);
                document.removeEventListener("touchstart", onPointerDown, true);
                document.removeEventListener("touchend", onTouchEnd, true);
            };
        }
    }, [
        ref,
        isDisabled,
        onPointerDown,
        triggerInteractOutside
    ]);
}
function $edcfa848c42f94f4$var$isValidEvent(event, ref) {
    if (event.button > 0) return false;
    if (event.target) {
        // if the event target is no longer in the document, ignore
        const ownerDocument = event.target.ownerDocument;
        if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;
        // If the target is within a top layer element (e.g. toasts), ignore.
        if (event.target.closest("[data-react-aria-top-layer]")) return false;
    }
    return ref.current && !ref.current.contains(event.target);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $951fbcbbca8db6ce$export$48d1ea6320830260(handler) {
    if (!handler) return;
    let shouldStopPropagation = true;
    return (e)=>{
        let event = {
            ...e,
            preventDefault () {
                e.preventDefault();
            },
            isDefaultPrevented () {
                return e.isDefaultPrevented();
            },
            stopPropagation () {
                console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
            },
            continuePropagation () {
                shouldStopPropagation = false;
            }
        };
        handler(event);
        if (shouldStopPropagation) e.stopPropagation();
    };
}


function $892d64db2a3c53b0$export$8f71654801c2f7cd(props) {
    return {
        keyboardProps: props.isDisabled ? {} : {
            onKeyDown: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyDown),
            onKeyUp: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyUp)
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $c09386fc48fa427d$export$36da96379f79f245(props) {
    let { onMoveStart: onMoveStart , onMove: onMove , onMoveEnd: onMoveEnd  } = props;
    let state = (0, $goTMa$react.useRef)({
        didMove: false,
        lastPosition: null,
        id: null
    });
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let move = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType, deltaX, deltaY)=>{
        if (deltaX === 0 && deltaY === 0) return;
        if (!state.current.didMove) {
            state.current.didMove = true;
            onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart({
                type: "movestart",
                pointerType: pointerType,
                shiftKey: originalEvent.shiftKey,
                metaKey: originalEvent.metaKey,
                ctrlKey: originalEvent.ctrlKey,
                altKey: originalEvent.altKey
            });
        }
        onMove({
            type: "move",
            pointerType: pointerType,
            deltaX: deltaX,
            deltaY: deltaY,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let end = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)();
        if (state.current.didMove) onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd({
            type: "moveend",
            pointerType: pointerType,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let moveProps = (0, $goTMa$react.useMemo)(()=>{
        let moveProps = {};
        let start = ()=>{
            (0, $f7e14e656343df57$export$16a4697467175487)();
            state.current.didMove = false;
        };
        if (typeof PointerEvent === "undefined") {
            let onMouseMove = (e)=>{
                if (e.button === 0) {
                    move(e, "mouse", e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onMouseUp = (e)=>{
                if (e.button === 0) {
                    end(e, "mouse");
                    removeGlobalListener(window, "mousemove", onMouseMove, false);
                    removeGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            moveProps.onMouseDown = (e)=>{
                if (e.button === 0) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    addGlobalListener(window, "mousemove", onMouseMove, false);
                    addGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            let onTouchMove = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id);
                if (touch >= 0) {
                    let { pageX: pageX , pageY: pageY  } = e.changedTouches[touch];
                    move(e, "touch", pageX - state.current.lastPosition.pageX, pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: pageX,
                        pageY: pageY
                    };
                }
            };
            let onTouchEnd = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id);
                if (touch >= 0) {
                    end(e, "touch");
                    state.current.id = null;
                    removeGlobalListener(window, "touchmove", onTouchMove);
                    removeGlobalListener(window, "touchend", onTouchEnd);
                    removeGlobalListener(window, "touchcancel", onTouchEnd);
                }
            };
            moveProps.onTouchStart = (e)=>{
                if (e.changedTouches.length === 0 || state.current.id != null) return;
                let { pageX: pageX , pageY: pageY , identifier: identifier  } = e.changedTouches[0];
                start();
                e.stopPropagation();
                e.preventDefault();
                state.current.lastPosition = {
                    pageX: pageX,
                    pageY: pageY
                };
                state.current.id = identifier;
                addGlobalListener(window, "touchmove", onTouchMove, false);
                addGlobalListener(window, "touchend", onTouchEnd, false);
                addGlobalListener(window, "touchcancel", onTouchEnd, false);
            };
        } else {
            let onPointerMove = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    // Problems with PointerEvent#movementX/movementY:
                    // 1. it is always 0 on macOS Safari.
                    // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS
                    move(e, pointerType, e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    end(e, pointerType);
                    state.current.id = null;
                    removeGlobalListener(window, "pointermove", onPointerMove, false);
                    removeGlobalListener(window, "pointerup", onPointerUp, false);
                    removeGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
            moveProps.onPointerDown = (e)=>{
                if (e.button === 0 && state.current.id == null) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    state.current.id = e.pointerId;
                    addGlobalListener(window, "pointermove", onPointerMove, false);
                    addGlobalListener(window, "pointerup", onPointerUp, false);
                    addGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
        }
        let triggerKeyboardMove = (e, deltaX, deltaY)=>{
            start();
            move(e, "keyboard", deltaX, deltaY);
            end(e, "keyboard");
        };
        moveProps.onKeyDown = (e)=>{
            switch(e.key){
                case "Left":
                case "ArrowLeft":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, -1, 0);
                    break;
                case "Right":
                case "ArrowRight":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 1, 0);
                    break;
                case "Up":
                case "ArrowUp":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, -1);
                    break;
                case "Down":
                case "ArrowDown":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, 1);
                    break;
            }
        };
        return moveProps;
    }, [
        state,
        addGlobalListener,
        removeGlobalListener,
        move,
        end
    ]);
    return {
        moveProps: moveProps
    };
}



/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $a3dbce0aed7087e2$export$2123ff2b87c81ca(props, ref) {
    let { onScroll: onScroll , isDisabled: isDisabled  } = props;
    let onScrollHandler = (0, $goTMa$react.useCallback)((e)=>{
        // If the ctrlKey is pressed, this is a zoom event, do nothing.
        if (e.ctrlKey) return;
        // stop scrolling the page
        e.preventDefault();
        e.stopPropagation();
        if (onScroll) onScroll({
            deltaX: e.deltaX,
            deltaY: e.deltaY
        });
    }, [
        onScroll
    ]);
    (0, $goTMa$reactariautils.useEvent)(ref, "wheel", isDisabled ? null : onScrollHandler);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD = 500;
function $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9(props) {
    let { isDisabled: isDisabled , onLongPressStart: onLongPressStart , onLongPressEnd: onLongPressEnd , onLongPress: onLongPress , threshold: threshold = $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD , accessibilityDescription: accessibilityDescription  } = props;
    const timeRef = (0, $goTMa$react.useRef)(null);
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let { pressProps: pressProps  } = (0, $0294ea432cd92340$export$45712eceda6fad21)({
        isDisabled: isDisabled,
        onPressStart (e) {
            if (e.pointerType === "mouse" || e.pointerType === "touch") {
                if (onLongPressStart) onLongPressStart({
                    ...e,
                    type: "longpressstart"
                });
                timeRef.current = setTimeout(()=>{
                    // Prevent other usePress handlers from also handling this event.
                    e.target.dispatchEvent(new PointerEvent("pointercancel", {
                        bubbles: true
                    }));
                    if (onLongPress) onLongPress({
                        ...e,
                        type: "longpress"
                    });
                    timeRef.current = null;
                }, threshold);
                // Prevent context menu, which may be opened on long press on touch devices
                if (e.pointerType === "touch") {
                    let onContextMenu = (e)=>{
                        e.preventDefault();
                    };
                    addGlobalListener(e.target, "contextmenu", onContextMenu, {
                        once: true
                    });
                    addGlobalListener(window, "pointerup", ()=>{
                        // If no contextmenu event is fired quickly after pointerup, remove the handler
                        // so future context menu events outside a long press are not prevented.
                        setTimeout(()=>{
                            removeGlobalListener(e.target, "contextmenu", onContextMenu);
                        }, 30);
                    }, {
                        once: true
                    });
                }
            }
        },
        onPressEnd (e) {
            if (timeRef.current) clearTimeout(timeRef.current);
            if (onLongPressEnd && (e.pointerType === "mouse" || e.pointerType === "touch")) onLongPressEnd({
                ...e,
                type: "longpressend"
            });
        }
    });
    let descriptionProps = (0, $goTMa$reactariautils.useDescription)(onLongPress && !isDisabled ? accessibilityDescription : null);
    return {
        longPressProps: (0, $goTMa$reactariautils.mergeProps)(pressProps, descriptionProps)
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 95806:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $4hxXn$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "SSRProvider", () => $29383e587d62412a$export$9f8ac96af4b1b2ae);
$parcel$export(module.exports, "useSSRSafeId", () => $29383e587d62412a$export$619500959fc48b26);
$parcel$export(module.exports, "useIsSSR", () => $29383e587d62412a$export$535bd6ca7f90a273);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We must avoid a circular dependency with @react-aria/utils, and this useLayoutEffect is
// guarded by a check that it only runs on the client side.
// eslint-disable-next-line rulesdir/useLayoutEffectRule

// Default context value to use in case there is no SSRProvider. This is fine for
// client-only apps. In order to support multiple copies of React Aria potentially
// being on the page at once, the prefix is set to a random number. SSRProvider
// will reset this to zero for consistency between server and client, so in the
// SSR case multiple copies of React Aria is not supported.
const $29383e587d62412a$var$defaultContext = {
    prefix: String(Math.round(Math.random() * 10000000000)),
    current: 0,
    isSSR: false
};
const $29383e587d62412a$var$SSRContext = /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createContext($29383e587d62412a$var$defaultContext);
// This is only used in React < 18.
function $29383e587d62412a$var$LegacySSRProvider(props) {
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let counter = $29383e587d62412a$var$useCounter(cur === $29383e587d62412a$var$defaultContext);
    let [isSSR, setIsSSR] = (0, $4hxXn$react.useState)(true);
    let value = (0, $4hxXn$react.useMemo)(()=>({
            // If this is the first SSRProvider, start with an empty string prefix, otherwise
            // append and increment the counter.
            prefix: cur === $29383e587d62412a$var$defaultContext ? "" : `${cur.prefix}-${counter}`,
            current: 0,
            isSSR: isSSR
        }), [
        cur,
        counter,
        isSSR
    ]);
    // If on the client, and the component was initially server rendered,
    // then schedule a layout effect to update the component after hydration.
    if (typeof window !== "undefined") // This if statement technically breaks the rules of hooks, but is safe
    // because the condition never changes after mounting.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, $4hxXn$react.useLayoutEffect)(()=>{
        setIsSSR(false);
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$SSRContext.Provider, {
        value: value
    }, props.children);
}
let $29383e587d62412a$var$warnedAboutSSRProvider = false;
function $29383e587d62412a$export$9f8ac96af4b1b2ae(props) {
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function") {
        if (!$29383e587d62412a$var$warnedAboutSSRProvider) {
            console.warn("In React 18, SSRProvider is not necessary and is a noop. You can remove it from your app.");
            $29383e587d62412a$var$warnedAboutSSRProvider = true;
        }
        return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement((0, ($parcel$interopDefault($4hxXn$react))).Fragment, null, props.children);
    }
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$LegacySSRProvider, props);
}
let $29383e587d62412a$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
let $29383e587d62412a$var$componentIds = new WeakMap();
function $29383e587d62412a$var$useCounter(isDisabled = false) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let ref = (0, $4hxXn$react.useRef)(null);
    // eslint-disable-next-line rulesdir/pure-render
    if (ref.current === null && !isDisabled) {
        var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner;
        // In strict mode, React renders components twice, and the ref will be reset to null on the second render.
        // This means our id counter will be incremented twice instead of once. This is a problem because on the
        // server, components are only rendered once and so ids generated on the server won't match the client.
        // In React 18, useId was introduced to solve this, but it is not available in older versions. So to solve this
        // we need to use some React internals to access the underlying Fiber instance, which is stable between renders.
        // This is exposed as ReactCurrentOwner in development, which is all we need since StrictMode only runs in development.
        // To ensure that we only increment the global counter once, we store the starting id for this component in
        // a weak map associated with the Fiber. On the second render, we reset the global counter to this value.
        // Since React runs the second render immediately after the first, this is safe.
        // @ts-ignore
        let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, ($parcel$interopDefault($4hxXn$react))).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;
        if (currentOwner) {
            let prevComponentValue = $29383e587d62412a$var$componentIds.get(currentOwner);
            if (prevComponentValue == null) // On the first render, and first call to useId, store the id and state in our weak map.
            $29383e587d62412a$var$componentIds.set(currentOwner, {
                id: ctx.current,
                state: currentOwner.memoizedState
            });
            else if (currentOwner.memoizedState !== prevComponentValue.state) {
                // On the second render, the memoizedState gets reset by React.
                // Reset the counter, and remove from the weak map so we don't
                // do this for subsequent useId calls.
                ctx.current = prevComponentValue.id;
                $29383e587d62412a$var$componentIds.delete(currentOwner);
            }
        }
        // eslint-disable-next-line rulesdir/pure-render
        ref.current = ++ctx.current;
    }
    // eslint-disable-next-line rulesdir/pure-render
    return ref.current;
}
function $29383e587d62412a$var$useLegacySSRSafeId(defaultId) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    // If we are rendering in a non-DOM environment, and there's no SSRProvider,
    // provide a warning to hint to the developer to add one.
    if (ctx === $29383e587d62412a$var$defaultContext && !$29383e587d62412a$var$canUseDOM) console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
    let counter = $29383e587d62412a$var$useCounter(!!defaultId);
    return defaultId || `react-aria${ctx.prefix}-${counter}`;
}
function $29383e587d62412a$var$useModernSSRSafeId(defaultId) {
    // @ts-ignore
    let id = (0, ($parcel$interopDefault($4hxXn$react))).useId();
    let [didSSR] = (0, $4hxXn$react.useState)($29383e587d62412a$export$535bd6ca7f90a273());
    let prefix = didSSR ? "react-aria" : `react-aria${$29383e587d62412a$var$defaultContext.prefix}`;
    return defaultId || `${prefix}-${id}`;
}
const $29383e587d62412a$export$619500959fc48b26 = typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function" ? $29383e587d62412a$var$useModernSSRSafeId : $29383e587d62412a$var$useLegacySSRSafeId;
function $29383e587d62412a$var$getSnapshot() {
    return false;
}
function $29383e587d62412a$var$getServerSnapshot() {
    return true;
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function $29383e587d62412a$var$subscribe(onStoreChange) {
    // noop
    return ()=>{};
}
function $29383e587d62412a$export$535bd6ca7f90a273() {
    // In React 18, we can use useSyncExternalStore to detect if we're server rendering or hydrating.
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"] === "function") return (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"]($29383e587d62412a$var$subscribe, $29383e587d62412a$var$getSnapshot, $29383e587d62412a$var$getServerSnapshot);
    // eslint-disable-next-line react-hooks/rules-of-hooks
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    return cur.isSSR;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 51044:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $1Yh1N$reactstatelyutils = __webpack_require__(12259);
var $1Yh1N$react = __webpack_require__(18038);
var $1Yh1N$reactariassr = __webpack_require__(95806);
var $1Yh1N$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useId", () => $8c61827343eed941$export$f680877a34711e37);
$parcel$export(module.exports, "mergeIds", () => $8c61827343eed941$export$cd8c9cb68f842629);
$parcel$export(module.exports, "useSlotId", () => $8c61827343eed941$export$b4cc09c592e8fdb8);
$parcel$export(module.exports, "chain", () => $1e2191638e54f613$export$e08e3b67e392101e);
$parcel$export(module.exports, "mergeProps", () => $f847cd1382ea7cd4$export$9d1611c77c2fe928);
$parcel$export(module.exports, "mergeRefs", () => $f05dc24eafaeb7e2$export$c9058316764c140e);
$parcel$export(module.exports, "filterDOMProps", () => $8d15d0e1797d4238$export$457c3d6518dd4c6f);
$parcel$export(module.exports, "focusWithoutScrolling", () => $1117b6c0d4c4c164$export$de79e2c695e052f3);
$parcel$export(module.exports, "getOffset", () => $16ec41ef3e36c19c$export$622cea445a1c5b7d);
$parcel$export(module.exports, "runAfterTransition", () => $e8117ebcab55be6a$export$24490316f764c430);
$parcel$export(module.exports, "useDrag1D", () => $28ed3fb20343b78b$export$7bbed75feba39706);
$parcel$export(module.exports, "useGlobalListeners", () => $4571ff54ac709100$export$4eaf04e54aa8eed6);
$parcel$export(module.exports, "useLabels", () => $6ec78bde395c477d$export$d6875122194c7b44);
$parcel$export(module.exports, "useObjectRef", () => $475b35fe72ba49b3$export$4338b53315abf666);
$parcel$export(module.exports, "useUpdateEffect", () => $29293a6f5c75b37e$export$496315a1608d9602);
$parcel$export(module.exports, "useLayoutEffect", () => $78605a5d7424e31b$export$e5c5a5f917a5871c);
$parcel$export(module.exports, "useResizeObserver", () => $37733e1652f47193$export$683480f191c0e3ea);
$parcel$export(module.exports, "useSyncRef", () => $6fc733991a9f977c$export$4debdb1a3f0fa79e);
$parcel$export(module.exports, "getScrollParent", () => $d796e7157ac96470$export$cfa2225e87938781);
$parcel$export(module.exports, "isScrollable", () => $d796e7157ac96470$export$2bb74740c4e19def);
$parcel$export(module.exports, "useViewportSize", () => $8b24bab62f5c65ad$export$d699905dd57c73ca);
$parcel$export(module.exports, "useDescription", () => $34da4502ea8120db$export$f8aeda7b10753fa1);
$parcel$export(module.exports, "isMac", () => $9e20cff0af27e8cc$export$9ac100e40613ea10);
$parcel$export(module.exports, "isIPhone", () => $9e20cff0af27e8cc$export$186c6964ca17d99);
$parcel$export(module.exports, "isIPad", () => $9e20cff0af27e8cc$export$7bef049ce92e4224);
$parcel$export(module.exports, "isIOS", () => $9e20cff0af27e8cc$export$fedb369cb70207f1);
$parcel$export(module.exports, "isAppleDevice", () => $9e20cff0af27e8cc$export$e1865c3bedcd822b);
$parcel$export(module.exports, "isWebKit", () => $9e20cff0af27e8cc$export$78551043582a6a98);
$parcel$export(module.exports, "isChrome", () => $9e20cff0af27e8cc$export$6446a186d09e379e);
$parcel$export(module.exports, "isAndroid", () => $9e20cff0af27e8cc$export$a11b0059900ceec8);
$parcel$export(module.exports, "useEvent", () => $2a8c0bb1629926c8$export$90fc3a17d93f704c);
$parcel$export(module.exports, "useValueEffect", () => $19a2307bfabafaf1$export$14d238f342723f25);
$parcel$export(module.exports, "scrollIntoView", () => $449412113267a1fe$export$53a0910f038337bd);
$parcel$export(module.exports, "scrollIntoViewport", () => $449412113267a1fe$export$c826860796309d1b);
$parcel$export(module.exports, "clamp", () => $1Yh1N$reactstatelyutils.clamp);
$parcel$export(module.exports, "snapValueToStep", () => $1Yh1N$reactstatelyutils.snapValueToStep);
$parcel$export(module.exports, "isVirtualClick", () => $577e795361f19be9$export$60278871457622de);
$parcel$export(module.exports, "isVirtualPointerEvent", () => $577e795361f19be9$export$29bf1b5f2c56cf63);
$parcel$export(module.exports, "useEffectEvent", () => $1254e5bb94ac8761$export$7f54fc3180508a52);
$parcel$export(module.exports, "useDeepMemo", () => $20e6e72fbf5dc81e$export$722debc0e56fea39);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $78605a5d7424e31b$export$e5c5a5f917a5871c = typeof window !== "undefined" ? (0, ($parcel$interopDefault($1Yh1N$react))).useLayoutEffect : ()=>{};



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $19a2307bfabafaf1$export$14d238f342723f25(defaultValue) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultValue);
    let valueRef = (0, $1Yh1N$react.useRef)(value);
    let effect = (0, $1Yh1N$react.useRef)(null);
    // Must be stable so that `queue` is stable.
    let nextIter = (0, $1Yh1N$react.useCallback)(()=>{
        // Run the generator to the next yield.
        let newValue = effect.current.next();
        while(!newValue.done && valueRef.current === newValue.value)// If the value is the same as the current value,
        // then continue to the next yield. Otherwise,
        // set the value in state and wait for the next layout effect.
        newValue = effect.current.next();
        // If the generator is done, reset the effect.
        if (newValue.done) {
            effect.current = null;
            return;
        }
        // Always update valueRef when setting the state.
        // This is needed because the function is not regenerated with the new state value since
        // they must be stable across renders. Instead, it gets carried in the ref, but the setState
        // is also needed in order to cause a rerender.
        setValue(newValue.value);
        valueRef.current = newValue.value;
    // this list of dependencies is stable, setState and refs never change after first render.
    }, [
        setValue,
        valueRef,
        effect
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        // If there is an effect currently running, continue to the next yield.
        if (effect.current) nextIter();
    });
    // queue must be a stable function, much like setState.
    let queue = (0, $1Yh1N$react.useCallback)((fn)=>{
        effect.current = fn(valueRef.current);
        nextIter();
    // this list of dependencies is stable, setState and refs never change after first render.
    // in addition, nextIter is stable as outlined above
    }, [
        nextIter,
        effect,
        valueRef
    ]);
    return [
        value,
        queue
    ];
}


let $8c61827343eed941$var$idsUpdaterMap = new Map();
function $8c61827343eed941$export$f680877a34711e37(defaultId) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultId);
    let nextId = (0, $1Yh1N$react.useRef)(null);
    let res = (0, $1Yh1N$reactariassr.useSSRSafeId)(value);
    let updateValue = (0, $1Yh1N$react.useCallback)((val)=>{
        nextId.current = val;
    }, []);
    $8c61827343eed941$var$idsUpdaterMap.set(res, updateValue);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        let r = res;
        return ()=>{
            $8c61827343eed941$var$idsUpdaterMap.delete(r);
        };
    }, [
        res
    ]);
    // This cannot cause an infinite loop because the ref is updated first.
    // eslint-disable-next-line
    (0, $1Yh1N$react.useEffect)(()=>{
        let newId = nextId.current;
        if (newId) {
            nextId.current = null;
            setValue(newId);
        }
    });
    return res;
}
function $8c61827343eed941$export$cd8c9cb68f842629(idA, idB) {
    if (idA === idB) return idA;
    let setIdA = $8c61827343eed941$var$idsUpdaterMap.get(idA);
    if (setIdA) {
        setIdA(idB);
        return idB;
    }
    let setIdB = $8c61827343eed941$var$idsUpdaterMap.get(idB);
    if (setIdB) {
        setIdB(idA);
        return idA;
    }
    return idB;
}
function $8c61827343eed941$export$b4cc09c592e8fdb8(depArray = []) {
    let id = $8c61827343eed941$export$f680877a34711e37();
    let [resolvedId, setResolvedId] = (0, $19a2307bfabafaf1$export$14d238f342723f25)(id);
    let updateId = (0, $1Yh1N$react.useCallback)(()=>{
        setResolvedId(function*() {
            yield id;
            yield document.getElementById(id) ? id : undefined;
        });
    }, [
        id,
        setResolvedId
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(updateId, [
        id,
        updateId,
        ...depArray
    ]);
    return resolvedId;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /**
 * Calls all functions in the order they were chained with the same arguments.
 */ function $1e2191638e54f613$export$e08e3b67e392101e(...callbacks) {
    return (...args)=>{
        for (let callback of callbacks)if (typeof callback === "function") callback(...args);
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $f847cd1382ea7cd4$export$9d1611c77c2fe928(...args) {
    // Start with a base clone of the first argument. This is a lot faster than starting
    // with an empty object and adding properties as we go.
    let result = {
        ...args[0]
    };
    for(let i = 1; i < args.length; i++){
        let props = args[i];
        for(let key in props){
            let a = result[key];
            let b = props[key];
            // Chain events
            if (typeof a === "function" && typeof b === "function" && // This is a lot faster than a regex.
            key[0] === "o" && key[1] === "n" && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = (0, $1e2191638e54f613$export$e08e3b67e392101e)(a, b);
            else if ((key === "className" || key === "UNSAFE_className") && typeof a === "string" && typeof b === "string") result[key] = (0, ($parcel$interopDefault($1Yh1N$clsx)))(a, b);
            else if (key === "id" && a && b) result.id = (0, $8c61827343eed941$export$cd8c9cb68f842629)(a, b);
            else result[key] = b !== undefined ? b : a;
        }
    }
    return result;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $f05dc24eafaeb7e2$export$c9058316764c140e(...refs) {
    if (refs.length === 1) return refs[0];
    return (value)=>{
        for (let ref of refs){
            if (typeof ref === "function") ref(value);
            else if (ref != null) ref.current = value;
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ const $8d15d0e1797d4238$var$DOMPropNames = new Set([
    "id"
]);
const $8d15d0e1797d4238$var$labelablePropNames = new Set([
    "aria-label",
    "aria-labelledby",
    "aria-describedby",
    "aria-details"
]);
const $8d15d0e1797d4238$var$propRe = /^(data-.*)$/;
function $8d15d0e1797d4238$export$457c3d6518dd4c6f(props, opts = {}) {
    let { labelable: labelable , propNames: propNames  } = opts;
    let filteredProps = {};
    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($8d15d0e1797d4238$var$DOMPropNames.has(prop) || labelable && $8d15d0e1797d4238$var$labelablePropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $8d15d0e1797d4238$var$propRe.test(prop))) filteredProps[prop] = props[prop];
    return filteredProps;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $1117b6c0d4c4c164$export$de79e2c695e052f3(element) {
    if ($1117b6c0d4c4c164$var$supportsPreventScroll()) element.focus({
        preventScroll: true
    });
    else {
        let scrollableElements = $1117b6c0d4c4c164$var$getScrollableElements(element);
        element.focus();
        $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements);
    }
}
let $1117b6c0d4c4c164$var$supportsPreventScrollCached = null;
function $1117b6c0d4c4c164$var$supportsPreventScroll() {
    if ($1117b6c0d4c4c164$var$supportsPreventScrollCached == null) {
        $1117b6c0d4c4c164$var$supportsPreventScrollCached = false;
        try {
            var focusElem = document.createElement("div");
            focusElem.focus({
                get preventScroll () {
                    $1117b6c0d4c4c164$var$supportsPreventScrollCached = true;
                    return true;
                }
            });
        } catch (e) {
        // Ignore
        }
    }
    return $1117b6c0d4c4c164$var$supportsPreventScrollCached;
}
function $1117b6c0d4c4c164$var$getScrollableElements(element) {
    var parent = element.parentNode;
    var scrollableElements = [];
    var rootScrollingElement = document.scrollingElement || document.documentElement;
    while(parent instanceof HTMLElement && parent !== rootScrollingElement){
        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({
            element: parent,
            scrollTop: parent.scrollTop,
            scrollLeft: parent.scrollLeft
        });
        parent = parent.parentNode;
    }
    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
        element: rootScrollingElement,
        scrollTop: rootScrollingElement.scrollTop,
        scrollLeft: rootScrollingElement.scrollLeft
    });
    return scrollableElements;
}
function $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements) {
    for (let { element: element , scrollTop: scrollTop , scrollLeft: scrollLeft  } of scrollableElements){
        element.scrollTop = scrollTop;
        element.scrollLeft = scrollLeft;
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $16ec41ef3e36c19c$export$622cea445a1c5b7d(element, reverse, orientation = "horizontal") {
    let rect = element.getBoundingClientRect();
    if (reverse) return orientation === "horizontal" ? rect.right : rect.bottom;
    return orientation === "horizontal" ? rect.left : rect.top;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We store a global list of elements that are currently transitioning,
// mapped to a set of CSS properties that are transitioning for that element.
// This is necessary rather than a simple count of transitions because of browser
// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather
// than one or the other. So we need to track what's actually transitioning so that
// we can ignore these duplicate events.
let $e8117ebcab55be6a$var$transitionsByElement = new Map();
// A list of callbacks to call once there are no transitioning elements.
let $e8117ebcab55be6a$var$transitionCallbacks = new Set();
function $e8117ebcab55be6a$var$setupGlobalEvents() {
    if (typeof window === "undefined") return;
    let onTransitionStart = (e)=>{
        // Add the transitioning property to the list for this element.
        let transitions = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!transitions) {
            transitions = new Set();
            $e8117ebcab55be6a$var$transitionsByElement.set(e.target, transitions);
            // The transitioncancel event must be registered on the element itself, rather than as a global
            // event. This enables us to handle when the node is deleted from the document while it is transitioning.
            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.
            e.target.addEventListener("transitioncancel", onTransitionEnd);
        }
        transitions.add(e.propertyName);
    };
    let onTransitionEnd = (e)=>{
        // Remove property from list of transitioning properties.
        let properties = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!properties) return;
        properties.delete(e.propertyName);
        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.
        if (properties.size === 0) {
            e.target.removeEventListener("transitioncancel", onTransitionEnd);
            $e8117ebcab55be6a$var$transitionsByElement.delete(e.target);
        }
        // If no transitioning elements, call all of the queued callbacks.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) {
            for (let cb of $e8117ebcab55be6a$var$transitionCallbacks)cb();
            $e8117ebcab55be6a$var$transitionCallbacks.clear();
        }
    };
    document.body.addEventListener("transitionrun", onTransitionStart);
    document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e8117ebcab55be6a$var$setupGlobalEvents();
    else document.addEventListener("DOMContentLoaded", $e8117ebcab55be6a$var$setupGlobalEvents);
}
function $e8117ebcab55be6a$export$24490316f764c430(fn) {
    // Wait one frame to see if an animation starts, e.g. a transition on mount.
    requestAnimationFrame(()=>{
        // If no transitions are running, call the function immediately.
        // Otherwise, add it to a list of callbacks to run at the end of the animation.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) fn();
        else $e8117ebcab55be6a$var$transitionCallbacks.add(fn);
    });
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 

// Keep track of elements that we are currently handling dragging for via useDrag1D.
// If there's an ancestor and a descendant both using useDrag1D(), and the user starts
// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.
const $28ed3fb20343b78b$var$draggingElements = [];
function $28ed3fb20343b78b$export$7bbed75feba39706(props) {
    console.warn("useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html");
    let { containerRef: containerRef , reverse: reverse , orientation: orientation , onHover: onHover , onDrag: onDrag , onPositionChange: onPositionChange , onIncrement: onIncrement , onDecrement: onDecrement , onIncrementToMax: onIncrementToMax , onDecrementToMin: onDecrementToMin , onCollapseToggle: onCollapseToggle  } = props;
    let getPosition = (e)=>orientation === "horizontal" ? e.clientX : e.clientY;
    let getNextOffset = (e)=>{
        let containerOffset = (0, $16ec41ef3e36c19c$export$622cea445a1c5b7d)(containerRef.current, reverse, orientation);
        let mouseOffset = getPosition(e);
        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;
        return nextOffset;
    };
    let dragging = (0, $1Yh1N$react.useRef)(false);
    let prevPosition = (0, $1Yh1N$react.useRef)(0);
    // Keep track of the current handlers in a ref so that the events can access them.
    let handlers = (0, $1Yh1N$react.useRef)({
        onPositionChange: onPositionChange,
        onDrag: onDrag
    });
    handlers.current.onDrag = onDrag;
    handlers.current.onPositionChange = onPositionChange;
    let onMouseDragged = (e)=>{
        e.preventDefault();
        let nextOffset = getNextOffset(e);
        if (!dragging.current) {
            dragging.current = true;
            if (handlers.current.onDrag) handlers.current.onDrag(true);
            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        }
        if (prevPosition.current === nextOffset) return;
        prevPosition.current = nextOffset;
        if (onPositionChange) onPositionChange(nextOffset);
    };
    let onMouseUp = (e)=>{
        const target = e.target;
        dragging.current = false;
        let nextOffset = getNextOffset(e);
        if (handlers.current.onDrag) handlers.current.onDrag(false);
        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        $28ed3fb20343b78b$var$draggingElements.splice($28ed3fb20343b78b$var$draggingElements.indexOf(target), 1);
        window.removeEventListener("mouseup", onMouseUp, false);
        window.removeEventListener("mousemove", onMouseDragged, false);
    };
    let onMouseDown = (e)=>{
        const target = e.currentTarget;
        // If we're already handling dragging on a descendant with useDrag1D, then
        // we don't want to handle the drag motion on this target as well.
        if ($28ed3fb20343b78b$var$draggingElements.some((elt)=>target.contains(elt))) return;
        $28ed3fb20343b78b$var$draggingElements.push(target);
        window.addEventListener("mousemove", onMouseDragged, false);
        window.addEventListener("mouseup", onMouseUp, false);
    };
    let onMouseEnter = ()=>{
        if (onHover) onHover(true);
    };
    let onMouseOut = ()=>{
        if (onHover) onHover(false);
    };
    let onKeyDown = (e)=>{
        switch(e.key){
            case "Left":
            case "ArrowLeft":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Up":
            case "ArrowUp":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Right":
            case "ArrowRight":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Down":
            case "ArrowDown":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Home":
                e.preventDefault();
                if (onDecrementToMin) onDecrementToMin();
                break;
            case "End":
                e.preventDefault();
                if (onIncrementToMax) onIncrementToMax();
                break;
            case "Enter":
                e.preventDefault();
                if (onCollapseToggle) onCollapseToggle();
                break;
        }
    };
    return {
        onMouseDown: onMouseDown,
        onMouseEnter: onMouseEnter,
        onMouseOut: onMouseOut,
        onKeyDown: onKeyDown
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $4571ff54ac709100$export$4eaf04e54aa8eed6() {
    let globalListeners = (0, $1Yh1N$react.useRef)(new Map());
    let addGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        // Make sure we remove the listener after it is called with the `once` option.
        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{
            globalListeners.current.delete(listener);
            listener(...args);
        } : listener;
        globalListeners.current.set(listener, {
            type: type,
            eventTarget: eventTarget,
            fn: fn,
            options: options
        });
        eventTarget.addEventListener(type, listener, options);
    }, []);
    let removeGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        var _globalListeners_current_get;
        let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
        eventTarget.removeEventListener(type, fn, options);
        globalListeners.current.delete(listener);
    }, []);
    let removeAllGlobalListeners = (0, $1Yh1N$react.useCallback)(()=>{
        globalListeners.current.forEach((value, key)=>{
            removeGlobalListener(value.eventTarget, value.type, key, value.options);
        });
    }, [
        removeGlobalListener
    ]);
    // eslint-disable-next-line arrow-body-style
    (0, $1Yh1N$react.useEffect)(()=>{
        return removeAllGlobalListeners;
    }, [
        removeAllGlobalListeners
    ]);
    return {
        addGlobalListener: addGlobalListener,
        removeGlobalListener: removeGlobalListener,
        removeAllGlobalListeners: removeAllGlobalListeners
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6ec78bde395c477d$export$d6875122194c7b44(props, defaultLabel) {
    let { id: id , "aria-label": label , "aria-labelledby": labelledBy  } = props;
    // If there is both an aria-label and aria-labelledby,
    // combine them by pointing to the element itself.
    id = (0, $8c61827343eed941$export$f680877a34711e37)(id);
    if (labelledBy && label) {
        let ids = new Set([
            id,
            ...labelledBy.trim().split(/\s+/)
        ]);
        labelledBy = [
            ...ids
        ].join(" ");
    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\s+/).join(" ");
    // If no labels are provided, use the default
    if (!label && !labelledBy && defaultLabel) label = defaultLabel;
    return {
        id: id,
        "aria-label": label,
        "aria-labelledby": labelledBy
    };
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $475b35fe72ba49b3$export$4338b53315abf666(forwardedRef) {
    const objRef = (0, $1Yh1N$react.useRef)();
    return (0, $1Yh1N$react.useMemo)(()=>({
            get current () {
                return objRef.current;
            },
            set current (value){
                objRef.current = value;
                if (typeof forwardedRef === "function") forwardedRef(value);
                else if (forwardedRef) forwardedRef.current = value;
            }
        }), [
        forwardedRef
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $29293a6f5c75b37e$export$496315a1608d9602(effect, dependencies) {
    const isInitialMount = (0, $1Yh1N$react.useRef)(true);
    const lastDeps = (0, $1Yh1N$react.useRef)(null);
    (0, $1Yh1N$react.useEffect)(()=>{
        isInitialMount.current = true;
        return ()=>{
            isInitialMount.current = false;
        };
    }, []);
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isInitialMount.current) isInitialMount.current = false;
        else if (!lastDeps.current || dependencies.some((dep, i)=>!Object.is(dep, lastDeps[i]))) effect();
        lastDeps.current = dependencies;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencies);
}




function $37733e1652f47193$var$hasResizeObserver() {
    return typeof window.ResizeObserver !== "undefined";
}
function $37733e1652f47193$export$683480f191c0e3ea(options) {
    const { ref: ref , onResize: onResize  } = options;
    (0, $1Yh1N$react.useEffect)(()=>{
        let element = ref === null || ref === void 0 ? void 0 : ref.current;
        if (!element) return;
        if (!$37733e1652f47193$var$hasResizeObserver()) {
            window.addEventListener("resize", onResize, false);
            return ()=>{
                window.removeEventListener("resize", onResize, false);
            };
        } else {
            const resizeObserverInstance = new window.ResizeObserver((entries)=>{
                if (!entries.length) return;
                onResize();
            });
            resizeObserverInstance.observe(element);
            return ()=>{
                if (element) resizeObserverInstance.unobserve(element);
            };
        }
    }, [
        onResize,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6fc733991a9f977c$export$4debdb1a3f0fa79e(context, ref) {
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (context && context.ref && ref) {
            context.ref.current = ref.current;
            return ()=>{
                context.ref.current = null;
            };
        }
    }, [
        context,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d796e7157ac96470$export$cfa2225e87938781(node) {
    if ($d796e7157ac96470$export$2bb74740c4e19def(node)) node = node.parentElement;
    while(node && !$d796e7157ac96470$export$2bb74740c4e19def(node))node = node.parentElement;
    return node || document.scrollingElement || document.documentElement;
}
function $d796e7157ac96470$export$2bb74740c4e19def(node) {
    let style = window.getComputedStyle(node);
    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// @ts-ignore
let $8b24bab62f5c65ad$var$visualViewport = typeof window !== "undefined" && window.visualViewport;
function $8b24bab62f5c65ad$export$d699905dd57c73ca() {
    let [size, setSize] = (0, $1Yh1N$react.useState)(()=>$8b24bab62f5c65ad$var$getViewportSize());
    (0, $1Yh1N$react.useEffect)(()=>{
        // Use visualViewport api to track available height even on iOS virtual keyboard opening
        let onResize = ()=>{
            setSize((size)=>{
                let newSize = $8b24bab62f5c65ad$var$getViewportSize();
                if (newSize.width === size.width && newSize.height === size.height) return size;
                return newSize;
            });
        };
        if (!$8b24bab62f5c65ad$var$visualViewport) window.addEventListener("resize", onResize);
        else $8b24bab62f5c65ad$var$visualViewport.addEventListener("resize", onResize);
        return ()=>{
            if (!$8b24bab62f5c65ad$var$visualViewport) window.removeEventListener("resize", onResize);
            else $8b24bab62f5c65ad$var$visualViewport.removeEventListener("resize", onResize);
        };
    }, []);
    return size;
}
function $8b24bab62f5c65ad$var$getViewportSize() {
    return {
        width: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.width) || window.innerWidth,
        height: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.height) || window.innerHeight
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

let $34da4502ea8120db$var$descriptionId = 0;
const $34da4502ea8120db$var$descriptionNodes = new Map();
function $34da4502ea8120db$export$f8aeda7b10753fa1(description) {
    let [id, setId] = (0, $1Yh1N$react.useState)(undefined);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (!description) return;
        let desc = $34da4502ea8120db$var$descriptionNodes.get(description);
        if (!desc) {
            let id = `react-aria-description-${$34da4502ea8120db$var$descriptionId++}`;
            setId(id);
            let node = document.createElement("div");
            node.id = id;
            node.style.display = "none";
            node.textContent = description;
            document.body.appendChild(node);
            desc = {
                refCount: 0,
                element: node
            };
            $34da4502ea8120db$var$descriptionNodes.set(description, desc);
        } else setId(desc.element.id);
        desc.refCount++;
        return ()=>{
            if (--desc.refCount === 0) {
                desc.element.remove();
                $34da4502ea8120db$var$descriptionNodes.delete(description);
            }
        };
    }, [
        description
    ]);
    return {
        "aria-describedby": description ? id : undefined
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $9e20cff0af27e8cc$var$testUserAgent(re) {
    var _window_navigator_userAgentData;
    if (typeof window === "undefined" || window.navigator == null) return false;
    return ((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand)=>re.test(brand.brand))) || re.test(window.navigator.userAgent);
}
function $9e20cff0af27e8cc$var$testPlatform(re) {
    var _window_navigator_userAgentData;
    return typeof window !== "undefined" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $9e20cff0af27e8cc$export$9ac100e40613ea10() {
    return $9e20cff0af27e8cc$var$testPlatform(/^Mac/i);
}
function $9e20cff0af27e8cc$export$186c6964ca17d99() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPhone/i);
}
function $9e20cff0af27e8cc$export$7bef049ce92e4224() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
    $9e20cff0af27e8cc$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
}
function $9e20cff0af27e8cc$export$fedb369cb70207f1() {
    return $9e20cff0af27e8cc$export$186c6964ca17d99() || $9e20cff0af27e8cc$export$7bef049ce92e4224();
}
function $9e20cff0af27e8cc$export$e1865c3bedcd822b() {
    return $9e20cff0af27e8cc$export$9ac100e40613ea10() || $9e20cff0af27e8cc$export$fedb369cb70207f1();
}
function $9e20cff0af27e8cc$export$78551043582a6a98() {
    return $9e20cff0af27e8cc$var$testUserAgent(/AppleWebKit/i) && !$9e20cff0af27e8cc$export$6446a186d09e379e();
}
function $9e20cff0af27e8cc$export$6446a186d09e379e() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Chrome/i);
}
function $9e20cff0af27e8cc$export$a11b0059900ceec8() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Android/i);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1254e5bb94ac8761$export$7f54fc3180508a52(fn) {
    const ref = (0, $1Yh1N$react.useRef)(null);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        ref.current = fn;
    }, [
        fn
    ]);
    return (0, $1Yh1N$react.useCallback)((...args)=>{
        const f = ref.current;
        return f(...args);
    }, []);
}


function $2a8c0bb1629926c8$export$90fc3a17d93f704c(ref, event, handler, options) {
    let handleEvent = (0, $1254e5bb94ac8761$export$7f54fc3180508a52)(handler);
    let isDisabled = handler == null;
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isDisabled) return;
        let element = ref.current;
        element.addEventListener(event, handleEvent, options);
        return ()=>{
            element.removeEventListener(event, handleEvent, options);
        };
    }, [
        ref,
        event,
        options,
        isDisabled,
        handleEvent
    ]);
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $449412113267a1fe$export$53a0910f038337bd(scrollView, element) {
    let offsetX = $449412113267a1fe$var$relativeOffset(scrollView, element, "left");
    let offsetY = $449412113267a1fe$var$relativeOffset(scrollView, element, "top");
    let width = element.offsetWidth;
    let height = element.offsetHeight;
    let x = scrollView.scrollLeft;
    let y = scrollView.scrollTop;
    // Account for top/left border offsetting the scroll top/Left
    let { borderTopWidth: borderTopWidth , borderLeftWidth: borderLeftWidth  } = getComputedStyle(scrollView);
    let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);
    let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);
    // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width
    let maxX = borderAdjustedX + scrollView.clientWidth;
    let maxY = borderAdjustedY + scrollView.clientHeight;
    if (offsetX <= x) x = offsetX - parseInt(borderLeftWidth, 10);
    else if (offsetX + width > maxX) x += offsetX + width - maxX;
    if (offsetY <= borderAdjustedY) y = offsetY - parseInt(borderTopWidth, 10);
    else if (offsetY + height > maxY) y += offsetY + height - maxY;
    scrollView.scrollLeft = x;
    scrollView.scrollTop = y;
}
/**
 * Computes the offset left or top from child to ancestor by accumulating
 * offsetLeft or offsetTop through intervening offsetParents.
 */ function $449412113267a1fe$var$relativeOffset(ancestor, child, axis) {
    const prop = axis === "left" ? "offsetLeft" : "offsetTop";
    let sum = 0;
    while(child.offsetParent){
        sum += child[prop];
        if (child.offsetParent === ancestor) break;
        else if (child.offsetParent.contains(ancestor)) {
            // If the ancestor is not `position:relative`, then we stop at
            // _its_ offset parent, and we subtract off _its_ offset, so that
            // we end up with the proper offset from child to ancestor.
            sum -= ancestor[prop];
            break;
        }
        child = child.offsetParent;
    }
    return sum;
}
function $449412113267a1fe$export$c826860796309d1b(targetElement, opts) {
    if (document.contains(targetElement)) {
        let root = document.scrollingElement || document.documentElement;
        let isScrollPrevented = window.getComputedStyle(root).overflow === "hidden";
        // If scrolling is not currently prevented then we aren’t in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view
        if (!isScrollPrevented) {
            var // use scrollIntoView({block: 'nearest'}) instead of .focus to check if the element is fully in view or not since .focus()
            // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically
            _targetElement_scrollIntoView;
            let { left: originalLeft , top: originalTop  } = targetElement.getBoundingClientRect();
            targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {
                block: "nearest"
            });
            let { left: newLeft , top: newTop  } = targetElement.getBoundingClientRect();
            // Account for sub pixel differences from rounding
            if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {
                var _opts_containingElement, _opts_containingElement_scrollIntoView, _targetElement_scrollIntoView1;
                opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {
                    block: "center",
                    inline: "center"
                });
                (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {
                    block: "nearest"
                });
            }
        } else {
            let scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.
            while(targetElement && scrollParent && targetElement !== root && scrollParent !== root){
                $449412113267a1fe$export$53a0910f038337bd(scrollParent, targetElement);
                targetElement = scrollParent;
                scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            }
        }
    }
}



/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $577e795361f19be9$export$60278871457622de(event) {
    // JAWS/NVDA with Firefox.
    if (event.mozInputSource === 0 && event.isTrusted) return true;
    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead
    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check
    // to detect TalkBack virtual clicks.
    if ((0, $9e20cff0af27e8cc$export$a11b0059900ceec8)() && event.pointerType) return event.type === "click" && event.buttons === 1;
    return event.detail === 0 && !event.pointerType;
}
function $577e795361f19be9$export$29bf1b5f2c56cf63(event) {
    // If the pointer size is zero, then we assume it's from a screen reader.
    // Android TalkBack double tap will sometimes return a event with width and height of 1
    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.
    // Cannot use "event.pressure === 0" as the sole check due to Safari pointer events always returning pressure === 0
    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush
    // Talkback double tap from Windows Firefox touch screen press
    return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse";
}



/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 
function $20e6e72fbf5dc81e$export$722debc0e56fea39(value, isEqual) {
    // Using a ref during render is ok here because it's only an optimization – both values are equivalent.
    // If a render is thrown away, it'll still work the same no matter if the next render is the same or not.
    let lastValue = (0, $1Yh1N$react.useRef)(null);
    if (value && lastValue.current && isEqual(value, lastValue.current)) value = lastValue.current;
    lastValue.current = value;
    return value;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 72356:
/***/ ((module) => {

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "announce", () => $97cebfa4133ebec3$export$a9b970dcc4ae71a9);
$parcel$export(module.exports, "clearAnnouncer", () => $97cebfa4133ebec3$export$d10ae4f68404609a);
$parcel$export(module.exports, "destroyAnnouncer", () => $97cebfa4133ebec3$export$d8686216b8b81b2f);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* Inspired by https://github.com/AlmeroSteyn/react-aria-live */ const $97cebfa4133ebec3$var$LIVEREGION_TIMEOUT_DELAY = 7000;
let $97cebfa4133ebec3$var$liveAnnouncer = null;
function $97cebfa4133ebec3$export$a9b970dcc4ae71a9(message, assertiveness = "assertive", timeout = $97cebfa4133ebec3$var$LIVEREGION_TIMEOUT_DELAY) {
    if (!$97cebfa4133ebec3$var$liveAnnouncer) $97cebfa4133ebec3$var$liveAnnouncer = new $97cebfa4133ebec3$var$LiveAnnouncer();
    $97cebfa4133ebec3$var$liveAnnouncer.announce(message, assertiveness, timeout);
}
function $97cebfa4133ebec3$export$d10ae4f68404609a(assertiveness) {
    if ($97cebfa4133ebec3$var$liveAnnouncer) $97cebfa4133ebec3$var$liveAnnouncer.clear(assertiveness);
}
function $97cebfa4133ebec3$export$d8686216b8b81b2f() {
    if ($97cebfa4133ebec3$var$liveAnnouncer) {
        $97cebfa4133ebec3$var$liveAnnouncer.destroy();
        $97cebfa4133ebec3$var$liveAnnouncer = null;
    }
}
// LiveAnnouncer is implemented using vanilla DOM, not React. That's because as of React 18
// ReactDOM.render is deprecated, and the replacement, ReactDOM.createRoot is moved into a
// subpath import `react-dom/client`. That makes it hard for us to support multiple React versions.
// As a global API, we can't use portals without introducing a breaking API change. LiveAnnouncer
// is simple enough to implement without React, so that's what we do here.
// See this discussion for more details: https://github.com/reactwg/react-18/discussions/125#discussioncomment-2382638
class $97cebfa4133ebec3$var$LiveAnnouncer {
    createLog(ariaLive) {
        let node = document.createElement("div");
        node.setAttribute("role", "log");
        node.setAttribute("aria-live", ariaLive);
        node.setAttribute("aria-relevant", "additions");
        return node;
    }
    destroy() {
        if (!this.node) return;
        document.body.removeChild(this.node);
        this.node = null;
    }
    announce(message, assertiveness = "assertive", timeout = $97cebfa4133ebec3$var$LIVEREGION_TIMEOUT_DELAY) {
        if (!this.node) return;
        let node = document.createElement("div");
        node.textContent = message;
        if (assertiveness === "assertive") this.assertiveLog.appendChild(node);
        else this.politeLog.appendChild(node);
        if (message !== "") setTimeout(()=>{
            node.remove();
        }, timeout);
    }
    clear(assertiveness) {
        if (!this.node) return;
        if (!assertiveness || assertiveness === "assertive") this.assertiveLog.innerHTML = "";
        if (!assertiveness || assertiveness === "polite") this.politeLog.innerHTML = "";
    }
    constructor(){
        this.node = document.createElement("div");
        this.node.dataset.liveAnnouncer = "true";
        // copied from VisuallyHidden
        Object.assign(this.node.style, {
            border: 0,
            clip: "rect(0 0 0 0)",
            clipPath: "inset(50%)",
            height: "1px",
            margin: "-1px",
            overflow: "hidden",
            padding: 0,
            position: "absolute",
            width: "1px",
            whiteSpace: "nowrap"
        });
        this.assertiveLog = this.createLog("assertive");
        this.node.appendChild(this.assertiveLog);
        this.politeLog = this.createLog("polite");
        this.node.appendChild(this.politeLog);
        document.body.prepend(this.node);
    }
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 72928:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $fHYTQ$reactariautils = __webpack_require__(77335);
var $fHYTQ$reactariai18n = __webpack_require__(2211);
var $fHYTQ$reactariainteractions = __webpack_require__(34353);
var $fHYTQ$reactariaoverlays = __webpack_require__(27807);
var $fHYTQ$reactariaselection = __webpack_require__(14422);
var $fHYTQ$reactstatelycollections = __webpack_require__(92775);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useMenuTrigger", () => $7211ab9328763fb9$export$dc9c12ed27dd1b49);
$parcel$export(module.exports, "useMenu", () => $a3815f0132802737$export$38eaa17faae8f579);
$parcel$export(module.exports, "useMenuItem", () => $38191ed02615ec07$export$9d32628fc2aea7da);
$parcel$export(module.exports, "useMenuSection", () => $63008655e23408c5$export$73f7a44322579622);
var $5128c2fd7e261f09$exports = {};
var $429891642bf97c51$exports = {};
$429891642bf97c51$exports = {
    "longPressMessage": `اضغط مطولاً أو اضغط على Alt + السهم لأسفل لفتح القائمة`
};


var $40d90b799072e111$exports = {};
$40d90b799072e111$exports = {
    "longPressMessage": `Натиснете продължително или натиснете Alt+ стрелка надолу, за да отворите менюто`
};


var $587b89d60e4f3e24$exports = {};
$587b89d60e4f3e24$exports = {
    "longPressMessage": `Dlouhým stiskem nebo stisknutím kláves Alt + šipka dolů otevřete nabídku`
};


var $79eb8045886465e9$exports = {};
$79eb8045886465e9$exports = {
    "longPressMessage": `Langt tryk eller tryk på Alt + pil ned for at åbne menuen`
};


var $9c6faa2088d34bf1$exports = {};
$9c6faa2088d34bf1$exports = {
    "longPressMessage": `Drücken Sie lange oder drücken Sie Alt + Nach-unten, um das Menü zu öffnen`
};


var $ee6e1292c61a8135$exports = {};
$ee6e1292c61a8135$exports = {
    "longPressMessage": `Πιέστε παρατεταμένα ή πατήστε Alt + κάτω βέλος για να ανοίξετε το μενού`
};


var $f479187898d153cc$exports = {};
$f479187898d153cc$exports = {
    "longPressMessage": `Long press or press Alt + ArrowDown to open menu`
};


var $1e6a91f77efbb11f$exports = {};
$1e6a91f77efbb11f$exports = {
    "longPressMessage": `Mantenga pulsado o pulse Alt + flecha abajo para abrir el menú`
};


var $f2fb75e964082636$exports = {};
$f2fb75e964082636$exports = {
    "longPressMessage": `Menüü avamiseks vajutage pikalt või vajutage klahve Alt + allanool`
};


var $75cc65c4b616fac1$exports = {};
$75cc65c4b616fac1$exports = {
    "longPressMessage": `Avaa valikko painamalla pohjassa tai näppäinyhdistelmällä Alt + Alanuoli`
};


var $82a179939aabd1ee$exports = {};
$82a179939aabd1ee$exports = {
    "longPressMessage": `Appuyez de manière prolongée ou appuyez sur Alt + Flèche vers le bas pour ouvrir le menu.`
};


var $40aa37345f1f8748$exports = {};
$40aa37345f1f8748$exports = {
    "longPressMessage": `לחץ לחיצה ארוכה או הקש Alt + ArrowDown כדי לפתוח את התפריט`
};


var $c00088e5c377e2c5$exports = {};
$c00088e5c377e2c5$exports = {
    "longPressMessage": `Dugo pritisnite ili pritisnite Alt + strelicu prema dolje za otvaranje izbornika`
};


var $51f736a409b7d295$exports = {};
$51f736a409b7d295$exports = {
    "longPressMessage": `Nyomja meg hosszan, vagy nyomja meg az Alt + lefele nyíl gombot a menü megnyitásához`
};


var $65bb74747bd8f2fb$exports = {};
$65bb74747bd8f2fb$exports = {
    "longPressMessage": `Premere a lungo o premere Alt + Freccia giù per aprire il menu`
};


var $1bc11da108727c27$exports = {};
$1bc11da108727c27$exports = {
    "longPressMessage": `長押しまたは Alt+下矢印キーでメニューを開く`
};


var $118d77e4be898c17$exports = {};
$118d77e4be898c17$exports = {
    "longPressMessage": `길게 누르거나 Alt + 아래쪽 화살표를 눌러 메뉴 열기`
};


var $4db9ebadbf792309$exports = {};
$4db9ebadbf792309$exports = {
    "longPressMessage": `Norėdami atidaryti meniu, nuspaudę palaikykite arba paspauskite „Alt + ArrowDown“.`
};


var $51288b53bc93ac3d$exports = {};
$51288b53bc93ac3d$exports = {
    "longPressMessage": `Lai atvērtu izvēlni, turiet nospiestu vai nospiediet taustiņu kombināciju Alt + lejupvērstā bultiņa`
};


var $1a4b31206cd66e98$exports = {};
$1a4b31206cd66e98$exports = {
    "longPressMessage": `Langt trykk eller trykk Alt + PilNed for å åpne menyen`
};


var $21e944c6af0b8453$exports = {};
$21e944c6af0b8453$exports = {
    "longPressMessage": `Druk lang op Alt + pijl-omlaag of druk op Alt om het menu te openen`
};


var $20509ccafe6fe6aa$exports = {};
$20509ccafe6fe6aa$exports = {
    "longPressMessage": `Naciśnij i przytrzymaj lub naciśnij klawisze Alt + Strzałka w dół, aby otworzyć menu`
};


var $8006eac1d5d4665b$exports = {};
$8006eac1d5d4665b$exports = {
    "longPressMessage": `Pressione e segure ou pressione Alt + Seta para baixo para abrir o menu`
};


var $4875d1b529941a0a$exports = {};
$4875d1b529941a0a$exports = {
    "longPressMessage": `Prima continuamente ou prima Alt + Seta Para Baixo para abrir o menu`
};


var $37939d04a40a865b$exports = {};
$37939d04a40a865b$exports = {
    "longPressMessage": `Apăsați lung sau apăsați pe Alt + săgeată în jos pentru a deschide meniul`
};


var $fd1c8a4521d30c69$exports = {};
$fd1c8a4521d30c69$exports = {
    "longPressMessage": `Нажмите и удерживайте или нажмите Alt + Стрелка вниз, чтобы открыть меню`
};


var $2940d0a4ba6cbd64$exports = {};
$2940d0a4ba6cbd64$exports = {
    "longPressMessage": `Ponuku otvoríte dlhým stlačením alebo stlačením klávesu Alt + klávesu so šípkou nadol`
};


var $cb481a56d5c8fa56$exports = {};
$cb481a56d5c8fa56$exports = {
    "longPressMessage": `Za odprtje menija pritisnite in držite gumb ali pritisnite Alt+puščica navzdol`
};


var $ecbdeaa2c85d1b32$exports = {};
$ecbdeaa2c85d1b32$exports = {
    "longPressMessage": `Dugo pritisnite ili pritisnite Alt + strelicu prema dole da otvorite meni`
};


var $aeca4735c8d1bab6$exports = {};
$aeca4735c8d1bab6$exports = {
    "longPressMessage": `Håll nedtryckt eller tryck på Alt + pil nedåt för att öppna menyn`
};


var $68243426be5c9f01$exports = {};
$68243426be5c9f01$exports = {
    "longPressMessage": `Menüyü açmak için uzun basın veya Alt + Aşağı Ok tuşuna basın`
};


var $bde63de8df74e87d$exports = {};
$bde63de8df74e87d$exports = {
    "longPressMessage": `Довго або звичайно натисніть комбінацію клавіш Alt і стрілка вниз, щоб відкрити меню`
};


var $2d16ab23cbf254d4$exports = {};
$2d16ab23cbf254d4$exports = {
    "longPressMessage": `长按或按 Alt + 向下方向键以打开菜单`
};


var $bd9ff3a1da9d944a$exports = {};
$bd9ff3a1da9d944a$exports = {
    "longPressMessage": `長按或按 Alt+向下鍵以開啟功能表`
};


$5128c2fd7e261f09$exports = {
    "ar-AE": $429891642bf97c51$exports,
    "bg-BG": $40d90b799072e111$exports,
    "cs-CZ": $587b89d60e4f3e24$exports,
    "da-DK": $79eb8045886465e9$exports,
    "de-DE": $9c6faa2088d34bf1$exports,
    "el-GR": $ee6e1292c61a8135$exports,
    "en-US": $f479187898d153cc$exports,
    "es-ES": $1e6a91f77efbb11f$exports,
    "et-EE": $f2fb75e964082636$exports,
    "fi-FI": $75cc65c4b616fac1$exports,
    "fr-FR": $82a179939aabd1ee$exports,
    "he-IL": $40aa37345f1f8748$exports,
    "hr-HR": $c00088e5c377e2c5$exports,
    "hu-HU": $51f736a409b7d295$exports,
    "it-IT": $65bb74747bd8f2fb$exports,
    "ja-JP": $1bc11da108727c27$exports,
    "ko-KR": $118d77e4be898c17$exports,
    "lt-LT": $4db9ebadbf792309$exports,
    "lv-LV": $51288b53bc93ac3d$exports,
    "nb-NO": $1a4b31206cd66e98$exports,
    "nl-NL": $21e944c6af0b8453$exports,
    "pl-PL": $20509ccafe6fe6aa$exports,
    "pt-BR": $8006eac1d5d4665b$exports,
    "pt-PT": $4875d1b529941a0a$exports,
    "ro-RO": $37939d04a40a865b$exports,
    "ru-RU": $fd1c8a4521d30c69$exports,
    "sk-SK": $2940d0a4ba6cbd64$exports,
    "sl-SI": $cb481a56d5c8fa56$exports,
    "sr-SP": $ecbdeaa2c85d1b32$exports,
    "sv-SE": $aeca4735c8d1bab6$exports,
    "tr-TR": $68243426be5c9f01$exports,
    "uk-UA": $bde63de8df74e87d$exports,
    "zh-CN": $2d16ab23cbf254d4$exports,
    "zh-TW": $bd9ff3a1da9d944a$exports
};






function $7211ab9328763fb9$export$dc9c12ed27dd1b49(props, state, ref) {
    let { type: type = 'menu' , isDisabled: isDisabled , trigger: trigger = 'press'  } = props;
    let menuTriggerId = $fHYTQ$reactariautils.useId();
    let { triggerProps: triggerProps , overlayProps: overlayProps  } = $fHYTQ$reactariaoverlays.useOverlayTrigger({
        type: type
    }, state, ref);
    let onKeyDown = (e)=>{
        if (isDisabled) return;
        if (trigger === 'longPress' && !e.altKey) return;
        if (ref && ref.current) switch(e.key){
            case 'Enter':
            case ' ':
                if (trigger === 'longPress') return;
            // fallthrough
            case 'ArrowDown':
                // Stop propagation, unless it would already be handled by useKeyboard.
                if (!('continuePropagation' in e)) e.stopPropagation();
                e.preventDefault();
                state.toggle('first');
                break;
            case 'ArrowUp':
                if (!('continuePropagation' in e)) e.stopPropagation();
                e.preventDefault();
                state.toggle('last');
                break;
        }
    };
    let stringFormatter = $fHYTQ$reactariai18n.useLocalizedStringFormatter((/*@__PURE__*/$parcel$interopDefault($5128c2fd7e261f09$exports)));
    let { longPressProps: longPressProps  } = $fHYTQ$reactariainteractions.useLongPress({
        isDisabled: isDisabled || trigger !== 'longPress',
        accessibilityDescription: stringFormatter.format('longPressMessage'),
        onLongPressStart () {
            state.close();
        },
        onLongPress () {
            state.open('first');
        }
    });
    let pressProps = {
        onPressStart (e) {
            // For consistency with native, open the menu on mouse/key down, but touch up.
            if (e.pointerType !== 'touch' && e.pointerType !== 'keyboard' && !isDisabled) // If opened with a screen reader, auto focus the first item.
            // Otherwise, the menu itself will be focused.
            state.toggle(e.pointerType === 'virtual' ? 'first' : null);
        },
        onPress (e) {
            if (e.pointerType === 'touch' && !isDisabled) state.toggle();
        }
    };
    // omit onPress from triggerProps since we override it above.
    delete triggerProps.onPress;
    return {
        menuTriggerProps: {
            ...triggerProps,
            ...trigger === 'press' ? pressProps : longPressProps,
            id: menuTriggerId,
            onKeyDown: onKeyDown
        },
        menuProps: {
            ...overlayProps,
            'aria-labelledby': menuTriggerId,
            autoFocus: state.focusStrategy,
            onClose: state.close
        }
    };
}




const $a3815f0132802737$export$6f49b4016bfc8d56 = new WeakMap();
function $a3815f0132802737$export$38eaa17faae8f579(props, state, ref) {
    let { shouldFocusWrap: shouldFocusWrap = true , ...otherProps } = props;
    if (!props['aria-label'] && !props['aria-labelledby']) console.warn('An aria-label or aria-labelledby prop is required for accessibility.');
    let domProps = $fHYTQ$reactariautils.filterDOMProps(props, {
        labelable: true
    });
    let { listProps: listProps  } = $fHYTQ$reactariaselection.useSelectableList({
        ...otherProps,
        ref: ref,
        selectionManager: state.selectionManager,
        collection: state.collection,
        disabledKeys: state.disabledKeys,
        shouldFocusWrap: shouldFocusWrap
    });
    $a3815f0132802737$export$6f49b4016bfc8d56.set(state, {
        onClose: props.onClose,
        onAction: props.onAction
    });
    return {
        menuProps: $fHYTQ$reactariautils.mergeProps(domProps, {
            role: 'menu',
            ...listProps
        })
    };
}







function $38191ed02615ec07$export$9d32628fc2aea7da(props, state, ref) {
    let { key: key , closeOnSelect: closeOnSelect , isVirtualized: isVirtualized  } = props;
    var _isDisabled;
    let isDisabled = (_isDisabled = props.isDisabled) !== null && _isDisabled !== void 0 ? _isDisabled : state.disabledKeys.has(key);
    var _isSelected;
    let isSelected = (_isSelected = props.isSelected) !== null && _isSelected !== void 0 ? _isSelected : state.selectionManager.isSelected(key);
    let isFocused = state.selectionManager.focusedKey === key;
    let data = $a3815f0132802737$export$6f49b4016bfc8d56.get(state);
    let onClose = props.onClose || data.onClose;
    let onAction = props.onAction || data.onAction;
    let role = 'menuitem';
    if (state.selectionManager.selectionMode === 'single') role = 'menuitemradio';
    else if (state.selectionManager.selectionMode === 'multiple') role = 'menuitemcheckbox';
    let labelId = $fHYTQ$reactariautils.useSlotId();
    let descriptionId = $fHYTQ$reactariautils.useSlotId();
    let keyboardId = $fHYTQ$reactariautils.useSlotId();
    let ariaProps = {
        'aria-disabled': isDisabled,
        role: role,
        'aria-label': props['aria-label'],
        'aria-labelledby': labelId,
        'aria-describedby': [
            descriptionId,
            keyboardId
        ].filter(Boolean).join(' ') || undefined
    };
    if (state.selectionManager.selectionMode !== 'none') ariaProps['aria-checked'] = isSelected;
    if (isVirtualized) {
        ariaProps['aria-posinset'] = state.collection.getItem(key).index;
        ariaProps['aria-setsize'] = $fHYTQ$reactstatelycollections.getItemCount(state.collection);
    }
    let onKeyDown = (e)=>{
        // Ignore repeating events, which may have started on the menu trigger before moving
        // focus to the menu item. We want to wait for a second complete key press sequence.
        if (e.repeat) return;
        switch(e.key){
            case ' ':
                if (!isDisabled && state.selectionManager.selectionMode === 'none' && closeOnSelect !== false && onClose) onClose();
                break;
            case 'Enter':
                // The Enter key should always close on select, except if overridden.
                if (!isDisabled && closeOnSelect !== false && onClose) onClose();
                break;
        }
    };
    let onPressStart = (e)=>{
        if (e.pointerType === 'keyboard' && onAction) onAction(key);
    };
    let onPressUp = (e)=>{
        if (e.pointerType !== 'keyboard') {
            if (onAction) onAction(key);
            // Pressing a menu item should close by default in single selection mode but not multiple
            // selection mode, except if overridden by the closeOnSelect prop.
            if (onClose && (closeOnSelect !== null && closeOnSelect !== void 0 ? closeOnSelect : state.selectionManager.selectionMode !== 'multiple')) onClose();
        }
    };
    let { itemProps: itemProps  } = $fHYTQ$reactariaselection.useSelectableItem({
        selectionManager: state.selectionManager,
        key: key,
        ref: ref,
        shouldSelectOnPressUp: true,
        allowsDifferentPressOrigin: true
    });
    let { pressProps: pressProps , isPressed: isPressed  } = $fHYTQ$reactariainteractions.usePress({
        onPressStart: onPressStart,
        onPressUp: onPressUp,
        isDisabled: isDisabled
    });
    let { hoverProps: hoverProps  } = $fHYTQ$reactariainteractions.useHover({
        isDisabled: isDisabled,
        onHoverStart () {
            if (!$fHYTQ$reactariainteractions.isFocusVisible()) {
                state.selectionManager.setFocused(true);
                state.selectionManager.setFocusedKey(key);
            }
        }
    });
    return {
        menuItemProps: {
            ...ariaProps,
            ...$fHYTQ$reactariautils.mergeProps(itemProps, pressProps, hoverProps, {
                onKeyDown: onKeyDown
            })
        },
        labelProps: {
            id: labelId
        },
        descriptionProps: {
            id: descriptionId
        },
        keyboardShortcutProps: {
            id: keyboardId
        },
        isFocused: isFocused,
        isSelected: isSelected,
        isPressed: isPressed,
        isDisabled: isDisabled
    };
}



function $63008655e23408c5$export$73f7a44322579622(props) {
    let { heading: heading , 'aria-label': ariaLabel  } = props;
    let headingId = $fHYTQ$reactariautils.useId();
    return {
        itemProps: {
            role: 'presentation'
        },
        headingProps: heading ? {
            // Techincally, menus cannot contain headings according to ARIA.
            // We hide the heading from assistive technology, and only use it
            // as a label for the nested group.
            id: headingId,
            'aria-hidden': true
        } : {
        },
        groupProps: {
            role: 'group',
            'aria-label': ariaLabel,
            'aria-labelledby': heading ? headingId : undefined
        }
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 27807:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $6Zb2x$react = __webpack_require__(18038);
var $6Zb2x$reactariautils = __webpack_require__(40246);
var $6Zb2x$reactariai18n = __webpack_require__(2211);
var $6Zb2x$reactariainteractions = __webpack_require__(71867);
var $6Zb2x$reactdom = __webpack_require__(98704);
var $6Zb2x$reactariassr = __webpack_require__(79933);
var $6Zb2x$reactariavisuallyhidden = __webpack_require__(20198);
var $6Zb2x$reactariafocus = __webpack_require__(98600);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useOverlayPosition", () => $cd94b4896dd97759$export$d39e1813b3bdd0e1);
$parcel$export(module.exports, "useOverlay", () => $82711f9cb668ecdb$export$ea8f71083e90600f);
$parcel$export(module.exports, "useOverlayTrigger", () => $b4878eb6316f670a$export$f9d5c8beee7d008d);
$parcel$export(module.exports, "usePreventScroll", () => $5c2f5cd01815d369$export$ee0f7cc6afcd1c18);
$parcel$export(module.exports, "ModalProvider", () => $0775ea8ea6a0565e$export$178405afcd8c5eb);
$parcel$export(module.exports, "useModalProvider", () => $0775ea8ea6a0565e$export$d9aaed4c3ece1bc0);
$parcel$export(module.exports, "OverlayProvider", () => $0775ea8ea6a0565e$export$bf688221f59024e5);
$parcel$export(module.exports, "OverlayContainer", () => $0775ea8ea6a0565e$export$b47c3594eab58386);
$parcel$export(module.exports, "useModal", () => $0775ea8ea6a0565e$export$33ffd74ebf07f060);
$parcel$export(module.exports, "DismissButton", () => $f69bb3e6457495cc$export$2317d149ed6f78c4);
$parcel$export(module.exports, "ariaHideOutside", () => $08ef1685902b6011$export$1c3ebcada18427bf);
$parcel$export(module.exports, "usePopover", () => $6c2dfcdee3e15e20$export$542a6fd13ac93354);
$parcel$export(module.exports, "useModalOverlay", () => $11b7e0b04b421e95$export$dbc0f175b25fb0fb);
$parcel$export(module.exports, "Overlay", () => $745edbb83ab4296f$export$c6fdb837b070b4ff);
$parcel$export(module.exports, "useOverlayFocusContain", () => $745edbb83ab4296f$export$14c98a7594375490);
const $5935ba4d7da2c103$var$AXIS = {
    top: 'top',
    bottom: 'top',
    left: 'left',
    right: 'left'
};
const $5935ba4d7da2c103$var$FLIPPED_DIRECTION = {
    top: 'bottom',
    bottom: 'top',
    left: 'right',
    right: 'left'
};
const $5935ba4d7da2c103$var$CROSS_AXIS = {
    top: 'left',
    left: 'top'
};
const $5935ba4d7da2c103$var$AXIS_SIZE = {
    top: 'height',
    left: 'width'
};
const $5935ba4d7da2c103$var$PARSED_PLACEMENT_CACHE = {
};
// @ts-ignore
let $5935ba4d7da2c103$var$visualViewport = typeof window !== 'undefined' && window.visualViewport;
function $5935ba4d7da2c103$var$getContainerDimensions(containerNode) {
    let width = 0, height = 0, top = 0, left = 0;
    let scroll = {
    };
    if (containerNode.tagName === 'BODY') {
        let documentElement = document.documentElement;
        var ref;
        width = (ref = $5935ba4d7da2c103$var$visualViewport === null || $5935ba4d7da2c103$var$visualViewport === void 0 ? void 0 : $5935ba4d7da2c103$var$visualViewport.width) !== null && ref !== void 0 ? ref : documentElement.clientWidth;
        var ref1;
        height = (ref1 = $5935ba4d7da2c103$var$visualViewport === null || $5935ba4d7da2c103$var$visualViewport === void 0 ? void 0 : $5935ba4d7da2c103$var$visualViewport.height) !== null && ref1 !== void 0 ? ref1 : documentElement.clientHeight;
        scroll.top = documentElement.scrollTop || containerNode.scrollTop;
        scroll.left = documentElement.scrollLeft || containerNode.scrollLeft;
    } else {
        ({ width: width , height: height , top: top , left: left  } = $5935ba4d7da2c103$var$getOffset(containerNode));
        scroll.top = containerNode.scrollTop;
        scroll.left = containerNode.scrollLeft;
    }
    return {
        width: width,
        height: height,
        scroll: scroll,
        top: top,
        left: left
    };
}
function $5935ba4d7da2c103$var$getScroll(node) {
    return {
        top: node.scrollTop,
        left: node.scrollLeft,
        width: node.scrollWidth,
        height: node.scrollHeight
    };
}
function $5935ba4d7da2c103$var$getDelta(axis, offset, size, containerDimensions, padding) {
    let containerScroll = containerDimensions.scroll[axis];
    let containerHeight = containerDimensions[$5935ba4d7da2c103$var$AXIS_SIZE[axis]];
    let startEdgeOffset = offset - padding - containerScroll;
    let endEdgeOffset = offset + padding - containerScroll + size;
    if (startEdgeOffset < 0) return -startEdgeOffset;
    else if (endEdgeOffset > containerHeight) return Math.max(containerHeight - endEdgeOffset, -startEdgeOffset);
    else return 0;
}
function $5935ba4d7da2c103$var$getMargins(node) {
    let style = window.getComputedStyle(node);
    return {
        top: parseInt(style.marginTop, 10) || 0,
        bottom: parseInt(style.marginBottom, 10) || 0,
        left: parseInt(style.marginLeft, 10) || 0,
        right: parseInt(style.marginRight, 10) || 0
    };
}
function $5935ba4d7da2c103$var$parsePlacement(input) {
    if ($5935ba4d7da2c103$var$PARSED_PLACEMENT_CACHE[input]) return $5935ba4d7da2c103$var$PARSED_PLACEMENT_CACHE[input];
    let [placement, crossPlacement] = input.split(' ');
    let axis = $5935ba4d7da2c103$var$AXIS[placement] || 'right';
    let crossAxis = $5935ba4d7da2c103$var$CROSS_AXIS[axis];
    if (!$5935ba4d7da2c103$var$AXIS[crossPlacement]) crossPlacement = 'center';
    let size = $5935ba4d7da2c103$var$AXIS_SIZE[axis];
    let crossSize = $5935ba4d7da2c103$var$AXIS_SIZE[crossAxis];
    $5935ba4d7da2c103$var$PARSED_PLACEMENT_CACHE[input] = {
        placement: placement,
        crossPlacement: crossPlacement,
        axis: axis,
        crossAxis: crossAxis,
        size: size,
        crossSize: crossSize
    };
    return $5935ba4d7da2c103$var$PARSED_PLACEMENT_CACHE[input];
}
function $5935ba4d7da2c103$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned) {
    let { placement: placement , crossPlacement: crossPlacement , axis: axis , crossAxis: crossAxis , size: size , crossSize: crossSize  } = placementInfo;
    let position = {
    };
    // button position
    position[crossAxis] = childOffset[crossAxis];
    if (crossPlacement === 'center') //  + (button size / 2) - (overlay size / 2)
    // at this point the overlay center should match the button center
    position[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]) / 2;
    else if (crossPlacement !== crossAxis) //  + (button size) - (overlay size)
    // at this point the overlay bottom should match the button bottom
    position[crossAxis] += childOffset[crossSize] - overlaySize[crossSize];
     /* else {
    the overlay top should match the button top
  } */ 
    // add the crossOffset from props
    position[crossAxis] += crossOffset;
    // this is button center position - the overlay size + half of the button to align bottom of overlay with button center
    let minViablePosition = childOffset[crossAxis] + childOffset[crossSize] / 2 - overlaySize[crossSize];
    // this is button position of center, aligns top of overlay with button center
    let maxViablePosition = childOffset[crossAxis] + childOffset[crossSize] / 2;
    // clamp it into the range of the min/max positions
    position[crossAxis] = Math.min(Math.max(minViablePosition, position[crossAxis]), maxViablePosition);
    // Floor these so the position isn't placed on a partial pixel, only whole pixels. Shouldn't matter if it was floored or ceiled, so chose one.
    if (placement === axis) {
        // If the container is positioned (non-static), then we use the container's actual
        // height, as `bottom` will be relative to this height.  But if the container is static,
        // then it can only be the `document.body`, and `bottom` will be relative to _its_
        // container, which should be as large as boundaryDimensions.
        const containerHeight = isContainerPositioned ? containerOffsetWithBoundary[size] : boundaryDimensions[size];
        position[$5935ba4d7da2c103$var$FLIPPED_DIRECTION[axis]] = Math.floor(containerHeight - childOffset[axis] + offset);
    } else position[axis] = Math.floor(childOffset[axis] + childOffset[size] + offset);
    return position;
}
function $5935ba4d7da2c103$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding) {
    return position.top != null ? Math.max(0, boundaryDimensions.height + boundaryDimensions.top + boundaryDimensions.scroll.top - (containerOffsetWithBoundary.top + position.top) - (margins.top + margins.bottom + padding) // save additional space for margin and padding
    ) : Math.max(0, childOffset.top + containerOffsetWithBoundary.top - (boundaryDimensions.top + boundaryDimensions.scroll.top) - (margins.top + margins.bottom + padding) // save additional space for margin and padding
    );
}
function $5935ba4d7da2c103$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding, placementInfo) {
    let { placement: placement , axis: axis , size: size  } = placementInfo;
    if (placement === axis) return Math.max(0, childOffset[axis] - boundaryDimensions[axis] - boundaryDimensions.scroll[axis] + containerOffsetWithBoundary[axis] - margins[axis] - margins[$5935ba4d7da2c103$var$FLIPPED_DIRECTION[axis]] - padding);
    return Math.max(0, boundaryDimensions[size] + boundaryDimensions[axis] + boundaryDimensions.scroll[axis] - containerOffsetWithBoundary[axis] - childOffset[axis] - childOffset[size] - margins[axis] - margins[$5935ba4d7da2c103$var$FLIPPED_DIRECTION[axis]] - padding);
}
function $5935ba4d7da2c103$export$6839422d1f33cee9(placementInput, childOffset, overlaySize, scrollSize, margins, padding, flip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, userSetMaxHeight) {
    let placementInfo = $5935ba4d7da2c103$var$parsePlacement(placementInput);
    let { size: size , crossAxis: crossAxis , crossSize: crossSize , placement: placement , crossPlacement: crossPlacement  } = placementInfo;
    let position = $5935ba4d7da2c103$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned);
    let normalizedOffset = offset;
    let space = $5935ba4d7da2c103$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, placementInfo);
    // Check if the scroll size of the overlay is greater than the available space to determine if we need to flip
    if (flip && scrollSize[size] > space) {
        let flippedPlacementInfo = $5935ba4d7da2c103$var$parsePlacement(`${$5935ba4d7da2c103$var$FLIPPED_DIRECTION[placement]} ${crossPlacement}`);
        let flippedPosition = $5935ba4d7da2c103$var$computePosition(childOffset, boundaryDimensions, overlaySize, flippedPlacementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned);
        let flippedSpace = $5935ba4d7da2c103$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, flippedPlacementInfo);
        // If the available space for the flipped position is greater than the original available space, flip.
        if (flippedSpace > space) {
            placementInfo = flippedPlacementInfo;
            position = flippedPosition;
            normalizedOffset = offset;
        }
    }
    let delta = $5935ba4d7da2c103$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);
    position[crossAxis] += delta;
    let maxHeight = $5935ba4d7da2c103$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding);
    if (userSetMaxHeight && userSetMaxHeight < maxHeight) maxHeight = userSetMaxHeight;
    overlaySize.height = Math.min(overlaySize.height, maxHeight);
    position = $5935ba4d7da2c103$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset, containerOffsetWithBoundary, isContainerPositioned);
    delta = $5935ba4d7da2c103$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);
    position[crossAxis] += delta;
    let arrowPosition = {
    };
    arrowPosition[crossAxis] = childOffset[crossAxis] - position[crossAxis] + childOffset[crossSize] / 2;
    return {
        position: position,
        maxHeight: maxHeight,
        arrowOffsetLeft: arrowPosition.left,
        arrowOffsetTop: arrowPosition.top,
        placement: placementInfo.placement
    };
}
function $5935ba4d7da2c103$export$b3ceb0cbf1056d98(opts) {
    let { placement: placement , targetNode: targetNode , overlayNode: overlayNode , scrollNode: scrollNode , padding: padding , shouldFlip: shouldFlip , boundaryElement: boundaryElement , offset: offset , crossOffset: crossOffset , maxHeight: maxHeight  } = opts;
    let container = overlayNode instanceof HTMLElement && overlayNode.offsetParent || document.body;
    let isBodyContainer = container.tagName === 'BODY';
    const containerPositionStyle = window.getComputedStyle(container).position;
    let isContainerPositioned = !!containerPositionStyle && containerPositionStyle !== 'static';
    let childOffset = isBodyContainer ? $5935ba4d7da2c103$var$getOffset(targetNode) : $5935ba4d7da2c103$var$getPosition(targetNode, container);
    if (!isBodyContainer) {
        let { marginTop: marginTop , marginLeft: marginLeft  } = window.getComputedStyle(targetNode);
        childOffset.top += parseInt(marginTop, 10) || 0;
        childOffset.left += parseInt(marginLeft, 10) || 0;
    }
    let overlaySize = $5935ba4d7da2c103$var$getOffset(overlayNode);
    let margins = $5935ba4d7da2c103$var$getMargins(overlayNode);
    overlaySize.width += margins.left + margins.right;
    overlaySize.height += margins.top + margins.bottom;
    let scrollSize = $5935ba4d7da2c103$var$getScroll(scrollNode);
    let boundaryDimensions = $5935ba4d7da2c103$var$getContainerDimensions(boundaryElement);
    let containerOffsetWithBoundary = boundaryElement.tagName === 'BODY' ? $5935ba4d7da2c103$var$getOffset(container) : $5935ba4d7da2c103$var$getPosition(container, boundaryElement);
    return $5935ba4d7da2c103$export$6839422d1f33cee9(placement, childOffset, overlaySize, scrollSize, margins, padding, shouldFlip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, maxHeight);
}
function $5935ba4d7da2c103$var$getOffset(node) {
    let { top: top , left: left , width: width , height: height  } = node.getBoundingClientRect();
    let { scrollTop: scrollTop , scrollLeft: scrollLeft , clientTop: clientTop , clientLeft: clientLeft  } = document.documentElement;
    return {
        top: top + scrollTop - clientTop,
        left: left + scrollLeft - clientLeft,
        width: width,
        height: height
    };
}
function $5935ba4d7da2c103$var$getPosition(node, parent) {
    let style = window.getComputedStyle(node);
    let offset;
    if (style.position === 'fixed') {
        let { top: top , left: left , width: width , height: height  } = node.getBoundingClientRect();
        offset = {
            top: top,
            left: left,
            width: width,
            height: height
        };
    } else {
        offset = $5935ba4d7da2c103$var$getOffset(node);
        let parentOffset = $5935ba4d7da2c103$var$getOffset(parent);
        let parentStyle = window.getComputedStyle(parent);
        parentOffset.top += (parseInt(parentStyle.borderTopWidth, 10) || 0) - parent.scrollTop;
        parentOffset.left += (parseInt(parentStyle.borderLeftWidth, 10) || 0) - parent.scrollLeft;
        offset.top -= parentOffset.top;
        offset.left -= parentOffset.left;
    }
    offset.top -= parseInt(style.marginTop, 10) || 0;
    offset.left -= parseInt(style.marginLeft, 10) || 0;
    return offset;
}




const $9a8aa1b0b336ea3a$export$f6211563215e3b37 = new WeakMap();
function $9a8aa1b0b336ea3a$export$18fc8428861184da(opts) {
    let { triggerRef: triggerRef , isOpen: isOpen , onClose: onClose  } = opts;
    $6Zb2x$react.useEffect(()=>{
        if (!isOpen) return;
        let onScroll = (e)=>{
            // Ignore if scrolling an scrollable region outside the trigger's tree.
            let target = e.target;
            // window is not a Node and doesn't have contain, but window contains everything
            if (!triggerRef.current || target instanceof Node && !target.contains(triggerRef.current)) return;
            let onCloseHandler = onClose || $9a8aa1b0b336ea3a$export$f6211563215e3b37.get(triggerRef.current);
            if (onCloseHandler) onCloseHandler();
        };
        window.addEventListener('scroll', onScroll, true);
        return ()=>{
            window.removeEventListener('scroll', onScroll, true);
        };
    }, [
        isOpen,
        onClose,
        triggerRef
    ]);
}




// @ts-ignore
let $cd94b4896dd97759$var$visualViewport = typeof window !== 'undefined' && window.visualViewport;
function $cd94b4896dd97759$export$d39e1813b3bdd0e1(props) {
    let { direction: direction  } = $6Zb2x$reactariai18n.useLocale();
    let { targetRef: targetRef , overlayRef: overlayRef , scrollRef: scrollRef = overlayRef , placement: placement = 'bottom' , containerPadding: containerPadding = 12 , shouldFlip: shouldFlip = true , boundaryElement: boundaryElement = typeof document !== 'undefined' ? document.body : null , offset: offset = 0 , crossOffset: crossOffset = 0 , shouldUpdatePosition: shouldUpdatePosition = true , isOpen: isOpen = true , onClose: onClose , maxHeight: maxHeight  } = props;
    let [position, setPosition] = $6Zb2x$react.useState({
        position: {
        },
        arrowOffsetLeft: undefined,
        arrowOffsetTop: undefined,
        maxHeight: undefined,
        placement: undefined
    });
    let deps = [
        shouldUpdatePosition,
        placement,
        overlayRef.current,
        targetRef.current,
        scrollRef.current,
        containerPadding,
        shouldFlip,
        boundaryElement,
        offset,
        crossOffset,
        isOpen,
        direction,
        maxHeight
    ];
    let updatePosition = $6Zb2x$react.useCallback(()=>{
        if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current || !boundaryElement) return;
        setPosition($5935ba4d7da2c103$export$b3ceb0cbf1056d98({
            placement: $cd94b4896dd97759$var$translateRTL(placement, direction),
            overlayNode: overlayRef.current,
            targetNode: targetRef.current,
            scrollNode: scrollRef.current,
            padding: containerPadding,
            shouldFlip: shouldFlip,
            boundaryElement: boundaryElement,
            offset: offset,
            crossOffset: crossOffset,
            maxHeight: maxHeight
        }));
    }, deps);
    // Update position when anything changes
    $6Zb2x$reactariautils.useLayoutEffect(updatePosition, deps);
    // Update position on window resize
    $cd94b4896dd97759$var$useResize(updatePosition);
    // Reposition the overlay and do not close on scroll while the visual viewport is resizing.
    // This will ensure that overlays adjust their positioning when the iOS virtual keyboard appears.
    let isResizing = $6Zb2x$react.useRef(false);
    $6Zb2x$reactariautils.useLayoutEffect(()=>{
        let timeout;
        let onResize = ()=>{
            isResizing.current = true;
            clearTimeout(timeout);
            timeout = setTimeout(()=>{
                isResizing.current = false;
            }, 500);
            updatePosition();
        };
        $cd94b4896dd97759$var$visualViewport === null || $cd94b4896dd97759$var$visualViewport === void 0 ? void 0 : $cd94b4896dd97759$var$visualViewport.addEventListener('resize', onResize);
        return ()=>{
            $cd94b4896dd97759$var$visualViewport === null || $cd94b4896dd97759$var$visualViewport === void 0 ? void 0 : $cd94b4896dd97759$var$visualViewport.removeEventListener('resize', onResize);
        };
    }, [
        updatePosition
    ]);
    let close = $6Zb2x$react.useCallback(()=>{
        if (!isResizing.current) onClose();
    }, [
        onClose,
        isResizing
    ]);
    // When scrolling a parent scrollable region of the trigger (other than the body),
    // we hide the popover. Otherwise, its position would be incorrect.
    $9a8aa1b0b336ea3a$export$18fc8428861184da({
        triggerRef: targetRef,
        isOpen: isOpen,
        onClose: onClose ? close : undefined
    });
    return {
        overlayProps: {
            style: {
                position: 'absolute',
                zIndex: 100000,
                ...position.position,
                maxHeight: position.maxHeight
            }
        },
        placement: position.placement,
        arrowProps: {
            style: {
                left: position.arrowOffsetLeft,
                top: position.arrowOffsetTop
            }
        },
        updatePosition: updatePosition
    };
}
function $cd94b4896dd97759$var$useResize(onResize) {
    $6Zb2x$reactariautils.useLayoutEffect(()=>{
        window.addEventListener('resize', onResize, false);
        return ()=>{
            window.removeEventListener('resize', onResize, false);
        };
    }, [
        onResize
    ]);
}
function $cd94b4896dd97759$var$translateRTL(position, direction) {
    if (direction === 'rtl') return position.replace('start', 'right').replace('end', 'left');
    return position.replace('start', 'left').replace('end', 'right');
}




const $82711f9cb668ecdb$var$visibleOverlays = [];
function $82711f9cb668ecdb$export$ea8f71083e90600f(props, ref) {
    let { onClose: onClose , shouldCloseOnBlur: shouldCloseOnBlur , isOpen: isOpen , isDismissable: isDismissable = false , isKeyboardDismissDisabled: isKeyboardDismissDisabled = false , shouldCloseOnInteractOutside: shouldCloseOnInteractOutside  } = props;
    // Add the overlay ref to the stack of visible overlays on mount, and remove on unmount.
    $6Zb2x$react.useEffect(()=>{
        if (isOpen) $82711f9cb668ecdb$var$visibleOverlays.push(ref);
        return ()=>{
            let index = $82711f9cb668ecdb$var$visibleOverlays.indexOf(ref);
            if (index >= 0) $82711f9cb668ecdb$var$visibleOverlays.splice(index, 1);
        };
    }, [
        isOpen,
        ref
    ]);
    // Only hide the overlay when it is the topmost visible overlay in the stack.
    let onHide = ()=>{
        if ($82711f9cb668ecdb$var$visibleOverlays[$82711f9cb668ecdb$var$visibleOverlays.length - 1] === ref && onClose) onClose();
    };
    let onInteractOutsideStart = (e)=>{
        if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.target)) {
            if ($82711f9cb668ecdb$var$visibleOverlays[$82711f9cb668ecdb$var$visibleOverlays.length - 1] === ref) {
                e.stopPropagation();
                e.preventDefault();
            }
        }
    };
    let onInteractOutside = (e)=>{
        if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.target)) {
            if ($82711f9cb668ecdb$var$visibleOverlays[$82711f9cb668ecdb$var$visibleOverlays.length - 1] === ref) {
                e.stopPropagation();
                e.preventDefault();
            }
            onHide();
        }
    };
    // Handle the escape key
    let onKeyDown = (e)=>{
        if (e.key === 'Escape' && !isKeyboardDismissDisabled) {
            e.stopPropagation();
            e.preventDefault();
            onHide();
        }
    };
    // Handle clicking outside the overlay to close it
    $6Zb2x$reactariainteractions.useInteractOutside({
        ref: ref,
        onInteractOutside: isDismissable ? onInteractOutside : null,
        onInteractOutsideStart: onInteractOutsideStart
    });
    let { focusWithinProps: focusWithinProps  } = $6Zb2x$reactariainteractions.useFocusWithin({
        isDisabled: !shouldCloseOnBlur,
        onBlurWithin: (e)=>{
            if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.relatedTarget)) onClose();
        }
    });
    let onPointerDownUnderlay = (e)=>{
        // fixes a firefox issue that starts text selection https://bugzilla.mozilla.org/show_bug.cgi?id=1675846
        if (e.target === e.currentTarget) e.preventDefault();
    };
    return {
        overlayProps: {
            onKeyDown: onKeyDown,
            ...focusWithinProps
        },
        underlayProps: {
            onPointerDown: onPointerDownUnderlay
        }
    };
}





function $b4878eb6316f670a$export$f9d5c8beee7d008d(props, state, ref) {
    let { type: type  } = props;
    let { isOpen: isOpen  } = state;
    // Backward compatibility. Share state close function with useOverlayPosition so it can close on scroll
    // without forcing users to pass onClose.
    $6Zb2x$react.useEffect(()=>{
        if (ref && ref.current) $9a8aa1b0b336ea3a$export$f6211563215e3b37.set(ref.current, state.close);
    });
    // Aria 1.1 supports multiple values for aria-haspopup other than just menus.
    // https://www.w3.org/TR/wai-aria-1.1/#aria-haspopup
    // However, we only add it for menus for now because screen readers often
    // announce it as a menu even for other values.
    let ariaHasPopup = undefined;
    if (type === 'menu') ariaHasPopup = true;
    else if (type === 'listbox') ariaHasPopup = 'listbox';
    let overlayId = $6Zb2x$reactariautils.useId();
    return {
        triggerProps: {
            'aria-haspopup': ariaHasPopup,
            'aria-expanded': isOpen,
            'aria-controls': isOpen ? overlayId : null,
            onPress: state.toggle
        },
        overlayProps: {
            id: overlayId
        }
    };
}



// @ts-ignore
const $5c2f5cd01815d369$var$visualViewport = typeof window !== 'undefined' && window.visualViewport;
// HTML input types that do not cause the software keyboard to appear.
const $5c2f5cd01815d369$var$nonTextInputTypes = new Set([
    'checkbox',
    'radio',
    'range',
    'color',
    'file',
    'image',
    'button',
    'submit',
    'reset'
]);
function $5c2f5cd01815d369$export$ee0f7cc6afcd1c18(options = {
}) {
    let { isDisabled: isDisabled  } = options;
    $6Zb2x$reactariautils.useLayoutEffect(()=>{
        if (isDisabled) return;
        if ($6Zb2x$reactariautils.isIOS()) return $5c2f5cd01815d369$var$preventScrollMobileSafari();
        else return $5c2f5cd01815d369$var$preventScrollStandard();
    }, [
        isDisabled
    ]);
}
// For most browsers, all we need to do is set `overflow: hidden` on the root element, and
// add some padding to prevent the page from shifting when the scrollbar is hidden.
function $5c2f5cd01815d369$var$preventScrollStandard() {
    return $6Zb2x$reactariautils.chain($5c2f5cd01815d369$var$setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`), $5c2f5cd01815d369$var$setStyle(document.documentElement, 'overflow', 'hidden'));
}
// Mobile Safari is a whole different beast. Even with overflow: hidden,
// it still scrolls the page in many situations:
//
// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.
// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of
//    it, so it becomes scrollable.
// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.
//    This may cause even fixed position elements to scroll off the screen.
// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always
//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.
//
// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:
//
// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling
//    on the window.
// 2. Prevent default on `touchmove` events inside a scrollable element when the scroll position is at the
//    top or bottom. This avoids the whole page scrolling instead, but does prevent overscrolling.
// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.
// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top
//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element
//    into view ourselves, without scrolling the whole page.
// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the
//    same visually, but makes the actual scroll position always zero. This is required to make all of the
//    above work or Safari will still try to scroll the page when focusing an input.
// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting
//    to navigate to an input with the next/previous buttons that's outside a modal.
function $5c2f5cd01815d369$var$preventScrollMobileSafari() {
    let scrollable;
    let lastY = 0;
    let onTouchStart = (e)=>{
        // Store the nearest scrollable parent element from the element that the user touched.
        scrollable = $6Zb2x$reactariautils.getScrollParent(e.target);
        if (scrollable === document.documentElement && scrollable === document.body) return;
        lastY = e.changedTouches[0].pageY;
    };
    let onTouchMove = (e)=>{
        // Prevent scrolling the window.
        if (scrollable === document.documentElement || scrollable === document.body) {
            e.preventDefault();
            return;
        }
        // Prevent scrolling up when at the top and scrolling down when at the bottom
        // of a nested scrollable area, otherwise mobile Safari will start scrolling
        // the window instead. Unfortunately, this disables bounce scrolling when at
        // the top but it's the best we can do.
        let y = e.changedTouches[0].pageY;
        let scrollTop = scrollable.scrollTop;
        let bottom = scrollable.scrollHeight - scrollable.clientHeight;
        if (scrollTop <= 0 && y > lastY || scrollTop >= bottom && y < lastY) e.preventDefault();
        lastY = y;
    };
    let onTouchEnd = (e)=>{
        let target = e.target;
        // Apply this change if we're not already focused on the target element
        if ($5c2f5cd01815d369$var$willOpenKeyboard(target) && target !== document.activeElement) {
            e.preventDefault();
            // Apply a transform to trick Safari into thinking the input is at the top of the page
            // so it doesn't try to scroll it into view. When tapping on an input, this needs to
            // be done before the "focus" event, so we have to focus the element ourselves.
            target.style.transform = 'translateY(-2000px)';
            target.focus();
            requestAnimationFrame(()=>{
                target.style.transform = '';
            });
        }
    };
    let onFocus = (e)=>{
        let target = e.target;
        if ($5c2f5cd01815d369$var$willOpenKeyboard(target)) {
            // Transform also needs to be applied in the focus event in cases where focus moves
            // other than tapping on an input directly, e.g. the next/previous buttons in the
            // software keyboard. In these cases, it seems applying the transform in the focus event
            // is good enough, whereas when tapping an input, it must be done before the focus event. 🤷‍♂️
            target.style.transform = 'translateY(-2000px)';
            requestAnimationFrame(()=>{
                target.style.transform = '';
                // This will have prevented the browser from scrolling the focused element into view,
                // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.
                if ($5c2f5cd01815d369$var$visualViewport) {
                    if ($5c2f5cd01815d369$var$visualViewport.height < window.innerHeight) // If the keyboard is already visible, do this after one additional frame
                    // to wait for the transform to be removed.
                    requestAnimationFrame(()=>{
                        $5c2f5cd01815d369$var$scrollIntoView(target);
                    });
                    else // Otherwise, wait for the visual viewport to resize before scrolling so we can
                    // measure the correct position to scroll to.
                    $5c2f5cd01815d369$var$visualViewport.addEventListener('resize', ()=>$5c2f5cd01815d369$var$scrollIntoView(target)
                    , {
                        once: true
                    });
                }
            });
        }
    };
    let onWindowScroll = ()=>{
        // Last resort. If the window scrolled, scroll it back to the top.
        // It should always be at the top because the body will have a negative margin (see below).
        window.scrollTo(0, 0);
    };
    // Record the original scroll position so we can restore it.
    // Then apply a negative margin to the body to offset it by the scroll position. This will
    // enable us to scroll the window to the top, which is required for the rest of this to work.
    let scrollX = window.pageXOffset;
    let scrollY = window.pageYOffset;
    let restoreStyles = $6Zb2x$reactariautils.chain($5c2f5cd01815d369$var$setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`), $5c2f5cd01815d369$var$setStyle(document.documentElement, 'overflow', 'hidden'), $5c2f5cd01815d369$var$setStyle(document.body, 'marginTop', `-${scrollY}px`));
    // Scroll to the top. The negative margin on the body will make this appear the same.
    window.scrollTo(0, 0);
    let removeEvents = $6Zb2x$reactariautils.chain($5c2f5cd01815d369$var$addEvent(document, 'touchstart', onTouchStart, {
        passive: false,
        capture: true
    }), $5c2f5cd01815d369$var$addEvent(document, 'touchmove', onTouchMove, {
        passive: false,
        capture: true
    }), $5c2f5cd01815d369$var$addEvent(document, 'touchend', onTouchEnd, {
        passive: false,
        capture: true
    }), $5c2f5cd01815d369$var$addEvent(document, 'focus', onFocus, true), $5c2f5cd01815d369$var$addEvent(window, 'scroll', onWindowScroll));
    return ()=>{
        // Restore styles and scroll the page back to where it was.
        restoreStyles();
        removeEvents();
        window.scrollTo(scrollX, scrollY);
    };
}
// Sets a CSS property on an element, and returns a function to revert it to the previous value.
function $5c2f5cd01815d369$var$setStyle(element, style, value) {
    let cur = element.style[style];
    element.style[style] = value;
    return ()=>{
        element.style[style] = cur;
    };
}
// Adds an event listener to an element, and returns a function to remove it.
function $5c2f5cd01815d369$var$addEvent(target, event, handler, options) {
    target.addEventListener(event, handler, options);
    return ()=>{
        target.removeEventListener(event, handler, options);
    };
}
function $5c2f5cd01815d369$var$scrollIntoView(target) {
    let root = document.scrollingElement || document.documentElement;
    while(target && target !== root){
        // Find the parent scrollable element and adjust the scroll position if the target is not already in view.
        let scrollable = $6Zb2x$reactariautils.getScrollParent(target);
        if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {
            let scrollableTop = scrollable.getBoundingClientRect().top;
            let targetTop = target.getBoundingClientRect().top;
            if (targetTop > scrollableTop + target.clientHeight) scrollable.scrollTop += targetTop - scrollableTop;
        }
        target = scrollable.parentElement;
    }
}
function $5c2f5cd01815d369$var$willOpenKeyboard(target) {
    return target instanceof HTMLInputElement && !$5c2f5cd01815d369$var$nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;
}





const $0775ea8ea6a0565e$var$Context = /*#__PURE__*/ ($parcel$interopDefault($6Zb2x$react)).createContext(null);
function $0775ea8ea6a0565e$export$178405afcd8c5eb(props) {
    let { children: children  } = props;
    let parent = $6Zb2x$react.useContext($0775ea8ea6a0565e$var$Context);
    let [modalCount, setModalCount] = $6Zb2x$react.useState(0);
    let context = $6Zb2x$react.useMemo(()=>({
            parent: parent,
            modalCount: modalCount,
            addModal () {
                setModalCount((count)=>count + 1
                );
                if (parent) parent.addModal();
            },
            removeModal () {
                setModalCount((count)=>count - 1
                );
                if (parent) parent.removeModal();
            }
        })
    , [
        parent,
        modalCount
    ]);
    return(/*#__PURE__*/ ($parcel$interopDefault($6Zb2x$react)).createElement($0775ea8ea6a0565e$var$Context.Provider, {
        value: context
    }, children));
}
function $0775ea8ea6a0565e$export$d9aaed4c3ece1bc0() {
    let context = $6Zb2x$react.useContext($0775ea8ea6a0565e$var$Context);
    return {
        modalProviderProps: {
            'aria-hidden': context && context.modalCount > 0 ? true : null
        }
    };
}
/**
 * Creates a root node that will be aria-hidden if there are other modals open.
 */ function $0775ea8ea6a0565e$var$OverlayContainerDOM(props) {
    let { modalProviderProps: modalProviderProps  } = $0775ea8ea6a0565e$export$d9aaed4c3ece1bc0();
    return(/*#__PURE__*/ ($parcel$interopDefault($6Zb2x$react)).createElement("div", {
        "data-overlay-container": true,
        ...props,
        ...modalProviderProps
    }));
}
function $0775ea8ea6a0565e$export$bf688221f59024e5(props) {
    return(/*#__PURE__*/ ($parcel$interopDefault($6Zb2x$react)).createElement($0775ea8ea6a0565e$export$178405afcd8c5eb, null, /*#__PURE__*/ ($parcel$interopDefault($6Zb2x$react)).createElement($0775ea8ea6a0565e$var$OverlayContainerDOM, props)));
}
function $0775ea8ea6a0565e$export$b47c3594eab58386(props) {
    let isSSR = $6Zb2x$reactariassr.useIsSSR();
    let { portalContainer: portalContainer = isSSR ? null : document.body , ...rest } = props;
    ($parcel$interopDefault($6Zb2x$react)).useEffect(()=>{
        if (portalContainer === null || portalContainer === void 0 ? void 0 : portalContainer.closest('[data-overlay-container]')) throw new Error('An OverlayContainer must not be inside another container. Please change the portalContainer prop.');
    }, [
        portalContainer
    ]);
    if (!portalContainer) return null;
    let contents = /*#__PURE__*/ ($parcel$interopDefault($6Zb2x$react)).createElement($0775ea8ea6a0565e$export$bf688221f59024e5, rest);
    return(/*#__PURE__*/ ($parcel$interopDefault($6Zb2x$reactdom)).createPortal(contents, portalContainer));
}
function $0775ea8ea6a0565e$export$33ffd74ebf07f060(options) {
    // Add aria-hidden to all parent providers on mount, and restore on unmount.
    let context = $6Zb2x$react.useContext($0775ea8ea6a0565e$var$Context);
    if (!context) throw new Error('Modal is not contained within a provider');
    $6Zb2x$react.useEffect(()=>{
        if ((options === null || options === void 0 ? void 0 : options.isDisabled) || !context || !context.parent) return;
        // The immediate context is from the provider containing this modal, so we only
        // want to trigger aria-hidden on its parents not on the modal provider itself.
        context.parent.addModal();
        return ()=>{
            if (context && context.parent) context.parent.removeModal();
        };
    }, [
        context,
        context.parent,
        options === null || options === void 0 ? void 0 : options.isDisabled
    ]);
    return {
        modalProps: {
            'data-ismodal': !(options === null || options === void 0 ? void 0 : options.isDisabled)
        }
    };
}


var $18d014414048a7ba$exports = {};
var $4393d9b86d3ad278$exports = {};
$4393d9b86d3ad278$exports = {
    "dismiss": `تجاهل`
};


var $254224013ae06959$exports = {};
$254224013ae06959$exports = {
    "dismiss": `Отхвърляне`
};


var $55d3567b59d09782$exports = {};
$55d3567b59d09782$exports = {
    "dismiss": `Odstranit`
};


var $0e419a7be7773c16$exports = {};
$0e419a7be7773c16$exports = {
    "dismiss": `Luk`
};


var $be606513c8356c34$exports = {};
$be606513c8356c34$exports = {
    "dismiss": `Schließen`
};


var $7d99787e5bd26f87$exports = {};
$7d99787e5bd26f87$exports = {
    "dismiss": `Απόρριψη`
};


var $0360f2a6534752c1$exports = {};
$0360f2a6534752c1$exports = {
    "dismiss": `Dismiss`
};


var $92bf4fdecfeb6a61$exports = {};
$92bf4fdecfeb6a61$exports = {
    "dismiss": `Descartar`
};


var $7c02fa9b9c598043$exports = {};
$7c02fa9b9c598043$exports = {
    "dismiss": `Lõpeta`
};


var $ba53535dcca59343$exports = {};
$ba53535dcca59343$exports = {
    "dismiss": `Hylkää`
};


var $2fbbcddf7d252cb7$exports = {};
$2fbbcddf7d252cb7$exports = {
    "dismiss": `Rejeter`
};


var $0a1f0520e07d3596$exports = {};
$0a1f0520e07d3596$exports = {
    "dismiss": `התעלם`
};


var $f7be5df1487823a9$exports = {};
$f7be5df1487823a9$exports = {
    "dismiss": `Odbaci`
};


var $8dbe4363bfbba3f9$exports = {};
$8dbe4363bfbba3f9$exports = {
    "dismiss": `Elutasítás`
};


var $90a445da1ad273e7$exports = {};
$90a445da1ad273e7$exports = {
    "dismiss": `Ignora`
};


var $e1ebf18259c9b1ee$exports = {};
$e1ebf18259c9b1ee$exports = {
    "dismiss": `閉じる`
};


var $765893642f3b4f72$exports = {};
$765893642f3b4f72$exports = {
    "dismiss": `무시`
};


var $af73ba24f63febd1$exports = {};
$af73ba24f63febd1$exports = {
    "dismiss": `Atmesti`
};


var $97aac9f6740ee412$exports = {};
$97aac9f6740ee412$exports = {
    "dismiss": `Nerādīt`
};


var $92fbe76e196d7e0a$exports = {};
$92fbe76e196d7e0a$exports = {
    "dismiss": `Lukk`
};


var $44399897afb701ce$exports = {};
$44399897afb701ce$exports = {
    "dismiss": `Negeren`
};


var $d679e258664d7384$exports = {};
$d679e258664d7384$exports = {
    "dismiss": `Zignoruj`
};


var $b51fc2992648966b$exports = {};
$b51fc2992648966b$exports = {
    "dismiss": `Descartar`
};


var $6abbc540dcd5f78c$exports = {};
$6abbc540dcd5f78c$exports = {
    "dismiss": `Dispensar`
};


var $6cbc0c9bf574473b$exports = {};
$6cbc0c9bf574473b$exports = {
    "dismiss": `Revocare`
};


var $009edbe58be6525b$exports = {};
$009edbe58be6525b$exports = {
    "dismiss": `Пропустить`
};


var $01cf6095489e78f7$exports = {};
$01cf6095489e78f7$exports = {
    "dismiss": `Zrušiť`
};


var $33fd5a1a3753e83f$exports = {};
$33fd5a1a3753e83f$exports = {
    "dismiss": `Opusti`
};


var $6b9373a558e74e84$exports = {};
$6b9373a558e74e84$exports = {
    "dismiss": `Odbaci`
};


var $90008194c3db7fce$exports = {};
$90008194c3db7fce$exports = {
    "dismiss": `Avvisa`
};


var $e29d21290b4ce15c$exports = {};
$e29d21290b4ce15c$exports = {
    "dismiss": `Kapat`
};


var $96139c59e8ba3f85$exports = {};
$96139c59e8ba3f85$exports = {
    "dismiss": `Скасувати`
};


var $052554192ea8e826$exports = {};
$052554192ea8e826$exports = {
    "dismiss": `取消`
};


var $3f3b5d798a5abdbc$exports = {};
$3f3b5d798a5abdbc$exports = {
    "dismiss": `關閉`
};


$18d014414048a7ba$exports = {
    "ar-AE": $4393d9b86d3ad278$exports,
    "bg-BG": $254224013ae06959$exports,
    "cs-CZ": $55d3567b59d09782$exports,
    "da-DK": $0e419a7be7773c16$exports,
    "de-DE": $be606513c8356c34$exports,
    "el-GR": $7d99787e5bd26f87$exports,
    "en-US": $0360f2a6534752c1$exports,
    "es-ES": $92bf4fdecfeb6a61$exports,
    "et-EE": $7c02fa9b9c598043$exports,
    "fi-FI": $ba53535dcca59343$exports,
    "fr-FR": $2fbbcddf7d252cb7$exports,
    "he-IL": $0a1f0520e07d3596$exports,
    "hr-HR": $f7be5df1487823a9$exports,
    "hu-HU": $8dbe4363bfbba3f9$exports,
    "it-IT": $90a445da1ad273e7$exports,
    "ja-JP": $e1ebf18259c9b1ee$exports,
    "ko-KR": $765893642f3b4f72$exports,
    "lt-LT": $af73ba24f63febd1$exports,
    "lv-LV": $97aac9f6740ee412$exports,
    "nb-NO": $92fbe76e196d7e0a$exports,
    "nl-NL": $44399897afb701ce$exports,
    "pl-PL": $d679e258664d7384$exports,
    "pt-BR": $b51fc2992648966b$exports,
    "pt-PT": $6abbc540dcd5f78c$exports,
    "ro-RO": $6cbc0c9bf574473b$exports,
    "ru-RU": $009edbe58be6525b$exports,
    "sk-SK": $01cf6095489e78f7$exports,
    "sl-SI": $33fd5a1a3753e83f$exports,
    "sr-SP": $6b9373a558e74e84$exports,
    "sv-SE": $90008194c3db7fce$exports,
    "tr-TR": $e29d21290b4ce15c$exports,
    "uk-UA": $96139c59e8ba3f85$exports,
    "zh-CN": $052554192ea8e826$exports,
    "zh-TW": $3f3b5d798a5abdbc$exports
};






function $f69bb3e6457495cc$export$2317d149ed6f78c4(props) {
    let { onDismiss: onDismiss , ...otherProps } = props;
    let stringFormatter = $6Zb2x$reactariai18n.useLocalizedStringFormatter((/*@__PURE__*/$parcel$interopDefault($18d014414048a7ba$exports)));
    let labels = $6Zb2x$reactariautils.useLabels(otherProps, stringFormatter.format('dismiss'));
    let onClick = ()=>{
        if (onDismiss) onDismiss();
    };
    return(/*#__PURE__*/ ($parcel$interopDefault($6Zb2x$react)).createElement($6Zb2x$reactariavisuallyhidden.VisuallyHidden, null, /*#__PURE__*/ ($parcel$interopDefault($6Zb2x$react)).createElement("button", {
        ...labels,
        tabIndex: -1,
        onClick: onClick
    })));
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Keeps a ref count of all hidden elements. Added to when hiding an element, and
// subtracted from when showing it again. When it reaches zero, aria-hidden is removed.
let $08ef1685902b6011$var$refCountMap = new WeakMap();
function $08ef1685902b6011$export$1c3ebcada18427bf(targets, root = document.body) {
    let visibleNodes = new Set(targets);
    let hiddenNodes = new Set();
    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode (node) {
            // If this node is a live announcer, add it to the set of nodes to keep visible.
            if ((node instanceof HTMLElement || node instanceof SVGElement) && node.dataset.liveAnnouncer === 'true') visibleNodes.add(node);
            // Skip this node and its children if it is one of the target nodes, or a live announcer.
            // Also skip children of already hidden nodes, as aria-hidden is recursive. An exception is
            // made for elements with role="row" since VoiceOver on iOS has issues hiding elements with role="row".
            // For that case we want to hide the cells inside as well (https://bugs.webkit.org/show_bug.cgi?id=222623).
            if (visibleNodes.has(node) || hiddenNodes.has(node.parentElement) && node.parentElement.getAttribute('role') !== 'row') return NodeFilter.FILTER_REJECT;
            // Skip this node but continue to children if one of the targets is inside the node.
            if (targets.some((target)=>node.contains(target)
            )) return NodeFilter.FILTER_SKIP;
            return NodeFilter.FILTER_ACCEPT;
        }
    });
    let hide = (node)=>{
        var ref;
        let refCount = (ref = $08ef1685902b6011$var$refCountMap.get(node)) !== null && ref !== void 0 ? ref : 0;
        // If already aria-hidden, and the ref count is zero, then this element
        // was already hidden and there's nothing for us to do.
        if (node.getAttribute('aria-hidden') === 'true' && refCount === 0) return;
        if (refCount === 0) node.setAttribute('aria-hidden', 'true');
        hiddenNodes.add(node);
        $08ef1685902b6011$var$refCountMap.set(node, refCount + 1);
    };
    let node1 = walker.nextNode();
    while(node1 != null){
        hide(node1);
        node1 = walker.nextNode();
    }
    let observer = new MutationObserver((changes)=>{
        for (let change of changes){
            if (change.type !== 'childList' || change.addedNodes.length === 0) continue;
            // If the parent element of the added nodes is not within one of the targets,
            // and not already inside a hidden node, hide all of the new children.
            if (![
                ...visibleNodes,
                ...hiddenNodes
            ].some((node)=>node.contains(change.target)
            )) for (let node2 of change.addedNodes){
                if ((node2 instanceof HTMLElement || node2 instanceof SVGElement) && node2.dataset.liveAnnouncer === 'true') visibleNodes.add(node2);
                else if (node2 instanceof Element) hide(node2);
            }
        }
    });
    observer.observe(root, {
        childList: true,
        subtree: true
    });
    return ()=>{
        observer.disconnect();
        for (let node of hiddenNodes){
            let count = $08ef1685902b6011$var$refCountMap.get(node);
            if (count === 1) {
                node.removeAttribute('aria-hidden');
                $08ef1685902b6011$var$refCountMap.delete(node);
            } else $08ef1685902b6011$var$refCountMap.set(node, count - 1);
        }
    };
}







function $6c2dfcdee3e15e20$export$542a6fd13ac93354(props, state) {
    let { triggerRef: triggerRef , popoverRef: popoverRef , isNonModal: isNonModal , ...otherProps } = props;
    let { overlayProps: overlayProps  } = $82711f9cb668ecdb$export$ea8f71083e90600f({
        isOpen: state.isOpen,
        onClose: state.close,
        shouldCloseOnBlur: true,
        isDismissable: true
    }, popoverRef);
    let { overlayProps: positionProps , arrowProps: arrowProps  } = $cd94b4896dd97759$export$d39e1813b3bdd0e1({
        ...otherProps,
        targetRef: triggerRef,
        overlayRef: popoverRef,
        isOpen: state.isOpen
    });
    $6Zb2x$react.useEffect(()=>{
        if (state.isOpen && !isNonModal) return $08ef1685902b6011$export$1c3ebcada18427bf([
            popoverRef.current
        ]);
    }, [
        isNonModal,
        state.isOpen,
        popoverRef
    ]);
    return {
        popoverProps: $6Zb2x$reactariautils.mergeProps(overlayProps, positionProps),
        arrowProps: arrowProps
    };
}











const $745edbb83ab4296f$var$OverlayContext = /*#__PURE__*/ ($parcel$interopDefault($6Zb2x$react)).createContext(null);
function $745edbb83ab4296f$export$c6fdb837b070b4ff(props) {
    let isSSR = $6Zb2x$reactariassr.useIsSSR();
    let { portalContainer: portalContainer = isSSR ? null : document.body  } = props;
    let [contain, setContain] = $6Zb2x$react.useState(false);
    if (!portalContainer) return null;
    let contents = /*#__PURE__*/ ($parcel$interopDefault($6Zb2x$react)).createElement($745edbb83ab4296f$var$OverlayContext.Provider, {
        value: setContain
    }, /*#__PURE__*/ ($parcel$interopDefault($6Zb2x$react)).createElement($6Zb2x$reactariafocus.FocusScope, {
        restoreFocus: true,
        contain: contain
    }, props.children));
    return(/*#__PURE__*/ ($parcel$interopDefault($6Zb2x$reactdom)).createPortal(contents, portalContainer));
}
function $745edbb83ab4296f$export$14c98a7594375490() {
    let setContain = $6Zb2x$react.useContext($745edbb83ab4296f$var$OverlayContext);
    $6Zb2x$reactariautils.useLayoutEffect(()=>{
        setContain === null || setContain === void 0 ? void 0 : setContain(true);
    }, [
        setContain
    ]);
}



function $11b7e0b04b421e95$export$dbc0f175b25fb0fb(props, state, ref) {
    let { overlayProps: overlayProps , underlayProps: underlayProps  } = $82711f9cb668ecdb$export$ea8f71083e90600f({
        ...props,
        isOpen: state.isOpen,
        onClose: state.close
    }, ref);
    $5c2f5cd01815d369$export$ee0f7cc6afcd1c18({
        isDisabled: !state.isOpen
    });
    $745edbb83ab4296f$export$14c98a7594375490();
    $6Zb2x$react.useEffect(()=>{
        if (state.isOpen) return $08ef1685902b6011$export$1c3ebcada18427bf([
            ref.current
        ]);
    }, [
        state.isOpen,
        ref
    ]);
    return {
        modalProps: $6Zb2x$reactariautils.mergeProps(overlayProps),
        underlayProps: underlayProps
    };
}





//# sourceMappingURL=main.js.map


/***/ }),

/***/ 98600:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $aB6Cp$react = __webpack_require__(18038);
var $aB6Cp$reactariautils = __webpack_require__(40246);
var $aB6Cp$reactariainteractions = __webpack_require__(71867);
var $aB6Cp$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "FocusScope", () => $a7a032acae3ddda9$export$20e40289641fbbb6);
$parcel$export(module.exports, "useFocusManager", () => $a7a032acae3ddda9$export$10c5169755ce7bd7);
$parcel$export(module.exports, "getFocusableTreeWalker", () => $a7a032acae3ddda9$export$2d6ec8fc375ceafa);
$parcel$export(module.exports, "createFocusManager", () => $a7a032acae3ddda9$export$c5251b9e124bf29);
$parcel$export(module.exports, "isElementInChildOfActiveScope", () => $a7a032acae3ddda9$export$1258395f99bf9cbf);
$parcel$export(module.exports, "FocusRing", () => $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d);
$parcel$export(module.exports, "FocusableProvider", () => $fb504d83237fd6ac$export$13f3202a3e5ddd5);
$parcel$export(module.exports, "useFocusable", () => $fb504d83237fd6ac$export$4c014de7c8940b4c);
$parcel$export(module.exports, "useFocusRing", () => $581a96d6eb128c1b$export$4e328f61c538687f);
$parcel$export(module.exports, "focusSafely", () => $1c7f9157d722357d$export$80f3e147d781571c);
$parcel$export(module.exports, "useHasTabbableChild", () => $259c6413a286f2e6$export$eac1895992b9f3d6);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1c7f9157d722357d$export$80f3e147d781571c(element) {
    // If the user is interacting with a virtual cursor, e.g. screen reader, then
    // wait until after any animated transitions that are currently occurring on
    // the page before shifting focus. This avoids issues with VoiceOver on iOS
    // causing the page to scroll when moving focus if the element is transitioning
    // from off the screen.
    if ((0, $aB6Cp$reactariainteractions.getInteractionModality)() === "virtual") {
        let lastFocusedElement = document.activeElement;
        (0, $aB6Cp$reactariautils.runAfterTransition)(()=>{
            // If focus did not move and the element is still in the document, focus it.
            if (document.activeElement === lastFocusedElement && document.contains(element)) (0, $aB6Cp$reactariautils.focusWithoutScrolling)(element);
        });
    } else (0, $aB6Cp$reactariautils.focusWithoutScrolling)(element);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d5156037ad898a4d$var$isStyleVisible(element) {
    if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) return false;
    let { display: display , visibility: visibility  } = element.style;
    let isVisible = display !== "none" && visibility !== "hidden" && visibility !== "collapse";
    if (isVisible) {
        const { getComputedStyle: getComputedStyle  } = element.ownerDocument.defaultView;
        let { display: computedDisplay , visibility: computedVisibility  } = getComputedStyle(element);
        isVisible = computedDisplay !== "none" && computedVisibility !== "hidden" && computedVisibility !== "collapse";
    }
    return isVisible;
}
function $d5156037ad898a4d$var$isAttributeVisible(element, childElement) {
    return !element.hasAttribute("hidden") && (element.nodeName === "DETAILS" && childElement && childElement.nodeName !== "SUMMARY" ? element.hasAttribute("open") : true);
}
function $d5156037ad898a4d$export$e989c0fffaa6b27a(element, childElement) {
    return element.nodeName !== "#comment" && $d5156037ad898a4d$var$isStyleVisible(element) && $d5156037ad898a4d$var$isAttributeVisible(element, childElement) && (!element.parentElement || $d5156037ad898a4d$export$e989c0fffaa6b27a(element.parentElement, element));
}




const $a7a032acae3ddda9$var$FocusContext = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createContext(null);
let $a7a032acae3ddda9$var$activeScope = null;
function $a7a032acae3ddda9$export$20e40289641fbbb6(props) {
    let { children: children , contain: contain , restoreFocus: restoreFocus , autoFocus: autoFocus  } = props;
    let startRef = (0, $aB6Cp$react.useRef)();
    let endRef = (0, $aB6Cp$react.useRef)();
    let scopeRef = (0, $aB6Cp$react.useRef)([]);
    let { parentNode: parentNode  } = (0, $aB6Cp$react.useContext)($a7a032acae3ddda9$var$FocusContext) || {};
    // Create a tree node here so we can add children to it even before it is added to the tree.
    let node = (0, $aB6Cp$react.useMemo)(()=>new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: scopeRef
        }), [
        scopeRef
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),
        // use the active scope as the parent instead of the parent from context. Layout effects run bottom
        // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope
        // that is being added should get the activeScope as its parent.
        let parent = parentNode || $a7a032acae3ddda9$export$d06fae2ee68b101e.root;
        if ($a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(parent.scopeRef) && $a7a032acae3ddda9$var$activeScope && !$a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, parent.scopeRef)) {
            let activeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
            if (activeNode) parent = activeNode;
        }
        // Add the node to the parent, and to the tree.
        parent.addChild(node);
        $a7a032acae3ddda9$export$d06fae2ee68b101e.addNode(node);
    }, [
        node,
        parentNode
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let node = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef);
        node.contain = contain;
    }, [
        contain
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        // Find all rendered nodes between the sentinels and add them to the scope.
        let node = startRef.current.nextSibling;
        let nodes = [];
        while(node && node !== endRef.current){
            nodes.push(node);
            node = node.nextSibling;
        }
        scopeRef.current = nodes;
    }, [
        children
    ]);
    $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain);
    $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus);
    // this layout effect needs to run last so that focusScopeTree cleanup happens at the last moment possible
    (0, $aB6Cp$react.useEffect)(()=>{
        if (scopeRef) {
            let activeElement = document.activeElement;
            let scope = null;
            // In strict mode, active scope is incorrectly updated since cleanup will run even though scope hasn't unmounted.
            // To fix this, we need to update the actual activeScope here
            if ($a7a032acae3ddda9$var$isElementInScope(activeElement, scopeRef.current)) {
                // Since useLayoutEffect runs for children first, we need to traverse the focusScope tree and find the bottom most scope that
                // contains the active element and set that as the activeScope
                for (let node of $a7a032acae3ddda9$export$d06fae2ee68b101e.traverse())if ($a7a032acae3ddda9$var$isElementInScope(activeElement, node.scopeRef.current)) scope = node;
                if (scope === $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef)) $a7a032acae3ddda9$var$activeScope = scope.scopeRef;
            }
            return ()=>{
                // Scope may have been re-parented.
                let parentScope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).parent.scopeRef;
                // Restore the active scope on unmount if this scope or a descendant scope is active.
                // Parent effect cleanups run before children, so we need to check if the
                // parent scope actually still exists before restoring the active scope to it.
                if ((scopeRef === $a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope(scopeRef, $a7a032acae3ddda9$var$activeScope)) && (!parentScope || $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(parentScope))) $a7a032acae3ddda9$var$activeScope = parentScope;
                $a7a032acae3ddda9$export$d06fae2ee68b101e.removeTreeNode(scopeRef);
            };
        }
    }, [
        scopeRef
    ]);
    let focusManager = (0, $aB6Cp$react.useMemo)(()=>$a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef), []);
    let value = (0, $aB6Cp$react.useMemo)(()=>({
            focusManager: focusManager,
            parentNode: node
        }), [
        node,
        focusManager
    ]);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement($a7a032acae3ddda9$var$FocusContext.Provider, {
        value: value
    }, /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement("span", {
        "data-focus-scope-start": true,
        hidden: true,
        ref: startRef
    }), children, /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement("span", {
        "data-focus-scope-end": true,
        hidden: true,
        ref: endRef
    }));
}
function $a7a032acae3ddda9$export$10c5169755ce7bd7() {
    var _useContext;
    return (_useContext = (0, $aB6Cp$react.useContext)($a7a032acae3ddda9$var$FocusContext)) === null || _useContext === void 0 ? void 0 : _useContext.focusManager;
}
function $a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef) {
    return {
        focusNext (opts = {}) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[0].previousElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = sentinel;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = {}) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[scope.length - 1].nextElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = sentinel;
                previousNode = walker.previousNode();
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = {}) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[0].previousElementSibling;
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = {}) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[scope.length - 1].nextElementSibling;
            let previousNode = walker.previousNode();
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        }
    };
}
const $a7a032acae3ddda9$var$focusableElements = [
    "input:not([disabled]):not([type=hidden])",
    "select:not([disabled])",
    "textarea:not([disabled])",
    "button:not([disabled])",
    "a[href]",
    "area[href]",
    "summary",
    "iframe",
    "object",
    "embed",
    "audio[controls]",
    "video[controls]",
    "[contenteditable]"
];
const $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
$a7a032acae3ddda9$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(':not([hidden]):not([tabindex="-1"]),');
function $a7a032acae3ddda9$var$getScopeRoot(scope) {
    return scope[0].parentElement;
}
function $a7a032acae3ddda9$var$shouldContainFocus(scopeRef) {
    let scope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
    while(scope && scope.scopeRef !== scopeRef){
        if (scope.contain) return false;
        scope = scope.parent;
    }
    return true;
}
function $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain) {
    let focusedNode = (0, $aB6Cp$react.useRef)();
    let raf = (0, $aB6Cp$react.useRef)(null);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let scope = scopeRef.current;
        if (!contain) {
            // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment
            if (raf.current) {
                cancelAnimationFrame(raf.current);
                raf.current = null;
            }
            return;
        }
        // Handle the Tab key to contain focus within the scope
        let onKeyDown = (e)=>{
            if (e.key !== "Tab" || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) return;
            let focusedElement = document.activeElement;
            let scope = scopeRef.current;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scope)) return;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: true
            }, scope);
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!nextElement) {
                walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;
                nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            }
            e.preventDefault();
            if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
        };
        let onFocus = (e)=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if ((!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) && $a7a032acae3ddda9$var$isElementInScope(e.target, scopeRef.current)) {
                $a7a032acae3ddda9$var$activeScope = scopeRef;
                focusedNode.current = e.target;
            } else if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(e.target, scopeRef)) {
                // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),
                // restore focus to the previously focused node or the first tabbable element in the active scope.
                if (focusedNode.current) focusedNode.current.focus();
                else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
            } else if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) focusedNode.current = e.target;
        };
        let onBlur = (e)=>{
            // Firefox doesn't shift focus back to the Dialog properly without this
            if (raf.current) cancelAnimationFrame(raf.current);
            raf.current = requestAnimationFrame(()=>{
                // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe
                if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(document.activeElement, scopeRef)) {
                    $a7a032acae3ddda9$var$activeScope = scopeRef;
                    if (document.body.contains(e.target)) {
                        focusedNode.current = e.target;
                        focusedNode.current.focus();
                    } else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
                }
            });
        };
        document.addEventListener("keydown", onKeyDown, false);
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        scope.forEach((element)=>element.addEventListener("focusout", onBlur, false));
        return ()=>{
            document.removeEventListener("keydown", onKeyDown, false);
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
            scope.forEach((element)=>element.removeEventListener("focusout", onBlur, false));
        };
    }, [
        scopeRef,
        contain
    ]);
    // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur
    // eslint-disable-next-line arrow-body-style
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        return ()=>{
            if (raf.current) cancelAnimationFrame(raf.current);
        };
    }, [
        raf
    ]);
}
function $a7a032acae3ddda9$var$isElementInAnyScope(element) {
    return $a7a032acae3ddda9$var$isElementInChildScope(element);
}
function $a7a032acae3ddda9$var$isElementInScope(element, scope) {
    return scope.some((node)=>node.contains(element));
}
function $a7a032acae3ddda9$var$isElementInChildScope(element, scope = null) {
    // If the element is within a top layer element (e.g. toasts), always allow moving focus there.
    if (element instanceof Element && element.closest("[data-react-aria-top-layer]")) return true;
    // node.contains in isElementInScope covers child scopes that are also DOM children,
    // but does not cover child scopes in portals.
    for (let { scopeRef: s  } of $a7a032acae3ddda9$export$d06fae2ee68b101e.traverse($a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scope))){
        if ($a7a032acae3ddda9$var$isElementInScope(element, s.current)) return true;
    }
    return false;
}
function $a7a032acae3ddda9$export$1258395f99bf9cbf(element) {
    return $a7a032acae3ddda9$var$isElementInChildScope(element, $a7a032acae3ddda9$var$activeScope);
}
function $a7a032acae3ddda9$var$isAncestorScope(ancestor, scope) {
    var _focusScopeTree_getTreeNode;
    let parent = (_focusScopeTree_getTreeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scope)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : _focusScopeTree_getTreeNode.parent;
    while(parent){
        if (parent.scopeRef === ancestor) return true;
        parent = parent.parent;
    }
    return false;
}
function $a7a032acae3ddda9$var$focusElement(element, scroll = false) {
    if (element != null && !scroll) try {
        (0, $1c7f9157d722357d$export$80f3e147d781571c)(element);
    } catch (err) {
    // ignore
    }
    else if (element != null) try {
        element.focus();
    } catch (err) {
    // ignore
    }
}
function $a7a032acae3ddda9$var$focusFirstInScope(scope, tabbable = true) {
    let sentinel = scope[0].previousElementSibling;
    let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
        tabbable: tabbable
    }, scope);
    walker.currentNode = sentinel;
    let nextNode = walker.nextNode();
    // If the scope does not contain a tabbable element, use the first focusable element.
    if (tabbable && !nextNode) {
        walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
            tabbable: false
        }, scope);
        walker.currentNode = sentinel;
        nextNode = walker.nextNode();
    }
    $a7a032acae3ddda9$var$focusElement(nextNode);
}
function $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus) {
    const autoFocusRef = (0, ($parcel$interopDefault($aB6Cp$react))).useRef(autoFocus);
    (0, $aB6Cp$react.useEffect)(()=>{
        if (autoFocusRef.current) {
            $a7a032acae3ddda9$var$activeScope = scopeRef;
            if (!$a7a032acae3ddda9$var$isElementInScope(document.activeElement, $a7a032acae3ddda9$var$activeScope.current)) $a7a032acae3ddda9$var$focusFirstInScope(scopeRef.current);
        }
        autoFocusRef.current = false;
    }, [
        scopeRef
    ]);
}
function $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restore, contain) {
    // tracks the active scope, in case restore and contain are both false.
    // if either are true, this is tracked in useRestoreFocus or useFocusContainment.
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if (restore || contain) return;
        let scope = scopeRef.current;
        let onFocus = (e)=>{
            let target = e.target;
            if ($a7a032acae3ddda9$var$isElementInScope(target, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
            else if (!$a7a032acae3ddda9$var$isElementInAnyScope(target)) $a7a032acae3ddda9$var$activeScope = null;
        };
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        return ()=>{
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
        };
    }, [
        scopeRef,
        restore,
        contain
    ]);
}
function $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef) {
    let scope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
    while(scope && scope.scopeRef !== scopeRef){
        if (scope.nodeToRestore) return false;
        scope = scope.parent;
    }
    return (scope === null || scope === void 0 ? void 0 : scope.scopeRef) === scopeRef;
}
function $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
    // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.
    const nodeToRestoreRef = (0, $aB6Cp$react.useRef)(typeof document !== "undefined" ? document.activeElement : null);
    // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus
    // restoring-non-containing scopes should only care if they become active so they can perform the restore
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let scope = scopeRef.current;
        if (!restoreFocus || contain) return;
        let onFocus = ()=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if ((!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) && $a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
        };
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        return ()=>{
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        scopeRef,
        contain
    ]);
    // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if (!restoreFocus) return;
        $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = nodeToRestoreRef.current;
        // Handle the Tab key so that tabbing out of the scope goes to the next element
        // after the node that had focus when the scope mounted. This is important when
        // using portals for overlays, so that focus goes to the expected element when
        // tabbing out of the overlay.
        let onKeyDown = (e)=>{
            if (e.key !== "Tab" || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) return;
            let focusedElement = document.activeElement;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scopeRef.current)) return;
            let nodeToRestore = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;
            // Create a DOM tree walker that matches all tabbable elements
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(document.body, {
                tabbable: true
            });
            // Find the next tabbable element after the currently focused element
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!document.body.contains(nodeToRestore) || nodeToRestore === document.body) {
                nodeToRestore = null;
                $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = null;
            }
            // If there is no next element, or it is outside the current scope, move focus to the
            // next element after the node to restore to instead.
            if ((!nextElement || !$a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {
                walker.currentNode = nodeToRestore;
                // Skip over elements within the scope, in case the scope immediately follows the node to restore.
                do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
                while ($a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current));
                e.preventDefault();
                e.stopPropagation();
                if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
                else // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)
                // then move focus to the body.
                // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)
                if (!$a7a032acae3ddda9$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();
                else $a7a032acae3ddda9$var$focusElement(nodeToRestore, true);
            }
        };
        if (!contain) document.addEventListener("keydown", onKeyDown, true);
        return ()=>{
            if (!contain) document.removeEventListener("keydown", onKeyDown, true);
            let nodeToRestore = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;
            // if we already lost focus to the body and this was the active scope, then we should attempt to restore
            if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps
            ($a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current) || document.activeElement === document.body && $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef))) {
                // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it
                let clonedTree = $a7a032acae3ddda9$export$d06fae2ee68b101e.clone();
                requestAnimationFrame(()=>{
                    // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere
                    if (document.activeElement === document.body) {
                        // look up the tree starting with our scope to find a nodeToRestore still in the DOM
                        let treeNode = clonedTree.getTreeNode(scopeRef);
                        while(treeNode){
                            if (treeNode.nodeToRestore && document.body.contains(treeNode.nodeToRestore)) {
                                $a7a032acae3ddda9$var$focusElement(treeNode.nodeToRestore);
                                return;
                            }
                            treeNode = treeNode.parent;
                        }
                        // If no nodeToRestore was found, focus the first element in the nearest
                        // ancestor scope that is still in the tree.
                        treeNode = clonedTree.getTreeNode(scopeRef);
                        while(treeNode){
                            if (treeNode.scopeRef && $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(treeNode.scopeRef)) {
                                $a7a032acae3ddda9$var$focusFirstInScope(treeNode.scopeRef.current, true);
                                return;
                            }
                            treeNode = treeNode.parent;
                        }
                    }
                });
            }
        };
    }, [
        scopeRef,
        restoreFocus,
        contain
    ]);
}
function $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, opts, scope) {
    let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR : $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR;
    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode (node) {
            var _opts_from;
            // Skip nodes inside the starting node.
            if (opts === null || opts === void 0 ? void 0 : (_opts_from = opts.from) === null || _opts_from === void 0 ? void 0 : _opts_from.contains(node)) return NodeFilter.FILTER_REJECT;
            if (node.matches(selector) && (0, $d5156037ad898a4d$export$e989c0fffaa6b27a)(node) && (!scope || $a7a032acae3ddda9$var$isElementInScope(node, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node))) return NodeFilter.FILTER_ACCEPT;
            return NodeFilter.FILTER_SKIP;
        }
    });
    if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;
    return walker;
}
function $a7a032acae3ddda9$export$c5251b9e124bf29(ref, defaultOptions = {}) {
    return {
        focusNext (opts = {}) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = root;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            else {
                let next = $a7a032acae3ddda9$var$last(walker);
                if (next) $a7a032acae3ddda9$var$focusElement(next, true);
                return next;
            }
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = root;
                previousNode = $a7a032acae3ddda9$var$last(walker);
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let next = $a7a032acae3ddda9$var$last(walker);
            if (next) $a7a032acae3ddda9$var$focusElement(next, true);
            return next;
        }
    };
}
function $a7a032acae3ddda9$var$last(walker) {
    let next;
    let last;
    do {
        last = walker.lastChild();
        if (last) next = last;
    }while (last);
    return next;
}
class $a7a032acae3ddda9$var$Tree {
    get size() {
        return this.fastMap.size;
    }
    getTreeNode(data) {
        return this.fastMap.get(data);
    }
    addTreeNode(scopeRef, parent, nodeToRestore) {
        let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);
        let node = new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: scopeRef
        });
        parentNode.addChild(node);
        node.parent = parentNode;
        this.fastMap.set(scopeRef, node);
        if (nodeToRestore) node.nodeToRestore = nodeToRestore;
    }
    addNode(node) {
        this.fastMap.set(node.scopeRef, node);
    }
    removeTreeNode(scopeRef) {
        // never remove the root
        if (scopeRef === null) return;
        let node = this.fastMap.get(scopeRef);
        let parentNode = node.parent;
        // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing
        // if we are, then replace the siblings restore with the restore from the scope we're removing
        for (let current of this.traverse())if (current !== node && node.nodeToRestore && current.nodeToRestore && node.scopeRef.current && $a7a032acae3ddda9$var$isElementInScope(current.nodeToRestore, node.scopeRef.current)) current.nodeToRestore = node.nodeToRestore;
        let children = node.children;
        parentNode.removeChild(node);
        if (children.size > 0) children.forEach((child)=>parentNode.addChild(child));
        this.fastMap.delete(node.scopeRef);
    }
    // Pre Order Depth First
    *traverse(node = this.root) {
        if (node.scopeRef != null) yield node;
        if (node.children.size > 0) for (let child of node.children)yield* this.traverse(child);
    }
    clone() {
        let newTree = new $a7a032acae3ddda9$var$Tree();
        for (let node of this.traverse())newTree.addTreeNode(node.scopeRef, node.parent.scopeRef, node.nodeToRestore);
        return newTree;
    }
    constructor(){
        this.fastMap = new Map();
        this.root = new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: null
        });
        this.fastMap.set(null, this.root);
    }
}
class $a7a032acae3ddda9$var$TreeNode {
    addChild(node) {
        this.children.add(node);
        node.parent = this;
    }
    removeChild(node) {
        this.children.delete(node);
        node.parent = undefined;
    }
    constructor(props){
        this.children = new Set();
        this.contain = false;
        this.scopeRef = props.scopeRef;
    }
}
let $a7a032acae3ddda9$export$d06fae2ee68b101e = new $a7a032acae3ddda9$var$Tree();


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 




function $581a96d6eb128c1b$export$4e328f61c538687f(props = {}) {
    let { autoFocus: autoFocus = false , isTextInput: isTextInput , within: within  } = props;
    let state = (0, $aB6Cp$react.useRef)({
        isFocused: false,
        isFocusVisible: autoFocus || (0, $aB6Cp$reactariainteractions.isFocusVisible)()
    });
    let [isFocused, setFocused] = (0, $aB6Cp$react.useState)(false);
    let [isFocusVisibleState, setFocusVisible] = (0, $aB6Cp$react.useState)(()=>state.current.isFocused && state.current.isFocusVisible);
    let updateState = (0, $aB6Cp$react.useCallback)(()=>setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
    let onFocusChange = (0, $aB6Cp$react.useCallback)((isFocused)=>{
        state.current.isFocused = isFocused;
        setFocused(isFocused);
        updateState();
    }, [
        updateState
    ]);
    (0, $aB6Cp$reactariainteractions.useFocusVisibleListener)((isFocusVisible)=>{
        state.current.isFocusVisible = isFocusVisible;
        updateState();
    }, [], {
        isTextInput: isTextInput
    });
    let { focusProps: focusProps  } = (0, $aB6Cp$reactariainteractions.useFocus)({
        isDisabled: within,
        onFocusChange: onFocusChange
    });
    let { focusWithinProps: focusWithinProps  } = (0, $aB6Cp$reactariainteractions.useFocusWithin)({
        isDisabled: !within,
        onFocusWithinChange: onFocusChange
    });
    return {
        isFocused: isFocused,
        isFocusVisible: isFocusVisibleState,
        focusProps: within ? focusWithinProps : focusProps
    };
}


function $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d(props) {
    let { children: children , focusClass: focusClass , focusRingClass: focusRingClass  } = props;
    let { isFocused: isFocused , isFocusVisible: isFocusVisible , focusProps: focusProps  } = (0, $581a96d6eb128c1b$export$4e328f61c538687f)(props);
    let child = (0, ($parcel$interopDefault($aB6Cp$react))).Children.only(children);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).cloneElement(child, (0, $aB6Cp$reactariautils.mergeProps)(child.props, {
        ...focusProps,
        className: (0, ($parcel$interopDefault($aB6Cp$clsx)))({
            [focusClass || ""]: isFocused,
            [focusRingClass || ""]: isFocusVisible
        })
    }));
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



let $fb504d83237fd6ac$var$FocusableContext = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createContext(null);
function $fb504d83237fd6ac$var$useFocusableContext(ref) {
    let context = (0, $aB6Cp$react.useContext)($fb504d83237fd6ac$var$FocusableContext) || {};
    (0, $aB6Cp$reactariautils.useSyncRef)(context, ref);
    // eslint-disable-next-line
    let { ref: _ , ...otherProps } = context;
    return otherProps;
}
/**
 * Provides DOM props to the nearest focusable child.
 */ function $fb504d83237fd6ac$var$FocusableProvider(props, ref) {
    let { children: children , ...otherProps } = props;
    let context = {
        ...otherProps,
        ref: ref
    };
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement($fb504d83237fd6ac$var$FocusableContext.Provider, {
        value: context
    }, children);
}
let $fb504d83237fd6ac$export$13f3202a3e5ddd5 = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).forwardRef($fb504d83237fd6ac$var$FocusableProvider);
function $fb504d83237fd6ac$export$4c014de7c8940b4c(props, domRef) {
    let { focusProps: focusProps  } = (0, $aB6Cp$reactariainteractions.useFocus)(props);
    let { keyboardProps: keyboardProps  } = (0, $aB6Cp$reactariainteractions.useKeyboard)(props);
    let interactions = (0, $aB6Cp$reactariautils.mergeProps)(focusProps, keyboardProps);
    let domProps = $fb504d83237fd6ac$var$useFocusableContext(domRef);
    let interactionProps = props.isDisabled ? {} : domProps;
    let autoFocusRef = (0, $aB6Cp$react.useRef)(props.autoFocus);
    (0, $aB6Cp$react.useEffect)(()=>{
        if (autoFocusRef.current && domRef.current) (0, $1c7f9157d722357d$export$80f3e147d781571c)(domRef.current);
        autoFocusRef.current = false;
    }, [
        domRef
    ]);
    return {
        focusableProps: (0, $aB6Cp$reactariautils.mergeProps)({
            ...interactions,
            tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined
        }, interactionProps)
    };
}




/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $259c6413a286f2e6$export$eac1895992b9f3d6(ref, options) {
    let isDisabled = options === null || options === void 0 ? void 0 : options.isDisabled;
    let [hasTabbableChild, setHasTabbableChild] = (0, $aB6Cp$react.useState)(false);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if ((ref === null || ref === void 0 ? void 0 : ref.current) && !isDisabled) {
            let update = ()=>{
                if (ref.current) {
                    let walker = (0, $a7a032acae3ddda9$export$2d6ec8fc375ceafa)(ref.current, {
                        tabbable: true
                    });
                    setHasTabbableChild(!!walker.nextNode());
                }
            };
            update();
            // Update when new elements are inserted, or the tabIndex/disabled attribute updates.
            let observer = new MutationObserver(update);
            observer.observe(ref.current, {
                subtree: true,
                childList: true,
                attributes: true,
                attributeFilter: [
                    "tabIndex",
                    "disabled"
                ]
            });
            return ()=>{
                // Disconnect mutation observer when a React update occurs on the top-level component
                // so we update synchronously after re-rendering. Otherwise React will emit act warnings
                // in tests since mutation observers fire asynchronously. The mutation observer is necessary
                // so we also update if a child component re-renders and adds/removes something tabbable.
                observer.disconnect();
            };
        }
    });
    return isDisabled ? false : hasTabbableChild;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 71867:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $goTMa$reactariautils = __webpack_require__(40246);
var $goTMa$react = __webpack_require__(18038);
var $goTMa$reactariassr = __webpack_require__(79933);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "Pressable", () => $e1dbec26039c051d$export$27c701ed9e449e99);
$parcel$export(module.exports, "PressResponder", () => $3596bae48579386f$export$3351871ee4b288b8);
$parcel$export(module.exports, "useFocus", () => $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6);
$parcel$export(module.exports, "isFocusVisible", () => $e77252a287ef94ab$export$b9b3dfddab17db27);
$parcel$export(module.exports, "getInteractionModality", () => $e77252a287ef94ab$export$630ff653c5ada6a9);
$parcel$export(module.exports, "setInteractionModality", () => $e77252a287ef94ab$export$8397ddfc504fdb9a);
$parcel$export(module.exports, "useInteractionModality", () => $e77252a287ef94ab$export$98e20ec92f614cfe);
$parcel$export(module.exports, "useFocusVisible", () => $e77252a287ef94ab$export$ffd9e5021c1fb2d6);
$parcel$export(module.exports, "useFocusVisibleListener", () => $e77252a287ef94ab$export$ec71b4b83ac08ec3);
$parcel$export(module.exports, "useFocusWithin", () => $d16842bbd0359d1b$export$420e68273165f4ec);
$parcel$export(module.exports, "useHover", () => $ffbc150311c75f01$export$ae780daf29e6d456);
$parcel$export(module.exports, "useInteractOutside", () => $edcfa848c42f94f4$export$872b660ac5a1ff98);
$parcel$export(module.exports, "useKeyboard", () => $892d64db2a3c53b0$export$8f71654801c2f7cd);
$parcel$export(module.exports, "useMove", () => $c09386fc48fa427d$export$36da96379f79f245);
$parcel$export(module.exports, "usePress", () => $0294ea432cd92340$export$45712eceda6fad21);
$parcel$export(module.exports, "useScrollWheel", () => $a3dbce0aed7087e2$export$2123ff2b87c81ca);
$parcel$export(module.exports, "useLongPress", () => $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element
// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually
let $f7e14e656343df57$var$state = "default";
let $f7e14e656343df57$var$savedUserSelect = "";
let $f7e14e656343df57$var$modifiedElementMap = new WeakMap();
function $f7e14e656343df57$export$16a4697467175487(target) {
    if ((0, $goTMa$reactariautils.isIOS)()) {
        if ($f7e14e656343df57$var$state === "default") {
            $f7e14e656343df57$var$savedUserSelect = document.documentElement.style.webkitUserSelect;
            document.documentElement.style.webkitUserSelect = "none";
        }
        $f7e14e656343df57$var$state = "disabled";
    } else if (target instanceof HTMLElement || target instanceof SVGElement) {
        // If not iOS, store the target's original user-select and change to user-select: none
        // Ignore state since it doesn't apply for non iOS
        $f7e14e656343df57$var$modifiedElementMap.set(target, target.style.userSelect);
        target.style.userSelect = "none";
    }
}
function $f7e14e656343df57$export$b0d6fa1ab32e3295(target) {
    if ((0, $goTMa$reactariautils.isIOS)()) {
        // If the state is already default, there's nothing to do.
        // If it is restoring, then there's no need to queue a second restore.
        if ($f7e14e656343df57$var$state !== "disabled") return;
        $f7e14e656343df57$var$state = "restoring";
        // There appears to be a delay on iOS where selection still might occur
        // after pointer up, so wait a bit before removing user-select.
        setTimeout(()=>{
            // Wait for any CSS transitions to complete so we don't recompute style
            // for the whole page in the middle of the animation and cause jank.
            (0, $goTMa$reactariautils.runAfterTransition)(()=>{
                // Avoid race conditions
                if ($f7e14e656343df57$var$state === "restoring") {
                    if (document.documentElement.style.webkitUserSelect === "none") document.documentElement.style.webkitUserSelect = $f7e14e656343df57$var$savedUserSelect || "";
                    $f7e14e656343df57$var$savedUserSelect = "";
                    $f7e14e656343df57$var$state = "default";
                }
            });
        }, 300);
    } else if (target instanceof HTMLElement || target instanceof SVGElement) // If not iOS, restore the target's original user-select if any
    // Ignore state since it doesn't apply for non iOS
    {
        if (target && $f7e14e656343df57$var$modifiedElementMap.has(target)) {
            let targetOldUserSelect = $f7e14e656343df57$var$modifiedElementMap.get(target);
            if (target.style.userSelect === "none") target.style.userSelect = targetOldUserSelect;
            if (target.getAttribute("style") === "") target.removeAttribute("style");
            $f7e14e656343df57$var$modifiedElementMap.delete(target);
        }
    }
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $01d3f539e91688c8$export$5165eccb35aaadb5 = (0, ($parcel$interopDefault($goTMa$react))).createContext(null);
$01d3f539e91688c8$export$5165eccb35aaadb5.displayName = "PressResponderContext";



function $0294ea432cd92340$var$usePressResponderContext(props) {
    // Consume context from <PressResponder> and merge with props.
    let context = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));
    if (context) {
        let { register: register , ...contextProps } = context;
        props = (0, $goTMa$reactariautils.mergeProps)(contextProps, props);
        register();
    }
    (0, $goTMa$reactariautils.useSyncRef)(context, props.ref);
    return props;
}
function $0294ea432cd92340$export$45712eceda6fad21(props) {
    let { onPress: onPress , onPressChange: onPressChange , onPressStart: onPressStart , onPressEnd: onPressEnd , onPressUp: onPressUp , isDisabled: isDisabled , isPressed: isPressedProp , preventFocusOnPress: preventFocusOnPress , shouldCancelOnPointerExit: shouldCancelOnPointerExit , allowTextSelectionOnPress: allowTextSelectionOnPress , // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: _ , ...domProps } = $0294ea432cd92340$var$usePressResponderContext(props);
    let [isPressed, setPressed] = (0, $goTMa$react.useState)(false);
    let ref = (0, $goTMa$react.useRef)({
        isPressed: false,
        ignoreEmulatedMouseEvents: false,
        ignoreClickAfterPress: false,
        didFirePressStart: false,
        activePointerId: null,
        target: null,
        isOverTarget: false,
        pointerType: null
    });
    let { addGlobalListener: addGlobalListener , removeAllGlobalListeners: removeAllGlobalListeners  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let triggerPressStart = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        let state = ref.current;
        if (isDisabled || state.didFirePressStart) return;
        if (onPressStart) onPressStart({
            type: "pressstart",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
        if (onPressChange) onPressChange(true);
        state.didFirePressStart = true;
        setPressed(true);
    });
    let triggerPressEnd = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType, wasPressed = true)=>{
        let state = ref.current;
        if (!state.didFirePressStart) return;
        state.ignoreClickAfterPress = true;
        state.didFirePressStart = false;
        if (onPressEnd) onPressEnd({
            type: "pressend",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
        if (onPressChange) onPressChange(false);
        setPressed(false);
        if (onPress && wasPressed && !isDisabled) onPress({
            type: "press",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let triggerPressUp = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        if (isDisabled) return;
        if (onPressUp) onPressUp({
            type: "pressup",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let cancel = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        let state = ref.current;
        if (state.isPressed) {
            if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
            state.isPressed = false;
            state.isOverTarget = false;
            state.activePointerId = null;
            state.pointerType = null;
            removeAllGlobalListeners();
            if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
        }
    });
    let cancelOnPointerExit = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (shouldCancelOnPointerExit) cancel(e);
    });
    let pressProps = (0, $goTMa$react.useMemo)(()=>{
        let state = ref.current;
        let pressProps = {
            onKeyDown (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {
                    if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                    e.stopPropagation();
                    // If the event is repeating, it may have started on a different element
                    // after which focus moved to the current element. Ignore these events and
                    // only handle the first key down event.
                    if (!state.isPressed && !e.repeat) {
                        state.target = e.currentTarget;
                        state.isPressed = true;
                        triggerPressStart(e, "keyboard");
                        // Focus may move before the key up event, so register the event on the document
                        // instead of the same element where the key down event occurred.
                        addGlobalListener(document, "keyup", onKeyUp, false);
                    }
                } else if (e.key === "Enter" && $0294ea432cd92340$var$isHTMLAnchorLink(e.currentTarget)) // If the target is a link, we won't have handled this above because we want the default
                // browser behavior to open the link when pressing Enter. But we still need to prevent
                // default so that elements above do not also handle it (e.g. table row).
                e.stopPropagation();
            },
            onKeyUp (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target)) triggerPressUp($0294ea432cd92340$var$createEvent(state.target, e), "keyboard");
            },
            onClick (e) {
                if (e && !e.currentTarget.contains(e.target)) return;
                if (e && e.button === 0) {
                    e.stopPropagation();
                    if (isDisabled) e.preventDefault();
                    // If triggered from a screen reader or by using element.click(),
                    // trigger as if it were a keyboard click.
                    if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && (state.pointerType === "virtual" || (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent))) {
                        // Ensure the element receives focus (VoiceOver on iOS does not do this)
                        if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                        triggerPressStart(e, "virtual");
                        triggerPressUp(e, "virtual");
                        triggerPressEnd(e, "virtual");
                    }
                    state.ignoreEmulatedMouseEvents = false;
                    state.ignoreClickAfterPress = false;
                }
            }
        };
        let onKeyUp = (e)=>{
            if (state.isPressed && $0294ea432cd92340$var$isValidKeyboardEvent(e, state.target)) {
                if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                e.stopPropagation();
                state.isPressed = false;
                let target = e.target;
                triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), "keyboard", state.target.contains(target));
                removeAllGlobalListeners();
                // If the target is a link, trigger the click method to open the URL,
                // but defer triggering pressEnd until onClick event handler.
                if (state.target instanceof HTMLElement && state.target.contains(target) && ($0294ea432cd92340$var$isHTMLAnchorLink(state.target) || state.target.getAttribute("role") === "link")) state.target.click();
            }
        };
        if (typeof PointerEvent !== "undefined") {
            pressProps.onPointerDown = (e)=>{
                // Only handle left clicks, and ignore events that bubbled through portals.
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.
                // Ignore and let the onClick handler take care of it instead.
                // https://bugs.webkit.org/show_bug.cgi?id=222627
                // https://bugs.webkit.org/show_bug.cgi?id=223202
                if ((0, $goTMa$reactariautils.isVirtualPointerEvent)(e.nativeEvent)) {
                    state.pointerType = "virtual";
                    return;
                }
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on pointer down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                state.pointerType = e.pointerType;
                e.stopPropagation();
                if (!state.isPressed) {
                    state.isPressed = true;
                    state.isOverTarget = true;
                    state.activePointerId = e.pointerId;
                    state.target = e.currentTarget;
                    if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                    if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);
                    triggerPressStart(e, state.pointerType);
                    addGlobalListener(document, "pointermove", onPointerMove, false);
                    addGlobalListener(document, "pointerup", onPointerUp, false);
                    addGlobalListener(document, "pointercancel", onPointerCancel, false);
                }
            };
            pressProps.onMouseDown = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (e.button === 0) {
                    // Chrome and Firefox on touch Windows devices require mouse down events
                    // to be canceled in addition to pointer events, or an extra asynchronous
                    // focus event will be fired.
                    if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                    e.stopPropagation();
                }
            };
            pressProps.onPointerUp = (e)=>{
                // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.
                if (!e.currentTarget.contains(e.target) || state.pointerType === "virtual") return;
                // Only handle left clicks
                // Safari on iOS sometimes fires pointerup events, even
                // when the touch isn't over the target, so double check.
                if (e.button === 0 && $0294ea432cd92340$var$isOverTarget(e, e.currentTarget)) triggerPressUp(e, state.pointerType || e.pointerType);
            };
            // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.
            // Use pointer move events instead to implement our own hit testing.
            // See https://bugs.webkit.org/show_bug.cgi?id=199803
            let onPointerMove = (e)=>{
                if (e.pointerId !== state.activePointerId) return;
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0) {
                    if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    state.isPressed = false;
                    state.isOverTarget = false;
                    state.activePointerId = null;
                    state.pointerType = null;
                    removeAllGlobalListeners();
                    if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
                }
            };
            let onPointerCancel = (e)=>{
                cancel(e);
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.
                cancel(e);
            };
        } else {
            pressProps.onMouseDown = (e)=>{
                // Only handle left clicks
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on mouse down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                e.stopPropagation();
                if (state.ignoreEmulatedMouseEvents) return;
                state.isPressed = true;
                state.isOverTarget = true;
                state.target = e.currentTarget;
                state.pointerType = (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent) ? "virtual" : "mouse";
                if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(document, "mouseup", onMouseUp, false);
            };
            pressProps.onMouseEnter = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = true;
                    triggerPressStart(e, state.pointerType);
                }
            };
            pressProps.onMouseLeave = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            pressProps.onMouseUp = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType);
            };
            let onMouseUp = (e)=>{
                // Only handle left clicks
                if (e.button !== 0) return;
                state.isPressed = false;
                removeAllGlobalListeners();
                if (state.ignoreEmulatedMouseEvents) {
                    state.ignoreEmulatedMouseEvents = false;
                    return;
                }
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                state.isOverTarget = false;
            };
            pressProps.onTouchStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                let touch = $0294ea432cd92340$var$getTouchFromEvent(e.nativeEvent);
                if (!touch) return;
                state.activePointerId = touch.identifier;
                state.ignoreEmulatedMouseEvents = true;
                state.isOverTarget = true;
                state.isPressed = true;
                state.target = e.currentTarget;
                state.pointerType = "touch";
                // Due to browser inconsistencies, especially on mobile browsers, we prevent default
                // on the emulated mouse event and handle focusing the pressable element ourselves.
                if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(window, "scroll", onScroll, true);
            };
            pressProps.onTouchMove = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart(e, state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            pressProps.onTouchEnd = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    triggerPressUp(e, state.pointerType);
                    triggerPressEnd(e, state.pointerType);
                } else if (state.isOverTarget) triggerPressEnd(e, state.pointerType, false);
                state.isPressed = false;
                state.activePointerId = null;
                state.isOverTarget = false;
                state.ignoreEmulatedMouseEvents = true;
                if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
                removeAllGlobalListeners();
            };
            pressProps.onTouchCancel = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed) cancel(e);
            };
            let onScroll = (e)=>{
                if (state.isPressed && e.target.contains(state.target)) cancel({
                    currentTarget: state.target,
                    shiftKey: false,
                    ctrlKey: false,
                    metaKey: false,
                    altKey: false
                });
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                cancel(e);
            };
        }
        return pressProps;
    }, [
        addGlobalListener,
        isDisabled,
        preventFocusOnPress,
        removeAllGlobalListeners,
        allowTextSelectionOnPress,
        cancel,
        cancelOnPointerExit,
        triggerPressEnd,
        triggerPressStart,
        triggerPressUp
    ]);
    // Remove user-select: none in case component unmounts immediately after pressStart
    // eslint-disable-next-line arrow-body-style
    (0, $goTMa$react.useEffect)(()=>{
        return ()=>{
            if (!allowTextSelectionOnPress) // eslint-disable-next-line react-hooks/exhaustive-deps
            (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(ref.current.target);
        };
    }, [
        allowTextSelectionOnPress
    ]);
    return {
        isPressed: isPressedProp || isPressed,
        pressProps: (0, $goTMa$reactariautils.mergeProps)(domProps, pressProps)
    };
}
function $0294ea432cd92340$var$isHTMLAnchorLink(target) {
    return target.tagName === "A" && target.hasAttribute("href");
}
function $0294ea432cd92340$var$isValidKeyboardEvent(event, currentTarget) {
    const { key: key , code: code  } = event;
    const element = currentTarget;
    const role = element.getAttribute("role");
    // Accessibility for keyboards. Space and Enter only.
    // "Spacebar" is for IE 11
    return (key === "Enter" || key === " " || key === "Spacebar" || code === "Space") && !(element instanceof HTMLInputElement && !$0294ea432cd92340$var$isValidInputKey(element, key) || element instanceof HTMLTextAreaElement || element.isContentEditable) && // A link with a valid href should be handled natively,
    // unless it also has role='button' and was triggered using Space.
    (!$0294ea432cd92340$var$isHTMLAnchorLink(element) || role === "button" && key !== "Enter") && // An element with role='link' should only trigger with Enter key
    !(role === "link" && key !== "Enter");
}
function $0294ea432cd92340$var$getTouchFromEvent(event) {
    const { targetTouches: targetTouches  } = event;
    if (targetTouches.length > 0) return targetTouches[0];
    return null;
}
function $0294ea432cd92340$var$getTouchById(event, pointerId) {
    const changedTouches = event.changedTouches;
    for(let i = 0; i < changedTouches.length; i++){
        const touch = changedTouches[i];
        if (touch.identifier === pointerId) return touch;
    }
    return null;
}
function $0294ea432cd92340$var$createEvent(target, e) {
    return {
        currentTarget: target,
        shiftKey: e.shiftKey,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey
    };
}
function $0294ea432cd92340$var$getPointClientRect(point) {
    let offsetX = point.width / 2 || point.radiusX || 0;
    let offsetY = point.height / 2 || point.radiusY || 0;
    return {
        top: point.clientY - offsetY,
        right: point.clientX + offsetX,
        bottom: point.clientY + offsetY,
        left: point.clientX - offsetX
    };
}
function $0294ea432cd92340$var$areRectanglesOverlapping(a, b) {
    // check if they cannot overlap on x axis
    if (a.left > b.right || b.left > a.right) return false;
    // check if they cannot overlap on y axis
    if (a.top > b.bottom || b.top > a.bottom) return false;
    return true;
}
function $0294ea432cd92340$var$isOverTarget(point, target) {
    let rect = target.getBoundingClientRect();
    let pointRect = $0294ea432cd92340$var$getPointClientRect(point);
    return $0294ea432cd92340$var$areRectanglesOverlapping(rect, pointRect);
}
function $0294ea432cd92340$var$shouldPreventDefault(target) {
    // We cannot prevent default if the target is a draggable element.
    return !(target instanceof HTMLElement) || !target.draggable;
}
function $0294ea432cd92340$var$shouldPreventDefaultKeyboard(target, key) {
    if (target instanceof HTMLInputElement) return !$0294ea432cd92340$var$isValidInputKey(target, key);
    if (target instanceof HTMLButtonElement) return target.type !== "submit";
    return true;
}
const $0294ea432cd92340$var$nonTextInputTypes = new Set([
    "checkbox",
    "radio",
    "range",
    "color",
    "file",
    "image",
    "button",
    "submit",
    "reset"
]);
function $0294ea432cd92340$var$isValidInputKey(target, key) {
    // Only space should toggle checkboxes and radios, not enter.
    return target.type === "checkbox" || target.type === "radio" ? key === " " : $0294ea432cd92340$var$nonTextInputTypes.has(target.type);
}



const $e1dbec26039c051d$export$27c701ed9e449e99 = /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).forwardRef(({ children: children , ...props }, ref)=>{
    let newRef = (0, $goTMa$react.useRef)();
    ref = ref !== null && ref !== void 0 ? ref : newRef;
    let { pressProps: pressProps  } = (0, $0294ea432cd92340$export$45712eceda6fad21)({
        ...props,
        ref: ref
    });
    let child = (0, ($parcel$interopDefault($goTMa$react))).Children.only(children);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).cloneElement(child, // @ts-ignore
    {
        ref: ref,
        ...(0, $goTMa$reactariautils.mergeProps)(child.props, pressProps)
    });
});


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $3596bae48579386f$export$3351871ee4b288b8 = /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).forwardRef(({ children: children , ...props }, ref)=>{
    let isRegistered = (0, $goTMa$react.useRef)(false);
    let prevContext = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));
    let context = (0, $goTMa$reactariautils.mergeProps)(prevContext || {}, {
        ...props,
        ref: ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref),
        register () {
            isRegistered.current = true;
            if (prevContext) prevContext.register();
        }
    });
    (0, $goTMa$reactariautils.useSyncRef)(prevContext, ref);
    (0, $goTMa$react.useEffect)(()=>{
        if (!isRegistered.current) {
            console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.");
            isRegistered.current = true; // only warn once in strict mode.
        }
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).createElement((0, $01d3f539e91688c8$export$5165eccb35aaadb5).Provider, {
        value: context
    }, children);
});


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

class $625cf83917e112ad$export$905e7fc544a71f36 {
    isDefaultPrevented() {
        return this.nativeEvent.defaultPrevented;
    }
    preventDefault() {
        this.defaultPrevented = true;
        this.nativeEvent.preventDefault();
    }
    stopPropagation() {
        this.nativeEvent.stopPropagation();
        this.isPropagationStopped = ()=>true;
    }
    isPropagationStopped() {
        return false;
    }
    persist() {}
    constructor(type, nativeEvent){
        this.nativeEvent = nativeEvent;
        this.target = nativeEvent.target;
        this.currentTarget = nativeEvent.currentTarget;
        this.relatedTarget = nativeEvent.relatedTarget;
        this.bubbles = nativeEvent.bubbles;
        this.cancelable = nativeEvent.cancelable;
        this.defaultPrevented = nativeEvent.defaultPrevented;
        this.eventPhase = nativeEvent.eventPhase;
        this.isTrusted = nativeEvent.isTrusted;
        this.timeStamp = nativeEvent.timeStamp;
        this.type = type;
    }
}
function $625cf83917e112ad$export$715c682d09d639cc(onBlur) {
    let stateRef = (0, $goTMa$react.useRef)({
        isFocused: false,
        observer: null
    });
    // Clean up MutationObserver on unmount. See below.
    // eslint-disable-next-line arrow-body-style
    (0, $goTMa$reactariautils.useLayoutEffect)(()=>{
        const state = stateRef.current;
        return ()=>{
            if (state.observer) {
                state.observer.disconnect();
                state.observer = null;
            }
        };
    }, []);
    let dispatchBlur = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
    });
    // This function is called during a React onFocus event.
    return (0, $goTMa$react.useCallback)((e)=>{
        // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142
        // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a
        // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.
        // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.
        if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {
            stateRef.current.isFocused = true;
            let target = e.target;
            let onBlurHandler = (e)=>{
                stateRef.current.isFocused = false;
                if (target.disabled) // For backward compatibility, dispatch a (fake) React synthetic event.
                dispatchBlur(new $625cf83917e112ad$export$905e7fc544a71f36("blur", e));
                // We no longer need the MutationObserver once the target is blurred.
                if (stateRef.current.observer) {
                    stateRef.current.observer.disconnect();
                    stateRef.current.observer = null;
                }
            };
            target.addEventListener("focusout", onBlurHandler, {
                once: true
            });
            stateRef.current.observer = new MutationObserver(()=>{
                if (stateRef.current.isFocused && target.disabled) {
                    stateRef.current.observer.disconnect();
                    let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
                    target.dispatchEvent(new FocusEvent("blur", {
                        relatedTarget: relatedTargetEl
                    }));
                    target.dispatchEvent(new FocusEvent("focusout", {
                        bubbles: true,
                        relatedTarget: relatedTargetEl
                    }));
                }
            });
            stateRef.current.observer.observe(target, {
                attributes: true,
                attributeFilter: [
                    "disabled"
                ]
            });
        }
    }, [
        dispatchBlur
    ]);
}


function $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6(props) {
    let { isDisabled: isDisabled , onFocus: onFocusProp , onBlur: onBlurProp , onFocusChange: onFocusChange  } = props;
    const onBlur = (0, $goTMa$react.useCallback)((e)=>{
        if (e.target === e.currentTarget) {
            if (onBlurProp) onBlurProp(e);
            if (onFocusChange) onFocusChange(false);
            return true;
        }
    }, [
        onBlurProp,
        onFocusChange
    ]);
    const onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);
    const onFocus = (0, $goTMa$react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (e.target === e.currentTarget && document.activeElement === e.target) {
            if (onFocusProp) onFocusProp(e);
            if (onFocusChange) onFocusChange(true);
            onSyntheticFocus(e);
        }
    }, [
        onFocusChange,
        onFocusProp,
        onSyntheticFocus
    ]);
    return {
        focusProps: {
            onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,
            onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : undefined
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions



let $e77252a287ef94ab$var$currentModality = null;
let $e77252a287ef94ab$var$changeHandlers = new Set();
let $e77252a287ef94ab$var$hasSetupGlobalListeners = false;
let $e77252a287ef94ab$var$hasEventBeforeFocus = false;
let $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
// Only Tab or Esc keys will make focus visible on text input elements
const $e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS = {
    Tab: true,
    Escape: true
};
function $e77252a287ef94ab$var$triggerChangeHandlers(modality, e) {
    for (let handler of $e77252a287ef94ab$var$changeHandlers)handler(modality, e);
}
/**
 * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.
 */ function $e77252a287ef94ab$var$isValidKey(e) {
    // Control and Shift keys trigger when navigating back to the tab with keyboard.
    return !(e.metaKey || !(0, $goTMa$reactariautils.isMac)() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
function $e77252a287ef94ab$var$handleKeyboardEvent(e) {
    $e77252a287ef94ab$var$hasEventBeforeFocus = true;
    if ($e77252a287ef94ab$var$isValidKey(e)) {
        $e77252a287ef94ab$var$currentModality = "keyboard";
        $e77252a287ef94ab$var$triggerChangeHandlers("keyboard", e);
    }
}
function $e77252a287ef94ab$var$handlePointerEvent(e) {
    $e77252a287ef94ab$var$currentModality = "pointer";
    if (e.type === "mousedown" || e.type === "pointerdown") {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$triggerChangeHandlers("pointer", e);
    }
}
function $e77252a287ef94ab$var$handleClickEvent(e) {
    if ((0, $goTMa$reactariautils.isVirtualClick)(e)) {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$currentModality = "virtual";
    }
}
function $e77252a287ef94ab$var$handleFocusEvent(e) {
    // Firefox fires two extra focus events when the user first clicks into an iframe:
    // first on the window, then on the document. We ignore these events so they don't
    // cause keyboard focus rings to appear.
    if (e.target === window || e.target === document) return;
    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.
    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.
    if (!$e77252a287ef94ab$var$hasEventBeforeFocus && !$e77252a287ef94ab$var$hasBlurredWindowRecently) {
        $e77252a287ef94ab$var$currentModality = "virtual";
        $e77252a287ef94ab$var$triggerChangeHandlers("virtual", e);
    }
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
}
function $e77252a287ef94ab$var$handleWindowBlur() {
    // When the window is blurred, reset state. This is necessary when tabbing out of the window,
    // for example, since a subsequent focus event won't be fired.
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = true;
}
/**
 * Setup global event listeners to control when keyboard focus style should be visible.
 */ function $e77252a287ef94ab$var$setupGlobalFocusEvents() {
    if (typeof window === "undefined" || $e77252a287ef94ab$var$hasSetupGlobalListeners) return;
    // Programmatic focus() calls shouldn't affect the current input modality.
    // However, we need to detect other cases when a focus event occurs without
    // a preceding user event (e.g. screen reader focus). Overriding the focus
    // method on HTMLElement.prototype is a bit hacky, but works.
    let focus = HTMLElement.prototype.focus;
    HTMLElement.prototype.focus = function() {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        focus.apply(this, arguments);
    };
    document.addEventListener("keydown", $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener("keyup", $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener("click", $e77252a287ef94ab$var$handleClickEvent, true);
    // Register focus events on the window so they are sure to happen
    // before React's event listeners (registered on the document).
    window.addEventListener("focus", $e77252a287ef94ab$var$handleFocusEvent, true);
    window.addEventListener("blur", $e77252a287ef94ab$var$handleWindowBlur, false);
    if (typeof PointerEvent !== "undefined") {
        document.addEventListener("pointerdown", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("pointermove", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("pointerup", $e77252a287ef94ab$var$handlePointerEvent, true);
    } else {
        document.addEventListener("mousedown", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("mousemove", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("mouseup", $e77252a287ef94ab$var$handlePointerEvent, true);
    }
    $e77252a287ef94ab$var$hasSetupGlobalListeners = true;
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e77252a287ef94ab$var$setupGlobalFocusEvents();
    else document.addEventListener("DOMContentLoaded", $e77252a287ef94ab$var$setupGlobalFocusEvents);
}
function $e77252a287ef94ab$export$b9b3dfddab17db27() {
    return $e77252a287ef94ab$var$currentModality !== "pointer";
}
function $e77252a287ef94ab$export$630ff653c5ada6a9() {
    return $e77252a287ef94ab$var$currentModality;
}
function $e77252a287ef94ab$export$8397ddfc504fdb9a(modality) {
    $e77252a287ef94ab$var$currentModality = modality;
    $e77252a287ef94ab$var$triggerChangeHandlers(modality, null);
}
function $e77252a287ef94ab$export$98e20ec92f614cfe() {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    let [modality, setModality] = (0, $goTMa$react.useState)($e77252a287ef94ab$var$currentModality);
    (0, $goTMa$react.useEffect)(()=>{
        let handler = ()=>{
            setModality($e77252a287ef94ab$var$currentModality);
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    }, []);
    return (0, $goTMa$reactariassr.useIsSSR)() ? null : modality;
}
/**
 * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that
 * focus visible style can be properly set.
 */ function $e77252a287ef94ab$var$isKeyboardFocusEvent(isTextInput, modality, e) {
    return !(isTextInput && modality === "keyboard" && e instanceof KeyboardEvent && !$e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);
}
function $e77252a287ef94ab$export$ffd9e5021c1fb2d6(props = {}) {
    let { isTextInput: isTextInput , autoFocus: autoFocus  } = props;
    let [isFocusVisibleState, setFocusVisible] = (0, $goTMa$react.useState)(autoFocus || $e77252a287ef94ab$export$b9b3dfddab17db27());
    $e77252a287ef94ab$export$ec71b4b83ac08ec3((isFocusVisible)=>{
        setFocusVisible(isFocusVisible);
    }, [
        isTextInput
    ], {
        isTextInput: isTextInput
    });
    return {
        isFocusVisible: isFocusVisibleState
    };
}
function $e77252a287ef94ab$export$ec71b4b83ac08ec3(fn, deps, opts) {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    (0, $goTMa$react.useEffect)(()=>{
        let handler = (modality, e)=>{
            if (!$e77252a287ef94ab$var$isKeyboardFocusEvent(opts === null || opts === void 0 ? void 0 : opts.isTextInput, modality, e)) return;
            fn($e77252a287ef94ab$export$b9b3dfddab17db27());
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, deps);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $d16842bbd0359d1b$export$420e68273165f4ec(props) {
    let { isDisabled: isDisabled , onBlurWithin: onBlurWithin , onFocusWithin: onFocusWithin , onFocusWithinChange: onFocusWithinChange  } = props;
    let state = (0, $goTMa$react.useRef)({
        isFocusWithin: false
    });
    let onBlur = (0, $goTMa$react.useCallback)((e)=>{
        // We don't want to trigger onBlurWithin and then immediately onFocusWithin again
        // when moving focus inside the element. Only trigger if the currentTarget doesn't
        // include the relatedTarget (where focus is moving).
        if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {
            state.current.isFocusWithin = false;
            if (onBlurWithin) onBlurWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(false);
        }
    }, [
        onBlurWithin,
        onFocusWithinChange,
        state
    ]);
    let onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);
    let onFocus = (0, $goTMa$react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (!state.current.isFocusWithin && document.activeElement === e.target) {
            if (onFocusWithin) onFocusWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(true);
            state.current.isFocusWithin = true;
            onSyntheticFocus(e);
        }
    }, [
        onFocusWithin,
        onFocusWithinChange,
        onSyntheticFocus
    ]);
    if (isDisabled) return {
        focusWithinProps: {
            onFocus: null,
            onBlur: null
        }
    };
    return {
        focusWithinProps: {
            onFocus: onFocus,
            onBlur: onBlur
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

// iOS fires onPointerEnter twice: once with pointerType="touch" and again with pointerType="mouse".
// We want to ignore these emulated events so they do not trigger hover behavior.
// See https://bugs.webkit.org/show_bug.cgi?id=214609.
let $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
let $ffbc150311c75f01$var$hoverCount = 0;
function $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents() {
    $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = true;
    // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter
    // with pointerType="mouse" immediately after onPointerUp and before onFocus. On other
    // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in
    // the distant future because a user previously touched the element.
    setTimeout(()=>{
        $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
    }, 50);
}
function $ffbc150311c75f01$var$handleGlobalPointerEvent(e) {
    if (e.pointerType === "touch") $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $ffbc150311c75f01$var$setupGlobalTouchEvents() {
    if (typeof document === "undefined") return;
    if (typeof PointerEvent !== "undefined") document.addEventListener("pointerup", $ffbc150311c75f01$var$handleGlobalPointerEvent);
    else document.addEventListener("touchend", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    $ffbc150311c75f01$var$hoverCount++;
    return ()=>{
        $ffbc150311c75f01$var$hoverCount--;
        if ($ffbc150311c75f01$var$hoverCount > 0) return;
        if (typeof PointerEvent !== "undefined") document.removeEventListener("pointerup", $ffbc150311c75f01$var$handleGlobalPointerEvent);
        else document.removeEventListener("touchend", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    };
}
function $ffbc150311c75f01$export$ae780daf29e6d456(props) {
    let { onHoverStart: onHoverStart , onHoverChange: onHoverChange , onHoverEnd: onHoverEnd , isDisabled: isDisabled  } = props;
    let [isHovered, setHovered] = (0, $goTMa$react.useState)(false);
    let state = (0, $goTMa$react.useRef)({
        isHovered: false,
        ignoreEmulatedMouseEvents: false,
        pointerType: "",
        target: null
    }).current;
    (0, $goTMa$react.useEffect)($ffbc150311c75f01$var$setupGlobalTouchEvents, []);
    let { hoverProps: hoverProps , triggerHoverEnd: triggerHoverEnd  } = (0, $goTMa$react.useMemo)(()=>{
        let triggerHoverStart = (event, pointerType)=>{
            state.pointerType = pointerType;
            if (isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target)) return;
            state.isHovered = true;
            let target = event.currentTarget;
            state.target = target;
            if (onHoverStart) onHoverStart({
                type: "hoverstart",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(true);
            setHovered(true);
        };
        let triggerHoverEnd = (event, pointerType)=>{
            state.pointerType = "";
            state.target = null;
            if (pointerType === "touch" || !state.isHovered) return;
            state.isHovered = false;
            let target = event.currentTarget;
            if (onHoverEnd) onHoverEnd({
                type: "hoverend",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(false);
            setHovered(false);
        };
        let hoverProps = {};
        if (typeof PointerEvent !== "undefined") {
            hoverProps.onPointerEnter = (e)=>{
                if ($ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents && e.pointerType === "mouse") return;
                triggerHoverStart(e, e.pointerType);
            };
            hoverProps.onPointerLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);
            };
        } else {
            hoverProps.onTouchStart = ()=>{
                state.ignoreEmulatedMouseEvents = true;
            };
            hoverProps.onMouseEnter = (e)=>{
                if (!state.ignoreEmulatedMouseEvents && !$ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, "mouse");
                state.ignoreEmulatedMouseEvents = false;
            };
            hoverProps.onMouseLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, "mouse");
            };
        }
        return {
            hoverProps: hoverProps,
            triggerHoverEnd: triggerHoverEnd
        };
    }, [
        onHoverStart,
        onHoverChange,
        onHoverEnd,
        isDisabled,
        state
    ]);
    (0, $goTMa$react.useEffect)(()=>{
        // Call the triggerHoverEnd as soon as isDisabled changes to true
        // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering
        if (isDisabled) triggerHoverEnd({
            currentTarget: state.target
        }, state.pointerType);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        isDisabled
    ]);
    return {
        hoverProps: hoverProps,
        isHovered: isHovered
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $edcfa848c42f94f4$export$872b660ac5a1ff98(props) {
    let { ref: ref , onInteractOutside: onInteractOutside , isDisabled: isDisabled , onInteractOutsideStart: onInteractOutsideStart  } = props;
    let stateRef = (0, $goTMa$react.useRef)({
        isPointerDown: false,
        ignoreEmulatedMouseEvents: false
    });
    let onPointerDown = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (onInteractOutside && $edcfa848c42f94f4$var$isValidEvent(e, ref)) {
            if (onInteractOutsideStart) onInteractOutsideStart(e);
            stateRef.current.isPointerDown = true;
        }
    });
    let triggerInteractOutside = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (onInteractOutside) onInteractOutside(e);
    });
    (0, $goTMa$react.useEffect)(()=>{
        let state = stateRef.current;
        if (isDisabled) return;
        // Use pointer events if available. Otherwise, fall back to mouse and touch events.
        if (typeof PointerEvent !== "undefined") {
            let onPointerUp = (e)=>{
                if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            // changing these to capture phase fixed combobox
            document.addEventListener("pointerdown", onPointerDown, true);
            document.addEventListener("pointerup", onPointerUp, true);
            return ()=>{
                document.removeEventListener("pointerdown", onPointerDown, true);
                document.removeEventListener("pointerup", onPointerUp, true);
            };
        } else {
            let onMouseUp = (e)=>{
                if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;
                else if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            let onTouchEnd = (e)=>{
                state.ignoreEmulatedMouseEvents = true;
                if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            document.addEventListener("mousedown", onPointerDown, true);
            document.addEventListener("mouseup", onMouseUp, true);
            document.addEventListener("touchstart", onPointerDown, true);
            document.addEventListener("touchend", onTouchEnd, true);
            return ()=>{
                document.removeEventListener("mousedown", onPointerDown, true);
                document.removeEventListener("mouseup", onMouseUp, true);
                document.removeEventListener("touchstart", onPointerDown, true);
                document.removeEventListener("touchend", onTouchEnd, true);
            };
        }
    }, [
        ref,
        isDisabled,
        onPointerDown,
        triggerInteractOutside
    ]);
}
function $edcfa848c42f94f4$var$isValidEvent(event, ref) {
    if (event.button > 0) return false;
    if (event.target) {
        // if the event target is no longer in the document, ignore
        const ownerDocument = event.target.ownerDocument;
        if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;
        // If the target is within a top layer element (e.g. toasts), ignore.
        if (event.target.closest("[data-react-aria-top-layer]")) return false;
    }
    return ref.current && !ref.current.contains(event.target);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $951fbcbbca8db6ce$export$48d1ea6320830260(handler) {
    if (!handler) return;
    let shouldStopPropagation = true;
    return (e)=>{
        let event = {
            ...e,
            preventDefault () {
                e.preventDefault();
            },
            isDefaultPrevented () {
                return e.isDefaultPrevented();
            },
            stopPropagation () {
                console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
            },
            continuePropagation () {
                shouldStopPropagation = false;
            }
        };
        handler(event);
        if (shouldStopPropagation) e.stopPropagation();
    };
}


function $892d64db2a3c53b0$export$8f71654801c2f7cd(props) {
    return {
        keyboardProps: props.isDisabled ? {} : {
            onKeyDown: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyDown),
            onKeyUp: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyUp)
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $c09386fc48fa427d$export$36da96379f79f245(props) {
    let { onMoveStart: onMoveStart , onMove: onMove , onMoveEnd: onMoveEnd  } = props;
    let state = (0, $goTMa$react.useRef)({
        didMove: false,
        lastPosition: null,
        id: null
    });
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let move = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType, deltaX, deltaY)=>{
        if (deltaX === 0 && deltaY === 0) return;
        if (!state.current.didMove) {
            state.current.didMove = true;
            onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart({
                type: "movestart",
                pointerType: pointerType,
                shiftKey: originalEvent.shiftKey,
                metaKey: originalEvent.metaKey,
                ctrlKey: originalEvent.ctrlKey,
                altKey: originalEvent.altKey
            });
        }
        onMove({
            type: "move",
            pointerType: pointerType,
            deltaX: deltaX,
            deltaY: deltaY,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let end = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)();
        if (state.current.didMove) onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd({
            type: "moveend",
            pointerType: pointerType,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let moveProps = (0, $goTMa$react.useMemo)(()=>{
        let moveProps = {};
        let start = ()=>{
            (0, $f7e14e656343df57$export$16a4697467175487)();
            state.current.didMove = false;
        };
        if (typeof PointerEvent === "undefined") {
            let onMouseMove = (e)=>{
                if (e.button === 0) {
                    move(e, "mouse", e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onMouseUp = (e)=>{
                if (e.button === 0) {
                    end(e, "mouse");
                    removeGlobalListener(window, "mousemove", onMouseMove, false);
                    removeGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            moveProps.onMouseDown = (e)=>{
                if (e.button === 0) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    addGlobalListener(window, "mousemove", onMouseMove, false);
                    addGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            let onTouchMove = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id);
                if (touch >= 0) {
                    let { pageX: pageX , pageY: pageY  } = e.changedTouches[touch];
                    move(e, "touch", pageX - state.current.lastPosition.pageX, pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: pageX,
                        pageY: pageY
                    };
                }
            };
            let onTouchEnd = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id);
                if (touch >= 0) {
                    end(e, "touch");
                    state.current.id = null;
                    removeGlobalListener(window, "touchmove", onTouchMove);
                    removeGlobalListener(window, "touchend", onTouchEnd);
                    removeGlobalListener(window, "touchcancel", onTouchEnd);
                }
            };
            moveProps.onTouchStart = (e)=>{
                if (e.changedTouches.length === 0 || state.current.id != null) return;
                let { pageX: pageX , pageY: pageY , identifier: identifier  } = e.changedTouches[0];
                start();
                e.stopPropagation();
                e.preventDefault();
                state.current.lastPosition = {
                    pageX: pageX,
                    pageY: pageY
                };
                state.current.id = identifier;
                addGlobalListener(window, "touchmove", onTouchMove, false);
                addGlobalListener(window, "touchend", onTouchEnd, false);
                addGlobalListener(window, "touchcancel", onTouchEnd, false);
            };
        } else {
            let onPointerMove = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    // Problems with PointerEvent#movementX/movementY:
                    // 1. it is always 0 on macOS Safari.
                    // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS
                    move(e, pointerType, e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    end(e, pointerType);
                    state.current.id = null;
                    removeGlobalListener(window, "pointermove", onPointerMove, false);
                    removeGlobalListener(window, "pointerup", onPointerUp, false);
                    removeGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
            moveProps.onPointerDown = (e)=>{
                if (e.button === 0 && state.current.id == null) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    state.current.id = e.pointerId;
                    addGlobalListener(window, "pointermove", onPointerMove, false);
                    addGlobalListener(window, "pointerup", onPointerUp, false);
                    addGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
        }
        let triggerKeyboardMove = (e, deltaX, deltaY)=>{
            start();
            move(e, "keyboard", deltaX, deltaY);
            end(e, "keyboard");
        };
        moveProps.onKeyDown = (e)=>{
            switch(e.key){
                case "Left":
                case "ArrowLeft":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, -1, 0);
                    break;
                case "Right":
                case "ArrowRight":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 1, 0);
                    break;
                case "Up":
                case "ArrowUp":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, -1);
                    break;
                case "Down":
                case "ArrowDown":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, 1);
                    break;
            }
        };
        return moveProps;
    }, [
        state,
        addGlobalListener,
        removeGlobalListener,
        move,
        end
    ]);
    return {
        moveProps: moveProps
    };
}



/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $a3dbce0aed7087e2$export$2123ff2b87c81ca(props, ref) {
    let { onScroll: onScroll , isDisabled: isDisabled  } = props;
    let onScrollHandler = (0, $goTMa$react.useCallback)((e)=>{
        // If the ctrlKey is pressed, this is a zoom event, do nothing.
        if (e.ctrlKey) return;
        // stop scrolling the page
        e.preventDefault();
        e.stopPropagation();
        if (onScroll) onScroll({
            deltaX: e.deltaX,
            deltaY: e.deltaY
        });
    }, [
        onScroll
    ]);
    (0, $goTMa$reactariautils.useEvent)(ref, "wheel", isDisabled ? null : onScrollHandler);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD = 500;
function $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9(props) {
    let { isDisabled: isDisabled , onLongPressStart: onLongPressStart , onLongPressEnd: onLongPressEnd , onLongPress: onLongPress , threshold: threshold = $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD , accessibilityDescription: accessibilityDescription  } = props;
    const timeRef = (0, $goTMa$react.useRef)(null);
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let { pressProps: pressProps  } = (0, $0294ea432cd92340$export$45712eceda6fad21)({
        isDisabled: isDisabled,
        onPressStart (e) {
            if (e.pointerType === "mouse" || e.pointerType === "touch") {
                if (onLongPressStart) onLongPressStart({
                    ...e,
                    type: "longpressstart"
                });
                timeRef.current = setTimeout(()=>{
                    // Prevent other usePress handlers from also handling this event.
                    e.target.dispatchEvent(new PointerEvent("pointercancel", {
                        bubbles: true
                    }));
                    if (onLongPress) onLongPress({
                        ...e,
                        type: "longpress"
                    });
                    timeRef.current = null;
                }, threshold);
                // Prevent context menu, which may be opened on long press on touch devices
                if (e.pointerType === "touch") {
                    let onContextMenu = (e)=>{
                        e.preventDefault();
                    };
                    addGlobalListener(e.target, "contextmenu", onContextMenu, {
                        once: true
                    });
                    addGlobalListener(window, "pointerup", ()=>{
                        // If no contextmenu event is fired quickly after pointerup, remove the handler
                        // so future context menu events outside a long press are not prevented.
                        setTimeout(()=>{
                            removeGlobalListener(e.target, "contextmenu", onContextMenu);
                        }, 30);
                    }, {
                        once: true
                    });
                }
            }
        },
        onPressEnd (e) {
            if (timeRef.current) clearTimeout(timeRef.current);
            if (onLongPressEnd && (e.pointerType === "mouse" || e.pointerType === "touch")) onLongPressEnd({
                ...e,
                type: "longpressend"
            });
        }
    });
    let descriptionProps = (0, $goTMa$reactariautils.useDescription)(onLongPress && !isDisabled ? accessibilityDescription : null);
    return {
        longPressProps: (0, $goTMa$reactariautils.mergeProps)(pressProps, descriptionProps)
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 79933:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $4hxXn$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "SSRProvider", () => $29383e587d62412a$export$9f8ac96af4b1b2ae);
$parcel$export(module.exports, "useSSRSafeId", () => $29383e587d62412a$export$619500959fc48b26);
$parcel$export(module.exports, "useIsSSR", () => $29383e587d62412a$export$535bd6ca7f90a273);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We must avoid a circular dependency with @react-aria/utils, and this useLayoutEffect is
// guarded by a check that it only runs on the client side.
// eslint-disable-next-line rulesdir/useLayoutEffectRule

// Default context value to use in case there is no SSRProvider. This is fine for
// client-only apps. In order to support multiple copies of React Aria potentially
// being on the page at once, the prefix is set to a random number. SSRProvider
// will reset this to zero for consistency between server and client, so in the
// SSR case multiple copies of React Aria is not supported.
const $29383e587d62412a$var$defaultContext = {
    prefix: String(Math.round(Math.random() * 10000000000)),
    current: 0,
    isSSR: false
};
const $29383e587d62412a$var$SSRContext = /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createContext($29383e587d62412a$var$defaultContext);
// This is only used in React < 18.
function $29383e587d62412a$var$LegacySSRProvider(props) {
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let counter = $29383e587d62412a$var$useCounter(cur === $29383e587d62412a$var$defaultContext);
    let [isSSR, setIsSSR] = (0, $4hxXn$react.useState)(true);
    let value = (0, $4hxXn$react.useMemo)(()=>({
            // If this is the first SSRProvider, start with an empty string prefix, otherwise
            // append and increment the counter.
            prefix: cur === $29383e587d62412a$var$defaultContext ? "" : `${cur.prefix}-${counter}`,
            current: 0,
            isSSR: isSSR
        }), [
        cur,
        counter,
        isSSR
    ]);
    // If on the client, and the component was initially server rendered,
    // then schedule a layout effect to update the component after hydration.
    if (typeof window !== "undefined") // This if statement technically breaks the rules of hooks, but is safe
    // because the condition never changes after mounting.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, $4hxXn$react.useLayoutEffect)(()=>{
        setIsSSR(false);
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$SSRContext.Provider, {
        value: value
    }, props.children);
}
let $29383e587d62412a$var$warnedAboutSSRProvider = false;
function $29383e587d62412a$export$9f8ac96af4b1b2ae(props) {
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function") {
        if (!$29383e587d62412a$var$warnedAboutSSRProvider) {
            console.warn("In React 18, SSRProvider is not necessary and is a noop. You can remove it from your app.");
            $29383e587d62412a$var$warnedAboutSSRProvider = true;
        }
        return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement((0, ($parcel$interopDefault($4hxXn$react))).Fragment, null, props.children);
    }
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$LegacySSRProvider, props);
}
let $29383e587d62412a$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
let $29383e587d62412a$var$componentIds = new WeakMap();
function $29383e587d62412a$var$useCounter(isDisabled = false) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let ref = (0, $4hxXn$react.useRef)(null);
    // eslint-disable-next-line rulesdir/pure-render
    if (ref.current === null && !isDisabled) {
        var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner;
        // In strict mode, React renders components twice, and the ref will be reset to null on the second render.
        // This means our id counter will be incremented twice instead of once. This is a problem because on the
        // server, components are only rendered once and so ids generated on the server won't match the client.
        // In React 18, useId was introduced to solve this, but it is not available in older versions. So to solve this
        // we need to use some React internals to access the underlying Fiber instance, which is stable between renders.
        // This is exposed as ReactCurrentOwner in development, which is all we need since StrictMode only runs in development.
        // To ensure that we only increment the global counter once, we store the starting id for this component in
        // a weak map associated with the Fiber. On the second render, we reset the global counter to this value.
        // Since React runs the second render immediately after the first, this is safe.
        // @ts-ignore
        let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, ($parcel$interopDefault($4hxXn$react))).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;
        if (currentOwner) {
            let prevComponentValue = $29383e587d62412a$var$componentIds.get(currentOwner);
            if (prevComponentValue == null) // On the first render, and first call to useId, store the id and state in our weak map.
            $29383e587d62412a$var$componentIds.set(currentOwner, {
                id: ctx.current,
                state: currentOwner.memoizedState
            });
            else if (currentOwner.memoizedState !== prevComponentValue.state) {
                // On the second render, the memoizedState gets reset by React.
                // Reset the counter, and remove from the weak map so we don't
                // do this for subsequent useId calls.
                ctx.current = prevComponentValue.id;
                $29383e587d62412a$var$componentIds.delete(currentOwner);
            }
        }
        // eslint-disable-next-line rulesdir/pure-render
        ref.current = ++ctx.current;
    }
    // eslint-disable-next-line rulesdir/pure-render
    return ref.current;
}
function $29383e587d62412a$var$useLegacySSRSafeId(defaultId) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    // If we are rendering in a non-DOM environment, and there's no SSRProvider,
    // provide a warning to hint to the developer to add one.
    if (ctx === $29383e587d62412a$var$defaultContext && !$29383e587d62412a$var$canUseDOM) console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
    let counter = $29383e587d62412a$var$useCounter(!!defaultId);
    return defaultId || `react-aria${ctx.prefix}-${counter}`;
}
function $29383e587d62412a$var$useModernSSRSafeId(defaultId) {
    // @ts-ignore
    let id = (0, ($parcel$interopDefault($4hxXn$react))).useId();
    let [didSSR] = (0, $4hxXn$react.useState)($29383e587d62412a$export$535bd6ca7f90a273());
    let prefix = didSSR ? "react-aria" : `react-aria${$29383e587d62412a$var$defaultContext.prefix}`;
    return defaultId || `${prefix}-${id}`;
}
const $29383e587d62412a$export$619500959fc48b26 = typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function" ? $29383e587d62412a$var$useModernSSRSafeId : $29383e587d62412a$var$useLegacySSRSafeId;
function $29383e587d62412a$var$getSnapshot() {
    return false;
}
function $29383e587d62412a$var$getServerSnapshot() {
    return true;
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function $29383e587d62412a$var$subscribe(onStoreChange) {
    // noop
    return ()=>{};
}
function $29383e587d62412a$export$535bd6ca7f90a273() {
    // In React 18, we can use useSyncExternalStore to detect if we're server rendering or hydrating.
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"] === "function") return (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"]($29383e587d62412a$var$subscribe, $29383e587d62412a$var$getSnapshot, $29383e587d62412a$var$getServerSnapshot);
    // eslint-disable-next-line react-hooks/rules-of-hooks
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    return cur.isSSR;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 40246:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $1Yh1N$reactstatelyutils = __webpack_require__(12259);
var $1Yh1N$react = __webpack_require__(18038);
var $1Yh1N$reactariassr = __webpack_require__(79933);
var $1Yh1N$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useId", () => $8c61827343eed941$export$f680877a34711e37);
$parcel$export(module.exports, "mergeIds", () => $8c61827343eed941$export$cd8c9cb68f842629);
$parcel$export(module.exports, "useSlotId", () => $8c61827343eed941$export$b4cc09c592e8fdb8);
$parcel$export(module.exports, "chain", () => $1e2191638e54f613$export$e08e3b67e392101e);
$parcel$export(module.exports, "mergeProps", () => $f847cd1382ea7cd4$export$9d1611c77c2fe928);
$parcel$export(module.exports, "mergeRefs", () => $f05dc24eafaeb7e2$export$c9058316764c140e);
$parcel$export(module.exports, "filterDOMProps", () => $8d15d0e1797d4238$export$457c3d6518dd4c6f);
$parcel$export(module.exports, "focusWithoutScrolling", () => $1117b6c0d4c4c164$export$de79e2c695e052f3);
$parcel$export(module.exports, "getOffset", () => $16ec41ef3e36c19c$export$622cea445a1c5b7d);
$parcel$export(module.exports, "runAfterTransition", () => $e8117ebcab55be6a$export$24490316f764c430);
$parcel$export(module.exports, "useDrag1D", () => $28ed3fb20343b78b$export$7bbed75feba39706);
$parcel$export(module.exports, "useGlobalListeners", () => $4571ff54ac709100$export$4eaf04e54aa8eed6);
$parcel$export(module.exports, "useLabels", () => $6ec78bde395c477d$export$d6875122194c7b44);
$parcel$export(module.exports, "useObjectRef", () => $475b35fe72ba49b3$export$4338b53315abf666);
$parcel$export(module.exports, "useUpdateEffect", () => $29293a6f5c75b37e$export$496315a1608d9602);
$parcel$export(module.exports, "useLayoutEffect", () => $78605a5d7424e31b$export$e5c5a5f917a5871c);
$parcel$export(module.exports, "useResizeObserver", () => $37733e1652f47193$export$683480f191c0e3ea);
$parcel$export(module.exports, "useSyncRef", () => $6fc733991a9f977c$export$4debdb1a3f0fa79e);
$parcel$export(module.exports, "getScrollParent", () => $d796e7157ac96470$export$cfa2225e87938781);
$parcel$export(module.exports, "isScrollable", () => $d796e7157ac96470$export$2bb74740c4e19def);
$parcel$export(module.exports, "useViewportSize", () => $8b24bab62f5c65ad$export$d699905dd57c73ca);
$parcel$export(module.exports, "useDescription", () => $34da4502ea8120db$export$f8aeda7b10753fa1);
$parcel$export(module.exports, "isMac", () => $9e20cff0af27e8cc$export$9ac100e40613ea10);
$parcel$export(module.exports, "isIPhone", () => $9e20cff0af27e8cc$export$186c6964ca17d99);
$parcel$export(module.exports, "isIPad", () => $9e20cff0af27e8cc$export$7bef049ce92e4224);
$parcel$export(module.exports, "isIOS", () => $9e20cff0af27e8cc$export$fedb369cb70207f1);
$parcel$export(module.exports, "isAppleDevice", () => $9e20cff0af27e8cc$export$e1865c3bedcd822b);
$parcel$export(module.exports, "isWebKit", () => $9e20cff0af27e8cc$export$78551043582a6a98);
$parcel$export(module.exports, "isChrome", () => $9e20cff0af27e8cc$export$6446a186d09e379e);
$parcel$export(module.exports, "isAndroid", () => $9e20cff0af27e8cc$export$a11b0059900ceec8);
$parcel$export(module.exports, "useEvent", () => $2a8c0bb1629926c8$export$90fc3a17d93f704c);
$parcel$export(module.exports, "useValueEffect", () => $19a2307bfabafaf1$export$14d238f342723f25);
$parcel$export(module.exports, "scrollIntoView", () => $449412113267a1fe$export$53a0910f038337bd);
$parcel$export(module.exports, "scrollIntoViewport", () => $449412113267a1fe$export$c826860796309d1b);
$parcel$export(module.exports, "clamp", () => $1Yh1N$reactstatelyutils.clamp);
$parcel$export(module.exports, "snapValueToStep", () => $1Yh1N$reactstatelyutils.snapValueToStep);
$parcel$export(module.exports, "isVirtualClick", () => $577e795361f19be9$export$60278871457622de);
$parcel$export(module.exports, "isVirtualPointerEvent", () => $577e795361f19be9$export$29bf1b5f2c56cf63);
$parcel$export(module.exports, "useEffectEvent", () => $1254e5bb94ac8761$export$7f54fc3180508a52);
$parcel$export(module.exports, "useDeepMemo", () => $20e6e72fbf5dc81e$export$722debc0e56fea39);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $78605a5d7424e31b$export$e5c5a5f917a5871c = typeof window !== "undefined" ? (0, ($parcel$interopDefault($1Yh1N$react))).useLayoutEffect : ()=>{};



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $19a2307bfabafaf1$export$14d238f342723f25(defaultValue) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultValue);
    let valueRef = (0, $1Yh1N$react.useRef)(value);
    let effect = (0, $1Yh1N$react.useRef)(null);
    // Must be stable so that `queue` is stable.
    let nextIter = (0, $1Yh1N$react.useCallback)(()=>{
        // Run the generator to the next yield.
        let newValue = effect.current.next();
        while(!newValue.done && valueRef.current === newValue.value)// If the value is the same as the current value,
        // then continue to the next yield. Otherwise,
        // set the value in state and wait for the next layout effect.
        newValue = effect.current.next();
        // If the generator is done, reset the effect.
        if (newValue.done) {
            effect.current = null;
            return;
        }
        // Always update valueRef when setting the state.
        // This is needed because the function is not regenerated with the new state value since
        // they must be stable across renders. Instead, it gets carried in the ref, but the setState
        // is also needed in order to cause a rerender.
        setValue(newValue.value);
        valueRef.current = newValue.value;
    // this list of dependencies is stable, setState and refs never change after first render.
    }, [
        setValue,
        valueRef,
        effect
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        // If there is an effect currently running, continue to the next yield.
        if (effect.current) nextIter();
    });
    // queue must be a stable function, much like setState.
    let queue = (0, $1Yh1N$react.useCallback)((fn)=>{
        effect.current = fn(valueRef.current);
        nextIter();
    // this list of dependencies is stable, setState and refs never change after first render.
    // in addition, nextIter is stable as outlined above
    }, [
        nextIter,
        effect,
        valueRef
    ]);
    return [
        value,
        queue
    ];
}


let $8c61827343eed941$var$idsUpdaterMap = new Map();
function $8c61827343eed941$export$f680877a34711e37(defaultId) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultId);
    let nextId = (0, $1Yh1N$react.useRef)(null);
    let res = (0, $1Yh1N$reactariassr.useSSRSafeId)(value);
    let updateValue = (0, $1Yh1N$react.useCallback)((val)=>{
        nextId.current = val;
    }, []);
    $8c61827343eed941$var$idsUpdaterMap.set(res, updateValue);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        let r = res;
        return ()=>{
            $8c61827343eed941$var$idsUpdaterMap.delete(r);
        };
    }, [
        res
    ]);
    // This cannot cause an infinite loop because the ref is updated first.
    // eslint-disable-next-line
    (0, $1Yh1N$react.useEffect)(()=>{
        let newId = nextId.current;
        if (newId) {
            nextId.current = null;
            setValue(newId);
        }
    });
    return res;
}
function $8c61827343eed941$export$cd8c9cb68f842629(idA, idB) {
    if (idA === idB) return idA;
    let setIdA = $8c61827343eed941$var$idsUpdaterMap.get(idA);
    if (setIdA) {
        setIdA(idB);
        return idB;
    }
    let setIdB = $8c61827343eed941$var$idsUpdaterMap.get(idB);
    if (setIdB) {
        setIdB(idA);
        return idA;
    }
    return idB;
}
function $8c61827343eed941$export$b4cc09c592e8fdb8(depArray = []) {
    let id = $8c61827343eed941$export$f680877a34711e37();
    let [resolvedId, setResolvedId] = (0, $19a2307bfabafaf1$export$14d238f342723f25)(id);
    let updateId = (0, $1Yh1N$react.useCallback)(()=>{
        setResolvedId(function*() {
            yield id;
            yield document.getElementById(id) ? id : undefined;
        });
    }, [
        id,
        setResolvedId
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(updateId, [
        id,
        updateId,
        ...depArray
    ]);
    return resolvedId;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /**
 * Calls all functions in the order they were chained with the same arguments.
 */ function $1e2191638e54f613$export$e08e3b67e392101e(...callbacks) {
    return (...args)=>{
        for (let callback of callbacks)if (typeof callback === "function") callback(...args);
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $f847cd1382ea7cd4$export$9d1611c77c2fe928(...args) {
    // Start with a base clone of the first argument. This is a lot faster than starting
    // with an empty object and adding properties as we go.
    let result = {
        ...args[0]
    };
    for(let i = 1; i < args.length; i++){
        let props = args[i];
        for(let key in props){
            let a = result[key];
            let b = props[key];
            // Chain events
            if (typeof a === "function" && typeof b === "function" && // This is a lot faster than a regex.
            key[0] === "o" && key[1] === "n" && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = (0, $1e2191638e54f613$export$e08e3b67e392101e)(a, b);
            else if ((key === "className" || key === "UNSAFE_className") && typeof a === "string" && typeof b === "string") result[key] = (0, ($parcel$interopDefault($1Yh1N$clsx)))(a, b);
            else if (key === "id" && a && b) result.id = (0, $8c61827343eed941$export$cd8c9cb68f842629)(a, b);
            else result[key] = b !== undefined ? b : a;
        }
    }
    return result;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $f05dc24eafaeb7e2$export$c9058316764c140e(...refs) {
    if (refs.length === 1) return refs[0];
    return (value)=>{
        for (let ref of refs){
            if (typeof ref === "function") ref(value);
            else if (ref != null) ref.current = value;
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ const $8d15d0e1797d4238$var$DOMPropNames = new Set([
    "id"
]);
const $8d15d0e1797d4238$var$labelablePropNames = new Set([
    "aria-label",
    "aria-labelledby",
    "aria-describedby",
    "aria-details"
]);
const $8d15d0e1797d4238$var$propRe = /^(data-.*)$/;
function $8d15d0e1797d4238$export$457c3d6518dd4c6f(props, opts = {}) {
    let { labelable: labelable , propNames: propNames  } = opts;
    let filteredProps = {};
    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($8d15d0e1797d4238$var$DOMPropNames.has(prop) || labelable && $8d15d0e1797d4238$var$labelablePropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $8d15d0e1797d4238$var$propRe.test(prop))) filteredProps[prop] = props[prop];
    return filteredProps;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $1117b6c0d4c4c164$export$de79e2c695e052f3(element) {
    if ($1117b6c0d4c4c164$var$supportsPreventScroll()) element.focus({
        preventScroll: true
    });
    else {
        let scrollableElements = $1117b6c0d4c4c164$var$getScrollableElements(element);
        element.focus();
        $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements);
    }
}
let $1117b6c0d4c4c164$var$supportsPreventScrollCached = null;
function $1117b6c0d4c4c164$var$supportsPreventScroll() {
    if ($1117b6c0d4c4c164$var$supportsPreventScrollCached == null) {
        $1117b6c0d4c4c164$var$supportsPreventScrollCached = false;
        try {
            var focusElem = document.createElement("div");
            focusElem.focus({
                get preventScroll () {
                    $1117b6c0d4c4c164$var$supportsPreventScrollCached = true;
                    return true;
                }
            });
        } catch (e) {
        // Ignore
        }
    }
    return $1117b6c0d4c4c164$var$supportsPreventScrollCached;
}
function $1117b6c0d4c4c164$var$getScrollableElements(element) {
    var parent = element.parentNode;
    var scrollableElements = [];
    var rootScrollingElement = document.scrollingElement || document.documentElement;
    while(parent instanceof HTMLElement && parent !== rootScrollingElement){
        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({
            element: parent,
            scrollTop: parent.scrollTop,
            scrollLeft: parent.scrollLeft
        });
        parent = parent.parentNode;
    }
    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
        element: rootScrollingElement,
        scrollTop: rootScrollingElement.scrollTop,
        scrollLeft: rootScrollingElement.scrollLeft
    });
    return scrollableElements;
}
function $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements) {
    for (let { element: element , scrollTop: scrollTop , scrollLeft: scrollLeft  } of scrollableElements){
        element.scrollTop = scrollTop;
        element.scrollLeft = scrollLeft;
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $16ec41ef3e36c19c$export$622cea445a1c5b7d(element, reverse, orientation = "horizontal") {
    let rect = element.getBoundingClientRect();
    if (reverse) return orientation === "horizontal" ? rect.right : rect.bottom;
    return orientation === "horizontal" ? rect.left : rect.top;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We store a global list of elements that are currently transitioning,
// mapped to a set of CSS properties that are transitioning for that element.
// This is necessary rather than a simple count of transitions because of browser
// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather
// than one or the other. So we need to track what's actually transitioning so that
// we can ignore these duplicate events.
let $e8117ebcab55be6a$var$transitionsByElement = new Map();
// A list of callbacks to call once there are no transitioning elements.
let $e8117ebcab55be6a$var$transitionCallbacks = new Set();
function $e8117ebcab55be6a$var$setupGlobalEvents() {
    if (typeof window === "undefined") return;
    let onTransitionStart = (e)=>{
        // Add the transitioning property to the list for this element.
        let transitions = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!transitions) {
            transitions = new Set();
            $e8117ebcab55be6a$var$transitionsByElement.set(e.target, transitions);
            // The transitioncancel event must be registered on the element itself, rather than as a global
            // event. This enables us to handle when the node is deleted from the document while it is transitioning.
            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.
            e.target.addEventListener("transitioncancel", onTransitionEnd);
        }
        transitions.add(e.propertyName);
    };
    let onTransitionEnd = (e)=>{
        // Remove property from list of transitioning properties.
        let properties = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!properties) return;
        properties.delete(e.propertyName);
        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.
        if (properties.size === 0) {
            e.target.removeEventListener("transitioncancel", onTransitionEnd);
            $e8117ebcab55be6a$var$transitionsByElement.delete(e.target);
        }
        // If no transitioning elements, call all of the queued callbacks.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) {
            for (let cb of $e8117ebcab55be6a$var$transitionCallbacks)cb();
            $e8117ebcab55be6a$var$transitionCallbacks.clear();
        }
    };
    document.body.addEventListener("transitionrun", onTransitionStart);
    document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e8117ebcab55be6a$var$setupGlobalEvents();
    else document.addEventListener("DOMContentLoaded", $e8117ebcab55be6a$var$setupGlobalEvents);
}
function $e8117ebcab55be6a$export$24490316f764c430(fn) {
    // Wait one frame to see if an animation starts, e.g. a transition on mount.
    requestAnimationFrame(()=>{
        // If no transitions are running, call the function immediately.
        // Otherwise, add it to a list of callbacks to run at the end of the animation.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) fn();
        else $e8117ebcab55be6a$var$transitionCallbacks.add(fn);
    });
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 

// Keep track of elements that we are currently handling dragging for via useDrag1D.
// If there's an ancestor and a descendant both using useDrag1D(), and the user starts
// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.
const $28ed3fb20343b78b$var$draggingElements = [];
function $28ed3fb20343b78b$export$7bbed75feba39706(props) {
    console.warn("useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html");
    let { containerRef: containerRef , reverse: reverse , orientation: orientation , onHover: onHover , onDrag: onDrag , onPositionChange: onPositionChange , onIncrement: onIncrement , onDecrement: onDecrement , onIncrementToMax: onIncrementToMax , onDecrementToMin: onDecrementToMin , onCollapseToggle: onCollapseToggle  } = props;
    let getPosition = (e)=>orientation === "horizontal" ? e.clientX : e.clientY;
    let getNextOffset = (e)=>{
        let containerOffset = (0, $16ec41ef3e36c19c$export$622cea445a1c5b7d)(containerRef.current, reverse, orientation);
        let mouseOffset = getPosition(e);
        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;
        return nextOffset;
    };
    let dragging = (0, $1Yh1N$react.useRef)(false);
    let prevPosition = (0, $1Yh1N$react.useRef)(0);
    // Keep track of the current handlers in a ref so that the events can access them.
    let handlers = (0, $1Yh1N$react.useRef)({
        onPositionChange: onPositionChange,
        onDrag: onDrag
    });
    handlers.current.onDrag = onDrag;
    handlers.current.onPositionChange = onPositionChange;
    let onMouseDragged = (e)=>{
        e.preventDefault();
        let nextOffset = getNextOffset(e);
        if (!dragging.current) {
            dragging.current = true;
            if (handlers.current.onDrag) handlers.current.onDrag(true);
            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        }
        if (prevPosition.current === nextOffset) return;
        prevPosition.current = nextOffset;
        if (onPositionChange) onPositionChange(nextOffset);
    };
    let onMouseUp = (e)=>{
        const target = e.target;
        dragging.current = false;
        let nextOffset = getNextOffset(e);
        if (handlers.current.onDrag) handlers.current.onDrag(false);
        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        $28ed3fb20343b78b$var$draggingElements.splice($28ed3fb20343b78b$var$draggingElements.indexOf(target), 1);
        window.removeEventListener("mouseup", onMouseUp, false);
        window.removeEventListener("mousemove", onMouseDragged, false);
    };
    let onMouseDown = (e)=>{
        const target = e.currentTarget;
        // If we're already handling dragging on a descendant with useDrag1D, then
        // we don't want to handle the drag motion on this target as well.
        if ($28ed3fb20343b78b$var$draggingElements.some((elt)=>target.contains(elt))) return;
        $28ed3fb20343b78b$var$draggingElements.push(target);
        window.addEventListener("mousemove", onMouseDragged, false);
        window.addEventListener("mouseup", onMouseUp, false);
    };
    let onMouseEnter = ()=>{
        if (onHover) onHover(true);
    };
    let onMouseOut = ()=>{
        if (onHover) onHover(false);
    };
    let onKeyDown = (e)=>{
        switch(e.key){
            case "Left":
            case "ArrowLeft":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Up":
            case "ArrowUp":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Right":
            case "ArrowRight":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Down":
            case "ArrowDown":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Home":
                e.preventDefault();
                if (onDecrementToMin) onDecrementToMin();
                break;
            case "End":
                e.preventDefault();
                if (onIncrementToMax) onIncrementToMax();
                break;
            case "Enter":
                e.preventDefault();
                if (onCollapseToggle) onCollapseToggle();
                break;
        }
    };
    return {
        onMouseDown: onMouseDown,
        onMouseEnter: onMouseEnter,
        onMouseOut: onMouseOut,
        onKeyDown: onKeyDown
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $4571ff54ac709100$export$4eaf04e54aa8eed6() {
    let globalListeners = (0, $1Yh1N$react.useRef)(new Map());
    let addGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        // Make sure we remove the listener after it is called with the `once` option.
        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{
            globalListeners.current.delete(listener);
            listener(...args);
        } : listener;
        globalListeners.current.set(listener, {
            type: type,
            eventTarget: eventTarget,
            fn: fn,
            options: options
        });
        eventTarget.addEventListener(type, listener, options);
    }, []);
    let removeGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        var _globalListeners_current_get;
        let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
        eventTarget.removeEventListener(type, fn, options);
        globalListeners.current.delete(listener);
    }, []);
    let removeAllGlobalListeners = (0, $1Yh1N$react.useCallback)(()=>{
        globalListeners.current.forEach((value, key)=>{
            removeGlobalListener(value.eventTarget, value.type, key, value.options);
        });
    }, [
        removeGlobalListener
    ]);
    // eslint-disable-next-line arrow-body-style
    (0, $1Yh1N$react.useEffect)(()=>{
        return removeAllGlobalListeners;
    }, [
        removeAllGlobalListeners
    ]);
    return {
        addGlobalListener: addGlobalListener,
        removeGlobalListener: removeGlobalListener,
        removeAllGlobalListeners: removeAllGlobalListeners
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6ec78bde395c477d$export$d6875122194c7b44(props, defaultLabel) {
    let { id: id , "aria-label": label , "aria-labelledby": labelledBy  } = props;
    // If there is both an aria-label and aria-labelledby,
    // combine them by pointing to the element itself.
    id = (0, $8c61827343eed941$export$f680877a34711e37)(id);
    if (labelledBy && label) {
        let ids = new Set([
            id,
            ...labelledBy.trim().split(/\s+/)
        ]);
        labelledBy = [
            ...ids
        ].join(" ");
    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\s+/).join(" ");
    // If no labels are provided, use the default
    if (!label && !labelledBy && defaultLabel) label = defaultLabel;
    return {
        id: id,
        "aria-label": label,
        "aria-labelledby": labelledBy
    };
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $475b35fe72ba49b3$export$4338b53315abf666(forwardedRef) {
    const objRef = (0, $1Yh1N$react.useRef)();
    return (0, $1Yh1N$react.useMemo)(()=>({
            get current () {
                return objRef.current;
            },
            set current (value){
                objRef.current = value;
                if (typeof forwardedRef === "function") forwardedRef(value);
                else if (forwardedRef) forwardedRef.current = value;
            }
        }), [
        forwardedRef
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $29293a6f5c75b37e$export$496315a1608d9602(effect, dependencies) {
    const isInitialMount = (0, $1Yh1N$react.useRef)(true);
    const lastDeps = (0, $1Yh1N$react.useRef)(null);
    (0, $1Yh1N$react.useEffect)(()=>{
        isInitialMount.current = true;
        return ()=>{
            isInitialMount.current = false;
        };
    }, []);
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isInitialMount.current) isInitialMount.current = false;
        else if (!lastDeps.current || dependencies.some((dep, i)=>!Object.is(dep, lastDeps[i]))) effect();
        lastDeps.current = dependencies;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencies);
}




function $37733e1652f47193$var$hasResizeObserver() {
    return typeof window.ResizeObserver !== "undefined";
}
function $37733e1652f47193$export$683480f191c0e3ea(options) {
    const { ref: ref , onResize: onResize  } = options;
    (0, $1Yh1N$react.useEffect)(()=>{
        let element = ref === null || ref === void 0 ? void 0 : ref.current;
        if (!element) return;
        if (!$37733e1652f47193$var$hasResizeObserver()) {
            window.addEventListener("resize", onResize, false);
            return ()=>{
                window.removeEventListener("resize", onResize, false);
            };
        } else {
            const resizeObserverInstance = new window.ResizeObserver((entries)=>{
                if (!entries.length) return;
                onResize();
            });
            resizeObserverInstance.observe(element);
            return ()=>{
                if (element) resizeObserverInstance.unobserve(element);
            };
        }
    }, [
        onResize,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6fc733991a9f977c$export$4debdb1a3f0fa79e(context, ref) {
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (context && context.ref && ref) {
            context.ref.current = ref.current;
            return ()=>{
                context.ref.current = null;
            };
        }
    }, [
        context,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d796e7157ac96470$export$cfa2225e87938781(node) {
    if ($d796e7157ac96470$export$2bb74740c4e19def(node)) node = node.parentElement;
    while(node && !$d796e7157ac96470$export$2bb74740c4e19def(node))node = node.parentElement;
    return node || document.scrollingElement || document.documentElement;
}
function $d796e7157ac96470$export$2bb74740c4e19def(node) {
    let style = window.getComputedStyle(node);
    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// @ts-ignore
let $8b24bab62f5c65ad$var$visualViewport = typeof window !== "undefined" && window.visualViewport;
function $8b24bab62f5c65ad$export$d699905dd57c73ca() {
    let [size, setSize] = (0, $1Yh1N$react.useState)(()=>$8b24bab62f5c65ad$var$getViewportSize());
    (0, $1Yh1N$react.useEffect)(()=>{
        // Use visualViewport api to track available height even on iOS virtual keyboard opening
        let onResize = ()=>{
            setSize((size)=>{
                let newSize = $8b24bab62f5c65ad$var$getViewportSize();
                if (newSize.width === size.width && newSize.height === size.height) return size;
                return newSize;
            });
        };
        if (!$8b24bab62f5c65ad$var$visualViewport) window.addEventListener("resize", onResize);
        else $8b24bab62f5c65ad$var$visualViewport.addEventListener("resize", onResize);
        return ()=>{
            if (!$8b24bab62f5c65ad$var$visualViewport) window.removeEventListener("resize", onResize);
            else $8b24bab62f5c65ad$var$visualViewport.removeEventListener("resize", onResize);
        };
    }, []);
    return size;
}
function $8b24bab62f5c65ad$var$getViewportSize() {
    return {
        width: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.width) || window.innerWidth,
        height: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.height) || window.innerHeight
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

let $34da4502ea8120db$var$descriptionId = 0;
const $34da4502ea8120db$var$descriptionNodes = new Map();
function $34da4502ea8120db$export$f8aeda7b10753fa1(description) {
    let [id, setId] = (0, $1Yh1N$react.useState)(undefined);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (!description) return;
        let desc = $34da4502ea8120db$var$descriptionNodes.get(description);
        if (!desc) {
            let id = `react-aria-description-${$34da4502ea8120db$var$descriptionId++}`;
            setId(id);
            let node = document.createElement("div");
            node.id = id;
            node.style.display = "none";
            node.textContent = description;
            document.body.appendChild(node);
            desc = {
                refCount: 0,
                element: node
            };
            $34da4502ea8120db$var$descriptionNodes.set(description, desc);
        } else setId(desc.element.id);
        desc.refCount++;
        return ()=>{
            if (--desc.refCount === 0) {
                desc.element.remove();
                $34da4502ea8120db$var$descriptionNodes.delete(description);
            }
        };
    }, [
        description
    ]);
    return {
        "aria-describedby": description ? id : undefined
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $9e20cff0af27e8cc$var$testUserAgent(re) {
    var _window_navigator_userAgentData;
    if (typeof window === "undefined" || window.navigator == null) return false;
    return ((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand)=>re.test(brand.brand))) || re.test(window.navigator.userAgent);
}
function $9e20cff0af27e8cc$var$testPlatform(re) {
    var _window_navigator_userAgentData;
    return typeof window !== "undefined" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $9e20cff0af27e8cc$export$9ac100e40613ea10() {
    return $9e20cff0af27e8cc$var$testPlatform(/^Mac/i);
}
function $9e20cff0af27e8cc$export$186c6964ca17d99() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPhone/i);
}
function $9e20cff0af27e8cc$export$7bef049ce92e4224() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
    $9e20cff0af27e8cc$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
}
function $9e20cff0af27e8cc$export$fedb369cb70207f1() {
    return $9e20cff0af27e8cc$export$186c6964ca17d99() || $9e20cff0af27e8cc$export$7bef049ce92e4224();
}
function $9e20cff0af27e8cc$export$e1865c3bedcd822b() {
    return $9e20cff0af27e8cc$export$9ac100e40613ea10() || $9e20cff0af27e8cc$export$fedb369cb70207f1();
}
function $9e20cff0af27e8cc$export$78551043582a6a98() {
    return $9e20cff0af27e8cc$var$testUserAgent(/AppleWebKit/i) && !$9e20cff0af27e8cc$export$6446a186d09e379e();
}
function $9e20cff0af27e8cc$export$6446a186d09e379e() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Chrome/i);
}
function $9e20cff0af27e8cc$export$a11b0059900ceec8() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Android/i);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1254e5bb94ac8761$export$7f54fc3180508a52(fn) {
    const ref = (0, $1Yh1N$react.useRef)(null);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        ref.current = fn;
    }, [
        fn
    ]);
    return (0, $1Yh1N$react.useCallback)((...args)=>{
        const f = ref.current;
        return f(...args);
    }, []);
}


function $2a8c0bb1629926c8$export$90fc3a17d93f704c(ref, event, handler, options) {
    let handleEvent = (0, $1254e5bb94ac8761$export$7f54fc3180508a52)(handler);
    let isDisabled = handler == null;
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isDisabled) return;
        let element = ref.current;
        element.addEventListener(event, handleEvent, options);
        return ()=>{
            element.removeEventListener(event, handleEvent, options);
        };
    }, [
        ref,
        event,
        options,
        isDisabled,
        handleEvent
    ]);
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $449412113267a1fe$export$53a0910f038337bd(scrollView, element) {
    let offsetX = $449412113267a1fe$var$relativeOffset(scrollView, element, "left");
    let offsetY = $449412113267a1fe$var$relativeOffset(scrollView, element, "top");
    let width = element.offsetWidth;
    let height = element.offsetHeight;
    let x = scrollView.scrollLeft;
    let y = scrollView.scrollTop;
    // Account for top/left border offsetting the scroll top/Left
    let { borderTopWidth: borderTopWidth , borderLeftWidth: borderLeftWidth  } = getComputedStyle(scrollView);
    let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);
    let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);
    // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width
    let maxX = borderAdjustedX + scrollView.clientWidth;
    let maxY = borderAdjustedY + scrollView.clientHeight;
    if (offsetX <= x) x = offsetX - parseInt(borderLeftWidth, 10);
    else if (offsetX + width > maxX) x += offsetX + width - maxX;
    if (offsetY <= borderAdjustedY) y = offsetY - parseInt(borderTopWidth, 10);
    else if (offsetY + height > maxY) y += offsetY + height - maxY;
    scrollView.scrollLeft = x;
    scrollView.scrollTop = y;
}
/**
 * Computes the offset left or top from child to ancestor by accumulating
 * offsetLeft or offsetTop through intervening offsetParents.
 */ function $449412113267a1fe$var$relativeOffset(ancestor, child, axis) {
    const prop = axis === "left" ? "offsetLeft" : "offsetTop";
    let sum = 0;
    while(child.offsetParent){
        sum += child[prop];
        if (child.offsetParent === ancestor) break;
        else if (child.offsetParent.contains(ancestor)) {
            // If the ancestor is not `position:relative`, then we stop at
            // _its_ offset parent, and we subtract off _its_ offset, so that
            // we end up with the proper offset from child to ancestor.
            sum -= ancestor[prop];
            break;
        }
        child = child.offsetParent;
    }
    return sum;
}
function $449412113267a1fe$export$c826860796309d1b(targetElement, opts) {
    if (document.contains(targetElement)) {
        let root = document.scrollingElement || document.documentElement;
        let isScrollPrevented = window.getComputedStyle(root).overflow === "hidden";
        // If scrolling is not currently prevented then we aren’t in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view
        if (!isScrollPrevented) {
            var // use scrollIntoView({block: 'nearest'}) instead of .focus to check if the element is fully in view or not since .focus()
            // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically
            _targetElement_scrollIntoView;
            let { left: originalLeft , top: originalTop  } = targetElement.getBoundingClientRect();
            targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {
                block: "nearest"
            });
            let { left: newLeft , top: newTop  } = targetElement.getBoundingClientRect();
            // Account for sub pixel differences from rounding
            if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {
                var _opts_containingElement, _opts_containingElement_scrollIntoView, _targetElement_scrollIntoView1;
                opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {
                    block: "center",
                    inline: "center"
                });
                (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {
                    block: "nearest"
                });
            }
        } else {
            let scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.
            while(targetElement && scrollParent && targetElement !== root && scrollParent !== root){
                $449412113267a1fe$export$53a0910f038337bd(scrollParent, targetElement);
                targetElement = scrollParent;
                scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            }
        }
    }
}



/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $577e795361f19be9$export$60278871457622de(event) {
    // JAWS/NVDA with Firefox.
    if (event.mozInputSource === 0 && event.isTrusted) return true;
    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead
    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check
    // to detect TalkBack virtual clicks.
    if ((0, $9e20cff0af27e8cc$export$a11b0059900ceec8)() && event.pointerType) return event.type === "click" && event.buttons === 1;
    return event.detail === 0 && !event.pointerType;
}
function $577e795361f19be9$export$29bf1b5f2c56cf63(event) {
    // If the pointer size is zero, then we assume it's from a screen reader.
    // Android TalkBack double tap will sometimes return a event with width and height of 1
    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.
    // Cannot use "event.pressure === 0" as the sole check due to Safari pointer events always returning pressure === 0
    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush
    // Talkback double tap from Windows Firefox touch screen press
    return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse";
}



/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 
function $20e6e72fbf5dc81e$export$722debc0e56fea39(value, isEqual) {
    // Using a ref during render is ok here because it's only an optimization – both values are equivalent.
    // If a render is thrown away, it'll still work the same no matter if the next render is the same or not.
    let lastValue = (0, $1Yh1N$react.useRef)(null);
    if (value && lastValue.current && isEqual(value, lastValue.current)) value = lastValue.current;
    lastValue.current = value;
    return value;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 87642:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $fMEGB$reactariautils = __webpack_require__(29061);
var $fMEGB$reactariafocus = __webpack_require__(74032);
var $fMEGB$reactariainteractions = __webpack_require__(81941);
var $fMEGB$reactarialabel = __webpack_require__(26894);
var $fMEGB$reactariai18n = __webpack_require__(2211);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useRadio", () => $e184702b1b7f1863$export$37b0961d2f4751e2);
$parcel$export(module.exports, "useRadioGroup", () => $dfcade00a56a6317$export$62b9571f283ff5c2);

const $eeb149278aae5c67$export$3b7b268d09480394 = new WeakMap();
const $eeb149278aae5c67$export$8e8b214e06dd397d = new WeakMap();
const $eeb149278aae5c67$export$61c8d3f0151e21b2 = new WeakMap();




function $e184702b1b7f1863$export$37b0961d2f4751e2(props, state, ref) {
    let { value: value , children: children , 'aria-label': ariaLabel , 'aria-labelledby': ariaLabelledby  } = props;
    const isDisabled = props.isDisabled || state.isDisabled;
    let hasChildren = children != null;
    let hasAriaLabel = ariaLabel != null || ariaLabelledby != null;
    if (!hasChildren && !hasAriaLabel) console.warn('If you do not provide children, you must specify an aria-label for accessibility');
    let checked = state.selectedValue === value;
    let onChange = (e)=>{
        e.stopPropagation();
        state.setSelectedValue(value);
    };
    let { pressProps: pressProps  } = $fMEGB$reactariainteractions.usePress({
        isDisabled: isDisabled
    });
    let { focusableProps: focusableProps  } = $fMEGB$reactariafocus.useFocusable($fMEGB$reactariautils.mergeProps(props, {
        onFocus: ()=>state.setLastFocusedValue(value)
    }), ref);
    let interactions = $fMEGB$reactariautils.mergeProps(pressProps, focusableProps);
    let domProps = $fMEGB$reactariautils.filterDOMProps(props, {
        labelable: true
    });
    let tabIndex = state.lastFocusedValue === value || state.lastFocusedValue == null ? 0 : -1;
    if (isDisabled) tabIndex = undefined;
    return {
        inputProps: $fMEGB$reactariautils.mergeProps(domProps, {
            ...interactions,
            type: 'radio',
            name: $eeb149278aae5c67$export$3b7b268d09480394.get(state),
            tabIndex: tabIndex,
            disabled: isDisabled,
            checked: checked,
            value: value,
            onChange: onChange,
            'aria-describedby': [
                state.validationState === 'invalid' ? $eeb149278aae5c67$export$61c8d3f0151e21b2.get(state) : null,
                $eeb149278aae5c67$export$8e8b214e06dd397d.get(state)
            ].filter(Boolean).join(' ') || undefined
        }),
        isDisabled: isDisabled,
        isSelected: checked
    };
}








function $dfcade00a56a6317$export$62b9571f283ff5c2(props, state) {
    let { name: name , validationState: validationState , isReadOnly: isReadOnly , isRequired: isRequired , isDisabled: isDisabled , orientation: orientation = 'vertical'  } = props;
    let { direction: direction  } = $fMEGB$reactariai18n.useLocale();
    let { labelProps: labelProps , fieldProps: fieldProps , descriptionProps: descriptionProps , errorMessageProps: errorMessageProps  } = $fMEGB$reactarialabel.useField({
        ...props,
        // Radio group is not an HTML input element so it
        // shouldn't be labeled by a <label> element.
        labelElementType: 'span'
    });
    $eeb149278aae5c67$export$8e8b214e06dd397d.set(state, descriptionProps.id);
    $eeb149278aae5c67$export$61c8d3f0151e21b2.set(state, errorMessageProps.id);
    let domProps = $fMEGB$reactariautils.filterDOMProps(props, {
        labelable: true
    });
    // When the radio group loses focus, reset the focusable radio to null if
    // there is no selection. This allows tabbing into the group from either
    // direction to go to the first or last radio.
    let { focusWithinProps: focusWithinProps  } = $fMEGB$reactariainteractions.useFocusWithin({
        onBlurWithin () {
            if (!state.selectedValue) state.setLastFocusedValue(null);
        }
    });
    let onKeyDown = (e)=>{
        let nextDir;
        switch(e.key){
            case 'ArrowRight':
                if (direction === 'rtl' && orientation !== 'vertical') nextDir = 'prev';
                else nextDir = 'next';
                break;
            case 'ArrowLeft':
                if (direction === 'rtl' && orientation !== 'vertical') nextDir = 'next';
                else nextDir = 'prev';
                break;
            case 'ArrowDown':
                nextDir = 'next';
                break;
            case 'ArrowUp':
                nextDir = 'prev';
                break;
            default:
                return;
        }
        e.preventDefault();
        let walker = $fMEGB$reactariafocus.getFocusableTreeWalker(e.currentTarget, {
            from: e.target
        });
        let nextElem;
        if (nextDir === 'next') {
            nextElem = walker.nextNode();
            if (!nextElem) {
                walker.currentNode = e.currentTarget;
                nextElem = walker.firstChild();
            }
        } else {
            nextElem = walker.previousNode();
            if (!nextElem) {
                walker.currentNode = e.currentTarget;
                nextElem = walker.lastChild();
            }
        }
        if (nextElem) {
            // Call focus on nextElem so that keyboard navigation scrolls the radio into view
            nextElem.focus();
            state.setSelectedValue(nextElem.value);
        }
    };
    let groupName = $fMEGB$reactariautils.useId(name);
    $eeb149278aae5c67$export$3b7b268d09480394.set(state, groupName);
    return {
        radioGroupProps: $fMEGB$reactariautils.mergeProps(domProps, {
            // https://www.w3.org/TR/wai-aria-1.2/#radiogroup
            role: 'radiogroup',
            onKeyDown: onKeyDown,
            'aria-invalid': validationState === 'invalid' || undefined,
            'aria-errormessage': props['aria-errormessage'],
            'aria-readonly': isReadOnly || undefined,
            'aria-required': isRequired || undefined,
            'aria-disabled': isDisabled || undefined,
            'aria-orientation': orientation,
            ...fieldProps,
            ...focusWithinProps
        }),
        labelProps: labelProps,
        descriptionProps: descriptionProps,
        errorMessageProps: errorMessageProps
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 74032:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $aB6Cp$react = __webpack_require__(18038);
var $aB6Cp$reactariautils = __webpack_require__(29061);
var $aB6Cp$reactariainteractions = __webpack_require__(81941);
var $aB6Cp$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "FocusScope", () => $a7a032acae3ddda9$export$20e40289641fbbb6);
$parcel$export(module.exports, "useFocusManager", () => $a7a032acae3ddda9$export$10c5169755ce7bd7);
$parcel$export(module.exports, "getFocusableTreeWalker", () => $a7a032acae3ddda9$export$2d6ec8fc375ceafa);
$parcel$export(module.exports, "createFocusManager", () => $a7a032acae3ddda9$export$c5251b9e124bf29);
$parcel$export(module.exports, "isElementInChildOfActiveScope", () => $a7a032acae3ddda9$export$1258395f99bf9cbf);
$parcel$export(module.exports, "FocusRing", () => $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d);
$parcel$export(module.exports, "FocusableProvider", () => $fb504d83237fd6ac$export$13f3202a3e5ddd5);
$parcel$export(module.exports, "useFocusable", () => $fb504d83237fd6ac$export$4c014de7c8940b4c);
$parcel$export(module.exports, "useFocusRing", () => $581a96d6eb128c1b$export$4e328f61c538687f);
$parcel$export(module.exports, "focusSafely", () => $1c7f9157d722357d$export$80f3e147d781571c);
$parcel$export(module.exports, "useHasTabbableChild", () => $259c6413a286f2e6$export$eac1895992b9f3d6);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1c7f9157d722357d$export$80f3e147d781571c(element) {
    // If the user is interacting with a virtual cursor, e.g. screen reader, then
    // wait until after any animated transitions that are currently occurring on
    // the page before shifting focus. This avoids issues with VoiceOver on iOS
    // causing the page to scroll when moving focus if the element is transitioning
    // from off the screen.
    if ((0, $aB6Cp$reactariainteractions.getInteractionModality)() === "virtual") {
        let lastFocusedElement = document.activeElement;
        (0, $aB6Cp$reactariautils.runAfterTransition)(()=>{
            // If focus did not move and the element is still in the document, focus it.
            if (document.activeElement === lastFocusedElement && document.contains(element)) (0, $aB6Cp$reactariautils.focusWithoutScrolling)(element);
        });
    } else (0, $aB6Cp$reactariautils.focusWithoutScrolling)(element);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d5156037ad898a4d$var$isStyleVisible(element) {
    if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) return false;
    let { display: display , visibility: visibility  } = element.style;
    let isVisible = display !== "none" && visibility !== "hidden" && visibility !== "collapse";
    if (isVisible) {
        const { getComputedStyle: getComputedStyle  } = element.ownerDocument.defaultView;
        let { display: computedDisplay , visibility: computedVisibility  } = getComputedStyle(element);
        isVisible = computedDisplay !== "none" && computedVisibility !== "hidden" && computedVisibility !== "collapse";
    }
    return isVisible;
}
function $d5156037ad898a4d$var$isAttributeVisible(element, childElement) {
    return !element.hasAttribute("hidden") && (element.nodeName === "DETAILS" && childElement && childElement.nodeName !== "SUMMARY" ? element.hasAttribute("open") : true);
}
function $d5156037ad898a4d$export$e989c0fffaa6b27a(element, childElement) {
    return element.nodeName !== "#comment" && $d5156037ad898a4d$var$isStyleVisible(element) && $d5156037ad898a4d$var$isAttributeVisible(element, childElement) && (!element.parentElement || $d5156037ad898a4d$export$e989c0fffaa6b27a(element.parentElement, element));
}




const $a7a032acae3ddda9$var$FocusContext = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createContext(null);
let $a7a032acae3ddda9$var$activeScope = null;
function $a7a032acae3ddda9$export$20e40289641fbbb6(props) {
    let { children: children , contain: contain , restoreFocus: restoreFocus , autoFocus: autoFocus  } = props;
    let startRef = (0, $aB6Cp$react.useRef)();
    let endRef = (0, $aB6Cp$react.useRef)();
    let scopeRef = (0, $aB6Cp$react.useRef)([]);
    let { parentNode: parentNode  } = (0, $aB6Cp$react.useContext)($a7a032acae3ddda9$var$FocusContext) || {};
    // Create a tree node here so we can add children to it even before it is added to the tree.
    let node = (0, $aB6Cp$react.useMemo)(()=>new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: scopeRef
        }), [
        scopeRef
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),
        // use the active scope as the parent instead of the parent from context. Layout effects run bottom
        // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope
        // that is being added should get the activeScope as its parent.
        let parent = parentNode || $a7a032acae3ddda9$export$d06fae2ee68b101e.root;
        if ($a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(parent.scopeRef) && $a7a032acae3ddda9$var$activeScope && !$a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, parent.scopeRef)) {
            let activeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
            if (activeNode) parent = activeNode;
        }
        // Add the node to the parent, and to the tree.
        parent.addChild(node);
        $a7a032acae3ddda9$export$d06fae2ee68b101e.addNode(node);
    }, [
        node,
        parentNode
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let node = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef);
        node.contain = contain;
    }, [
        contain
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        // Find all rendered nodes between the sentinels and add them to the scope.
        let node = startRef.current.nextSibling;
        let nodes = [];
        while(node && node !== endRef.current){
            nodes.push(node);
            node = node.nextSibling;
        }
        scopeRef.current = nodes;
    }, [
        children
    ]);
    $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain);
    $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus);
    // this layout effect needs to run last so that focusScopeTree cleanup happens at the last moment possible
    (0, $aB6Cp$react.useEffect)(()=>{
        if (scopeRef) {
            let activeElement = document.activeElement;
            let scope = null;
            // In strict mode, active scope is incorrectly updated since cleanup will run even though scope hasn't unmounted.
            // To fix this, we need to update the actual activeScope here
            if ($a7a032acae3ddda9$var$isElementInScope(activeElement, scopeRef.current)) {
                // Since useLayoutEffect runs for children first, we need to traverse the focusScope tree and find the bottom most scope that
                // contains the active element and set that as the activeScope
                for (let node of $a7a032acae3ddda9$export$d06fae2ee68b101e.traverse())if ($a7a032acae3ddda9$var$isElementInScope(activeElement, node.scopeRef.current)) scope = node;
                if (scope === $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef)) $a7a032acae3ddda9$var$activeScope = scope.scopeRef;
            }
            return ()=>{
                // Scope may have been re-parented.
                let parentScope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).parent.scopeRef;
                // Restore the active scope on unmount if this scope or a descendant scope is active.
                // Parent effect cleanups run before children, so we need to check if the
                // parent scope actually still exists before restoring the active scope to it.
                if ((scopeRef === $a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope(scopeRef, $a7a032acae3ddda9$var$activeScope)) && (!parentScope || $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(parentScope))) $a7a032acae3ddda9$var$activeScope = parentScope;
                $a7a032acae3ddda9$export$d06fae2ee68b101e.removeTreeNode(scopeRef);
            };
        }
    }, [
        scopeRef
    ]);
    let focusManager = (0, $aB6Cp$react.useMemo)(()=>$a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef), []);
    let value = (0, $aB6Cp$react.useMemo)(()=>({
            focusManager: focusManager,
            parentNode: node
        }), [
        node,
        focusManager
    ]);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement($a7a032acae3ddda9$var$FocusContext.Provider, {
        value: value
    }, /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement("span", {
        "data-focus-scope-start": true,
        hidden: true,
        ref: startRef
    }), children, /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement("span", {
        "data-focus-scope-end": true,
        hidden: true,
        ref: endRef
    }));
}
function $a7a032acae3ddda9$export$10c5169755ce7bd7() {
    var _useContext;
    return (_useContext = (0, $aB6Cp$react.useContext)($a7a032acae3ddda9$var$FocusContext)) === null || _useContext === void 0 ? void 0 : _useContext.focusManager;
}
function $a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef) {
    return {
        focusNext (opts = {}) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[0].previousElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = sentinel;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = {}) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[scope.length - 1].nextElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = sentinel;
                previousNode = walker.previousNode();
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = {}) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[0].previousElementSibling;
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = {}) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[scope.length - 1].nextElementSibling;
            let previousNode = walker.previousNode();
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        }
    };
}
const $a7a032acae3ddda9$var$focusableElements = [
    "input:not([disabled]):not([type=hidden])",
    "select:not([disabled])",
    "textarea:not([disabled])",
    "button:not([disabled])",
    "a[href]",
    "area[href]",
    "summary",
    "iframe",
    "object",
    "embed",
    "audio[controls]",
    "video[controls]",
    "[contenteditable]"
];
const $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
$a7a032acae3ddda9$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(':not([hidden]):not([tabindex="-1"]),');
function $a7a032acae3ddda9$var$getScopeRoot(scope) {
    return scope[0].parentElement;
}
function $a7a032acae3ddda9$var$shouldContainFocus(scopeRef) {
    let scope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
    while(scope && scope.scopeRef !== scopeRef){
        if (scope.contain) return false;
        scope = scope.parent;
    }
    return true;
}
function $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain) {
    let focusedNode = (0, $aB6Cp$react.useRef)();
    let raf = (0, $aB6Cp$react.useRef)(null);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let scope = scopeRef.current;
        if (!contain) {
            // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment
            if (raf.current) {
                cancelAnimationFrame(raf.current);
                raf.current = null;
            }
            return;
        }
        // Handle the Tab key to contain focus within the scope
        let onKeyDown = (e)=>{
            if (e.key !== "Tab" || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) return;
            let focusedElement = document.activeElement;
            let scope = scopeRef.current;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scope)) return;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: true
            }, scope);
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!nextElement) {
                walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;
                nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            }
            e.preventDefault();
            if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
        };
        let onFocus = (e)=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if ((!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) && $a7a032acae3ddda9$var$isElementInScope(e.target, scopeRef.current)) {
                $a7a032acae3ddda9$var$activeScope = scopeRef;
                focusedNode.current = e.target;
            } else if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(e.target, scopeRef)) {
                // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),
                // restore focus to the previously focused node or the first tabbable element in the active scope.
                if (focusedNode.current) focusedNode.current.focus();
                else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
            } else if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) focusedNode.current = e.target;
        };
        let onBlur = (e)=>{
            // Firefox doesn't shift focus back to the Dialog properly without this
            if (raf.current) cancelAnimationFrame(raf.current);
            raf.current = requestAnimationFrame(()=>{
                // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe
                if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(document.activeElement, scopeRef)) {
                    $a7a032acae3ddda9$var$activeScope = scopeRef;
                    if (document.body.contains(e.target)) {
                        focusedNode.current = e.target;
                        focusedNode.current.focus();
                    } else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
                }
            });
        };
        document.addEventListener("keydown", onKeyDown, false);
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        scope.forEach((element)=>element.addEventListener("focusout", onBlur, false));
        return ()=>{
            document.removeEventListener("keydown", onKeyDown, false);
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
            scope.forEach((element)=>element.removeEventListener("focusout", onBlur, false));
        };
    }, [
        scopeRef,
        contain
    ]);
    // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur
    // eslint-disable-next-line arrow-body-style
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        return ()=>{
            if (raf.current) cancelAnimationFrame(raf.current);
        };
    }, [
        raf
    ]);
}
function $a7a032acae3ddda9$var$isElementInAnyScope(element) {
    return $a7a032acae3ddda9$var$isElementInChildScope(element);
}
function $a7a032acae3ddda9$var$isElementInScope(element, scope) {
    return scope.some((node)=>node.contains(element));
}
function $a7a032acae3ddda9$var$isElementInChildScope(element, scope = null) {
    // If the element is within a top layer element (e.g. toasts), always allow moving focus there.
    if (element instanceof Element && element.closest("[data-react-aria-top-layer]")) return true;
    // node.contains in isElementInScope covers child scopes that are also DOM children,
    // but does not cover child scopes in portals.
    for (let { scopeRef: s  } of $a7a032acae3ddda9$export$d06fae2ee68b101e.traverse($a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scope))){
        if ($a7a032acae3ddda9$var$isElementInScope(element, s.current)) return true;
    }
    return false;
}
function $a7a032acae3ddda9$export$1258395f99bf9cbf(element) {
    return $a7a032acae3ddda9$var$isElementInChildScope(element, $a7a032acae3ddda9$var$activeScope);
}
function $a7a032acae3ddda9$var$isAncestorScope(ancestor, scope) {
    var _focusScopeTree_getTreeNode;
    let parent = (_focusScopeTree_getTreeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scope)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : _focusScopeTree_getTreeNode.parent;
    while(parent){
        if (parent.scopeRef === ancestor) return true;
        parent = parent.parent;
    }
    return false;
}
function $a7a032acae3ddda9$var$focusElement(element, scroll = false) {
    if (element != null && !scroll) try {
        (0, $1c7f9157d722357d$export$80f3e147d781571c)(element);
    } catch (err) {
    // ignore
    }
    else if (element != null) try {
        element.focus();
    } catch (err) {
    // ignore
    }
}
function $a7a032acae3ddda9$var$focusFirstInScope(scope, tabbable = true) {
    let sentinel = scope[0].previousElementSibling;
    let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
        tabbable: tabbable
    }, scope);
    walker.currentNode = sentinel;
    let nextNode = walker.nextNode();
    // If the scope does not contain a tabbable element, use the first focusable element.
    if (tabbable && !nextNode) {
        walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
            tabbable: false
        }, scope);
        walker.currentNode = sentinel;
        nextNode = walker.nextNode();
    }
    $a7a032acae3ddda9$var$focusElement(nextNode);
}
function $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus) {
    const autoFocusRef = (0, ($parcel$interopDefault($aB6Cp$react))).useRef(autoFocus);
    (0, $aB6Cp$react.useEffect)(()=>{
        if (autoFocusRef.current) {
            $a7a032acae3ddda9$var$activeScope = scopeRef;
            if (!$a7a032acae3ddda9$var$isElementInScope(document.activeElement, $a7a032acae3ddda9$var$activeScope.current)) $a7a032acae3ddda9$var$focusFirstInScope(scopeRef.current);
        }
        autoFocusRef.current = false;
    }, [
        scopeRef
    ]);
}
function $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restore, contain) {
    // tracks the active scope, in case restore and contain are both false.
    // if either are true, this is tracked in useRestoreFocus or useFocusContainment.
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if (restore || contain) return;
        let scope = scopeRef.current;
        let onFocus = (e)=>{
            let target = e.target;
            if ($a7a032acae3ddda9$var$isElementInScope(target, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
            else if (!$a7a032acae3ddda9$var$isElementInAnyScope(target)) $a7a032acae3ddda9$var$activeScope = null;
        };
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        return ()=>{
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
        };
    }, [
        scopeRef,
        restore,
        contain
    ]);
}
function $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef) {
    let scope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
    while(scope && scope.scopeRef !== scopeRef){
        if (scope.nodeToRestore) return false;
        scope = scope.parent;
    }
    return (scope === null || scope === void 0 ? void 0 : scope.scopeRef) === scopeRef;
}
function $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
    // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.
    const nodeToRestoreRef = (0, $aB6Cp$react.useRef)(typeof document !== "undefined" ? document.activeElement : null);
    // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus
    // restoring-non-containing scopes should only care if they become active so they can perform the restore
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let scope = scopeRef.current;
        if (!restoreFocus || contain) return;
        let onFocus = ()=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if ((!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) && $a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
        };
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        return ()=>{
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        scopeRef,
        contain
    ]);
    // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if (!restoreFocus) return;
        $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = nodeToRestoreRef.current;
        // Handle the Tab key so that tabbing out of the scope goes to the next element
        // after the node that had focus when the scope mounted. This is important when
        // using portals for overlays, so that focus goes to the expected element when
        // tabbing out of the overlay.
        let onKeyDown = (e)=>{
            if (e.key !== "Tab" || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) return;
            let focusedElement = document.activeElement;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scopeRef.current)) return;
            let nodeToRestore = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;
            // Create a DOM tree walker that matches all tabbable elements
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(document.body, {
                tabbable: true
            });
            // Find the next tabbable element after the currently focused element
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!document.body.contains(nodeToRestore) || nodeToRestore === document.body) {
                nodeToRestore = null;
                $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = null;
            }
            // If there is no next element, or it is outside the current scope, move focus to the
            // next element after the node to restore to instead.
            if ((!nextElement || !$a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {
                walker.currentNode = nodeToRestore;
                // Skip over elements within the scope, in case the scope immediately follows the node to restore.
                do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
                while ($a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current));
                e.preventDefault();
                e.stopPropagation();
                if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
                else // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)
                // then move focus to the body.
                // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)
                if (!$a7a032acae3ddda9$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();
                else $a7a032acae3ddda9$var$focusElement(nodeToRestore, true);
            }
        };
        if (!contain) document.addEventListener("keydown", onKeyDown, true);
        return ()=>{
            if (!contain) document.removeEventListener("keydown", onKeyDown, true);
            let nodeToRestore = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;
            // if we already lost focus to the body and this was the active scope, then we should attempt to restore
            if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps
            ($a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current) || document.activeElement === document.body && $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef))) {
                // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it
                let clonedTree = $a7a032acae3ddda9$export$d06fae2ee68b101e.clone();
                requestAnimationFrame(()=>{
                    // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere
                    if (document.activeElement === document.body) {
                        // look up the tree starting with our scope to find a nodeToRestore still in the DOM
                        let treeNode = clonedTree.getTreeNode(scopeRef);
                        while(treeNode){
                            if (treeNode.nodeToRestore && document.body.contains(treeNode.nodeToRestore)) {
                                $a7a032acae3ddda9$var$focusElement(treeNode.nodeToRestore);
                                return;
                            }
                            treeNode = treeNode.parent;
                        }
                        // If no nodeToRestore was found, focus the first element in the nearest
                        // ancestor scope that is still in the tree.
                        treeNode = clonedTree.getTreeNode(scopeRef);
                        while(treeNode){
                            if (treeNode.scopeRef && $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(treeNode.scopeRef)) {
                                $a7a032acae3ddda9$var$focusFirstInScope(treeNode.scopeRef.current, true);
                                return;
                            }
                            treeNode = treeNode.parent;
                        }
                    }
                });
            }
        };
    }, [
        scopeRef,
        restoreFocus,
        contain
    ]);
}
function $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, opts, scope) {
    let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR : $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR;
    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode (node) {
            var _opts_from;
            // Skip nodes inside the starting node.
            if (opts === null || opts === void 0 ? void 0 : (_opts_from = opts.from) === null || _opts_from === void 0 ? void 0 : _opts_from.contains(node)) return NodeFilter.FILTER_REJECT;
            if (node.matches(selector) && (0, $d5156037ad898a4d$export$e989c0fffaa6b27a)(node) && (!scope || $a7a032acae3ddda9$var$isElementInScope(node, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node))) return NodeFilter.FILTER_ACCEPT;
            return NodeFilter.FILTER_SKIP;
        }
    });
    if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;
    return walker;
}
function $a7a032acae3ddda9$export$c5251b9e124bf29(ref, defaultOptions = {}) {
    return {
        focusNext (opts = {}) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = root;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            else {
                let next = $a7a032acae3ddda9$var$last(walker);
                if (next) $a7a032acae3ddda9$var$focusElement(next, true);
                return next;
            }
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = root;
                previousNode = $a7a032acae3ddda9$var$last(walker);
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let next = $a7a032acae3ddda9$var$last(walker);
            if (next) $a7a032acae3ddda9$var$focusElement(next, true);
            return next;
        }
    };
}
function $a7a032acae3ddda9$var$last(walker) {
    let next;
    let last;
    do {
        last = walker.lastChild();
        if (last) next = last;
    }while (last);
    return next;
}
class $a7a032acae3ddda9$var$Tree {
    get size() {
        return this.fastMap.size;
    }
    getTreeNode(data) {
        return this.fastMap.get(data);
    }
    addTreeNode(scopeRef, parent, nodeToRestore) {
        let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);
        let node = new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: scopeRef
        });
        parentNode.addChild(node);
        node.parent = parentNode;
        this.fastMap.set(scopeRef, node);
        if (nodeToRestore) node.nodeToRestore = nodeToRestore;
    }
    addNode(node) {
        this.fastMap.set(node.scopeRef, node);
    }
    removeTreeNode(scopeRef) {
        // never remove the root
        if (scopeRef === null) return;
        let node = this.fastMap.get(scopeRef);
        let parentNode = node.parent;
        // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing
        // if we are, then replace the siblings restore with the restore from the scope we're removing
        for (let current of this.traverse())if (current !== node && node.nodeToRestore && current.nodeToRestore && node.scopeRef.current && $a7a032acae3ddda9$var$isElementInScope(current.nodeToRestore, node.scopeRef.current)) current.nodeToRestore = node.nodeToRestore;
        let children = node.children;
        parentNode.removeChild(node);
        if (children.size > 0) children.forEach((child)=>parentNode.addChild(child));
        this.fastMap.delete(node.scopeRef);
    }
    // Pre Order Depth First
    *traverse(node = this.root) {
        if (node.scopeRef != null) yield node;
        if (node.children.size > 0) for (let child of node.children)yield* this.traverse(child);
    }
    clone() {
        let newTree = new $a7a032acae3ddda9$var$Tree();
        for (let node of this.traverse())newTree.addTreeNode(node.scopeRef, node.parent.scopeRef, node.nodeToRestore);
        return newTree;
    }
    constructor(){
        this.fastMap = new Map();
        this.root = new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: null
        });
        this.fastMap.set(null, this.root);
    }
}
class $a7a032acae3ddda9$var$TreeNode {
    addChild(node) {
        this.children.add(node);
        node.parent = this;
    }
    removeChild(node) {
        this.children.delete(node);
        node.parent = undefined;
    }
    constructor(props){
        this.children = new Set();
        this.contain = false;
        this.scopeRef = props.scopeRef;
    }
}
let $a7a032acae3ddda9$export$d06fae2ee68b101e = new $a7a032acae3ddda9$var$Tree();


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 




function $581a96d6eb128c1b$export$4e328f61c538687f(props = {}) {
    let { autoFocus: autoFocus = false , isTextInput: isTextInput , within: within  } = props;
    let state = (0, $aB6Cp$react.useRef)({
        isFocused: false,
        isFocusVisible: autoFocus || (0, $aB6Cp$reactariainteractions.isFocusVisible)()
    });
    let [isFocused, setFocused] = (0, $aB6Cp$react.useState)(false);
    let [isFocusVisibleState, setFocusVisible] = (0, $aB6Cp$react.useState)(()=>state.current.isFocused && state.current.isFocusVisible);
    let updateState = (0, $aB6Cp$react.useCallback)(()=>setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
    let onFocusChange = (0, $aB6Cp$react.useCallback)((isFocused)=>{
        state.current.isFocused = isFocused;
        setFocused(isFocused);
        updateState();
    }, [
        updateState
    ]);
    (0, $aB6Cp$reactariainteractions.useFocusVisibleListener)((isFocusVisible)=>{
        state.current.isFocusVisible = isFocusVisible;
        updateState();
    }, [], {
        isTextInput: isTextInput
    });
    let { focusProps: focusProps  } = (0, $aB6Cp$reactariainteractions.useFocus)({
        isDisabled: within,
        onFocusChange: onFocusChange
    });
    let { focusWithinProps: focusWithinProps  } = (0, $aB6Cp$reactariainteractions.useFocusWithin)({
        isDisabled: !within,
        onFocusWithinChange: onFocusChange
    });
    return {
        isFocused: isFocused,
        isFocusVisible: isFocusVisibleState,
        focusProps: within ? focusWithinProps : focusProps
    };
}


function $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d(props) {
    let { children: children , focusClass: focusClass , focusRingClass: focusRingClass  } = props;
    let { isFocused: isFocused , isFocusVisible: isFocusVisible , focusProps: focusProps  } = (0, $581a96d6eb128c1b$export$4e328f61c538687f)(props);
    let child = (0, ($parcel$interopDefault($aB6Cp$react))).Children.only(children);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).cloneElement(child, (0, $aB6Cp$reactariautils.mergeProps)(child.props, {
        ...focusProps,
        className: (0, ($parcel$interopDefault($aB6Cp$clsx)))({
            [focusClass || ""]: isFocused,
            [focusRingClass || ""]: isFocusVisible
        })
    }));
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



let $fb504d83237fd6ac$var$FocusableContext = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createContext(null);
function $fb504d83237fd6ac$var$useFocusableContext(ref) {
    let context = (0, $aB6Cp$react.useContext)($fb504d83237fd6ac$var$FocusableContext) || {};
    (0, $aB6Cp$reactariautils.useSyncRef)(context, ref);
    // eslint-disable-next-line
    let { ref: _ , ...otherProps } = context;
    return otherProps;
}
/**
 * Provides DOM props to the nearest focusable child.
 */ function $fb504d83237fd6ac$var$FocusableProvider(props, ref) {
    let { children: children , ...otherProps } = props;
    let context = {
        ...otherProps,
        ref: ref
    };
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement($fb504d83237fd6ac$var$FocusableContext.Provider, {
        value: context
    }, children);
}
let $fb504d83237fd6ac$export$13f3202a3e5ddd5 = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).forwardRef($fb504d83237fd6ac$var$FocusableProvider);
function $fb504d83237fd6ac$export$4c014de7c8940b4c(props, domRef) {
    let { focusProps: focusProps  } = (0, $aB6Cp$reactariainteractions.useFocus)(props);
    let { keyboardProps: keyboardProps  } = (0, $aB6Cp$reactariainteractions.useKeyboard)(props);
    let interactions = (0, $aB6Cp$reactariautils.mergeProps)(focusProps, keyboardProps);
    let domProps = $fb504d83237fd6ac$var$useFocusableContext(domRef);
    let interactionProps = props.isDisabled ? {} : domProps;
    let autoFocusRef = (0, $aB6Cp$react.useRef)(props.autoFocus);
    (0, $aB6Cp$react.useEffect)(()=>{
        if (autoFocusRef.current && domRef.current) (0, $1c7f9157d722357d$export$80f3e147d781571c)(domRef.current);
        autoFocusRef.current = false;
    }, [
        domRef
    ]);
    return {
        focusableProps: (0, $aB6Cp$reactariautils.mergeProps)({
            ...interactions,
            tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined
        }, interactionProps)
    };
}




/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $259c6413a286f2e6$export$eac1895992b9f3d6(ref, options) {
    let isDisabled = options === null || options === void 0 ? void 0 : options.isDisabled;
    let [hasTabbableChild, setHasTabbableChild] = (0, $aB6Cp$react.useState)(false);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if ((ref === null || ref === void 0 ? void 0 : ref.current) && !isDisabled) {
            let update = ()=>{
                if (ref.current) {
                    let walker = (0, $a7a032acae3ddda9$export$2d6ec8fc375ceafa)(ref.current, {
                        tabbable: true
                    });
                    setHasTabbableChild(!!walker.nextNode());
                }
            };
            update();
            // Update when new elements are inserted, or the tabIndex/disabled attribute updates.
            let observer = new MutationObserver(update);
            observer.observe(ref.current, {
                subtree: true,
                childList: true,
                attributes: true,
                attributeFilter: [
                    "tabIndex",
                    "disabled"
                ]
            });
            return ()=>{
                // Disconnect mutation observer when a React update occurs on the top-level component
                // so we update synchronously after re-rendering. Otherwise React will emit act warnings
                // in tests since mutation observers fire asynchronously. The mutation observer is necessary
                // so we also update if a child component re-renders and adds/removes something tabbable.
                observer.disconnect();
            };
        }
    });
    return isDisabled ? false : hasTabbableChild;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 81941:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $goTMa$reactariautils = __webpack_require__(29061);
var $goTMa$react = __webpack_require__(18038);
var $goTMa$reactariassr = __webpack_require__(53163);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "Pressable", () => $e1dbec26039c051d$export$27c701ed9e449e99);
$parcel$export(module.exports, "PressResponder", () => $3596bae48579386f$export$3351871ee4b288b8);
$parcel$export(module.exports, "useFocus", () => $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6);
$parcel$export(module.exports, "isFocusVisible", () => $e77252a287ef94ab$export$b9b3dfddab17db27);
$parcel$export(module.exports, "getInteractionModality", () => $e77252a287ef94ab$export$630ff653c5ada6a9);
$parcel$export(module.exports, "setInteractionModality", () => $e77252a287ef94ab$export$8397ddfc504fdb9a);
$parcel$export(module.exports, "useInteractionModality", () => $e77252a287ef94ab$export$98e20ec92f614cfe);
$parcel$export(module.exports, "useFocusVisible", () => $e77252a287ef94ab$export$ffd9e5021c1fb2d6);
$parcel$export(module.exports, "useFocusVisibleListener", () => $e77252a287ef94ab$export$ec71b4b83ac08ec3);
$parcel$export(module.exports, "useFocusWithin", () => $d16842bbd0359d1b$export$420e68273165f4ec);
$parcel$export(module.exports, "useHover", () => $ffbc150311c75f01$export$ae780daf29e6d456);
$parcel$export(module.exports, "useInteractOutside", () => $edcfa848c42f94f4$export$872b660ac5a1ff98);
$parcel$export(module.exports, "useKeyboard", () => $892d64db2a3c53b0$export$8f71654801c2f7cd);
$parcel$export(module.exports, "useMove", () => $c09386fc48fa427d$export$36da96379f79f245);
$parcel$export(module.exports, "usePress", () => $0294ea432cd92340$export$45712eceda6fad21);
$parcel$export(module.exports, "useScrollWheel", () => $a3dbce0aed7087e2$export$2123ff2b87c81ca);
$parcel$export(module.exports, "useLongPress", () => $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element
// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually
let $f7e14e656343df57$var$state = "default";
let $f7e14e656343df57$var$savedUserSelect = "";
let $f7e14e656343df57$var$modifiedElementMap = new WeakMap();
function $f7e14e656343df57$export$16a4697467175487(target) {
    if ((0, $goTMa$reactariautils.isIOS)()) {
        if ($f7e14e656343df57$var$state === "default") {
            $f7e14e656343df57$var$savedUserSelect = document.documentElement.style.webkitUserSelect;
            document.documentElement.style.webkitUserSelect = "none";
        }
        $f7e14e656343df57$var$state = "disabled";
    } else if (target instanceof HTMLElement || target instanceof SVGElement) {
        // If not iOS, store the target's original user-select and change to user-select: none
        // Ignore state since it doesn't apply for non iOS
        $f7e14e656343df57$var$modifiedElementMap.set(target, target.style.userSelect);
        target.style.userSelect = "none";
    }
}
function $f7e14e656343df57$export$b0d6fa1ab32e3295(target) {
    if ((0, $goTMa$reactariautils.isIOS)()) {
        // If the state is already default, there's nothing to do.
        // If it is restoring, then there's no need to queue a second restore.
        if ($f7e14e656343df57$var$state !== "disabled") return;
        $f7e14e656343df57$var$state = "restoring";
        // There appears to be a delay on iOS where selection still might occur
        // after pointer up, so wait a bit before removing user-select.
        setTimeout(()=>{
            // Wait for any CSS transitions to complete so we don't recompute style
            // for the whole page in the middle of the animation and cause jank.
            (0, $goTMa$reactariautils.runAfterTransition)(()=>{
                // Avoid race conditions
                if ($f7e14e656343df57$var$state === "restoring") {
                    if (document.documentElement.style.webkitUserSelect === "none") document.documentElement.style.webkitUserSelect = $f7e14e656343df57$var$savedUserSelect || "";
                    $f7e14e656343df57$var$savedUserSelect = "";
                    $f7e14e656343df57$var$state = "default";
                }
            });
        }, 300);
    } else if (target instanceof HTMLElement || target instanceof SVGElement) // If not iOS, restore the target's original user-select if any
    // Ignore state since it doesn't apply for non iOS
    {
        if (target && $f7e14e656343df57$var$modifiedElementMap.has(target)) {
            let targetOldUserSelect = $f7e14e656343df57$var$modifiedElementMap.get(target);
            if (target.style.userSelect === "none") target.style.userSelect = targetOldUserSelect;
            if (target.getAttribute("style") === "") target.removeAttribute("style");
            $f7e14e656343df57$var$modifiedElementMap.delete(target);
        }
    }
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $01d3f539e91688c8$export$5165eccb35aaadb5 = (0, ($parcel$interopDefault($goTMa$react))).createContext(null);
$01d3f539e91688c8$export$5165eccb35aaadb5.displayName = "PressResponderContext";



function $0294ea432cd92340$var$usePressResponderContext(props) {
    // Consume context from <PressResponder> and merge with props.
    let context = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));
    if (context) {
        let { register: register , ...contextProps } = context;
        props = (0, $goTMa$reactariautils.mergeProps)(contextProps, props);
        register();
    }
    (0, $goTMa$reactariautils.useSyncRef)(context, props.ref);
    return props;
}
function $0294ea432cd92340$export$45712eceda6fad21(props) {
    let { onPress: onPress , onPressChange: onPressChange , onPressStart: onPressStart , onPressEnd: onPressEnd , onPressUp: onPressUp , isDisabled: isDisabled , isPressed: isPressedProp , preventFocusOnPress: preventFocusOnPress , shouldCancelOnPointerExit: shouldCancelOnPointerExit , allowTextSelectionOnPress: allowTextSelectionOnPress , // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: _ , ...domProps } = $0294ea432cd92340$var$usePressResponderContext(props);
    let [isPressed, setPressed] = (0, $goTMa$react.useState)(false);
    let ref = (0, $goTMa$react.useRef)({
        isPressed: false,
        ignoreEmulatedMouseEvents: false,
        ignoreClickAfterPress: false,
        didFirePressStart: false,
        activePointerId: null,
        target: null,
        isOverTarget: false,
        pointerType: null
    });
    let { addGlobalListener: addGlobalListener , removeAllGlobalListeners: removeAllGlobalListeners  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let triggerPressStart = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        let state = ref.current;
        if (isDisabled || state.didFirePressStart) return;
        if (onPressStart) onPressStart({
            type: "pressstart",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
        if (onPressChange) onPressChange(true);
        state.didFirePressStart = true;
        setPressed(true);
    });
    let triggerPressEnd = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType, wasPressed = true)=>{
        let state = ref.current;
        if (!state.didFirePressStart) return;
        state.ignoreClickAfterPress = true;
        state.didFirePressStart = false;
        if (onPressEnd) onPressEnd({
            type: "pressend",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
        if (onPressChange) onPressChange(false);
        setPressed(false);
        if (onPress && wasPressed && !isDisabled) onPress({
            type: "press",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let triggerPressUp = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        if (isDisabled) return;
        if (onPressUp) onPressUp({
            type: "pressup",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let cancel = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        let state = ref.current;
        if (state.isPressed) {
            if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
            state.isPressed = false;
            state.isOverTarget = false;
            state.activePointerId = null;
            state.pointerType = null;
            removeAllGlobalListeners();
            if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
        }
    });
    let cancelOnPointerExit = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (shouldCancelOnPointerExit) cancel(e);
    });
    let pressProps = (0, $goTMa$react.useMemo)(()=>{
        let state = ref.current;
        let pressProps = {
            onKeyDown (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {
                    if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                    e.stopPropagation();
                    // If the event is repeating, it may have started on a different element
                    // after which focus moved to the current element. Ignore these events and
                    // only handle the first key down event.
                    if (!state.isPressed && !e.repeat) {
                        state.target = e.currentTarget;
                        state.isPressed = true;
                        triggerPressStart(e, "keyboard");
                        // Focus may move before the key up event, so register the event on the document
                        // instead of the same element where the key down event occurred.
                        addGlobalListener(document, "keyup", onKeyUp, false);
                    }
                } else if (e.key === "Enter" && $0294ea432cd92340$var$isHTMLAnchorLink(e.currentTarget)) // If the target is a link, we won't have handled this above because we want the default
                // browser behavior to open the link when pressing Enter. But we still need to prevent
                // default so that elements above do not also handle it (e.g. table row).
                e.stopPropagation();
            },
            onKeyUp (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target)) triggerPressUp($0294ea432cd92340$var$createEvent(state.target, e), "keyboard");
            },
            onClick (e) {
                if (e && !e.currentTarget.contains(e.target)) return;
                if (e && e.button === 0) {
                    e.stopPropagation();
                    if (isDisabled) e.preventDefault();
                    // If triggered from a screen reader or by using element.click(),
                    // trigger as if it were a keyboard click.
                    if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && (state.pointerType === "virtual" || (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent))) {
                        // Ensure the element receives focus (VoiceOver on iOS does not do this)
                        if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                        triggerPressStart(e, "virtual");
                        triggerPressUp(e, "virtual");
                        triggerPressEnd(e, "virtual");
                    }
                    state.ignoreEmulatedMouseEvents = false;
                    state.ignoreClickAfterPress = false;
                }
            }
        };
        let onKeyUp = (e)=>{
            if (state.isPressed && $0294ea432cd92340$var$isValidKeyboardEvent(e, state.target)) {
                if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                e.stopPropagation();
                state.isPressed = false;
                let target = e.target;
                triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), "keyboard", state.target.contains(target));
                removeAllGlobalListeners();
                // If the target is a link, trigger the click method to open the URL,
                // but defer triggering pressEnd until onClick event handler.
                if (state.target instanceof HTMLElement && state.target.contains(target) && ($0294ea432cd92340$var$isHTMLAnchorLink(state.target) || state.target.getAttribute("role") === "link")) state.target.click();
            }
        };
        if (typeof PointerEvent !== "undefined") {
            pressProps.onPointerDown = (e)=>{
                // Only handle left clicks, and ignore events that bubbled through portals.
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.
                // Ignore and let the onClick handler take care of it instead.
                // https://bugs.webkit.org/show_bug.cgi?id=222627
                // https://bugs.webkit.org/show_bug.cgi?id=223202
                if ((0, $goTMa$reactariautils.isVirtualPointerEvent)(e.nativeEvent)) {
                    state.pointerType = "virtual";
                    return;
                }
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on pointer down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                state.pointerType = e.pointerType;
                e.stopPropagation();
                if (!state.isPressed) {
                    state.isPressed = true;
                    state.isOverTarget = true;
                    state.activePointerId = e.pointerId;
                    state.target = e.currentTarget;
                    if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                    if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);
                    triggerPressStart(e, state.pointerType);
                    addGlobalListener(document, "pointermove", onPointerMove, false);
                    addGlobalListener(document, "pointerup", onPointerUp, false);
                    addGlobalListener(document, "pointercancel", onPointerCancel, false);
                }
            };
            pressProps.onMouseDown = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (e.button === 0) {
                    // Chrome and Firefox on touch Windows devices require mouse down events
                    // to be canceled in addition to pointer events, or an extra asynchronous
                    // focus event will be fired.
                    if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                    e.stopPropagation();
                }
            };
            pressProps.onPointerUp = (e)=>{
                // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.
                if (!e.currentTarget.contains(e.target) || state.pointerType === "virtual") return;
                // Only handle left clicks
                // Safari on iOS sometimes fires pointerup events, even
                // when the touch isn't over the target, so double check.
                if (e.button === 0 && $0294ea432cd92340$var$isOverTarget(e, e.currentTarget)) triggerPressUp(e, state.pointerType || e.pointerType);
            };
            // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.
            // Use pointer move events instead to implement our own hit testing.
            // See https://bugs.webkit.org/show_bug.cgi?id=199803
            let onPointerMove = (e)=>{
                if (e.pointerId !== state.activePointerId) return;
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0) {
                    if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    state.isPressed = false;
                    state.isOverTarget = false;
                    state.activePointerId = null;
                    state.pointerType = null;
                    removeAllGlobalListeners();
                    if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
                }
            };
            let onPointerCancel = (e)=>{
                cancel(e);
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.
                cancel(e);
            };
        } else {
            pressProps.onMouseDown = (e)=>{
                // Only handle left clicks
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on mouse down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                e.stopPropagation();
                if (state.ignoreEmulatedMouseEvents) return;
                state.isPressed = true;
                state.isOverTarget = true;
                state.target = e.currentTarget;
                state.pointerType = (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent) ? "virtual" : "mouse";
                if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(document, "mouseup", onMouseUp, false);
            };
            pressProps.onMouseEnter = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = true;
                    triggerPressStart(e, state.pointerType);
                }
            };
            pressProps.onMouseLeave = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            pressProps.onMouseUp = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType);
            };
            let onMouseUp = (e)=>{
                // Only handle left clicks
                if (e.button !== 0) return;
                state.isPressed = false;
                removeAllGlobalListeners();
                if (state.ignoreEmulatedMouseEvents) {
                    state.ignoreEmulatedMouseEvents = false;
                    return;
                }
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                state.isOverTarget = false;
            };
            pressProps.onTouchStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                let touch = $0294ea432cd92340$var$getTouchFromEvent(e.nativeEvent);
                if (!touch) return;
                state.activePointerId = touch.identifier;
                state.ignoreEmulatedMouseEvents = true;
                state.isOverTarget = true;
                state.isPressed = true;
                state.target = e.currentTarget;
                state.pointerType = "touch";
                // Due to browser inconsistencies, especially on mobile browsers, we prevent default
                // on the emulated mouse event and handle focusing the pressable element ourselves.
                if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(window, "scroll", onScroll, true);
            };
            pressProps.onTouchMove = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart(e, state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            pressProps.onTouchEnd = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    triggerPressUp(e, state.pointerType);
                    triggerPressEnd(e, state.pointerType);
                } else if (state.isOverTarget) triggerPressEnd(e, state.pointerType, false);
                state.isPressed = false;
                state.activePointerId = null;
                state.isOverTarget = false;
                state.ignoreEmulatedMouseEvents = true;
                if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
                removeAllGlobalListeners();
            };
            pressProps.onTouchCancel = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed) cancel(e);
            };
            let onScroll = (e)=>{
                if (state.isPressed && e.target.contains(state.target)) cancel({
                    currentTarget: state.target,
                    shiftKey: false,
                    ctrlKey: false,
                    metaKey: false,
                    altKey: false
                });
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                cancel(e);
            };
        }
        return pressProps;
    }, [
        addGlobalListener,
        isDisabled,
        preventFocusOnPress,
        removeAllGlobalListeners,
        allowTextSelectionOnPress,
        cancel,
        cancelOnPointerExit,
        triggerPressEnd,
        triggerPressStart,
        triggerPressUp
    ]);
    // Remove user-select: none in case component unmounts immediately after pressStart
    // eslint-disable-next-line arrow-body-style
    (0, $goTMa$react.useEffect)(()=>{
        return ()=>{
            if (!allowTextSelectionOnPress) // eslint-disable-next-line react-hooks/exhaustive-deps
            (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(ref.current.target);
        };
    }, [
        allowTextSelectionOnPress
    ]);
    return {
        isPressed: isPressedProp || isPressed,
        pressProps: (0, $goTMa$reactariautils.mergeProps)(domProps, pressProps)
    };
}
function $0294ea432cd92340$var$isHTMLAnchorLink(target) {
    return target.tagName === "A" && target.hasAttribute("href");
}
function $0294ea432cd92340$var$isValidKeyboardEvent(event, currentTarget) {
    const { key: key , code: code  } = event;
    const element = currentTarget;
    const role = element.getAttribute("role");
    // Accessibility for keyboards. Space and Enter only.
    // "Spacebar" is for IE 11
    return (key === "Enter" || key === " " || key === "Spacebar" || code === "Space") && !(element instanceof HTMLInputElement && !$0294ea432cd92340$var$isValidInputKey(element, key) || element instanceof HTMLTextAreaElement || element.isContentEditable) && // A link with a valid href should be handled natively,
    // unless it also has role='button' and was triggered using Space.
    (!$0294ea432cd92340$var$isHTMLAnchorLink(element) || role === "button" && key !== "Enter") && // An element with role='link' should only trigger with Enter key
    !(role === "link" && key !== "Enter");
}
function $0294ea432cd92340$var$getTouchFromEvent(event) {
    const { targetTouches: targetTouches  } = event;
    if (targetTouches.length > 0) return targetTouches[0];
    return null;
}
function $0294ea432cd92340$var$getTouchById(event, pointerId) {
    const changedTouches = event.changedTouches;
    for(let i = 0; i < changedTouches.length; i++){
        const touch = changedTouches[i];
        if (touch.identifier === pointerId) return touch;
    }
    return null;
}
function $0294ea432cd92340$var$createEvent(target, e) {
    return {
        currentTarget: target,
        shiftKey: e.shiftKey,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey
    };
}
function $0294ea432cd92340$var$getPointClientRect(point) {
    let offsetX = point.width / 2 || point.radiusX || 0;
    let offsetY = point.height / 2 || point.radiusY || 0;
    return {
        top: point.clientY - offsetY,
        right: point.clientX + offsetX,
        bottom: point.clientY + offsetY,
        left: point.clientX - offsetX
    };
}
function $0294ea432cd92340$var$areRectanglesOverlapping(a, b) {
    // check if they cannot overlap on x axis
    if (a.left > b.right || b.left > a.right) return false;
    // check if they cannot overlap on y axis
    if (a.top > b.bottom || b.top > a.bottom) return false;
    return true;
}
function $0294ea432cd92340$var$isOverTarget(point, target) {
    let rect = target.getBoundingClientRect();
    let pointRect = $0294ea432cd92340$var$getPointClientRect(point);
    return $0294ea432cd92340$var$areRectanglesOverlapping(rect, pointRect);
}
function $0294ea432cd92340$var$shouldPreventDefault(target) {
    // We cannot prevent default if the target is a draggable element.
    return !(target instanceof HTMLElement) || !target.draggable;
}
function $0294ea432cd92340$var$shouldPreventDefaultKeyboard(target, key) {
    if (target instanceof HTMLInputElement) return !$0294ea432cd92340$var$isValidInputKey(target, key);
    if (target instanceof HTMLButtonElement) return target.type !== "submit";
    return true;
}
const $0294ea432cd92340$var$nonTextInputTypes = new Set([
    "checkbox",
    "radio",
    "range",
    "color",
    "file",
    "image",
    "button",
    "submit",
    "reset"
]);
function $0294ea432cd92340$var$isValidInputKey(target, key) {
    // Only space should toggle checkboxes and radios, not enter.
    return target.type === "checkbox" || target.type === "radio" ? key === " " : $0294ea432cd92340$var$nonTextInputTypes.has(target.type);
}



const $e1dbec26039c051d$export$27c701ed9e449e99 = /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).forwardRef(({ children: children , ...props }, ref)=>{
    let newRef = (0, $goTMa$react.useRef)();
    ref = ref !== null && ref !== void 0 ? ref : newRef;
    let { pressProps: pressProps  } = (0, $0294ea432cd92340$export$45712eceda6fad21)({
        ...props,
        ref: ref
    });
    let child = (0, ($parcel$interopDefault($goTMa$react))).Children.only(children);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).cloneElement(child, // @ts-ignore
    {
        ref: ref,
        ...(0, $goTMa$reactariautils.mergeProps)(child.props, pressProps)
    });
});


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $3596bae48579386f$export$3351871ee4b288b8 = /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).forwardRef(({ children: children , ...props }, ref)=>{
    let isRegistered = (0, $goTMa$react.useRef)(false);
    let prevContext = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));
    let context = (0, $goTMa$reactariautils.mergeProps)(prevContext || {}, {
        ...props,
        ref: ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref),
        register () {
            isRegistered.current = true;
            if (prevContext) prevContext.register();
        }
    });
    (0, $goTMa$reactariautils.useSyncRef)(prevContext, ref);
    (0, $goTMa$react.useEffect)(()=>{
        if (!isRegistered.current) {
            console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.");
            isRegistered.current = true; // only warn once in strict mode.
        }
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).createElement((0, $01d3f539e91688c8$export$5165eccb35aaadb5).Provider, {
        value: context
    }, children);
});


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

class $625cf83917e112ad$export$905e7fc544a71f36 {
    isDefaultPrevented() {
        return this.nativeEvent.defaultPrevented;
    }
    preventDefault() {
        this.defaultPrevented = true;
        this.nativeEvent.preventDefault();
    }
    stopPropagation() {
        this.nativeEvent.stopPropagation();
        this.isPropagationStopped = ()=>true;
    }
    isPropagationStopped() {
        return false;
    }
    persist() {}
    constructor(type, nativeEvent){
        this.nativeEvent = nativeEvent;
        this.target = nativeEvent.target;
        this.currentTarget = nativeEvent.currentTarget;
        this.relatedTarget = nativeEvent.relatedTarget;
        this.bubbles = nativeEvent.bubbles;
        this.cancelable = nativeEvent.cancelable;
        this.defaultPrevented = nativeEvent.defaultPrevented;
        this.eventPhase = nativeEvent.eventPhase;
        this.isTrusted = nativeEvent.isTrusted;
        this.timeStamp = nativeEvent.timeStamp;
        this.type = type;
    }
}
function $625cf83917e112ad$export$715c682d09d639cc(onBlur) {
    let stateRef = (0, $goTMa$react.useRef)({
        isFocused: false,
        observer: null
    });
    // Clean up MutationObserver on unmount. See below.
    // eslint-disable-next-line arrow-body-style
    (0, $goTMa$reactariautils.useLayoutEffect)(()=>{
        const state = stateRef.current;
        return ()=>{
            if (state.observer) {
                state.observer.disconnect();
                state.observer = null;
            }
        };
    }, []);
    let dispatchBlur = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
    });
    // This function is called during a React onFocus event.
    return (0, $goTMa$react.useCallback)((e)=>{
        // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142
        // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a
        // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.
        // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.
        if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {
            stateRef.current.isFocused = true;
            let target = e.target;
            let onBlurHandler = (e)=>{
                stateRef.current.isFocused = false;
                if (target.disabled) // For backward compatibility, dispatch a (fake) React synthetic event.
                dispatchBlur(new $625cf83917e112ad$export$905e7fc544a71f36("blur", e));
                // We no longer need the MutationObserver once the target is blurred.
                if (stateRef.current.observer) {
                    stateRef.current.observer.disconnect();
                    stateRef.current.observer = null;
                }
            };
            target.addEventListener("focusout", onBlurHandler, {
                once: true
            });
            stateRef.current.observer = new MutationObserver(()=>{
                if (stateRef.current.isFocused && target.disabled) {
                    stateRef.current.observer.disconnect();
                    let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
                    target.dispatchEvent(new FocusEvent("blur", {
                        relatedTarget: relatedTargetEl
                    }));
                    target.dispatchEvent(new FocusEvent("focusout", {
                        bubbles: true,
                        relatedTarget: relatedTargetEl
                    }));
                }
            });
            stateRef.current.observer.observe(target, {
                attributes: true,
                attributeFilter: [
                    "disabled"
                ]
            });
        }
    }, [
        dispatchBlur
    ]);
}


function $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6(props) {
    let { isDisabled: isDisabled , onFocus: onFocusProp , onBlur: onBlurProp , onFocusChange: onFocusChange  } = props;
    const onBlur = (0, $goTMa$react.useCallback)((e)=>{
        if (e.target === e.currentTarget) {
            if (onBlurProp) onBlurProp(e);
            if (onFocusChange) onFocusChange(false);
            return true;
        }
    }, [
        onBlurProp,
        onFocusChange
    ]);
    const onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);
    const onFocus = (0, $goTMa$react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (e.target === e.currentTarget && document.activeElement === e.target) {
            if (onFocusProp) onFocusProp(e);
            if (onFocusChange) onFocusChange(true);
            onSyntheticFocus(e);
        }
    }, [
        onFocusChange,
        onFocusProp,
        onSyntheticFocus
    ]);
    return {
        focusProps: {
            onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,
            onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : undefined
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions



let $e77252a287ef94ab$var$currentModality = null;
let $e77252a287ef94ab$var$changeHandlers = new Set();
let $e77252a287ef94ab$var$hasSetupGlobalListeners = false;
let $e77252a287ef94ab$var$hasEventBeforeFocus = false;
let $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
// Only Tab or Esc keys will make focus visible on text input elements
const $e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS = {
    Tab: true,
    Escape: true
};
function $e77252a287ef94ab$var$triggerChangeHandlers(modality, e) {
    for (let handler of $e77252a287ef94ab$var$changeHandlers)handler(modality, e);
}
/**
 * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.
 */ function $e77252a287ef94ab$var$isValidKey(e) {
    // Control and Shift keys trigger when navigating back to the tab with keyboard.
    return !(e.metaKey || !(0, $goTMa$reactariautils.isMac)() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
function $e77252a287ef94ab$var$handleKeyboardEvent(e) {
    $e77252a287ef94ab$var$hasEventBeforeFocus = true;
    if ($e77252a287ef94ab$var$isValidKey(e)) {
        $e77252a287ef94ab$var$currentModality = "keyboard";
        $e77252a287ef94ab$var$triggerChangeHandlers("keyboard", e);
    }
}
function $e77252a287ef94ab$var$handlePointerEvent(e) {
    $e77252a287ef94ab$var$currentModality = "pointer";
    if (e.type === "mousedown" || e.type === "pointerdown") {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$triggerChangeHandlers("pointer", e);
    }
}
function $e77252a287ef94ab$var$handleClickEvent(e) {
    if ((0, $goTMa$reactariautils.isVirtualClick)(e)) {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$currentModality = "virtual";
    }
}
function $e77252a287ef94ab$var$handleFocusEvent(e) {
    // Firefox fires two extra focus events when the user first clicks into an iframe:
    // first on the window, then on the document. We ignore these events so they don't
    // cause keyboard focus rings to appear.
    if (e.target === window || e.target === document) return;
    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.
    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.
    if (!$e77252a287ef94ab$var$hasEventBeforeFocus && !$e77252a287ef94ab$var$hasBlurredWindowRecently) {
        $e77252a287ef94ab$var$currentModality = "virtual";
        $e77252a287ef94ab$var$triggerChangeHandlers("virtual", e);
    }
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
}
function $e77252a287ef94ab$var$handleWindowBlur() {
    // When the window is blurred, reset state. This is necessary when tabbing out of the window,
    // for example, since a subsequent focus event won't be fired.
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = true;
}
/**
 * Setup global event listeners to control when keyboard focus style should be visible.
 */ function $e77252a287ef94ab$var$setupGlobalFocusEvents() {
    if (typeof window === "undefined" || $e77252a287ef94ab$var$hasSetupGlobalListeners) return;
    // Programmatic focus() calls shouldn't affect the current input modality.
    // However, we need to detect other cases when a focus event occurs without
    // a preceding user event (e.g. screen reader focus). Overriding the focus
    // method on HTMLElement.prototype is a bit hacky, but works.
    let focus = HTMLElement.prototype.focus;
    HTMLElement.prototype.focus = function() {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        focus.apply(this, arguments);
    };
    document.addEventListener("keydown", $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener("keyup", $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener("click", $e77252a287ef94ab$var$handleClickEvent, true);
    // Register focus events on the window so they are sure to happen
    // before React's event listeners (registered on the document).
    window.addEventListener("focus", $e77252a287ef94ab$var$handleFocusEvent, true);
    window.addEventListener("blur", $e77252a287ef94ab$var$handleWindowBlur, false);
    if (typeof PointerEvent !== "undefined") {
        document.addEventListener("pointerdown", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("pointermove", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("pointerup", $e77252a287ef94ab$var$handlePointerEvent, true);
    } else {
        document.addEventListener("mousedown", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("mousemove", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("mouseup", $e77252a287ef94ab$var$handlePointerEvent, true);
    }
    $e77252a287ef94ab$var$hasSetupGlobalListeners = true;
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e77252a287ef94ab$var$setupGlobalFocusEvents();
    else document.addEventListener("DOMContentLoaded", $e77252a287ef94ab$var$setupGlobalFocusEvents);
}
function $e77252a287ef94ab$export$b9b3dfddab17db27() {
    return $e77252a287ef94ab$var$currentModality !== "pointer";
}
function $e77252a287ef94ab$export$630ff653c5ada6a9() {
    return $e77252a287ef94ab$var$currentModality;
}
function $e77252a287ef94ab$export$8397ddfc504fdb9a(modality) {
    $e77252a287ef94ab$var$currentModality = modality;
    $e77252a287ef94ab$var$triggerChangeHandlers(modality, null);
}
function $e77252a287ef94ab$export$98e20ec92f614cfe() {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    let [modality, setModality] = (0, $goTMa$react.useState)($e77252a287ef94ab$var$currentModality);
    (0, $goTMa$react.useEffect)(()=>{
        let handler = ()=>{
            setModality($e77252a287ef94ab$var$currentModality);
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    }, []);
    return (0, $goTMa$reactariassr.useIsSSR)() ? null : modality;
}
/**
 * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that
 * focus visible style can be properly set.
 */ function $e77252a287ef94ab$var$isKeyboardFocusEvent(isTextInput, modality, e) {
    return !(isTextInput && modality === "keyboard" && e instanceof KeyboardEvent && !$e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);
}
function $e77252a287ef94ab$export$ffd9e5021c1fb2d6(props = {}) {
    let { isTextInput: isTextInput , autoFocus: autoFocus  } = props;
    let [isFocusVisibleState, setFocusVisible] = (0, $goTMa$react.useState)(autoFocus || $e77252a287ef94ab$export$b9b3dfddab17db27());
    $e77252a287ef94ab$export$ec71b4b83ac08ec3((isFocusVisible)=>{
        setFocusVisible(isFocusVisible);
    }, [
        isTextInput
    ], {
        isTextInput: isTextInput
    });
    return {
        isFocusVisible: isFocusVisibleState
    };
}
function $e77252a287ef94ab$export$ec71b4b83ac08ec3(fn, deps, opts) {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    (0, $goTMa$react.useEffect)(()=>{
        let handler = (modality, e)=>{
            if (!$e77252a287ef94ab$var$isKeyboardFocusEvent(opts === null || opts === void 0 ? void 0 : opts.isTextInput, modality, e)) return;
            fn($e77252a287ef94ab$export$b9b3dfddab17db27());
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, deps);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $d16842bbd0359d1b$export$420e68273165f4ec(props) {
    let { isDisabled: isDisabled , onBlurWithin: onBlurWithin , onFocusWithin: onFocusWithin , onFocusWithinChange: onFocusWithinChange  } = props;
    let state = (0, $goTMa$react.useRef)({
        isFocusWithin: false
    });
    let onBlur = (0, $goTMa$react.useCallback)((e)=>{
        // We don't want to trigger onBlurWithin and then immediately onFocusWithin again
        // when moving focus inside the element. Only trigger if the currentTarget doesn't
        // include the relatedTarget (where focus is moving).
        if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {
            state.current.isFocusWithin = false;
            if (onBlurWithin) onBlurWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(false);
        }
    }, [
        onBlurWithin,
        onFocusWithinChange,
        state
    ]);
    let onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);
    let onFocus = (0, $goTMa$react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (!state.current.isFocusWithin && document.activeElement === e.target) {
            if (onFocusWithin) onFocusWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(true);
            state.current.isFocusWithin = true;
            onSyntheticFocus(e);
        }
    }, [
        onFocusWithin,
        onFocusWithinChange,
        onSyntheticFocus
    ]);
    if (isDisabled) return {
        focusWithinProps: {
            onFocus: null,
            onBlur: null
        }
    };
    return {
        focusWithinProps: {
            onFocus: onFocus,
            onBlur: onBlur
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

// iOS fires onPointerEnter twice: once with pointerType="touch" and again with pointerType="mouse".
// We want to ignore these emulated events so they do not trigger hover behavior.
// See https://bugs.webkit.org/show_bug.cgi?id=214609.
let $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
let $ffbc150311c75f01$var$hoverCount = 0;
function $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents() {
    $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = true;
    // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter
    // with pointerType="mouse" immediately after onPointerUp and before onFocus. On other
    // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in
    // the distant future because a user previously touched the element.
    setTimeout(()=>{
        $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
    }, 50);
}
function $ffbc150311c75f01$var$handleGlobalPointerEvent(e) {
    if (e.pointerType === "touch") $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $ffbc150311c75f01$var$setupGlobalTouchEvents() {
    if (typeof document === "undefined") return;
    if (typeof PointerEvent !== "undefined") document.addEventListener("pointerup", $ffbc150311c75f01$var$handleGlobalPointerEvent);
    else document.addEventListener("touchend", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    $ffbc150311c75f01$var$hoverCount++;
    return ()=>{
        $ffbc150311c75f01$var$hoverCount--;
        if ($ffbc150311c75f01$var$hoverCount > 0) return;
        if (typeof PointerEvent !== "undefined") document.removeEventListener("pointerup", $ffbc150311c75f01$var$handleGlobalPointerEvent);
        else document.removeEventListener("touchend", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    };
}
function $ffbc150311c75f01$export$ae780daf29e6d456(props) {
    let { onHoverStart: onHoverStart , onHoverChange: onHoverChange , onHoverEnd: onHoverEnd , isDisabled: isDisabled  } = props;
    let [isHovered, setHovered] = (0, $goTMa$react.useState)(false);
    let state = (0, $goTMa$react.useRef)({
        isHovered: false,
        ignoreEmulatedMouseEvents: false,
        pointerType: "",
        target: null
    }).current;
    (0, $goTMa$react.useEffect)($ffbc150311c75f01$var$setupGlobalTouchEvents, []);
    let { hoverProps: hoverProps , triggerHoverEnd: triggerHoverEnd  } = (0, $goTMa$react.useMemo)(()=>{
        let triggerHoverStart = (event, pointerType)=>{
            state.pointerType = pointerType;
            if (isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target)) return;
            state.isHovered = true;
            let target = event.currentTarget;
            state.target = target;
            if (onHoverStart) onHoverStart({
                type: "hoverstart",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(true);
            setHovered(true);
        };
        let triggerHoverEnd = (event, pointerType)=>{
            state.pointerType = "";
            state.target = null;
            if (pointerType === "touch" || !state.isHovered) return;
            state.isHovered = false;
            let target = event.currentTarget;
            if (onHoverEnd) onHoverEnd({
                type: "hoverend",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(false);
            setHovered(false);
        };
        let hoverProps = {};
        if (typeof PointerEvent !== "undefined") {
            hoverProps.onPointerEnter = (e)=>{
                if ($ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents && e.pointerType === "mouse") return;
                triggerHoverStart(e, e.pointerType);
            };
            hoverProps.onPointerLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);
            };
        } else {
            hoverProps.onTouchStart = ()=>{
                state.ignoreEmulatedMouseEvents = true;
            };
            hoverProps.onMouseEnter = (e)=>{
                if (!state.ignoreEmulatedMouseEvents && !$ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, "mouse");
                state.ignoreEmulatedMouseEvents = false;
            };
            hoverProps.onMouseLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, "mouse");
            };
        }
        return {
            hoverProps: hoverProps,
            triggerHoverEnd: triggerHoverEnd
        };
    }, [
        onHoverStart,
        onHoverChange,
        onHoverEnd,
        isDisabled,
        state
    ]);
    (0, $goTMa$react.useEffect)(()=>{
        // Call the triggerHoverEnd as soon as isDisabled changes to true
        // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering
        if (isDisabled) triggerHoverEnd({
            currentTarget: state.target
        }, state.pointerType);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        isDisabled
    ]);
    return {
        hoverProps: hoverProps,
        isHovered: isHovered
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $edcfa848c42f94f4$export$872b660ac5a1ff98(props) {
    let { ref: ref , onInteractOutside: onInteractOutside , isDisabled: isDisabled , onInteractOutsideStart: onInteractOutsideStart  } = props;
    let stateRef = (0, $goTMa$react.useRef)({
        isPointerDown: false,
        ignoreEmulatedMouseEvents: false
    });
    let onPointerDown = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (onInteractOutside && $edcfa848c42f94f4$var$isValidEvent(e, ref)) {
            if (onInteractOutsideStart) onInteractOutsideStart(e);
            stateRef.current.isPointerDown = true;
        }
    });
    let triggerInteractOutside = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (onInteractOutside) onInteractOutside(e);
    });
    (0, $goTMa$react.useEffect)(()=>{
        let state = stateRef.current;
        if (isDisabled) return;
        // Use pointer events if available. Otherwise, fall back to mouse and touch events.
        if (typeof PointerEvent !== "undefined") {
            let onPointerUp = (e)=>{
                if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            // changing these to capture phase fixed combobox
            document.addEventListener("pointerdown", onPointerDown, true);
            document.addEventListener("pointerup", onPointerUp, true);
            return ()=>{
                document.removeEventListener("pointerdown", onPointerDown, true);
                document.removeEventListener("pointerup", onPointerUp, true);
            };
        } else {
            let onMouseUp = (e)=>{
                if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;
                else if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            let onTouchEnd = (e)=>{
                state.ignoreEmulatedMouseEvents = true;
                if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            document.addEventListener("mousedown", onPointerDown, true);
            document.addEventListener("mouseup", onMouseUp, true);
            document.addEventListener("touchstart", onPointerDown, true);
            document.addEventListener("touchend", onTouchEnd, true);
            return ()=>{
                document.removeEventListener("mousedown", onPointerDown, true);
                document.removeEventListener("mouseup", onMouseUp, true);
                document.removeEventListener("touchstart", onPointerDown, true);
                document.removeEventListener("touchend", onTouchEnd, true);
            };
        }
    }, [
        ref,
        isDisabled,
        onPointerDown,
        triggerInteractOutside
    ]);
}
function $edcfa848c42f94f4$var$isValidEvent(event, ref) {
    if (event.button > 0) return false;
    if (event.target) {
        // if the event target is no longer in the document, ignore
        const ownerDocument = event.target.ownerDocument;
        if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;
        // If the target is within a top layer element (e.g. toasts), ignore.
        if (event.target.closest("[data-react-aria-top-layer]")) return false;
    }
    return ref.current && !ref.current.contains(event.target);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $951fbcbbca8db6ce$export$48d1ea6320830260(handler) {
    if (!handler) return;
    let shouldStopPropagation = true;
    return (e)=>{
        let event = {
            ...e,
            preventDefault () {
                e.preventDefault();
            },
            isDefaultPrevented () {
                return e.isDefaultPrevented();
            },
            stopPropagation () {
                console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
            },
            continuePropagation () {
                shouldStopPropagation = false;
            }
        };
        handler(event);
        if (shouldStopPropagation) e.stopPropagation();
    };
}


function $892d64db2a3c53b0$export$8f71654801c2f7cd(props) {
    return {
        keyboardProps: props.isDisabled ? {} : {
            onKeyDown: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyDown),
            onKeyUp: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyUp)
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $c09386fc48fa427d$export$36da96379f79f245(props) {
    let { onMoveStart: onMoveStart , onMove: onMove , onMoveEnd: onMoveEnd  } = props;
    let state = (0, $goTMa$react.useRef)({
        didMove: false,
        lastPosition: null,
        id: null
    });
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let move = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType, deltaX, deltaY)=>{
        if (deltaX === 0 && deltaY === 0) return;
        if (!state.current.didMove) {
            state.current.didMove = true;
            onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart({
                type: "movestart",
                pointerType: pointerType,
                shiftKey: originalEvent.shiftKey,
                metaKey: originalEvent.metaKey,
                ctrlKey: originalEvent.ctrlKey,
                altKey: originalEvent.altKey
            });
        }
        onMove({
            type: "move",
            pointerType: pointerType,
            deltaX: deltaX,
            deltaY: deltaY,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let end = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)();
        if (state.current.didMove) onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd({
            type: "moveend",
            pointerType: pointerType,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let moveProps = (0, $goTMa$react.useMemo)(()=>{
        let moveProps = {};
        let start = ()=>{
            (0, $f7e14e656343df57$export$16a4697467175487)();
            state.current.didMove = false;
        };
        if (typeof PointerEvent === "undefined") {
            let onMouseMove = (e)=>{
                if (e.button === 0) {
                    move(e, "mouse", e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onMouseUp = (e)=>{
                if (e.button === 0) {
                    end(e, "mouse");
                    removeGlobalListener(window, "mousemove", onMouseMove, false);
                    removeGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            moveProps.onMouseDown = (e)=>{
                if (e.button === 0) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    addGlobalListener(window, "mousemove", onMouseMove, false);
                    addGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            let onTouchMove = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id);
                if (touch >= 0) {
                    let { pageX: pageX , pageY: pageY  } = e.changedTouches[touch];
                    move(e, "touch", pageX - state.current.lastPosition.pageX, pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: pageX,
                        pageY: pageY
                    };
                }
            };
            let onTouchEnd = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id);
                if (touch >= 0) {
                    end(e, "touch");
                    state.current.id = null;
                    removeGlobalListener(window, "touchmove", onTouchMove);
                    removeGlobalListener(window, "touchend", onTouchEnd);
                    removeGlobalListener(window, "touchcancel", onTouchEnd);
                }
            };
            moveProps.onTouchStart = (e)=>{
                if (e.changedTouches.length === 0 || state.current.id != null) return;
                let { pageX: pageX , pageY: pageY , identifier: identifier  } = e.changedTouches[0];
                start();
                e.stopPropagation();
                e.preventDefault();
                state.current.lastPosition = {
                    pageX: pageX,
                    pageY: pageY
                };
                state.current.id = identifier;
                addGlobalListener(window, "touchmove", onTouchMove, false);
                addGlobalListener(window, "touchend", onTouchEnd, false);
                addGlobalListener(window, "touchcancel", onTouchEnd, false);
            };
        } else {
            let onPointerMove = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    // Problems with PointerEvent#movementX/movementY:
                    // 1. it is always 0 on macOS Safari.
                    // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS
                    move(e, pointerType, e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    end(e, pointerType);
                    state.current.id = null;
                    removeGlobalListener(window, "pointermove", onPointerMove, false);
                    removeGlobalListener(window, "pointerup", onPointerUp, false);
                    removeGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
            moveProps.onPointerDown = (e)=>{
                if (e.button === 0 && state.current.id == null) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    state.current.id = e.pointerId;
                    addGlobalListener(window, "pointermove", onPointerMove, false);
                    addGlobalListener(window, "pointerup", onPointerUp, false);
                    addGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
        }
        let triggerKeyboardMove = (e, deltaX, deltaY)=>{
            start();
            move(e, "keyboard", deltaX, deltaY);
            end(e, "keyboard");
        };
        moveProps.onKeyDown = (e)=>{
            switch(e.key){
                case "Left":
                case "ArrowLeft":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, -1, 0);
                    break;
                case "Right":
                case "ArrowRight":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 1, 0);
                    break;
                case "Up":
                case "ArrowUp":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, -1);
                    break;
                case "Down":
                case "ArrowDown":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, 1);
                    break;
            }
        };
        return moveProps;
    }, [
        state,
        addGlobalListener,
        removeGlobalListener,
        move,
        end
    ]);
    return {
        moveProps: moveProps
    };
}



/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $a3dbce0aed7087e2$export$2123ff2b87c81ca(props, ref) {
    let { onScroll: onScroll , isDisabled: isDisabled  } = props;
    let onScrollHandler = (0, $goTMa$react.useCallback)((e)=>{
        // If the ctrlKey is pressed, this is a zoom event, do nothing.
        if (e.ctrlKey) return;
        // stop scrolling the page
        e.preventDefault();
        e.stopPropagation();
        if (onScroll) onScroll({
            deltaX: e.deltaX,
            deltaY: e.deltaY
        });
    }, [
        onScroll
    ]);
    (0, $goTMa$reactariautils.useEvent)(ref, "wheel", isDisabled ? null : onScrollHandler);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD = 500;
function $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9(props) {
    let { isDisabled: isDisabled , onLongPressStart: onLongPressStart , onLongPressEnd: onLongPressEnd , onLongPress: onLongPress , threshold: threshold = $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD , accessibilityDescription: accessibilityDescription  } = props;
    const timeRef = (0, $goTMa$react.useRef)(null);
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let { pressProps: pressProps  } = (0, $0294ea432cd92340$export$45712eceda6fad21)({
        isDisabled: isDisabled,
        onPressStart (e) {
            if (e.pointerType === "mouse" || e.pointerType === "touch") {
                if (onLongPressStart) onLongPressStart({
                    ...e,
                    type: "longpressstart"
                });
                timeRef.current = setTimeout(()=>{
                    // Prevent other usePress handlers from also handling this event.
                    e.target.dispatchEvent(new PointerEvent("pointercancel", {
                        bubbles: true
                    }));
                    if (onLongPress) onLongPress({
                        ...e,
                        type: "longpress"
                    });
                    timeRef.current = null;
                }, threshold);
                // Prevent context menu, which may be opened on long press on touch devices
                if (e.pointerType === "touch") {
                    let onContextMenu = (e)=>{
                        e.preventDefault();
                    };
                    addGlobalListener(e.target, "contextmenu", onContextMenu, {
                        once: true
                    });
                    addGlobalListener(window, "pointerup", ()=>{
                        // If no contextmenu event is fired quickly after pointerup, remove the handler
                        // so future context menu events outside a long press are not prevented.
                        setTimeout(()=>{
                            removeGlobalListener(e.target, "contextmenu", onContextMenu);
                        }, 30);
                    }, {
                        once: true
                    });
                }
            }
        },
        onPressEnd (e) {
            if (timeRef.current) clearTimeout(timeRef.current);
            if (onLongPressEnd && (e.pointerType === "mouse" || e.pointerType === "touch")) onLongPressEnd({
                ...e,
                type: "longpressend"
            });
        }
    });
    let descriptionProps = (0, $goTMa$reactariautils.useDescription)(onLongPress && !isDisabled ? accessibilityDescription : null);
    return {
        longPressProps: (0, $goTMa$reactariautils.mergeProps)(pressProps, descriptionProps)
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 53163:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $4hxXn$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "SSRProvider", () => $29383e587d62412a$export$9f8ac96af4b1b2ae);
$parcel$export(module.exports, "useSSRSafeId", () => $29383e587d62412a$export$619500959fc48b26);
$parcel$export(module.exports, "useIsSSR", () => $29383e587d62412a$export$535bd6ca7f90a273);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We must avoid a circular dependency with @react-aria/utils, and this useLayoutEffect is
// guarded by a check that it only runs on the client side.
// eslint-disable-next-line rulesdir/useLayoutEffectRule

// Default context value to use in case there is no SSRProvider. This is fine for
// client-only apps. In order to support multiple copies of React Aria potentially
// being on the page at once, the prefix is set to a random number. SSRProvider
// will reset this to zero for consistency between server and client, so in the
// SSR case multiple copies of React Aria is not supported.
const $29383e587d62412a$var$defaultContext = {
    prefix: String(Math.round(Math.random() * 10000000000)),
    current: 0,
    isSSR: false
};
const $29383e587d62412a$var$SSRContext = /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createContext($29383e587d62412a$var$defaultContext);
// This is only used in React < 18.
function $29383e587d62412a$var$LegacySSRProvider(props) {
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let counter = $29383e587d62412a$var$useCounter(cur === $29383e587d62412a$var$defaultContext);
    let [isSSR, setIsSSR] = (0, $4hxXn$react.useState)(true);
    let value = (0, $4hxXn$react.useMemo)(()=>({
            // If this is the first SSRProvider, start with an empty string prefix, otherwise
            // append and increment the counter.
            prefix: cur === $29383e587d62412a$var$defaultContext ? "" : `${cur.prefix}-${counter}`,
            current: 0,
            isSSR: isSSR
        }), [
        cur,
        counter,
        isSSR
    ]);
    // If on the client, and the component was initially server rendered,
    // then schedule a layout effect to update the component after hydration.
    if (typeof window !== "undefined") // This if statement technically breaks the rules of hooks, but is safe
    // because the condition never changes after mounting.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, $4hxXn$react.useLayoutEffect)(()=>{
        setIsSSR(false);
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$SSRContext.Provider, {
        value: value
    }, props.children);
}
let $29383e587d62412a$var$warnedAboutSSRProvider = false;
function $29383e587d62412a$export$9f8ac96af4b1b2ae(props) {
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function") {
        if (!$29383e587d62412a$var$warnedAboutSSRProvider) {
            console.warn("In React 18, SSRProvider is not necessary and is a noop. You can remove it from your app.");
            $29383e587d62412a$var$warnedAboutSSRProvider = true;
        }
        return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement((0, ($parcel$interopDefault($4hxXn$react))).Fragment, null, props.children);
    }
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$LegacySSRProvider, props);
}
let $29383e587d62412a$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
let $29383e587d62412a$var$componentIds = new WeakMap();
function $29383e587d62412a$var$useCounter(isDisabled = false) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let ref = (0, $4hxXn$react.useRef)(null);
    // eslint-disable-next-line rulesdir/pure-render
    if (ref.current === null && !isDisabled) {
        var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner;
        // In strict mode, React renders components twice, and the ref will be reset to null on the second render.
        // This means our id counter will be incremented twice instead of once. This is a problem because on the
        // server, components are only rendered once and so ids generated on the server won't match the client.
        // In React 18, useId was introduced to solve this, but it is not available in older versions. So to solve this
        // we need to use some React internals to access the underlying Fiber instance, which is stable between renders.
        // This is exposed as ReactCurrentOwner in development, which is all we need since StrictMode only runs in development.
        // To ensure that we only increment the global counter once, we store the starting id for this component in
        // a weak map associated with the Fiber. On the second render, we reset the global counter to this value.
        // Since React runs the second render immediately after the first, this is safe.
        // @ts-ignore
        let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, ($parcel$interopDefault($4hxXn$react))).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;
        if (currentOwner) {
            let prevComponentValue = $29383e587d62412a$var$componentIds.get(currentOwner);
            if (prevComponentValue == null) // On the first render, and first call to useId, store the id and state in our weak map.
            $29383e587d62412a$var$componentIds.set(currentOwner, {
                id: ctx.current,
                state: currentOwner.memoizedState
            });
            else if (currentOwner.memoizedState !== prevComponentValue.state) {
                // On the second render, the memoizedState gets reset by React.
                // Reset the counter, and remove from the weak map so we don't
                // do this for subsequent useId calls.
                ctx.current = prevComponentValue.id;
                $29383e587d62412a$var$componentIds.delete(currentOwner);
            }
        }
        // eslint-disable-next-line rulesdir/pure-render
        ref.current = ++ctx.current;
    }
    // eslint-disable-next-line rulesdir/pure-render
    return ref.current;
}
function $29383e587d62412a$var$useLegacySSRSafeId(defaultId) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    // If we are rendering in a non-DOM environment, and there's no SSRProvider,
    // provide a warning to hint to the developer to add one.
    if (ctx === $29383e587d62412a$var$defaultContext && !$29383e587d62412a$var$canUseDOM) console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
    let counter = $29383e587d62412a$var$useCounter(!!defaultId);
    return defaultId || `react-aria${ctx.prefix}-${counter}`;
}
function $29383e587d62412a$var$useModernSSRSafeId(defaultId) {
    // @ts-ignore
    let id = (0, ($parcel$interopDefault($4hxXn$react))).useId();
    let [didSSR] = (0, $4hxXn$react.useState)($29383e587d62412a$export$535bd6ca7f90a273());
    let prefix = didSSR ? "react-aria" : `react-aria${$29383e587d62412a$var$defaultContext.prefix}`;
    return defaultId || `${prefix}-${id}`;
}
const $29383e587d62412a$export$619500959fc48b26 = typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function" ? $29383e587d62412a$var$useModernSSRSafeId : $29383e587d62412a$var$useLegacySSRSafeId;
function $29383e587d62412a$var$getSnapshot() {
    return false;
}
function $29383e587d62412a$var$getServerSnapshot() {
    return true;
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function $29383e587d62412a$var$subscribe(onStoreChange) {
    // noop
    return ()=>{};
}
function $29383e587d62412a$export$535bd6ca7f90a273() {
    // In React 18, we can use useSyncExternalStore to detect if we're server rendering or hydrating.
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"] === "function") return (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"]($29383e587d62412a$var$subscribe, $29383e587d62412a$var$getSnapshot, $29383e587d62412a$var$getServerSnapshot);
    // eslint-disable-next-line react-hooks/rules-of-hooks
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    return cur.isSSR;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 29061:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $1Yh1N$reactstatelyutils = __webpack_require__(12259);
var $1Yh1N$react = __webpack_require__(18038);
var $1Yh1N$reactariassr = __webpack_require__(53163);
var $1Yh1N$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useId", () => $8c61827343eed941$export$f680877a34711e37);
$parcel$export(module.exports, "mergeIds", () => $8c61827343eed941$export$cd8c9cb68f842629);
$parcel$export(module.exports, "useSlotId", () => $8c61827343eed941$export$b4cc09c592e8fdb8);
$parcel$export(module.exports, "chain", () => $1e2191638e54f613$export$e08e3b67e392101e);
$parcel$export(module.exports, "mergeProps", () => $f847cd1382ea7cd4$export$9d1611c77c2fe928);
$parcel$export(module.exports, "mergeRefs", () => $f05dc24eafaeb7e2$export$c9058316764c140e);
$parcel$export(module.exports, "filterDOMProps", () => $8d15d0e1797d4238$export$457c3d6518dd4c6f);
$parcel$export(module.exports, "focusWithoutScrolling", () => $1117b6c0d4c4c164$export$de79e2c695e052f3);
$parcel$export(module.exports, "getOffset", () => $16ec41ef3e36c19c$export$622cea445a1c5b7d);
$parcel$export(module.exports, "runAfterTransition", () => $e8117ebcab55be6a$export$24490316f764c430);
$parcel$export(module.exports, "useDrag1D", () => $28ed3fb20343b78b$export$7bbed75feba39706);
$parcel$export(module.exports, "useGlobalListeners", () => $4571ff54ac709100$export$4eaf04e54aa8eed6);
$parcel$export(module.exports, "useLabels", () => $6ec78bde395c477d$export$d6875122194c7b44);
$parcel$export(module.exports, "useObjectRef", () => $475b35fe72ba49b3$export$4338b53315abf666);
$parcel$export(module.exports, "useUpdateEffect", () => $29293a6f5c75b37e$export$496315a1608d9602);
$parcel$export(module.exports, "useLayoutEffect", () => $78605a5d7424e31b$export$e5c5a5f917a5871c);
$parcel$export(module.exports, "useResizeObserver", () => $37733e1652f47193$export$683480f191c0e3ea);
$parcel$export(module.exports, "useSyncRef", () => $6fc733991a9f977c$export$4debdb1a3f0fa79e);
$parcel$export(module.exports, "getScrollParent", () => $d796e7157ac96470$export$cfa2225e87938781);
$parcel$export(module.exports, "isScrollable", () => $d796e7157ac96470$export$2bb74740c4e19def);
$parcel$export(module.exports, "useViewportSize", () => $8b24bab62f5c65ad$export$d699905dd57c73ca);
$parcel$export(module.exports, "useDescription", () => $34da4502ea8120db$export$f8aeda7b10753fa1);
$parcel$export(module.exports, "isMac", () => $9e20cff0af27e8cc$export$9ac100e40613ea10);
$parcel$export(module.exports, "isIPhone", () => $9e20cff0af27e8cc$export$186c6964ca17d99);
$parcel$export(module.exports, "isIPad", () => $9e20cff0af27e8cc$export$7bef049ce92e4224);
$parcel$export(module.exports, "isIOS", () => $9e20cff0af27e8cc$export$fedb369cb70207f1);
$parcel$export(module.exports, "isAppleDevice", () => $9e20cff0af27e8cc$export$e1865c3bedcd822b);
$parcel$export(module.exports, "isWebKit", () => $9e20cff0af27e8cc$export$78551043582a6a98);
$parcel$export(module.exports, "isChrome", () => $9e20cff0af27e8cc$export$6446a186d09e379e);
$parcel$export(module.exports, "isAndroid", () => $9e20cff0af27e8cc$export$a11b0059900ceec8);
$parcel$export(module.exports, "useEvent", () => $2a8c0bb1629926c8$export$90fc3a17d93f704c);
$parcel$export(module.exports, "useValueEffect", () => $19a2307bfabafaf1$export$14d238f342723f25);
$parcel$export(module.exports, "scrollIntoView", () => $449412113267a1fe$export$53a0910f038337bd);
$parcel$export(module.exports, "scrollIntoViewport", () => $449412113267a1fe$export$c826860796309d1b);
$parcel$export(module.exports, "clamp", () => $1Yh1N$reactstatelyutils.clamp);
$parcel$export(module.exports, "snapValueToStep", () => $1Yh1N$reactstatelyutils.snapValueToStep);
$parcel$export(module.exports, "isVirtualClick", () => $577e795361f19be9$export$60278871457622de);
$parcel$export(module.exports, "isVirtualPointerEvent", () => $577e795361f19be9$export$29bf1b5f2c56cf63);
$parcel$export(module.exports, "useEffectEvent", () => $1254e5bb94ac8761$export$7f54fc3180508a52);
$parcel$export(module.exports, "useDeepMemo", () => $20e6e72fbf5dc81e$export$722debc0e56fea39);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $78605a5d7424e31b$export$e5c5a5f917a5871c = typeof window !== "undefined" ? (0, ($parcel$interopDefault($1Yh1N$react))).useLayoutEffect : ()=>{};



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $19a2307bfabafaf1$export$14d238f342723f25(defaultValue) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultValue);
    let valueRef = (0, $1Yh1N$react.useRef)(value);
    let effect = (0, $1Yh1N$react.useRef)(null);
    // Must be stable so that `queue` is stable.
    let nextIter = (0, $1Yh1N$react.useCallback)(()=>{
        // Run the generator to the next yield.
        let newValue = effect.current.next();
        while(!newValue.done && valueRef.current === newValue.value)// If the value is the same as the current value,
        // then continue to the next yield. Otherwise,
        // set the value in state and wait for the next layout effect.
        newValue = effect.current.next();
        // If the generator is done, reset the effect.
        if (newValue.done) {
            effect.current = null;
            return;
        }
        // Always update valueRef when setting the state.
        // This is needed because the function is not regenerated with the new state value since
        // they must be stable across renders. Instead, it gets carried in the ref, but the setState
        // is also needed in order to cause a rerender.
        setValue(newValue.value);
        valueRef.current = newValue.value;
    // this list of dependencies is stable, setState and refs never change after first render.
    }, [
        setValue,
        valueRef,
        effect
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        // If there is an effect currently running, continue to the next yield.
        if (effect.current) nextIter();
    });
    // queue must be a stable function, much like setState.
    let queue = (0, $1Yh1N$react.useCallback)((fn)=>{
        effect.current = fn(valueRef.current);
        nextIter();
    // this list of dependencies is stable, setState and refs never change after first render.
    // in addition, nextIter is stable as outlined above
    }, [
        nextIter,
        effect,
        valueRef
    ]);
    return [
        value,
        queue
    ];
}


let $8c61827343eed941$var$idsUpdaterMap = new Map();
function $8c61827343eed941$export$f680877a34711e37(defaultId) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultId);
    let nextId = (0, $1Yh1N$react.useRef)(null);
    let res = (0, $1Yh1N$reactariassr.useSSRSafeId)(value);
    let updateValue = (0, $1Yh1N$react.useCallback)((val)=>{
        nextId.current = val;
    }, []);
    $8c61827343eed941$var$idsUpdaterMap.set(res, updateValue);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        let r = res;
        return ()=>{
            $8c61827343eed941$var$idsUpdaterMap.delete(r);
        };
    }, [
        res
    ]);
    // This cannot cause an infinite loop because the ref is updated first.
    // eslint-disable-next-line
    (0, $1Yh1N$react.useEffect)(()=>{
        let newId = nextId.current;
        if (newId) {
            nextId.current = null;
            setValue(newId);
        }
    });
    return res;
}
function $8c61827343eed941$export$cd8c9cb68f842629(idA, idB) {
    if (idA === idB) return idA;
    let setIdA = $8c61827343eed941$var$idsUpdaterMap.get(idA);
    if (setIdA) {
        setIdA(idB);
        return idB;
    }
    let setIdB = $8c61827343eed941$var$idsUpdaterMap.get(idB);
    if (setIdB) {
        setIdB(idA);
        return idA;
    }
    return idB;
}
function $8c61827343eed941$export$b4cc09c592e8fdb8(depArray = []) {
    let id = $8c61827343eed941$export$f680877a34711e37();
    let [resolvedId, setResolvedId] = (0, $19a2307bfabafaf1$export$14d238f342723f25)(id);
    let updateId = (0, $1Yh1N$react.useCallback)(()=>{
        setResolvedId(function*() {
            yield id;
            yield document.getElementById(id) ? id : undefined;
        });
    }, [
        id,
        setResolvedId
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(updateId, [
        id,
        updateId,
        ...depArray
    ]);
    return resolvedId;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /**
 * Calls all functions in the order they were chained with the same arguments.
 */ function $1e2191638e54f613$export$e08e3b67e392101e(...callbacks) {
    return (...args)=>{
        for (let callback of callbacks)if (typeof callback === "function") callback(...args);
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $f847cd1382ea7cd4$export$9d1611c77c2fe928(...args) {
    // Start with a base clone of the first argument. This is a lot faster than starting
    // with an empty object and adding properties as we go.
    let result = {
        ...args[0]
    };
    for(let i = 1; i < args.length; i++){
        let props = args[i];
        for(let key in props){
            let a = result[key];
            let b = props[key];
            // Chain events
            if (typeof a === "function" && typeof b === "function" && // This is a lot faster than a regex.
            key[0] === "o" && key[1] === "n" && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = (0, $1e2191638e54f613$export$e08e3b67e392101e)(a, b);
            else if ((key === "className" || key === "UNSAFE_className") && typeof a === "string" && typeof b === "string") result[key] = (0, ($parcel$interopDefault($1Yh1N$clsx)))(a, b);
            else if (key === "id" && a && b) result.id = (0, $8c61827343eed941$export$cd8c9cb68f842629)(a, b);
            else result[key] = b !== undefined ? b : a;
        }
    }
    return result;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $f05dc24eafaeb7e2$export$c9058316764c140e(...refs) {
    if (refs.length === 1) return refs[0];
    return (value)=>{
        for (let ref of refs){
            if (typeof ref === "function") ref(value);
            else if (ref != null) ref.current = value;
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ const $8d15d0e1797d4238$var$DOMPropNames = new Set([
    "id"
]);
const $8d15d0e1797d4238$var$labelablePropNames = new Set([
    "aria-label",
    "aria-labelledby",
    "aria-describedby",
    "aria-details"
]);
const $8d15d0e1797d4238$var$propRe = /^(data-.*)$/;
function $8d15d0e1797d4238$export$457c3d6518dd4c6f(props, opts = {}) {
    let { labelable: labelable , propNames: propNames  } = opts;
    let filteredProps = {};
    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($8d15d0e1797d4238$var$DOMPropNames.has(prop) || labelable && $8d15d0e1797d4238$var$labelablePropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $8d15d0e1797d4238$var$propRe.test(prop))) filteredProps[prop] = props[prop];
    return filteredProps;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $1117b6c0d4c4c164$export$de79e2c695e052f3(element) {
    if ($1117b6c0d4c4c164$var$supportsPreventScroll()) element.focus({
        preventScroll: true
    });
    else {
        let scrollableElements = $1117b6c0d4c4c164$var$getScrollableElements(element);
        element.focus();
        $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements);
    }
}
let $1117b6c0d4c4c164$var$supportsPreventScrollCached = null;
function $1117b6c0d4c4c164$var$supportsPreventScroll() {
    if ($1117b6c0d4c4c164$var$supportsPreventScrollCached == null) {
        $1117b6c0d4c4c164$var$supportsPreventScrollCached = false;
        try {
            var focusElem = document.createElement("div");
            focusElem.focus({
                get preventScroll () {
                    $1117b6c0d4c4c164$var$supportsPreventScrollCached = true;
                    return true;
                }
            });
        } catch (e) {
        // Ignore
        }
    }
    return $1117b6c0d4c4c164$var$supportsPreventScrollCached;
}
function $1117b6c0d4c4c164$var$getScrollableElements(element) {
    var parent = element.parentNode;
    var scrollableElements = [];
    var rootScrollingElement = document.scrollingElement || document.documentElement;
    while(parent instanceof HTMLElement && parent !== rootScrollingElement){
        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({
            element: parent,
            scrollTop: parent.scrollTop,
            scrollLeft: parent.scrollLeft
        });
        parent = parent.parentNode;
    }
    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
        element: rootScrollingElement,
        scrollTop: rootScrollingElement.scrollTop,
        scrollLeft: rootScrollingElement.scrollLeft
    });
    return scrollableElements;
}
function $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements) {
    for (let { element: element , scrollTop: scrollTop , scrollLeft: scrollLeft  } of scrollableElements){
        element.scrollTop = scrollTop;
        element.scrollLeft = scrollLeft;
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $16ec41ef3e36c19c$export$622cea445a1c5b7d(element, reverse, orientation = "horizontal") {
    let rect = element.getBoundingClientRect();
    if (reverse) return orientation === "horizontal" ? rect.right : rect.bottom;
    return orientation === "horizontal" ? rect.left : rect.top;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We store a global list of elements that are currently transitioning,
// mapped to a set of CSS properties that are transitioning for that element.
// This is necessary rather than a simple count of transitions because of browser
// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather
// than one or the other. So we need to track what's actually transitioning so that
// we can ignore these duplicate events.
let $e8117ebcab55be6a$var$transitionsByElement = new Map();
// A list of callbacks to call once there are no transitioning elements.
let $e8117ebcab55be6a$var$transitionCallbacks = new Set();
function $e8117ebcab55be6a$var$setupGlobalEvents() {
    if (typeof window === "undefined") return;
    let onTransitionStart = (e)=>{
        // Add the transitioning property to the list for this element.
        let transitions = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!transitions) {
            transitions = new Set();
            $e8117ebcab55be6a$var$transitionsByElement.set(e.target, transitions);
            // The transitioncancel event must be registered on the element itself, rather than as a global
            // event. This enables us to handle when the node is deleted from the document while it is transitioning.
            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.
            e.target.addEventListener("transitioncancel", onTransitionEnd);
        }
        transitions.add(e.propertyName);
    };
    let onTransitionEnd = (e)=>{
        // Remove property from list of transitioning properties.
        let properties = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!properties) return;
        properties.delete(e.propertyName);
        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.
        if (properties.size === 0) {
            e.target.removeEventListener("transitioncancel", onTransitionEnd);
            $e8117ebcab55be6a$var$transitionsByElement.delete(e.target);
        }
        // If no transitioning elements, call all of the queued callbacks.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) {
            for (let cb of $e8117ebcab55be6a$var$transitionCallbacks)cb();
            $e8117ebcab55be6a$var$transitionCallbacks.clear();
        }
    };
    document.body.addEventListener("transitionrun", onTransitionStart);
    document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e8117ebcab55be6a$var$setupGlobalEvents();
    else document.addEventListener("DOMContentLoaded", $e8117ebcab55be6a$var$setupGlobalEvents);
}
function $e8117ebcab55be6a$export$24490316f764c430(fn) {
    // Wait one frame to see if an animation starts, e.g. a transition on mount.
    requestAnimationFrame(()=>{
        // If no transitions are running, call the function immediately.
        // Otherwise, add it to a list of callbacks to run at the end of the animation.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) fn();
        else $e8117ebcab55be6a$var$transitionCallbacks.add(fn);
    });
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 

// Keep track of elements that we are currently handling dragging for via useDrag1D.
// If there's an ancestor and a descendant both using useDrag1D(), and the user starts
// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.
const $28ed3fb20343b78b$var$draggingElements = [];
function $28ed3fb20343b78b$export$7bbed75feba39706(props) {
    console.warn("useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html");
    let { containerRef: containerRef , reverse: reverse , orientation: orientation , onHover: onHover , onDrag: onDrag , onPositionChange: onPositionChange , onIncrement: onIncrement , onDecrement: onDecrement , onIncrementToMax: onIncrementToMax , onDecrementToMin: onDecrementToMin , onCollapseToggle: onCollapseToggle  } = props;
    let getPosition = (e)=>orientation === "horizontal" ? e.clientX : e.clientY;
    let getNextOffset = (e)=>{
        let containerOffset = (0, $16ec41ef3e36c19c$export$622cea445a1c5b7d)(containerRef.current, reverse, orientation);
        let mouseOffset = getPosition(e);
        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;
        return nextOffset;
    };
    let dragging = (0, $1Yh1N$react.useRef)(false);
    let prevPosition = (0, $1Yh1N$react.useRef)(0);
    // Keep track of the current handlers in a ref so that the events can access them.
    let handlers = (0, $1Yh1N$react.useRef)({
        onPositionChange: onPositionChange,
        onDrag: onDrag
    });
    handlers.current.onDrag = onDrag;
    handlers.current.onPositionChange = onPositionChange;
    let onMouseDragged = (e)=>{
        e.preventDefault();
        let nextOffset = getNextOffset(e);
        if (!dragging.current) {
            dragging.current = true;
            if (handlers.current.onDrag) handlers.current.onDrag(true);
            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        }
        if (prevPosition.current === nextOffset) return;
        prevPosition.current = nextOffset;
        if (onPositionChange) onPositionChange(nextOffset);
    };
    let onMouseUp = (e)=>{
        const target = e.target;
        dragging.current = false;
        let nextOffset = getNextOffset(e);
        if (handlers.current.onDrag) handlers.current.onDrag(false);
        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        $28ed3fb20343b78b$var$draggingElements.splice($28ed3fb20343b78b$var$draggingElements.indexOf(target), 1);
        window.removeEventListener("mouseup", onMouseUp, false);
        window.removeEventListener("mousemove", onMouseDragged, false);
    };
    let onMouseDown = (e)=>{
        const target = e.currentTarget;
        // If we're already handling dragging on a descendant with useDrag1D, then
        // we don't want to handle the drag motion on this target as well.
        if ($28ed3fb20343b78b$var$draggingElements.some((elt)=>target.contains(elt))) return;
        $28ed3fb20343b78b$var$draggingElements.push(target);
        window.addEventListener("mousemove", onMouseDragged, false);
        window.addEventListener("mouseup", onMouseUp, false);
    };
    let onMouseEnter = ()=>{
        if (onHover) onHover(true);
    };
    let onMouseOut = ()=>{
        if (onHover) onHover(false);
    };
    let onKeyDown = (e)=>{
        switch(e.key){
            case "Left":
            case "ArrowLeft":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Up":
            case "ArrowUp":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Right":
            case "ArrowRight":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Down":
            case "ArrowDown":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Home":
                e.preventDefault();
                if (onDecrementToMin) onDecrementToMin();
                break;
            case "End":
                e.preventDefault();
                if (onIncrementToMax) onIncrementToMax();
                break;
            case "Enter":
                e.preventDefault();
                if (onCollapseToggle) onCollapseToggle();
                break;
        }
    };
    return {
        onMouseDown: onMouseDown,
        onMouseEnter: onMouseEnter,
        onMouseOut: onMouseOut,
        onKeyDown: onKeyDown
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $4571ff54ac709100$export$4eaf04e54aa8eed6() {
    let globalListeners = (0, $1Yh1N$react.useRef)(new Map());
    let addGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        // Make sure we remove the listener after it is called with the `once` option.
        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{
            globalListeners.current.delete(listener);
            listener(...args);
        } : listener;
        globalListeners.current.set(listener, {
            type: type,
            eventTarget: eventTarget,
            fn: fn,
            options: options
        });
        eventTarget.addEventListener(type, listener, options);
    }, []);
    let removeGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        var _globalListeners_current_get;
        let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
        eventTarget.removeEventListener(type, fn, options);
        globalListeners.current.delete(listener);
    }, []);
    let removeAllGlobalListeners = (0, $1Yh1N$react.useCallback)(()=>{
        globalListeners.current.forEach((value, key)=>{
            removeGlobalListener(value.eventTarget, value.type, key, value.options);
        });
    }, [
        removeGlobalListener
    ]);
    // eslint-disable-next-line arrow-body-style
    (0, $1Yh1N$react.useEffect)(()=>{
        return removeAllGlobalListeners;
    }, [
        removeAllGlobalListeners
    ]);
    return {
        addGlobalListener: addGlobalListener,
        removeGlobalListener: removeGlobalListener,
        removeAllGlobalListeners: removeAllGlobalListeners
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6ec78bde395c477d$export$d6875122194c7b44(props, defaultLabel) {
    let { id: id , "aria-label": label , "aria-labelledby": labelledBy  } = props;
    // If there is both an aria-label and aria-labelledby,
    // combine them by pointing to the element itself.
    id = (0, $8c61827343eed941$export$f680877a34711e37)(id);
    if (labelledBy && label) {
        let ids = new Set([
            id,
            ...labelledBy.trim().split(/\s+/)
        ]);
        labelledBy = [
            ...ids
        ].join(" ");
    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\s+/).join(" ");
    // If no labels are provided, use the default
    if (!label && !labelledBy && defaultLabel) label = defaultLabel;
    return {
        id: id,
        "aria-label": label,
        "aria-labelledby": labelledBy
    };
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $475b35fe72ba49b3$export$4338b53315abf666(forwardedRef) {
    const objRef = (0, $1Yh1N$react.useRef)();
    return (0, $1Yh1N$react.useMemo)(()=>({
            get current () {
                return objRef.current;
            },
            set current (value){
                objRef.current = value;
                if (typeof forwardedRef === "function") forwardedRef(value);
                else if (forwardedRef) forwardedRef.current = value;
            }
        }), [
        forwardedRef
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $29293a6f5c75b37e$export$496315a1608d9602(effect, dependencies) {
    const isInitialMount = (0, $1Yh1N$react.useRef)(true);
    const lastDeps = (0, $1Yh1N$react.useRef)(null);
    (0, $1Yh1N$react.useEffect)(()=>{
        isInitialMount.current = true;
        return ()=>{
            isInitialMount.current = false;
        };
    }, []);
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isInitialMount.current) isInitialMount.current = false;
        else if (!lastDeps.current || dependencies.some((dep, i)=>!Object.is(dep, lastDeps[i]))) effect();
        lastDeps.current = dependencies;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencies);
}




function $37733e1652f47193$var$hasResizeObserver() {
    return typeof window.ResizeObserver !== "undefined";
}
function $37733e1652f47193$export$683480f191c0e3ea(options) {
    const { ref: ref , onResize: onResize  } = options;
    (0, $1Yh1N$react.useEffect)(()=>{
        let element = ref === null || ref === void 0 ? void 0 : ref.current;
        if (!element) return;
        if (!$37733e1652f47193$var$hasResizeObserver()) {
            window.addEventListener("resize", onResize, false);
            return ()=>{
                window.removeEventListener("resize", onResize, false);
            };
        } else {
            const resizeObserverInstance = new window.ResizeObserver((entries)=>{
                if (!entries.length) return;
                onResize();
            });
            resizeObserverInstance.observe(element);
            return ()=>{
                if (element) resizeObserverInstance.unobserve(element);
            };
        }
    }, [
        onResize,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6fc733991a9f977c$export$4debdb1a3f0fa79e(context, ref) {
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (context && context.ref && ref) {
            context.ref.current = ref.current;
            return ()=>{
                context.ref.current = null;
            };
        }
    }, [
        context,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d796e7157ac96470$export$cfa2225e87938781(node) {
    if ($d796e7157ac96470$export$2bb74740c4e19def(node)) node = node.parentElement;
    while(node && !$d796e7157ac96470$export$2bb74740c4e19def(node))node = node.parentElement;
    return node || document.scrollingElement || document.documentElement;
}
function $d796e7157ac96470$export$2bb74740c4e19def(node) {
    let style = window.getComputedStyle(node);
    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// @ts-ignore
let $8b24bab62f5c65ad$var$visualViewport = typeof window !== "undefined" && window.visualViewport;
function $8b24bab62f5c65ad$export$d699905dd57c73ca() {
    let [size, setSize] = (0, $1Yh1N$react.useState)(()=>$8b24bab62f5c65ad$var$getViewportSize());
    (0, $1Yh1N$react.useEffect)(()=>{
        // Use visualViewport api to track available height even on iOS virtual keyboard opening
        let onResize = ()=>{
            setSize((size)=>{
                let newSize = $8b24bab62f5c65ad$var$getViewportSize();
                if (newSize.width === size.width && newSize.height === size.height) return size;
                return newSize;
            });
        };
        if (!$8b24bab62f5c65ad$var$visualViewport) window.addEventListener("resize", onResize);
        else $8b24bab62f5c65ad$var$visualViewport.addEventListener("resize", onResize);
        return ()=>{
            if (!$8b24bab62f5c65ad$var$visualViewport) window.removeEventListener("resize", onResize);
            else $8b24bab62f5c65ad$var$visualViewport.removeEventListener("resize", onResize);
        };
    }, []);
    return size;
}
function $8b24bab62f5c65ad$var$getViewportSize() {
    return {
        width: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.width) || window.innerWidth,
        height: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.height) || window.innerHeight
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

let $34da4502ea8120db$var$descriptionId = 0;
const $34da4502ea8120db$var$descriptionNodes = new Map();
function $34da4502ea8120db$export$f8aeda7b10753fa1(description) {
    let [id, setId] = (0, $1Yh1N$react.useState)(undefined);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (!description) return;
        let desc = $34da4502ea8120db$var$descriptionNodes.get(description);
        if (!desc) {
            let id = `react-aria-description-${$34da4502ea8120db$var$descriptionId++}`;
            setId(id);
            let node = document.createElement("div");
            node.id = id;
            node.style.display = "none";
            node.textContent = description;
            document.body.appendChild(node);
            desc = {
                refCount: 0,
                element: node
            };
            $34da4502ea8120db$var$descriptionNodes.set(description, desc);
        } else setId(desc.element.id);
        desc.refCount++;
        return ()=>{
            if (--desc.refCount === 0) {
                desc.element.remove();
                $34da4502ea8120db$var$descriptionNodes.delete(description);
            }
        };
    }, [
        description
    ]);
    return {
        "aria-describedby": description ? id : undefined
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $9e20cff0af27e8cc$var$testUserAgent(re) {
    var _window_navigator_userAgentData;
    if (typeof window === "undefined" || window.navigator == null) return false;
    return ((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand)=>re.test(brand.brand))) || re.test(window.navigator.userAgent);
}
function $9e20cff0af27e8cc$var$testPlatform(re) {
    var _window_navigator_userAgentData;
    return typeof window !== "undefined" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $9e20cff0af27e8cc$export$9ac100e40613ea10() {
    return $9e20cff0af27e8cc$var$testPlatform(/^Mac/i);
}
function $9e20cff0af27e8cc$export$186c6964ca17d99() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPhone/i);
}
function $9e20cff0af27e8cc$export$7bef049ce92e4224() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
    $9e20cff0af27e8cc$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
}
function $9e20cff0af27e8cc$export$fedb369cb70207f1() {
    return $9e20cff0af27e8cc$export$186c6964ca17d99() || $9e20cff0af27e8cc$export$7bef049ce92e4224();
}
function $9e20cff0af27e8cc$export$e1865c3bedcd822b() {
    return $9e20cff0af27e8cc$export$9ac100e40613ea10() || $9e20cff0af27e8cc$export$fedb369cb70207f1();
}
function $9e20cff0af27e8cc$export$78551043582a6a98() {
    return $9e20cff0af27e8cc$var$testUserAgent(/AppleWebKit/i) && !$9e20cff0af27e8cc$export$6446a186d09e379e();
}
function $9e20cff0af27e8cc$export$6446a186d09e379e() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Chrome/i);
}
function $9e20cff0af27e8cc$export$a11b0059900ceec8() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Android/i);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1254e5bb94ac8761$export$7f54fc3180508a52(fn) {
    const ref = (0, $1Yh1N$react.useRef)(null);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        ref.current = fn;
    }, [
        fn
    ]);
    return (0, $1Yh1N$react.useCallback)((...args)=>{
        const f = ref.current;
        return f(...args);
    }, []);
}


function $2a8c0bb1629926c8$export$90fc3a17d93f704c(ref, event, handler, options) {
    let handleEvent = (0, $1254e5bb94ac8761$export$7f54fc3180508a52)(handler);
    let isDisabled = handler == null;
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isDisabled) return;
        let element = ref.current;
        element.addEventListener(event, handleEvent, options);
        return ()=>{
            element.removeEventListener(event, handleEvent, options);
        };
    }, [
        ref,
        event,
        options,
        isDisabled,
        handleEvent
    ]);
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $449412113267a1fe$export$53a0910f038337bd(scrollView, element) {
    let offsetX = $449412113267a1fe$var$relativeOffset(scrollView, element, "left");
    let offsetY = $449412113267a1fe$var$relativeOffset(scrollView, element, "top");
    let width = element.offsetWidth;
    let height = element.offsetHeight;
    let x = scrollView.scrollLeft;
    let y = scrollView.scrollTop;
    // Account for top/left border offsetting the scroll top/Left
    let { borderTopWidth: borderTopWidth , borderLeftWidth: borderLeftWidth  } = getComputedStyle(scrollView);
    let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);
    let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);
    // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width
    let maxX = borderAdjustedX + scrollView.clientWidth;
    let maxY = borderAdjustedY + scrollView.clientHeight;
    if (offsetX <= x) x = offsetX - parseInt(borderLeftWidth, 10);
    else if (offsetX + width > maxX) x += offsetX + width - maxX;
    if (offsetY <= borderAdjustedY) y = offsetY - parseInt(borderTopWidth, 10);
    else if (offsetY + height > maxY) y += offsetY + height - maxY;
    scrollView.scrollLeft = x;
    scrollView.scrollTop = y;
}
/**
 * Computes the offset left or top from child to ancestor by accumulating
 * offsetLeft or offsetTop through intervening offsetParents.
 */ function $449412113267a1fe$var$relativeOffset(ancestor, child, axis) {
    const prop = axis === "left" ? "offsetLeft" : "offsetTop";
    let sum = 0;
    while(child.offsetParent){
        sum += child[prop];
        if (child.offsetParent === ancestor) break;
        else if (child.offsetParent.contains(ancestor)) {
            // If the ancestor is not `position:relative`, then we stop at
            // _its_ offset parent, and we subtract off _its_ offset, so that
            // we end up with the proper offset from child to ancestor.
            sum -= ancestor[prop];
            break;
        }
        child = child.offsetParent;
    }
    return sum;
}
function $449412113267a1fe$export$c826860796309d1b(targetElement, opts) {
    if (document.contains(targetElement)) {
        let root = document.scrollingElement || document.documentElement;
        let isScrollPrevented = window.getComputedStyle(root).overflow === "hidden";
        // If scrolling is not currently prevented then we aren’t in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view
        if (!isScrollPrevented) {
            var // use scrollIntoView({block: 'nearest'}) instead of .focus to check if the element is fully in view or not since .focus()
            // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically
            _targetElement_scrollIntoView;
            let { left: originalLeft , top: originalTop  } = targetElement.getBoundingClientRect();
            targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {
                block: "nearest"
            });
            let { left: newLeft , top: newTop  } = targetElement.getBoundingClientRect();
            // Account for sub pixel differences from rounding
            if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {
                var _opts_containingElement, _opts_containingElement_scrollIntoView, _targetElement_scrollIntoView1;
                opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {
                    block: "center",
                    inline: "center"
                });
                (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {
                    block: "nearest"
                });
            }
        } else {
            let scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.
            while(targetElement && scrollParent && targetElement !== root && scrollParent !== root){
                $449412113267a1fe$export$53a0910f038337bd(scrollParent, targetElement);
                targetElement = scrollParent;
                scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            }
        }
    }
}



/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $577e795361f19be9$export$60278871457622de(event) {
    // JAWS/NVDA with Firefox.
    if (event.mozInputSource === 0 && event.isTrusted) return true;
    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead
    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check
    // to detect TalkBack virtual clicks.
    if ((0, $9e20cff0af27e8cc$export$a11b0059900ceec8)() && event.pointerType) return event.type === "click" && event.buttons === 1;
    return event.detail === 0 && !event.pointerType;
}
function $577e795361f19be9$export$29bf1b5f2c56cf63(event) {
    // If the pointer size is zero, then we assume it's from a screen reader.
    // Android TalkBack double tap will sometimes return a event with width and height of 1
    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.
    // Cannot use "event.pressure === 0" as the sole check due to Safari pointer events always returning pressure === 0
    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush
    // Talkback double tap from Windows Firefox touch screen press
    return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse";
}



/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 
function $20e6e72fbf5dc81e$export$722debc0e56fea39(value, isEqual) {
    // Using a ref during render is ok here because it's only an optimization – both values are equivalent.
    // If a render is thrown away, it'll still work the same no matter if the next render is the same or not.
    let lastValue = (0, $1Yh1N$react.useRef)(null);
    if (value && lastValue.current && isEqual(value, lastValue.current)) value = lastValue.current;
    lastValue.current = value;
    return value;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 14422:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $glPPV$react = __webpack_require__(18038);
var $glPPV$reactariafocus = __webpack_require__(66051);
var $glPPV$reactariautils = __webpack_require__(54494);
var $glPPV$reactariainteractions = __webpack_require__(16760);
var $glPPV$reactariai18n = __webpack_require__(76079);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useSelectableCollection", () => $b6837c2f80a3c32f$export$d6daf82dcd84e87c);
$parcel$export(module.exports, "useSelectableItem", () => $433b1145b0781e10$export$ecf600387e221c37);
$parcel$export(module.exports, "useSelectableList", () => $bd230acee196f50c$export$b95089534ab7c1fd);
$parcel$export(module.exports, "ListKeyboardDelegate", () => $836f880b12dcae5c$export$a05409b8bb224a5a);
$parcel$export(module.exports, "useTypeSelect", () => $a1189052f36475e8$export$e32c88dfddc6e1d8);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $ee0bdf4faa47f2a8$export$d3e3bd3e26688c04(e) {
    // Ctrl + Arrow Up/Arrow Down has a system wide meaning on macOS, so use Alt instead.
    // On Windows and Ubuntu, Alt + Space has a system wide meaning.
    return (0, $glPPV$reactariautils.isAppleDevice)() ? e.altKey : e.ctrlKey;
}
function $ee0bdf4faa47f2a8$export$16792effe837dba3(e) {
    if ((0, $glPPV$reactariautils.isMac)()) return e.metaKey;
    return e.ctrlKey;
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/**
 * Controls how long to wait before clearing the typeahead buffer.
 */ const $a1189052f36475e8$var$TYPEAHEAD_DEBOUNCE_WAIT_MS = 1000; // 1 second
function $a1189052f36475e8$export$e32c88dfddc6e1d8(options) {
    let { keyboardDelegate: keyboardDelegate , selectionManager: selectionManager , onTypeSelect: onTypeSelect  } = options;
    let state = (0, $glPPV$react.useRef)({
        search: "",
        timeout: null
    }).current;
    let onKeyDown = (e)=>{
        let character = $a1189052f36475e8$var$getStringForKey(e.key);
        if (!character || e.ctrlKey || e.metaKey || !e.currentTarget.contains(e.target)) return;
        // Do not propagate the Spacebar event if it's meant to be part of the search.
        // When we time out, the search term becomes empty, hence the check on length.
        // Trimming is to account for the case of pressing the Spacebar more than once,
        // which should cycle through the selection/deselection of the focused item.
        if (character === " " && state.search.trim().length > 0) {
            e.preventDefault();
            if (!("continuePropagation" in e)) e.stopPropagation();
        }
        state.search += character;
        // Use the delegate to find a key to focus.
        // Prioritize items after the currently focused item, falling back to searching the whole list.
        let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);
        // If no key found, search from the top.
        if (key == null) key = keyboardDelegate.getKeyForSearch(state.search);
        if (key != null) {
            selectionManager.setFocusedKey(key);
            if (onTypeSelect) onTypeSelect(key);
        }
        clearTimeout(state.timeout);
        state.timeout = setTimeout(()=>{
            state.search = "";
        }, $a1189052f36475e8$var$TYPEAHEAD_DEBOUNCE_WAIT_MS);
    };
    return {
        typeSelectProps: {
            // Using a capturing listener to catch the keydown event before
            // other hooks in order to handle the Spacebar event.
            onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null
        }
    };
}
function $a1189052f36475e8$var$getStringForKey(key) {
    // If the key is of length 1, it is an ASCII value.
    // Otherwise, if there are no ASCII characters in the key name,
    // it is a Unicode character.
    // See https://www.w3.org/TR/uievents-key/
    if (key.length === 1 || !/^[A-Z]/i.test(key)) return key;
    return "";
}


function $b6837c2f80a3c32f$export$d6daf82dcd84e87c(options) {
    let { selectionManager: manager , keyboardDelegate: delegate , ref: ref , autoFocus: autoFocus = false , shouldFocusWrap: shouldFocusWrap = false , disallowEmptySelection: disallowEmptySelection = false , disallowSelectAll: disallowSelectAll = false , selectOnFocus: selectOnFocus = manager.selectionBehavior === "replace" , disallowTypeAhead: disallowTypeAhead = false , shouldUseVirtualFocus: shouldUseVirtualFocus , allowsTabNavigation: allowsTabNavigation = false , isVirtualized: isVirtualized , scrollRef: // If no scrollRef is provided, assume the collection ref is the scrollable region
    scrollRef = ref  } = options;
    let { direction: direction  } = (0, $glPPV$reactariai18n.useLocale)();
    let onKeyDown = (e)=>{
        // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes
        if (e.altKey && e.key === "Tab") e.preventDefault();
        // Keyboard events bubble through portals. Don't handle keyboard events
        // for elements outside the collection (e.g. menus).
        if (!ref.current.contains(e.target)) return;
        const navigateToKey = (key, childFocus)=>{
            if (key != null) {
                manager.setFocusedKey(key, childFocus);
                if (e.shiftKey && manager.selectionMode === "multiple") manager.extendSelection(key);
                else if (selectOnFocus && !(0, $ee0bdf4faa47f2a8$export$d3e3bd3e26688c04)(e)) manager.replaceSelection(key);
            }
        };
        switch(e.key){
            case "ArrowDown":
                if (delegate.getKeyBelow) {
                    var _delegate_getFirstKey, _delegate_getFirstKey1;
                    e.preventDefault();
                    let nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : (_delegate_getFirstKey = delegate.getFirstKey) === null || _delegate_getFirstKey === void 0 ? void 0 : _delegate_getFirstKey.call(delegate);
                    if (nextKey == null && shouldFocusWrap) nextKey = (_delegate_getFirstKey1 = delegate.getFirstKey) === null || _delegate_getFirstKey1 === void 0 ? void 0 : _delegate_getFirstKey1.call(delegate, manager.focusedKey);
                    navigateToKey(nextKey);
                }
                break;
            case "ArrowUp":
                if (delegate.getKeyAbove) {
                    var _delegate_getLastKey, _delegate_getLastKey1;
                    e.preventDefault();
                    let nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : (_delegate_getLastKey = delegate.getLastKey) === null || _delegate_getLastKey === void 0 ? void 0 : _delegate_getLastKey.call(delegate);
                    if (nextKey == null && shouldFocusWrap) nextKey = (_delegate_getLastKey1 = delegate.getLastKey) === null || _delegate_getLastKey1 === void 0 ? void 0 : _delegate_getLastKey1.call(delegate, manager.focusedKey);
                    navigateToKey(nextKey);
                }
                break;
            case "ArrowLeft":
                if (delegate.getKeyLeftOf) {
                    var _delegate_getFirstKey2, _delegate_getLastKey2;
                    e.preventDefault();
                    let nextKey = delegate.getKeyLeftOf(manager.focusedKey);
                    if (nextKey == null && shouldFocusWrap) nextKey = direction === "rtl" ? (_delegate_getFirstKey2 = delegate.getFirstKey) === null || _delegate_getFirstKey2 === void 0 ? void 0 : _delegate_getFirstKey2.call(delegate, manager.focusedKey) : (_delegate_getLastKey2 = delegate.getLastKey) === null || _delegate_getLastKey2 === void 0 ? void 0 : _delegate_getLastKey2.call(delegate, manager.focusedKey);
                    navigateToKey(nextKey, direction === "rtl" ? "first" : "last");
                }
                break;
            case "ArrowRight":
                if (delegate.getKeyRightOf) {
                    var _delegate_getLastKey3, _delegate_getFirstKey3;
                    e.preventDefault();
                    let nextKey = delegate.getKeyRightOf(manager.focusedKey);
                    if (nextKey == null && shouldFocusWrap) nextKey = direction === "rtl" ? (_delegate_getLastKey3 = delegate.getLastKey) === null || _delegate_getLastKey3 === void 0 ? void 0 : _delegate_getLastKey3.call(delegate, manager.focusedKey) : (_delegate_getFirstKey3 = delegate.getFirstKey) === null || _delegate_getFirstKey3 === void 0 ? void 0 : _delegate_getFirstKey3.call(delegate, manager.focusedKey);
                    navigateToKey(nextKey, direction === "rtl" ? "last" : "first");
                }
                break;
            case "Home":
                if (delegate.getFirstKey) {
                    e.preventDefault();
                    let firstKey = delegate.getFirstKey(manager.focusedKey, (0, $ee0bdf4faa47f2a8$export$16792effe837dba3)(e));
                    manager.setFocusedKey(firstKey);
                    if ((0, $ee0bdf4faa47f2a8$export$16792effe837dba3)(e) && e.shiftKey && manager.selectionMode === "multiple") manager.extendSelection(firstKey);
                    else if (selectOnFocus) manager.replaceSelection(firstKey);
                }
                break;
            case "End":
                if (delegate.getLastKey) {
                    e.preventDefault();
                    let lastKey = delegate.getLastKey(manager.focusedKey, (0, $ee0bdf4faa47f2a8$export$16792effe837dba3)(e));
                    manager.setFocusedKey(lastKey);
                    if ((0, $ee0bdf4faa47f2a8$export$16792effe837dba3)(e) && e.shiftKey && manager.selectionMode === "multiple") manager.extendSelection(lastKey);
                    else if (selectOnFocus) manager.replaceSelection(lastKey);
                }
                break;
            case "PageDown":
                if (delegate.getKeyPageBelow) {
                    e.preventDefault();
                    let nextKey = delegate.getKeyPageBelow(manager.focusedKey);
                    navigateToKey(nextKey);
                }
                break;
            case "PageUp":
                if (delegate.getKeyPageAbove) {
                    e.preventDefault();
                    let nextKey = delegate.getKeyPageAbove(manager.focusedKey);
                    navigateToKey(nextKey);
                }
                break;
            case "a":
                if ((0, $ee0bdf4faa47f2a8$export$16792effe837dba3)(e) && manager.selectionMode === "multiple" && disallowSelectAll !== true) {
                    e.preventDefault();
                    manager.selectAll();
                }
                break;
            case "Escape":
                e.preventDefault();
                if (!disallowEmptySelection) manager.clearSelection();
                break;
            case "Tab":
                if (!allowsTabNavigation) {
                    // There may be elements that are "tabbable" inside a collection (e.g. in a grid cell).
                    // However, collections should be treated as a single tab stop, with arrow key navigation internally.
                    // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.
                    // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element
                    // in the collection, so that the browser default behavior will apply starting from that element
                    // rather than the currently focused one.
                    if (e.shiftKey) ref.current.focus();
                    else {
                        let walker = (0, $glPPV$reactariafocus.getFocusableTreeWalker)(ref.current, {
                            tabbable: true
                        });
                        let next;
                        let last;
                        do {
                            last = walker.lastChild();
                            if (last) next = last;
                        }while (last);
                        if (next && !next.contains(document.activeElement)) (0, $glPPV$reactariautils.focusWithoutScrolling)(next);
                    }
                    break;
                }
        }
    };
    // Store the scroll position so we can restore it later.
    let scrollPos = (0, $glPPV$react.useRef)({
        top: 0,
        left: 0
    });
    (0, $glPPV$reactariautils.useEvent)(scrollRef, "scroll", isVirtualized ? null : ()=>{
        scrollPos.current = {
            top: scrollRef.current.scrollTop,
            left: scrollRef.current.scrollLeft
        };
    });
    let onFocus = (e)=>{
        if (manager.isFocused) {
            // If a focus event bubbled through a portal, reset focus state.
            if (!e.currentTarget.contains(e.target)) manager.setFocused(false);
            return;
        }
        // Focus events can bubble through portals. Ignore these events.
        if (!e.currentTarget.contains(e.target)) return;
        manager.setFocused(true);
        if (manager.focusedKey == null) {
            let navigateToFirstKey = (key)=>{
                if (key != null) {
                    manager.setFocusedKey(key);
                    if (selectOnFocus) manager.replaceSelection(key);
                }
            };
            // If the user hasn't yet interacted with the collection, there will be no focusedKey set.
            // Attempt to detect whether the user is tabbing forward or backward into the collection
            // and either focus the first or last item accordingly.
            let relatedTarget = e.relatedTarget;
            var _manager_lastSelectedKey, _manager_firstSelectedKey;
            if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) navigateToFirstKey((_manager_lastSelectedKey = manager.lastSelectedKey) !== null && _manager_lastSelectedKey !== void 0 ? _manager_lastSelectedKey : delegate.getLastKey());
            else navigateToFirstKey((_manager_firstSelectedKey = manager.firstSelectedKey) !== null && _manager_firstSelectedKey !== void 0 ? _manager_firstSelectedKey : delegate.getFirstKey());
        } else if (!isVirtualized) {
            // Restore the scroll position to what it was before.
            scrollRef.current.scrollTop = scrollPos.current.top;
            scrollRef.current.scrollLeft = scrollPos.current.left;
        }
        if (!isVirtualized && manager.focusedKey != null) {
            // Refocus and scroll the focused item into view if it exists within the scrollable region.
            let element = scrollRef.current.querySelector(`[data-key="${manager.focusedKey}"]`);
            if (element) {
                // This prevents a flash of focus on the first/last element in the collection, or the collection itself.
                (0, $glPPV$reactariautils.focusWithoutScrolling)(element);
                let modality = (0, $glPPV$reactariainteractions.getInteractionModality)();
                if (modality === "keyboard") (0, $glPPV$reactariautils.scrollIntoViewport)(element, {
                    containingElement: ref.current
                });
            }
        }
    };
    let onBlur = (e)=>{
        // Don't set blurred and then focused again if moving focus within the collection.
        if (!e.currentTarget.contains(e.relatedTarget)) manager.setFocused(false);
    };
    const autoFocusRef = (0, $glPPV$react.useRef)(autoFocus);
    (0, $glPPV$react.useEffect)(()=>{
        if (autoFocusRef.current) {
            let focusedKey = null;
            // Check focus strategy to determine which item to focus
            if (autoFocus === "first") focusedKey = delegate.getFirstKey();
            if (autoFocus === "last") focusedKey = delegate.getLastKey();
            // If there are any selected keys, make the first one the new focus target
            let selectedKeys = manager.selectedKeys;
            if (selectedKeys.size) focusedKey = selectedKeys.values().next().value;
            manager.setFocused(true);
            manager.setFocusedKey(focusedKey);
            // If no default focus key is selected, focus the collection itself.
            if (focusedKey == null && !shouldUseVirtualFocus) (0, $glPPV$reactariafocus.focusSafely)(ref.current);
        }
        autoFocusRef.current = false;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    // If not virtualized, scroll the focused element into view when the focusedKey changes.
    // When virtualized, Virtualizer handles this internally.
    let lastFocusedKey = (0, $glPPV$react.useRef)(manager.focusedKey);
    (0, $glPPV$react.useEffect)(()=>{
        let modality = (0, $glPPV$reactariainteractions.getInteractionModality)();
        if (manager.isFocused && manager.focusedKey != null && (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current)) {
            let element = scrollRef.current.querySelector(`[data-key="${manager.focusedKey}"]`);
            if (element && modality === "keyboard") {
                if (!isVirtualized) (0, $glPPV$reactariautils.scrollIntoView)(scrollRef.current, element);
                (0, $glPPV$reactariautils.scrollIntoViewport)(element, {
                    containingElement: ref.current
                });
            }
        }
        // If the focused key becomes null (e.g. the last item is deleted), focus the whole collection.
        if (manager.isFocused && manager.focusedKey == null && lastFocusedKey.current != null) (0, $glPPV$reactariafocus.focusSafely)(ref.current);
        lastFocusedKey.current = manager.focusedKey;
    }, [
        isVirtualized,
        scrollRef,
        manager.focusedKey,
        manager.isFocused,
        ref
    ]);
    let handlers = {
        onKeyDown: onKeyDown,
        onFocus: onFocus,
        onBlur: onBlur,
        onMouseDown (e) {
            // Ignore events that bubbled through portals.
            if (scrollRef.current === e.target) // Prevent focus going to the collection when clicking on the scrollbar.
            e.preventDefault();
        }
    };
    let { typeSelectProps: typeSelectProps  } = (0, $a1189052f36475e8$export$e32c88dfddc6e1d8)({
        keyboardDelegate: delegate,
        selectionManager: manager
    });
    if (!disallowTypeAhead) handlers = (0, $glPPV$reactariautils.mergeProps)(typeSelectProps, handlers);
    // If nothing is focused within the collection, make the collection itself tabbable.
    // This will be marshalled to either the first or last item depending on where focus came from.
    // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try
    // to move real DOM focus to the element anyway.
    let tabIndex;
    if (!shouldUseVirtualFocus) tabIndex = manager.focusedKey == null ? 0 : -1;
    return {
        collectionProps: {
            ...handlers,
            tabIndex: tabIndex
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 




function $433b1145b0781e10$export$ecf600387e221c37(options) {
    let { selectionManager: manager , key: key , ref: ref , shouldSelectOnPressUp: shouldSelectOnPressUp , shouldUseVirtualFocus: shouldUseVirtualFocus , focus: focus , isDisabled: isDisabled , onAction: onAction , allowsDifferentPressOrigin: allowsDifferentPressOrigin  } = options;
    let onSelect = (e)=>{
        if (e.pointerType === "keyboard" && (0, $ee0bdf4faa47f2a8$export$d3e3bd3e26688c04)(e)) manager.toggleSelection(key);
        else {
            if (manager.selectionMode === "none") return;
            if (manager.selectionMode === "single") {
                if (manager.isSelected(key) && !manager.disallowEmptySelection) manager.toggleSelection(key);
                else manager.replaceSelection(key);
            } else if (e && e.shiftKey) manager.extendSelection(key);
            else if (manager.selectionBehavior === "toggle" || e && ((0, $ee0bdf4faa47f2a8$export$16792effe837dba3)(e) || e.pointerType === "touch" || e.pointerType === "virtual")) // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys
            manager.toggleSelection(key);
            else manager.replaceSelection(key);
        }
    };
    // Focus the associated DOM node when this item becomes the focusedKey
    (0, $glPPV$react.useEffect)(()=>{
        let isFocused = key === manager.focusedKey;
        if (isFocused && manager.isFocused && !shouldUseVirtualFocus) {
            if (focus) focus();
            else if (document.activeElement !== ref.current) (0, $glPPV$reactariafocus.focusSafely)(ref.current);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        ref,
        key,
        manager.focusedKey,
        manager.childFocusStrategy,
        manager.isFocused,
        shouldUseVirtualFocus
    ]);
    isDisabled = isDisabled || manager.isDisabled(key);
    // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused
    // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver
    // on iOS 14 doesn't try to move real DOM focus to the item anyway.
    let itemProps = {};
    if (!shouldUseVirtualFocus && !isDisabled) itemProps = {
        tabIndex: key === manager.focusedKey ? 0 : -1,
        onFocus (e) {
            if (e.target === ref.current) manager.setFocusedKey(key);
        }
    };
    else if (isDisabled) itemProps.onMouseDown = (e)=>{
        // Prevent focus going to the body when clicking on a disabled item.
        e.preventDefault();
    };
    // With checkbox selection, onAction (i.e. navigation) becomes primary, and occurs on a single click of the row.
    // Clicking the checkbox enters selection mode, after which clicking anywhere on any row toggles selection for that row.
    // With highlight selection, onAction is secondary, and occurs on double click. Single click selects the row.
    // With touch, onAction occurs on single tap, and long press enters selection mode.
    let allowsSelection = !isDisabled && manager.canSelectItem(key);
    let allowsActions = onAction && !isDisabled;
    let hasPrimaryAction = allowsActions && (manager.selectionBehavior === "replace" ? !allowsSelection : manager.isEmpty);
    let hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === "replace";
    let hasAction = hasPrimaryAction || hasSecondaryAction;
    let modality = (0, $glPPV$react.useRef)(null);
    let longPressEnabled = hasAction && allowsSelection;
    let longPressEnabledOnPressStart = (0, $glPPV$react.useRef)(false);
    let hadPrimaryActionOnPressStart = (0, $glPPV$react.useRef)(false);
    // By default, selection occurs on pointer down. This can be strange if selecting an
    // item causes the UI to disappear immediately (e.g. menus).
    // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.
    // onPress requires a pointer down event on the same element as pointer up. For menus,
    // we want to be able to have the pointer down on the trigger that opens the menu and
    // the pointer up on the menu item rather than requiring a separate press.
    // For keyboard events, selection still occurs on key down.
    let itemPressProps = {};
    if (shouldSelectOnPressUp) {
        itemPressProps.onPressStart = (e)=>{
            modality.current = e.pointerType;
            longPressEnabledOnPressStart.current = longPressEnabled;
            if (e.pointerType === "keyboard" && (!hasAction || $433b1145b0781e10$var$isSelectionKey())) onSelect(e);
        };
        // If allowsDifferentPressOrigin, make selection happen on pressUp (e.g. open menu on press down, selection on menu item happens on press up.)
        // Otherwise, have selection happen onPress (prevents listview row selection when clicking on interactable elements in the row)
        if (!allowsDifferentPressOrigin) itemPressProps.onPress = (e)=>{
            if (hasPrimaryAction || hasSecondaryAction && e.pointerType !== "mouse") {
                if (e.pointerType === "keyboard" && !$433b1145b0781e10$var$isActionKey()) return;
                onAction();
            } else if (e.pointerType !== "keyboard") onSelect(e);
        };
        else {
            itemPressProps.onPressUp = (e)=>{
                if (e.pointerType !== "keyboard") onSelect(e);
            };
            itemPressProps.onPress = hasPrimaryAction ? ()=>onAction() : null;
        }
    } else {
        itemPressProps.onPressStart = (e)=>{
            modality.current = e.pointerType;
            longPressEnabledOnPressStart.current = longPressEnabled;
            hadPrimaryActionOnPressStart.current = hasPrimaryAction;
            // Select on mouse down unless there is a primary action which will occur on mouse up.
            // For keyboard, select on key down. If there is an action, the Space key selects on key down,
            // and the Enter key performs onAction on key up.
            if (e.pointerType === "mouse" && !hasPrimaryAction || e.pointerType === "keyboard" && (!onAction || $433b1145b0781e10$var$isSelectionKey())) onSelect(e);
        };
        itemPressProps.onPress = (e)=>{
            // Selection occurs on touch up. Primary actions always occur on pointer up.
            // Both primary and secondary actions occur on Enter key up. The only exception
            // is secondary actions, which occur on double click with a mouse.
            if (e.pointerType === "touch" || e.pointerType === "pen" || e.pointerType === "virtual" || e.pointerType === "keyboard" && hasAction && $433b1145b0781e10$var$isActionKey() || e.pointerType === "mouse" && hadPrimaryActionOnPressStart.current) {
                if (hasAction) onAction();
                else onSelect(e);
            }
        };
    }
    itemProps["data-key"] = key;
    itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;
    let { pressProps: pressProps , isPressed: isPressed  } = (0, $glPPV$reactariainteractions.usePress)(itemPressProps);
    // Double clicking with a mouse with selectionBehavior = 'replace' performs an action.
    let onDoubleClick = hasSecondaryAction ? (e)=>{
        if (modality.current === "mouse") {
            e.stopPropagation();
            e.preventDefault();
            onAction();
        }
    } : undefined;
    // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior
    // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to
    // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.
    let { longPressProps: longPressProps  } = (0, $glPPV$reactariainteractions.useLongPress)({
        isDisabled: !longPressEnabled,
        onLongPress (e) {
            if (e.pointerType === "touch") {
                onSelect(e);
                manager.setSelectionBehavior("toggle");
            }
        }
    });
    // Prevent native drag and drop on long press if we also select on long press.
    // Once the user is in selection mode, they can long press again to drag.
    // Use a capturing listener to ensure this runs before useDrag, regardless of
    // the order the props get merged.
    let onDragStartCapture = (e)=>{
        if (modality.current === "touch" && longPressEnabledOnPressStart.current) e.preventDefault();
    };
    return {
        itemProps: (0, $glPPV$reactariautils.mergeProps)(itemProps, allowsSelection || hasPrimaryAction ? pressProps : {}, longPressEnabled ? longPressProps : {}, {
            onDoubleClick: onDoubleClick,
            onDragStartCapture: onDragStartCapture
        }),
        isPressed: isPressed,
        isSelected: manager.isSelected(key),
        isFocused: manager.isFocused && manager.focusedKey === key,
        isDisabled: isDisabled,
        allowsSelection: allowsSelection,
        hasAction: hasAction
    };
}
function $433b1145b0781e10$var$isActionKey() {
    let event = window.event;
    return (event === null || event === void 0 ? void 0 : event.key) === "Enter";
}
function $433b1145b0781e10$var$isSelectionKey() {
    let event = window.event;
    return (event === null || event === void 0 ? void 0 : event.key) === " " || (event === null || event === void 0 ? void 0 : event.code) === "Space";
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
class $836f880b12dcae5c$export$a05409b8bb224a5a {
    getNextKey(key) {
        key = this.collection.getKeyAfter(key);
        while(key != null){
            let item = this.collection.getItem(key);
            if (item.type === "item" && !this.disabledKeys.has(key)) return key;
            key = this.collection.getKeyAfter(key);
        }
        return null;
    }
    getPreviousKey(key) {
        key = this.collection.getKeyBefore(key);
        while(key != null){
            let item = this.collection.getItem(key);
            if (item.type === "item" && !this.disabledKeys.has(key)) return key;
            key = this.collection.getKeyBefore(key);
        }
        return null;
    }
    findKey(key, nextKey, shouldSkip) {
        let item = this.getItem(key);
        if (!item) return null;
        // Find the item above or below in the same column.
        let prevRect = item.getBoundingClientRect();
        do {
            key = nextKey(key);
            item = this.getItem(key);
        }while (item && shouldSkip(prevRect, item.getBoundingClientRect()));
        return key;
    }
    isSameRow(prevRect, itemRect) {
        return prevRect.top === itemRect.top || prevRect.left !== itemRect.left;
    }
    isSameColumn(prevRect, itemRect) {
        return prevRect.left === itemRect.left || prevRect.top !== itemRect.top;
    }
    getKeyBelow(key) {
        if (this.layout === "grid" && this.orientation === "vertical") return this.findKey(key, (key)=>this.getNextKey(key), this.isSameRow);
        else return this.getNextKey(key);
    }
    getKeyAbove(key) {
        if (this.layout === "grid" && this.orientation === "vertical") return this.findKey(key, (key)=>this.getPreviousKey(key), this.isSameRow);
        else return this.getPreviousKey(key);
    }
    getNextColumn(key, right) {
        return right ? this.getPreviousKey(key) : this.getNextKey(key);
    }
    getKeyRightOf(key) {
        if (this.layout === "grid") {
            if (this.orientation === "vertical") return this.getNextColumn(key, this.direction === "rtl");
            else return this.findKey(key, (key)=>this.getNextColumn(key, this.direction === "rtl"), this.isSameColumn);
        } else if (this.orientation === "horizontal") return this.getNextColumn(key, this.direction === "rtl");
        return null;
    }
    getKeyLeftOf(key) {
        if (this.layout === "grid") {
            if (this.orientation === "vertical") return this.getNextColumn(key, this.direction === "ltr");
            else return this.findKey(key, (key)=>this.getNextColumn(key, this.direction === "ltr"), this.isSameColumn);
        } else if (this.orientation === "horizontal") return this.getNextColumn(key, this.direction === "ltr");
        return null;
    }
    getFirstKey() {
        let key = this.collection.getFirstKey();
        while(key != null){
            let item = this.collection.getItem(key);
            if (item.type === "item" && !this.disabledKeys.has(key)) return key;
            key = this.collection.getKeyAfter(key);
        }
        return null;
    }
    getLastKey() {
        let key = this.collection.getLastKey();
        while(key != null){
            let item = this.collection.getItem(key);
            if (item.type === "item" && !this.disabledKeys.has(key)) return key;
            key = this.collection.getKeyBefore(key);
        }
        return null;
    }
    getItem(key) {
        return this.ref.current.querySelector(`[data-key="${key}"]`);
    }
    getKeyPageAbove(key) {
        let menu = this.ref.current;
        let item = this.getItem(key);
        if (!item) return null;
        if (!(0, $glPPV$reactariautils.isScrollable)(menu)) return this.getFirstKey();
        let containerRect = menu.getBoundingClientRect();
        let itemRect = item.getBoundingClientRect();
        if (this.orientation === "horizontal") {
            let containerX = containerRect.x - menu.scrollLeft;
            let pageX = Math.max(0, itemRect.x - containerX + itemRect.width - containerRect.width);
            while(item && itemRect.x - containerX > pageX){
                key = this.getKeyAbove(key);
                item = key == null ? null : this.getItem(key);
                itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();
            }
        } else {
            let containerY = containerRect.y - menu.scrollTop;
            let pageY = Math.max(0, itemRect.y - containerY + itemRect.height - containerRect.height);
            while(item && itemRect.y - containerY > pageY){
                key = this.getKeyAbove(key);
                item = key == null ? null : this.getItem(key);
                itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();
            }
        }
        return key !== null && key !== void 0 ? key : this.getFirstKey();
    }
    getKeyPageBelow(key) {
        let menu = this.ref.current;
        let item = this.getItem(key);
        if (!item) return null;
        if (!(0, $glPPV$reactariautils.isScrollable)(menu)) return this.getLastKey();
        let containerRect = menu.getBoundingClientRect();
        let itemRect = item.getBoundingClientRect();
        if (this.orientation === "horizontal") {
            let containerX = containerRect.x - menu.scrollLeft;
            let pageX = Math.min(menu.scrollWidth, itemRect.x - containerX - itemRect.width + containerRect.width);
            while(item && itemRect.x - containerX < pageX){
                key = this.getKeyBelow(key);
                item = key == null ? null : this.getItem(key);
                itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();
            }
        } else {
            let containerY = containerRect.y - menu.scrollTop;
            let pageY = Math.min(menu.scrollHeight, itemRect.y - containerY - itemRect.height + containerRect.height);
            while(item && itemRect.y - containerY < pageY){
                key = this.getKeyBelow(key);
                item = key == null ? null : this.getItem(key);
                itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();
            }
        }
        return key !== null && key !== void 0 ? key : this.getLastKey();
    }
    getKeyForSearch(search, fromKey) {
        if (!this.collator) return null;
        let collection = this.collection;
        let key = fromKey || this.getFirstKey();
        while(key != null){
            let item = collection.getItem(key);
            let substring = item.textValue.slice(0, search.length);
            if (item.textValue && this.collator.compare(substring, search) === 0) return key;
            key = this.getKeyBelow(key);
        }
        return null;
    }
    constructor(...args){
        if (args.length === 1) {
            let opts = args[0];
            this.collection = opts.collection;
            this.ref = opts.ref;
            this.disabledKeys = opts.disabledKeys || new Set();
            this.orientation = opts.orientation;
            this.direction = opts.direction;
            this.layout = opts.layout || "stack";
        } else {
            this.collection = args[0];
            this.disabledKeys = args[1];
            this.ref = args[2];
            this.collator = args[3];
            this.layout = "stack";
            this.orientation = "vertical";
        }
        // If this is a vertical stack, remove the left/right methods completely
        // so they aren't called by useDroppableCollection.
        if (this.layout === "stack" && this.orientation === "vertical") {
            this.getKeyLeftOf = undefined;
            this.getKeyRightOf = undefined;
        }
    }
}




function $bd230acee196f50c$export$b95089534ab7c1fd(props) {
    let { selectionManager: selectionManager , collection: collection , disabledKeys: disabledKeys , ref: ref , keyboardDelegate: keyboardDelegate , autoFocus: autoFocus , shouldFocusWrap: shouldFocusWrap , isVirtualized: isVirtualized , disallowEmptySelection: disallowEmptySelection , selectOnFocus: selectOnFocus = selectionManager.selectionBehavior === "replace" , disallowTypeAhead: disallowTypeAhead , shouldUseVirtualFocus: shouldUseVirtualFocus , allowsTabNavigation: allowsTabNavigation  } = props;
    // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
    // When virtualized, the layout object will be passed in as a prop and override this.
    let collator = (0, $glPPV$reactariai18n.useCollator)({
        usage: "search",
        sensitivity: "base"
    });
    let disabledBehavior = selectionManager.disabledBehavior;
    let delegate = (0, $glPPV$react.useMemo)(()=>keyboardDelegate || new (0, $836f880b12dcae5c$export$a05409b8bb224a5a)(collection, disabledBehavior === "selection" ? new Set() : disabledKeys, ref, collator), [
        keyboardDelegate,
        collection,
        disabledKeys,
        ref,
        collator,
        disabledBehavior
    ]);
    let { collectionProps: collectionProps  } = (0, $b6837c2f80a3c32f$export$d6daf82dcd84e87c)({
        ref: ref,
        selectionManager: selectionManager,
        keyboardDelegate: delegate,
        autoFocus: autoFocus,
        shouldFocusWrap: shouldFocusWrap,
        disallowEmptySelection: disallowEmptySelection,
        selectOnFocus: selectOnFocus,
        disallowTypeAhead: disallowTypeAhead,
        shouldUseVirtualFocus: shouldUseVirtualFocus,
        allowsTabNavigation: allowsTabNavigation,
        isVirtualized: isVirtualized,
        scrollRef: ref
    });
    return {
        listProps: collectionProps
    };
}






//# sourceMappingURL=main.js.map


/***/ }),

/***/ 66051:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $aB6Cp$react = __webpack_require__(18038);
var $aB6Cp$reactariautils = __webpack_require__(54494);
var $aB6Cp$reactariainteractions = __webpack_require__(16760);
var $aB6Cp$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "FocusScope", () => $a7a032acae3ddda9$export$20e40289641fbbb6);
$parcel$export(module.exports, "useFocusManager", () => $a7a032acae3ddda9$export$10c5169755ce7bd7);
$parcel$export(module.exports, "getFocusableTreeWalker", () => $a7a032acae3ddda9$export$2d6ec8fc375ceafa);
$parcel$export(module.exports, "createFocusManager", () => $a7a032acae3ddda9$export$c5251b9e124bf29);
$parcel$export(module.exports, "isElementInChildOfActiveScope", () => $a7a032acae3ddda9$export$1258395f99bf9cbf);
$parcel$export(module.exports, "FocusRing", () => $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d);
$parcel$export(module.exports, "FocusableProvider", () => $fb504d83237fd6ac$export$13f3202a3e5ddd5);
$parcel$export(module.exports, "useFocusable", () => $fb504d83237fd6ac$export$4c014de7c8940b4c);
$parcel$export(module.exports, "useFocusRing", () => $581a96d6eb128c1b$export$4e328f61c538687f);
$parcel$export(module.exports, "focusSafely", () => $1c7f9157d722357d$export$80f3e147d781571c);
$parcel$export(module.exports, "useHasTabbableChild", () => $259c6413a286f2e6$export$eac1895992b9f3d6);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1c7f9157d722357d$export$80f3e147d781571c(element) {
    // If the user is interacting with a virtual cursor, e.g. screen reader, then
    // wait until after any animated transitions that are currently occurring on
    // the page before shifting focus. This avoids issues with VoiceOver on iOS
    // causing the page to scroll when moving focus if the element is transitioning
    // from off the screen.
    if ((0, $aB6Cp$reactariainteractions.getInteractionModality)() === "virtual") {
        let lastFocusedElement = document.activeElement;
        (0, $aB6Cp$reactariautils.runAfterTransition)(()=>{
            // If focus did not move and the element is still in the document, focus it.
            if (document.activeElement === lastFocusedElement && document.contains(element)) (0, $aB6Cp$reactariautils.focusWithoutScrolling)(element);
        });
    } else (0, $aB6Cp$reactariautils.focusWithoutScrolling)(element);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d5156037ad898a4d$var$isStyleVisible(element) {
    if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) return false;
    let { display: display , visibility: visibility  } = element.style;
    let isVisible = display !== "none" && visibility !== "hidden" && visibility !== "collapse";
    if (isVisible) {
        const { getComputedStyle: getComputedStyle  } = element.ownerDocument.defaultView;
        let { display: computedDisplay , visibility: computedVisibility  } = getComputedStyle(element);
        isVisible = computedDisplay !== "none" && computedVisibility !== "hidden" && computedVisibility !== "collapse";
    }
    return isVisible;
}
function $d5156037ad898a4d$var$isAttributeVisible(element, childElement) {
    return !element.hasAttribute("hidden") && (element.nodeName === "DETAILS" && childElement && childElement.nodeName !== "SUMMARY" ? element.hasAttribute("open") : true);
}
function $d5156037ad898a4d$export$e989c0fffaa6b27a(element, childElement) {
    return element.nodeName !== "#comment" && $d5156037ad898a4d$var$isStyleVisible(element) && $d5156037ad898a4d$var$isAttributeVisible(element, childElement) && (!element.parentElement || $d5156037ad898a4d$export$e989c0fffaa6b27a(element.parentElement, element));
}




const $a7a032acae3ddda9$var$FocusContext = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createContext(null);
let $a7a032acae3ddda9$var$activeScope = null;
function $a7a032acae3ddda9$export$20e40289641fbbb6(props) {
    let { children: children , contain: contain , restoreFocus: restoreFocus , autoFocus: autoFocus  } = props;
    let startRef = (0, $aB6Cp$react.useRef)();
    let endRef = (0, $aB6Cp$react.useRef)();
    let scopeRef = (0, $aB6Cp$react.useRef)([]);
    let { parentNode: parentNode  } = (0, $aB6Cp$react.useContext)($a7a032acae3ddda9$var$FocusContext) || {};
    // Create a tree node here so we can add children to it even before it is added to the tree.
    let node = (0, $aB6Cp$react.useMemo)(()=>new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: scopeRef
        }), [
        scopeRef
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),
        // use the active scope as the parent instead of the parent from context. Layout effects run bottom
        // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope
        // that is being added should get the activeScope as its parent.
        let parent = parentNode || $a7a032acae3ddda9$export$d06fae2ee68b101e.root;
        if ($a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(parent.scopeRef) && $a7a032acae3ddda9$var$activeScope && !$a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, parent.scopeRef)) {
            let activeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
            if (activeNode) parent = activeNode;
        }
        // Add the node to the parent, and to the tree.
        parent.addChild(node);
        $a7a032acae3ddda9$export$d06fae2ee68b101e.addNode(node);
    }, [
        node,
        parentNode
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let node = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef);
        node.contain = contain;
    }, [
        contain
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        // Find all rendered nodes between the sentinels and add them to the scope.
        let node = startRef.current.nextSibling;
        let nodes = [];
        while(node && node !== endRef.current){
            nodes.push(node);
            node = node.nextSibling;
        }
        scopeRef.current = nodes;
    }, [
        children
    ]);
    $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain);
    $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus);
    // this layout effect needs to run last so that focusScopeTree cleanup happens at the last moment possible
    (0, $aB6Cp$react.useEffect)(()=>{
        if (scopeRef) {
            let activeElement = document.activeElement;
            let scope = null;
            // In strict mode, active scope is incorrectly updated since cleanup will run even though scope hasn't unmounted.
            // To fix this, we need to update the actual activeScope here
            if ($a7a032acae3ddda9$var$isElementInScope(activeElement, scopeRef.current)) {
                // Since useLayoutEffect runs for children first, we need to traverse the focusScope tree and find the bottom most scope that
                // contains the active element and set that as the activeScope
                for (let node of $a7a032acae3ddda9$export$d06fae2ee68b101e.traverse())if ($a7a032acae3ddda9$var$isElementInScope(activeElement, node.scopeRef.current)) scope = node;
                if (scope === $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef)) $a7a032acae3ddda9$var$activeScope = scope.scopeRef;
            }
            return ()=>{
                // Scope may have been re-parented.
                let parentScope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).parent.scopeRef;
                // Restore the active scope on unmount if this scope or a descendant scope is active.
                // Parent effect cleanups run before children, so we need to check if the
                // parent scope actually still exists before restoring the active scope to it.
                if ((scopeRef === $a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope(scopeRef, $a7a032acae3ddda9$var$activeScope)) && (!parentScope || $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(parentScope))) $a7a032acae3ddda9$var$activeScope = parentScope;
                $a7a032acae3ddda9$export$d06fae2ee68b101e.removeTreeNode(scopeRef);
            };
        }
    }, [
        scopeRef
    ]);
    let focusManager = (0, $aB6Cp$react.useMemo)(()=>$a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef), []);
    let value = (0, $aB6Cp$react.useMemo)(()=>({
            focusManager: focusManager,
            parentNode: node
        }), [
        node,
        focusManager
    ]);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement($a7a032acae3ddda9$var$FocusContext.Provider, {
        value: value
    }, /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement("span", {
        "data-focus-scope-start": true,
        hidden: true,
        ref: startRef
    }), children, /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement("span", {
        "data-focus-scope-end": true,
        hidden: true,
        ref: endRef
    }));
}
function $a7a032acae3ddda9$export$10c5169755ce7bd7() {
    var _useContext;
    return (_useContext = (0, $aB6Cp$react.useContext)($a7a032acae3ddda9$var$FocusContext)) === null || _useContext === void 0 ? void 0 : _useContext.focusManager;
}
function $a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef) {
    return {
        focusNext (opts = {}) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[0].previousElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = sentinel;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = {}) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[scope.length - 1].nextElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = sentinel;
                previousNode = walker.previousNode();
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = {}) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[0].previousElementSibling;
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = {}) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[scope.length - 1].nextElementSibling;
            let previousNode = walker.previousNode();
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        }
    };
}
const $a7a032acae3ddda9$var$focusableElements = [
    "input:not([disabled]):not([type=hidden])",
    "select:not([disabled])",
    "textarea:not([disabled])",
    "button:not([disabled])",
    "a[href]",
    "area[href]",
    "summary",
    "iframe",
    "object",
    "embed",
    "audio[controls]",
    "video[controls]",
    "[contenteditable]"
];
const $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
$a7a032acae3ddda9$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(':not([hidden]):not([tabindex="-1"]),');
function $a7a032acae3ddda9$var$getScopeRoot(scope) {
    return scope[0].parentElement;
}
function $a7a032acae3ddda9$var$shouldContainFocus(scopeRef) {
    let scope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
    while(scope && scope.scopeRef !== scopeRef){
        if (scope.contain) return false;
        scope = scope.parent;
    }
    return true;
}
function $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain) {
    let focusedNode = (0, $aB6Cp$react.useRef)();
    let raf = (0, $aB6Cp$react.useRef)(null);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let scope = scopeRef.current;
        if (!contain) {
            // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment
            if (raf.current) {
                cancelAnimationFrame(raf.current);
                raf.current = null;
            }
            return;
        }
        // Handle the Tab key to contain focus within the scope
        let onKeyDown = (e)=>{
            if (e.key !== "Tab" || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) return;
            let focusedElement = document.activeElement;
            let scope = scopeRef.current;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scope)) return;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: true
            }, scope);
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!nextElement) {
                walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;
                nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            }
            e.preventDefault();
            if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
        };
        let onFocus = (e)=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if ((!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) && $a7a032acae3ddda9$var$isElementInScope(e.target, scopeRef.current)) {
                $a7a032acae3ddda9$var$activeScope = scopeRef;
                focusedNode.current = e.target;
            } else if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(e.target, scopeRef)) {
                // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),
                // restore focus to the previously focused node or the first tabbable element in the active scope.
                if (focusedNode.current) focusedNode.current.focus();
                else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
            } else if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) focusedNode.current = e.target;
        };
        let onBlur = (e)=>{
            // Firefox doesn't shift focus back to the Dialog properly without this
            if (raf.current) cancelAnimationFrame(raf.current);
            raf.current = requestAnimationFrame(()=>{
                // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe
                if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(document.activeElement, scopeRef)) {
                    $a7a032acae3ddda9$var$activeScope = scopeRef;
                    if (document.body.contains(e.target)) {
                        focusedNode.current = e.target;
                        focusedNode.current.focus();
                    } else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
                }
            });
        };
        document.addEventListener("keydown", onKeyDown, false);
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        scope.forEach((element)=>element.addEventListener("focusout", onBlur, false));
        return ()=>{
            document.removeEventListener("keydown", onKeyDown, false);
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
            scope.forEach((element)=>element.removeEventListener("focusout", onBlur, false));
        };
    }, [
        scopeRef,
        contain
    ]);
    // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur
    // eslint-disable-next-line arrow-body-style
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        return ()=>{
            if (raf.current) cancelAnimationFrame(raf.current);
        };
    }, [
        raf
    ]);
}
function $a7a032acae3ddda9$var$isElementInAnyScope(element) {
    return $a7a032acae3ddda9$var$isElementInChildScope(element);
}
function $a7a032acae3ddda9$var$isElementInScope(element, scope) {
    return scope.some((node)=>node.contains(element));
}
function $a7a032acae3ddda9$var$isElementInChildScope(element, scope = null) {
    // If the element is within a top layer element (e.g. toasts), always allow moving focus there.
    if (element instanceof Element && element.closest("[data-react-aria-top-layer]")) return true;
    // node.contains in isElementInScope covers child scopes that are also DOM children,
    // but does not cover child scopes in portals.
    for (let { scopeRef: s  } of $a7a032acae3ddda9$export$d06fae2ee68b101e.traverse($a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scope))){
        if ($a7a032acae3ddda9$var$isElementInScope(element, s.current)) return true;
    }
    return false;
}
function $a7a032acae3ddda9$export$1258395f99bf9cbf(element) {
    return $a7a032acae3ddda9$var$isElementInChildScope(element, $a7a032acae3ddda9$var$activeScope);
}
function $a7a032acae3ddda9$var$isAncestorScope(ancestor, scope) {
    var _focusScopeTree_getTreeNode;
    let parent = (_focusScopeTree_getTreeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scope)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : _focusScopeTree_getTreeNode.parent;
    while(parent){
        if (parent.scopeRef === ancestor) return true;
        parent = parent.parent;
    }
    return false;
}
function $a7a032acae3ddda9$var$focusElement(element, scroll = false) {
    if (element != null && !scroll) try {
        (0, $1c7f9157d722357d$export$80f3e147d781571c)(element);
    } catch (err) {
    // ignore
    }
    else if (element != null) try {
        element.focus();
    } catch (err) {
    // ignore
    }
}
function $a7a032acae3ddda9$var$focusFirstInScope(scope, tabbable = true) {
    let sentinel = scope[0].previousElementSibling;
    let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
        tabbable: tabbable
    }, scope);
    walker.currentNode = sentinel;
    let nextNode = walker.nextNode();
    // If the scope does not contain a tabbable element, use the first focusable element.
    if (tabbable && !nextNode) {
        walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
            tabbable: false
        }, scope);
        walker.currentNode = sentinel;
        nextNode = walker.nextNode();
    }
    $a7a032acae3ddda9$var$focusElement(nextNode);
}
function $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus) {
    const autoFocusRef = (0, ($parcel$interopDefault($aB6Cp$react))).useRef(autoFocus);
    (0, $aB6Cp$react.useEffect)(()=>{
        if (autoFocusRef.current) {
            $a7a032acae3ddda9$var$activeScope = scopeRef;
            if (!$a7a032acae3ddda9$var$isElementInScope(document.activeElement, $a7a032acae3ddda9$var$activeScope.current)) $a7a032acae3ddda9$var$focusFirstInScope(scopeRef.current);
        }
        autoFocusRef.current = false;
    }, [
        scopeRef
    ]);
}
function $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restore, contain) {
    // tracks the active scope, in case restore and contain are both false.
    // if either are true, this is tracked in useRestoreFocus or useFocusContainment.
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if (restore || contain) return;
        let scope = scopeRef.current;
        let onFocus = (e)=>{
            let target = e.target;
            if ($a7a032acae3ddda9$var$isElementInScope(target, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
            else if (!$a7a032acae3ddda9$var$isElementInAnyScope(target)) $a7a032acae3ddda9$var$activeScope = null;
        };
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        return ()=>{
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
        };
    }, [
        scopeRef,
        restore,
        contain
    ]);
}
function $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef) {
    let scope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
    while(scope && scope.scopeRef !== scopeRef){
        if (scope.nodeToRestore) return false;
        scope = scope.parent;
    }
    return (scope === null || scope === void 0 ? void 0 : scope.scopeRef) === scopeRef;
}
function $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
    // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.
    const nodeToRestoreRef = (0, $aB6Cp$react.useRef)(typeof document !== "undefined" ? document.activeElement : null);
    // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus
    // restoring-non-containing scopes should only care if they become active so they can perform the restore
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let scope = scopeRef.current;
        if (!restoreFocus || contain) return;
        let onFocus = ()=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if ((!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) && $a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
        };
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        return ()=>{
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        scopeRef,
        contain
    ]);
    // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if (!restoreFocus) return;
        $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = nodeToRestoreRef.current;
        // Handle the Tab key so that tabbing out of the scope goes to the next element
        // after the node that had focus when the scope mounted. This is important when
        // using portals for overlays, so that focus goes to the expected element when
        // tabbing out of the overlay.
        let onKeyDown = (e)=>{
            if (e.key !== "Tab" || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) return;
            let focusedElement = document.activeElement;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scopeRef.current)) return;
            let nodeToRestore = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;
            // Create a DOM tree walker that matches all tabbable elements
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(document.body, {
                tabbable: true
            });
            // Find the next tabbable element after the currently focused element
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!document.body.contains(nodeToRestore) || nodeToRestore === document.body) {
                nodeToRestore = null;
                $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = null;
            }
            // If there is no next element, or it is outside the current scope, move focus to the
            // next element after the node to restore to instead.
            if ((!nextElement || !$a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {
                walker.currentNode = nodeToRestore;
                // Skip over elements within the scope, in case the scope immediately follows the node to restore.
                do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
                while ($a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current));
                e.preventDefault();
                e.stopPropagation();
                if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
                else // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)
                // then move focus to the body.
                // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)
                if (!$a7a032acae3ddda9$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();
                else $a7a032acae3ddda9$var$focusElement(nodeToRestore, true);
            }
        };
        if (!contain) document.addEventListener("keydown", onKeyDown, true);
        return ()=>{
            if (!contain) document.removeEventListener("keydown", onKeyDown, true);
            let nodeToRestore = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;
            // if we already lost focus to the body and this was the active scope, then we should attempt to restore
            if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps
            ($a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current) || document.activeElement === document.body && $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef))) {
                // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it
                let clonedTree = $a7a032acae3ddda9$export$d06fae2ee68b101e.clone();
                requestAnimationFrame(()=>{
                    // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere
                    if (document.activeElement === document.body) {
                        // look up the tree starting with our scope to find a nodeToRestore still in the DOM
                        let treeNode = clonedTree.getTreeNode(scopeRef);
                        while(treeNode){
                            if (treeNode.nodeToRestore && document.body.contains(treeNode.nodeToRestore)) {
                                $a7a032acae3ddda9$var$focusElement(treeNode.nodeToRestore);
                                return;
                            }
                            treeNode = treeNode.parent;
                        }
                        // If no nodeToRestore was found, focus the first element in the nearest
                        // ancestor scope that is still in the tree.
                        treeNode = clonedTree.getTreeNode(scopeRef);
                        while(treeNode){
                            if (treeNode.scopeRef && $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(treeNode.scopeRef)) {
                                $a7a032acae3ddda9$var$focusFirstInScope(treeNode.scopeRef.current, true);
                                return;
                            }
                            treeNode = treeNode.parent;
                        }
                    }
                });
            }
        };
    }, [
        scopeRef,
        restoreFocus,
        contain
    ]);
}
function $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, opts, scope) {
    let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR : $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR;
    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode (node) {
            var _opts_from;
            // Skip nodes inside the starting node.
            if (opts === null || opts === void 0 ? void 0 : (_opts_from = opts.from) === null || _opts_from === void 0 ? void 0 : _opts_from.contains(node)) return NodeFilter.FILTER_REJECT;
            if (node.matches(selector) && (0, $d5156037ad898a4d$export$e989c0fffaa6b27a)(node) && (!scope || $a7a032acae3ddda9$var$isElementInScope(node, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node))) return NodeFilter.FILTER_ACCEPT;
            return NodeFilter.FILTER_SKIP;
        }
    });
    if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;
    return walker;
}
function $a7a032acae3ddda9$export$c5251b9e124bf29(ref, defaultOptions = {}) {
    return {
        focusNext (opts = {}) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = root;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            else {
                let next = $a7a032acae3ddda9$var$last(walker);
                if (next) $a7a032acae3ddda9$var$focusElement(next, true);
                return next;
            }
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = root;
                previousNode = $a7a032acae3ddda9$var$last(walker);
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let next = $a7a032acae3ddda9$var$last(walker);
            if (next) $a7a032acae3ddda9$var$focusElement(next, true);
            return next;
        }
    };
}
function $a7a032acae3ddda9$var$last(walker) {
    let next;
    let last;
    do {
        last = walker.lastChild();
        if (last) next = last;
    }while (last);
    return next;
}
class $a7a032acae3ddda9$var$Tree {
    get size() {
        return this.fastMap.size;
    }
    getTreeNode(data) {
        return this.fastMap.get(data);
    }
    addTreeNode(scopeRef, parent, nodeToRestore) {
        let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);
        let node = new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: scopeRef
        });
        parentNode.addChild(node);
        node.parent = parentNode;
        this.fastMap.set(scopeRef, node);
        if (nodeToRestore) node.nodeToRestore = nodeToRestore;
    }
    addNode(node) {
        this.fastMap.set(node.scopeRef, node);
    }
    removeTreeNode(scopeRef) {
        // never remove the root
        if (scopeRef === null) return;
        let node = this.fastMap.get(scopeRef);
        let parentNode = node.parent;
        // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing
        // if we are, then replace the siblings restore with the restore from the scope we're removing
        for (let current of this.traverse())if (current !== node && node.nodeToRestore && current.nodeToRestore && node.scopeRef.current && $a7a032acae3ddda9$var$isElementInScope(current.nodeToRestore, node.scopeRef.current)) current.nodeToRestore = node.nodeToRestore;
        let children = node.children;
        parentNode.removeChild(node);
        if (children.size > 0) children.forEach((child)=>parentNode.addChild(child));
        this.fastMap.delete(node.scopeRef);
    }
    // Pre Order Depth First
    *traverse(node = this.root) {
        if (node.scopeRef != null) yield node;
        if (node.children.size > 0) for (let child of node.children)yield* this.traverse(child);
    }
    clone() {
        let newTree = new $a7a032acae3ddda9$var$Tree();
        for (let node of this.traverse())newTree.addTreeNode(node.scopeRef, node.parent.scopeRef, node.nodeToRestore);
        return newTree;
    }
    constructor(){
        this.fastMap = new Map();
        this.root = new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: null
        });
        this.fastMap.set(null, this.root);
    }
}
class $a7a032acae3ddda9$var$TreeNode {
    addChild(node) {
        this.children.add(node);
        node.parent = this;
    }
    removeChild(node) {
        this.children.delete(node);
        node.parent = undefined;
    }
    constructor(props){
        this.children = new Set();
        this.contain = false;
        this.scopeRef = props.scopeRef;
    }
}
let $a7a032acae3ddda9$export$d06fae2ee68b101e = new $a7a032acae3ddda9$var$Tree();


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 




function $581a96d6eb128c1b$export$4e328f61c538687f(props = {}) {
    let { autoFocus: autoFocus = false , isTextInput: isTextInput , within: within  } = props;
    let state = (0, $aB6Cp$react.useRef)({
        isFocused: false,
        isFocusVisible: autoFocus || (0, $aB6Cp$reactariainteractions.isFocusVisible)()
    });
    let [isFocused, setFocused] = (0, $aB6Cp$react.useState)(false);
    let [isFocusVisibleState, setFocusVisible] = (0, $aB6Cp$react.useState)(()=>state.current.isFocused && state.current.isFocusVisible);
    let updateState = (0, $aB6Cp$react.useCallback)(()=>setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
    let onFocusChange = (0, $aB6Cp$react.useCallback)((isFocused)=>{
        state.current.isFocused = isFocused;
        setFocused(isFocused);
        updateState();
    }, [
        updateState
    ]);
    (0, $aB6Cp$reactariainteractions.useFocusVisibleListener)((isFocusVisible)=>{
        state.current.isFocusVisible = isFocusVisible;
        updateState();
    }, [], {
        isTextInput: isTextInput
    });
    let { focusProps: focusProps  } = (0, $aB6Cp$reactariainteractions.useFocus)({
        isDisabled: within,
        onFocusChange: onFocusChange
    });
    let { focusWithinProps: focusWithinProps  } = (0, $aB6Cp$reactariainteractions.useFocusWithin)({
        isDisabled: !within,
        onFocusWithinChange: onFocusChange
    });
    return {
        isFocused: isFocused,
        isFocusVisible: isFocusVisibleState,
        focusProps: within ? focusWithinProps : focusProps
    };
}


function $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d(props) {
    let { children: children , focusClass: focusClass , focusRingClass: focusRingClass  } = props;
    let { isFocused: isFocused , isFocusVisible: isFocusVisible , focusProps: focusProps  } = (0, $581a96d6eb128c1b$export$4e328f61c538687f)(props);
    let child = (0, ($parcel$interopDefault($aB6Cp$react))).Children.only(children);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).cloneElement(child, (0, $aB6Cp$reactariautils.mergeProps)(child.props, {
        ...focusProps,
        className: (0, ($parcel$interopDefault($aB6Cp$clsx)))({
            [focusClass || ""]: isFocused,
            [focusRingClass || ""]: isFocusVisible
        })
    }));
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



let $fb504d83237fd6ac$var$FocusableContext = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createContext(null);
function $fb504d83237fd6ac$var$useFocusableContext(ref) {
    let context = (0, $aB6Cp$react.useContext)($fb504d83237fd6ac$var$FocusableContext) || {};
    (0, $aB6Cp$reactariautils.useSyncRef)(context, ref);
    // eslint-disable-next-line
    let { ref: _ , ...otherProps } = context;
    return otherProps;
}
/**
 * Provides DOM props to the nearest focusable child.
 */ function $fb504d83237fd6ac$var$FocusableProvider(props, ref) {
    let { children: children , ...otherProps } = props;
    let context = {
        ...otherProps,
        ref: ref
    };
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement($fb504d83237fd6ac$var$FocusableContext.Provider, {
        value: context
    }, children);
}
let $fb504d83237fd6ac$export$13f3202a3e5ddd5 = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).forwardRef($fb504d83237fd6ac$var$FocusableProvider);
function $fb504d83237fd6ac$export$4c014de7c8940b4c(props, domRef) {
    let { focusProps: focusProps  } = (0, $aB6Cp$reactariainteractions.useFocus)(props);
    let { keyboardProps: keyboardProps  } = (0, $aB6Cp$reactariainteractions.useKeyboard)(props);
    let interactions = (0, $aB6Cp$reactariautils.mergeProps)(focusProps, keyboardProps);
    let domProps = $fb504d83237fd6ac$var$useFocusableContext(domRef);
    let interactionProps = props.isDisabled ? {} : domProps;
    let autoFocusRef = (0, $aB6Cp$react.useRef)(props.autoFocus);
    (0, $aB6Cp$react.useEffect)(()=>{
        if (autoFocusRef.current && domRef.current) (0, $1c7f9157d722357d$export$80f3e147d781571c)(domRef.current);
        autoFocusRef.current = false;
    }, [
        domRef
    ]);
    return {
        focusableProps: (0, $aB6Cp$reactariautils.mergeProps)({
            ...interactions,
            tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined
        }, interactionProps)
    };
}




/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $259c6413a286f2e6$export$eac1895992b9f3d6(ref, options) {
    let isDisabled = options === null || options === void 0 ? void 0 : options.isDisabled;
    let [hasTabbableChild, setHasTabbableChild] = (0, $aB6Cp$react.useState)(false);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if ((ref === null || ref === void 0 ? void 0 : ref.current) && !isDisabled) {
            let update = ()=>{
                if (ref.current) {
                    let walker = (0, $a7a032acae3ddda9$export$2d6ec8fc375ceafa)(ref.current, {
                        tabbable: true
                    });
                    setHasTabbableChild(!!walker.nextNode());
                }
            };
            update();
            // Update when new elements are inserted, or the tabIndex/disabled attribute updates.
            let observer = new MutationObserver(update);
            observer.observe(ref.current, {
                subtree: true,
                childList: true,
                attributes: true,
                attributeFilter: [
                    "tabIndex",
                    "disabled"
                ]
            });
            return ()=>{
                // Disconnect mutation observer when a React update occurs on the top-level component
                // so we update synchronously after re-rendering. Otherwise React will emit act warnings
                // in tests since mutation observers fire asynchronously. The mutation observer is necessary
                // so we also update if a child component re-renders and adds/removes something tabbable.
                observer.disconnect();
            };
        }
    });
    return isDisabled ? false : hasTabbableChild;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 76079:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// useMessageFormatter is deprecated, but has a large dependency on intl-messageformat
// that we want to avoid. If it is built into the same file as the rest of the package,
// it deopts tree shaking in Parcel even when unused. Instead, it is split into a separate
// file and re-exported here, which allows tree shaking to work properly.
module.exports = __webpack_require__(51226);
Object.defineProperties(module.exports, Object.getOwnPropertyDescriptors(__webpack_require__(73674)));


/***/ }),

/***/ 51226:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $87SwK$react = __webpack_require__(18038);
var $87SwK$reactariassr = __webpack_require__(23221);
var $87SwK$internationalizedstring = __webpack_require__(36058);
var $87SwK$internationalizeddate = __webpack_require__(50031);
var $87SwK$reactariautils = __webpack_require__(54494);
var $87SwK$internationalizednumber = __webpack_require__(8483);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "I18nProvider", () => $47fa5ec5ff482271$export$a54013f0d02a8f82);
$parcel$export(module.exports, "useLocale", () => $47fa5ec5ff482271$export$43bb16f9c6d9e3f7);
$parcel$export(module.exports, "useMessageFormatter", () => $227f31f0c647c5fc$exports.useMessageFormatter);
$parcel$export(module.exports, "useLocalizedStringFormatter", () => $fc53663969a3d00a$export$f12b703ca79dfbb1);
$parcel$export(module.exports, "useListFormatter", () => $cb6a3e7d490e97a4$export$a2f47a3d2973640);
$parcel$export(module.exports, "useDateFormatter", () => $b80c530ff2e20243$export$85fd5fdf27bacc79);
$parcel$export(module.exports, "useNumberFormatter", () => $fea93c5b7c90d9f4$export$b7a616150fdb9f44);
$parcel$export(module.exports, "useCollator", () => $27a5ce66022270ad$export$a16aca283550c30d);
$parcel$export(module.exports, "useFilter", () => $832d079b867c7223$export$3274cf84b703fff);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // https://en.wikipedia.org/wiki/Right-to-left
const $4d65847630a056a8$var$RTL_SCRIPTS = new Set([
    "Arab",
    "Syrc",
    "Samr",
    "Mand",
    "Thaa",
    "Mend",
    "Nkoo",
    "Adlm",
    "Rohg",
    "Hebr"
]);
const $4d65847630a056a8$var$RTL_LANGS = new Set([
    "ae",
    "ar",
    "arc",
    "bcc",
    "bqi",
    "ckb",
    "dv",
    "fa",
    "glk",
    "he",
    "ku",
    "mzn",
    "nqo",
    "pnb",
    "ps",
    "sd",
    "ug",
    "ur",
    "yi"
]);
function $4d65847630a056a8$export$702d680b21cbd764(locale) {
    // If the Intl.Locale API is available, use it to get the script for the locale.
    // This is more accurate than guessing by language, since languages can be written in multiple scripts.
    // @ts-ignore
    if (Intl.Locale) {
        // @ts-ignore
        let script = new Intl.Locale(locale).maximize().script;
        return $4d65847630a056a8$var$RTL_SCRIPTS.has(script);
    }
    // If not, just guess by the language (first part of the locale)
    let lang = locale.split("-")[0];
    return $4d65847630a056a8$var$RTL_LANGS.has(lang);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $2919bdec75484e64$export$f09106e7c6677ec5() {
    // @ts-ignore
    let locale = typeof navigator !== "undefined" && (navigator.language || navigator.userLanguage) || "en-US";
    try {
        // @ts-ignore
        Intl.DateTimeFormat.supportedLocalesOf([
            locale
        ]);
    } catch (_err) {
        locale = "en-US";
    }
    return {
        locale: locale,
        direction: (0, $4d65847630a056a8$export$702d680b21cbd764)(locale) ? "rtl" : "ltr"
    };
}
let $2919bdec75484e64$var$currentLocale = $2919bdec75484e64$export$f09106e7c6677ec5();
let $2919bdec75484e64$var$listeners = new Set();
function $2919bdec75484e64$var$updateLocale() {
    $2919bdec75484e64$var$currentLocale = $2919bdec75484e64$export$f09106e7c6677ec5();
    for (let listener of $2919bdec75484e64$var$listeners)listener($2919bdec75484e64$var$currentLocale);
}
function $2919bdec75484e64$export$188ec29ebc2bdc3a() {
    let isSSR = (0, $87SwK$reactariassr.useIsSSR)();
    let [defaultLocale, setDefaultLocale] = (0, $87SwK$react.useState)($2919bdec75484e64$var$currentLocale);
    (0, $87SwK$react.useEffect)(()=>{
        if ($2919bdec75484e64$var$listeners.size === 0) window.addEventListener("languagechange", $2919bdec75484e64$var$updateLocale);
        $2919bdec75484e64$var$listeners.add(setDefaultLocale);
        return ()=>{
            $2919bdec75484e64$var$listeners.delete(setDefaultLocale);
            if ($2919bdec75484e64$var$listeners.size === 0) window.removeEventListener("languagechange", $2919bdec75484e64$var$updateLocale);
        };
    }, []);
    // We cannot determine the browser's language on the server, so default to
    // en-US. This will be updated after hydration on the client to the correct value.
    if (isSSR) return {
        locale: "en-US",
        direction: "ltr"
    };
    return defaultLocale;
}



const $47fa5ec5ff482271$var$I18nContext = /*#__PURE__*/ (0, ($parcel$interopDefault($87SwK$react))).createContext(null);
function $47fa5ec5ff482271$export$a54013f0d02a8f82(props) {
    let { locale: locale , children: children  } = props;
    let defaultLocale = (0, $2919bdec75484e64$export$188ec29ebc2bdc3a)();
    let value = locale ? {
        locale: locale,
        direction: (0, $4d65847630a056a8$export$702d680b21cbd764)(locale) ? "rtl" : "ltr"
    } : defaultLocale;
    return /*#__PURE__*/ (0, ($parcel$interopDefault($87SwK$react))).createElement($47fa5ec5ff482271$var$I18nContext.Provider, {
        value: value
    }, children);
}
function $47fa5ec5ff482271$export$43bb16f9c6d9e3f7() {
    let defaultLocale = (0, $2919bdec75484e64$export$188ec29ebc2bdc3a)();
    let context = (0, $87SwK$react.useContext)($47fa5ec5ff482271$var$I18nContext);
    return context || defaultLocale;
}


var $227f31f0c647c5fc$exports = {};
"use strict";


/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $fc53663969a3d00a$var$cache = new WeakMap();
function $fc53663969a3d00a$var$getCachedDictionary(strings) {
    let dictionary = $fc53663969a3d00a$var$cache.get(strings);
    if (!dictionary) {
        dictionary = new (0, $87SwK$internationalizedstring.LocalizedStringDictionary)(strings);
        $fc53663969a3d00a$var$cache.set(strings, dictionary);
    }
    return dictionary;
}
function $fc53663969a3d00a$export$f12b703ca79dfbb1(strings) {
    let { locale: locale  } = (0, $47fa5ec5ff482271$export$43bb16f9c6d9e3f7)();
    let dictionary = (0, $87SwK$react.useMemo)(()=>$fc53663969a3d00a$var$getCachedDictionary(strings), [
        strings
    ]);
    return (0, $87SwK$react.useMemo)(()=>new (0, $87SwK$internationalizedstring.LocalizedStringFormatter)(locale, dictionary), [
        locale,
        dictionary
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $cb6a3e7d490e97a4$export$a2f47a3d2973640(options = {}) {
    let { locale: locale  } = (0, $47fa5ec5ff482271$export$43bb16f9c6d9e3f7)();
    // @ts-ignore
    return (0, $87SwK$react.useMemo)(()=>new Intl.ListFormat(locale, options), [
        locale,
        options
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



function $b80c530ff2e20243$export$85fd5fdf27bacc79(options) {
    // Reuse last options object if it is shallowly equal, which allows the useMemo result to also be reused.
    options = (0, $87SwK$reactariautils.useDeepMemo)(options, $b80c530ff2e20243$var$isEqual);
    let { locale: locale  } = (0, $47fa5ec5ff482271$export$43bb16f9c6d9e3f7)();
    return (0, $87SwK$react.useMemo)(()=>new (0, $87SwK$internationalizeddate.DateFormatter)(locale, options), [
        locale,
        options
    ]);
}
function $b80c530ff2e20243$var$isEqual(a, b) {
    if (a === b) return true;
    let aKeys = Object.keys(a);
    let bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) return false;
    for (let key of aKeys){
        if (b[key] !== a[key]) return false;
    }
    return true;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $fea93c5b7c90d9f4$export$b7a616150fdb9f44(options = {}) {
    let { locale: locale  } = (0, $47fa5ec5ff482271$export$43bb16f9c6d9e3f7)();
    return (0, $87SwK$react.useMemo)(()=>new (0, $87SwK$internationalizednumber.NumberFormatter)(locale, options), [
        locale,
        options
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
let $27a5ce66022270ad$var$cache = new Map();
function $27a5ce66022270ad$export$a16aca283550c30d(options) {
    let { locale: locale  } = (0, $47fa5ec5ff482271$export$43bb16f9c6d9e3f7)();
    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : "");
    if ($27a5ce66022270ad$var$cache.has(cacheKey)) return $27a5ce66022270ad$var$cache.get(cacheKey);
    let formatter = new Intl.Collator(locale, options);
    $27a5ce66022270ad$var$cache.set(cacheKey, formatter);
    return formatter;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $832d079b867c7223$export$3274cf84b703fff(options) {
    let collator = (0, $27a5ce66022270ad$export$a16aca283550c30d)({
        usage: "search",
        ...options
    });
    // TODO(later): these methods don't currently support the ignorePunctuation option.
    let startsWith = (0, $87SwK$react.useCallback)((string, substring)=>{
        if (substring.length === 0) return true;
        // Normalize both strings so we can slice safely
        // TODO: take into account the ignorePunctuation option as well...
        string = string.normalize("NFC");
        substring = substring.normalize("NFC");
        return collator.compare(string.slice(0, substring.length), substring) === 0;
    }, [
        collator
    ]);
    let endsWith = (0, $87SwK$react.useCallback)((string, substring)=>{
        if (substring.length === 0) return true;
        string = string.normalize("NFC");
        substring = substring.normalize("NFC");
        return collator.compare(string.slice(-substring.length), substring) === 0;
    }, [
        collator
    ]);
    let contains = (0, $87SwK$react.useCallback)((string, substring)=>{
        if (substring.length === 0) return true;
        string = string.normalize("NFC");
        substring = substring.normalize("NFC");
        let scan = 0;
        let sliceLen = substring.length;
        for(; scan + sliceLen <= string.length; scan++){
            let slice = string.slice(scan, scan + sliceLen);
            if (collator.compare(substring, slice) === 0) return true;
        }
        return false;
    }, [
        collator
    ]);
    return (0, $87SwK$react.useMemo)(()=>({
            startsWith: startsWith,
            endsWith: endsWith,
            contains: contains
        }), [
        startsWith,
        endsWith,
        contains
    ]);
}




//# sourceMappingURL=real-main.js.map


/***/ }),

/***/ 73674:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.useMessageFormatter = useMessageFormatter;

var _message = __webpack_require__(81020);

var _react = __webpack_require__(18038);

var _i18n = __webpack_require__(76079);

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
const cache = new WeakMap();

function getCachedDictionary(strings) {
  let dictionary = cache.get(strings);

  if (!dictionary) {
    dictionary = new _message.MessageDictionary(strings);
    cache.set(strings, dictionary);
  }

  return dictionary;
}
/**
 * Handles formatting ICU Message strings to create localized strings for the current locale.
 * Automatically updates when the locale changes, and handles caching of messages for performance.
 * @param strings - A mapping of languages to strings by key.
 * @deprecated - use useLocalizedStringFormatter instead.
 */


function useMessageFormatter(strings) {
  let {
    locale
  } = (0, _i18n.useLocale)();
  let dictionary = (0, _react.useMemo)(() => getCachedDictionary(strings), [strings]);
  let formatter = (0, _react.useMemo)(() => new _message.MessageFormatter(locale, dictionary), [locale, dictionary]);
  return (0, _react.useCallback)((key, variables) => formatter.format(key, variables), [formatter]);
}


/***/ }),

/***/ 16760:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $goTMa$reactariautils = __webpack_require__(54494);
var $goTMa$react = __webpack_require__(18038);
var $goTMa$reactariassr = __webpack_require__(23221);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "Pressable", () => $e1dbec26039c051d$export$27c701ed9e449e99);
$parcel$export(module.exports, "PressResponder", () => $3596bae48579386f$export$3351871ee4b288b8);
$parcel$export(module.exports, "useFocus", () => $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6);
$parcel$export(module.exports, "isFocusVisible", () => $e77252a287ef94ab$export$b9b3dfddab17db27);
$parcel$export(module.exports, "getInteractionModality", () => $e77252a287ef94ab$export$630ff653c5ada6a9);
$parcel$export(module.exports, "setInteractionModality", () => $e77252a287ef94ab$export$8397ddfc504fdb9a);
$parcel$export(module.exports, "useInteractionModality", () => $e77252a287ef94ab$export$98e20ec92f614cfe);
$parcel$export(module.exports, "useFocusVisible", () => $e77252a287ef94ab$export$ffd9e5021c1fb2d6);
$parcel$export(module.exports, "useFocusVisibleListener", () => $e77252a287ef94ab$export$ec71b4b83ac08ec3);
$parcel$export(module.exports, "useFocusWithin", () => $d16842bbd0359d1b$export$420e68273165f4ec);
$parcel$export(module.exports, "useHover", () => $ffbc150311c75f01$export$ae780daf29e6d456);
$parcel$export(module.exports, "useInteractOutside", () => $edcfa848c42f94f4$export$872b660ac5a1ff98);
$parcel$export(module.exports, "useKeyboard", () => $892d64db2a3c53b0$export$8f71654801c2f7cd);
$parcel$export(module.exports, "useMove", () => $c09386fc48fa427d$export$36da96379f79f245);
$parcel$export(module.exports, "usePress", () => $0294ea432cd92340$export$45712eceda6fad21);
$parcel$export(module.exports, "useScrollWheel", () => $a3dbce0aed7087e2$export$2123ff2b87c81ca);
$parcel$export(module.exports, "useLongPress", () => $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element
// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually
let $f7e14e656343df57$var$state = "default";
let $f7e14e656343df57$var$savedUserSelect = "";
let $f7e14e656343df57$var$modifiedElementMap = new WeakMap();
function $f7e14e656343df57$export$16a4697467175487(target) {
    if ((0, $goTMa$reactariautils.isIOS)()) {
        if ($f7e14e656343df57$var$state === "default") {
            $f7e14e656343df57$var$savedUserSelect = document.documentElement.style.webkitUserSelect;
            document.documentElement.style.webkitUserSelect = "none";
        }
        $f7e14e656343df57$var$state = "disabled";
    } else if (target instanceof HTMLElement || target instanceof SVGElement) {
        // If not iOS, store the target's original user-select and change to user-select: none
        // Ignore state since it doesn't apply for non iOS
        $f7e14e656343df57$var$modifiedElementMap.set(target, target.style.userSelect);
        target.style.userSelect = "none";
    }
}
function $f7e14e656343df57$export$b0d6fa1ab32e3295(target) {
    if ((0, $goTMa$reactariautils.isIOS)()) {
        // If the state is already default, there's nothing to do.
        // If it is restoring, then there's no need to queue a second restore.
        if ($f7e14e656343df57$var$state !== "disabled") return;
        $f7e14e656343df57$var$state = "restoring";
        // There appears to be a delay on iOS where selection still might occur
        // after pointer up, so wait a bit before removing user-select.
        setTimeout(()=>{
            // Wait for any CSS transitions to complete so we don't recompute style
            // for the whole page in the middle of the animation and cause jank.
            (0, $goTMa$reactariautils.runAfterTransition)(()=>{
                // Avoid race conditions
                if ($f7e14e656343df57$var$state === "restoring") {
                    if (document.documentElement.style.webkitUserSelect === "none") document.documentElement.style.webkitUserSelect = $f7e14e656343df57$var$savedUserSelect || "";
                    $f7e14e656343df57$var$savedUserSelect = "";
                    $f7e14e656343df57$var$state = "default";
                }
            });
        }, 300);
    } else if (target instanceof HTMLElement || target instanceof SVGElement) // If not iOS, restore the target's original user-select if any
    // Ignore state since it doesn't apply for non iOS
    {
        if (target && $f7e14e656343df57$var$modifiedElementMap.has(target)) {
            let targetOldUserSelect = $f7e14e656343df57$var$modifiedElementMap.get(target);
            if (target.style.userSelect === "none") target.style.userSelect = targetOldUserSelect;
            if (target.getAttribute("style") === "") target.removeAttribute("style");
            $f7e14e656343df57$var$modifiedElementMap.delete(target);
        }
    }
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $01d3f539e91688c8$export$5165eccb35aaadb5 = (0, ($parcel$interopDefault($goTMa$react))).createContext(null);
$01d3f539e91688c8$export$5165eccb35aaadb5.displayName = "PressResponderContext";



function $0294ea432cd92340$var$usePressResponderContext(props) {
    // Consume context from <PressResponder> and merge with props.
    let context = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));
    if (context) {
        let { register: register , ...contextProps } = context;
        props = (0, $goTMa$reactariautils.mergeProps)(contextProps, props);
        register();
    }
    (0, $goTMa$reactariautils.useSyncRef)(context, props.ref);
    return props;
}
function $0294ea432cd92340$export$45712eceda6fad21(props) {
    let { onPress: onPress , onPressChange: onPressChange , onPressStart: onPressStart , onPressEnd: onPressEnd , onPressUp: onPressUp , isDisabled: isDisabled , isPressed: isPressedProp , preventFocusOnPress: preventFocusOnPress , shouldCancelOnPointerExit: shouldCancelOnPointerExit , allowTextSelectionOnPress: allowTextSelectionOnPress , // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: _ , ...domProps } = $0294ea432cd92340$var$usePressResponderContext(props);
    let [isPressed, setPressed] = (0, $goTMa$react.useState)(false);
    let ref = (0, $goTMa$react.useRef)({
        isPressed: false,
        ignoreEmulatedMouseEvents: false,
        ignoreClickAfterPress: false,
        didFirePressStart: false,
        activePointerId: null,
        target: null,
        isOverTarget: false,
        pointerType: null
    });
    let { addGlobalListener: addGlobalListener , removeAllGlobalListeners: removeAllGlobalListeners  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let triggerPressStart = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        let state = ref.current;
        if (isDisabled || state.didFirePressStart) return;
        if (onPressStart) onPressStart({
            type: "pressstart",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
        if (onPressChange) onPressChange(true);
        state.didFirePressStart = true;
        setPressed(true);
    });
    let triggerPressEnd = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType, wasPressed = true)=>{
        let state = ref.current;
        if (!state.didFirePressStart) return;
        state.ignoreClickAfterPress = true;
        state.didFirePressStart = false;
        if (onPressEnd) onPressEnd({
            type: "pressend",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
        if (onPressChange) onPressChange(false);
        setPressed(false);
        if (onPress && wasPressed && !isDisabled) onPress({
            type: "press",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let triggerPressUp = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        if (isDisabled) return;
        if (onPressUp) onPressUp({
            type: "pressup",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let cancel = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        let state = ref.current;
        if (state.isPressed) {
            if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
            state.isPressed = false;
            state.isOverTarget = false;
            state.activePointerId = null;
            state.pointerType = null;
            removeAllGlobalListeners();
            if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
        }
    });
    let cancelOnPointerExit = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (shouldCancelOnPointerExit) cancel(e);
    });
    let pressProps = (0, $goTMa$react.useMemo)(()=>{
        let state = ref.current;
        let pressProps = {
            onKeyDown (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {
                    if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                    e.stopPropagation();
                    // If the event is repeating, it may have started on a different element
                    // after which focus moved to the current element. Ignore these events and
                    // only handle the first key down event.
                    if (!state.isPressed && !e.repeat) {
                        state.target = e.currentTarget;
                        state.isPressed = true;
                        triggerPressStart(e, "keyboard");
                        // Focus may move before the key up event, so register the event on the document
                        // instead of the same element where the key down event occurred.
                        addGlobalListener(document, "keyup", onKeyUp, false);
                    }
                } else if (e.key === "Enter" && $0294ea432cd92340$var$isHTMLAnchorLink(e.currentTarget)) // If the target is a link, we won't have handled this above because we want the default
                // browser behavior to open the link when pressing Enter. But we still need to prevent
                // default so that elements above do not also handle it (e.g. table row).
                e.stopPropagation();
            },
            onKeyUp (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target)) triggerPressUp($0294ea432cd92340$var$createEvent(state.target, e), "keyboard");
            },
            onClick (e) {
                if (e && !e.currentTarget.contains(e.target)) return;
                if (e && e.button === 0) {
                    e.stopPropagation();
                    if (isDisabled) e.preventDefault();
                    // If triggered from a screen reader or by using element.click(),
                    // trigger as if it were a keyboard click.
                    if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && (state.pointerType === "virtual" || (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent))) {
                        // Ensure the element receives focus (VoiceOver on iOS does not do this)
                        if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                        triggerPressStart(e, "virtual");
                        triggerPressUp(e, "virtual");
                        triggerPressEnd(e, "virtual");
                    }
                    state.ignoreEmulatedMouseEvents = false;
                    state.ignoreClickAfterPress = false;
                }
            }
        };
        let onKeyUp = (e)=>{
            if (state.isPressed && $0294ea432cd92340$var$isValidKeyboardEvent(e, state.target)) {
                if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                e.stopPropagation();
                state.isPressed = false;
                let target = e.target;
                triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), "keyboard", state.target.contains(target));
                removeAllGlobalListeners();
                // If the target is a link, trigger the click method to open the URL,
                // but defer triggering pressEnd until onClick event handler.
                if (state.target instanceof HTMLElement && state.target.contains(target) && ($0294ea432cd92340$var$isHTMLAnchorLink(state.target) || state.target.getAttribute("role") === "link")) state.target.click();
            }
        };
        if (typeof PointerEvent !== "undefined") {
            pressProps.onPointerDown = (e)=>{
                // Only handle left clicks, and ignore events that bubbled through portals.
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.
                // Ignore and let the onClick handler take care of it instead.
                // https://bugs.webkit.org/show_bug.cgi?id=222627
                // https://bugs.webkit.org/show_bug.cgi?id=223202
                if ((0, $goTMa$reactariautils.isVirtualPointerEvent)(e.nativeEvent)) {
                    state.pointerType = "virtual";
                    return;
                }
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on pointer down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                state.pointerType = e.pointerType;
                e.stopPropagation();
                if (!state.isPressed) {
                    state.isPressed = true;
                    state.isOverTarget = true;
                    state.activePointerId = e.pointerId;
                    state.target = e.currentTarget;
                    if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                    if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);
                    triggerPressStart(e, state.pointerType);
                    addGlobalListener(document, "pointermove", onPointerMove, false);
                    addGlobalListener(document, "pointerup", onPointerUp, false);
                    addGlobalListener(document, "pointercancel", onPointerCancel, false);
                }
            };
            pressProps.onMouseDown = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (e.button === 0) {
                    // Chrome and Firefox on touch Windows devices require mouse down events
                    // to be canceled in addition to pointer events, or an extra asynchronous
                    // focus event will be fired.
                    if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                    e.stopPropagation();
                }
            };
            pressProps.onPointerUp = (e)=>{
                // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.
                if (!e.currentTarget.contains(e.target) || state.pointerType === "virtual") return;
                // Only handle left clicks
                // Safari on iOS sometimes fires pointerup events, even
                // when the touch isn't over the target, so double check.
                if (e.button === 0 && $0294ea432cd92340$var$isOverTarget(e, e.currentTarget)) triggerPressUp(e, state.pointerType || e.pointerType);
            };
            // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.
            // Use pointer move events instead to implement our own hit testing.
            // See https://bugs.webkit.org/show_bug.cgi?id=199803
            let onPointerMove = (e)=>{
                if (e.pointerId !== state.activePointerId) return;
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0) {
                    if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    state.isPressed = false;
                    state.isOverTarget = false;
                    state.activePointerId = null;
                    state.pointerType = null;
                    removeAllGlobalListeners();
                    if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
                }
            };
            let onPointerCancel = (e)=>{
                cancel(e);
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.
                cancel(e);
            };
        } else {
            pressProps.onMouseDown = (e)=>{
                // Only handle left clicks
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on mouse down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                e.stopPropagation();
                if (state.ignoreEmulatedMouseEvents) return;
                state.isPressed = true;
                state.isOverTarget = true;
                state.target = e.currentTarget;
                state.pointerType = (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent) ? "virtual" : "mouse";
                if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(document, "mouseup", onMouseUp, false);
            };
            pressProps.onMouseEnter = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = true;
                    triggerPressStart(e, state.pointerType);
                }
            };
            pressProps.onMouseLeave = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            pressProps.onMouseUp = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType);
            };
            let onMouseUp = (e)=>{
                // Only handle left clicks
                if (e.button !== 0) return;
                state.isPressed = false;
                removeAllGlobalListeners();
                if (state.ignoreEmulatedMouseEvents) {
                    state.ignoreEmulatedMouseEvents = false;
                    return;
                }
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                state.isOverTarget = false;
            };
            pressProps.onTouchStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                let touch = $0294ea432cd92340$var$getTouchFromEvent(e.nativeEvent);
                if (!touch) return;
                state.activePointerId = touch.identifier;
                state.ignoreEmulatedMouseEvents = true;
                state.isOverTarget = true;
                state.isPressed = true;
                state.target = e.currentTarget;
                state.pointerType = "touch";
                // Due to browser inconsistencies, especially on mobile browsers, we prevent default
                // on the emulated mouse event and handle focusing the pressable element ourselves.
                if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(window, "scroll", onScroll, true);
            };
            pressProps.onTouchMove = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart(e, state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            pressProps.onTouchEnd = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    triggerPressUp(e, state.pointerType);
                    triggerPressEnd(e, state.pointerType);
                } else if (state.isOverTarget) triggerPressEnd(e, state.pointerType, false);
                state.isPressed = false;
                state.activePointerId = null;
                state.isOverTarget = false;
                state.ignoreEmulatedMouseEvents = true;
                if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
                removeAllGlobalListeners();
            };
            pressProps.onTouchCancel = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed) cancel(e);
            };
            let onScroll = (e)=>{
                if (state.isPressed && e.target.contains(state.target)) cancel({
                    currentTarget: state.target,
                    shiftKey: false,
                    ctrlKey: false,
                    metaKey: false,
                    altKey: false
                });
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                cancel(e);
            };
        }
        return pressProps;
    }, [
        addGlobalListener,
        isDisabled,
        preventFocusOnPress,
        removeAllGlobalListeners,
        allowTextSelectionOnPress,
        cancel,
        cancelOnPointerExit,
        triggerPressEnd,
        triggerPressStart,
        triggerPressUp
    ]);
    // Remove user-select: none in case component unmounts immediately after pressStart
    // eslint-disable-next-line arrow-body-style
    (0, $goTMa$react.useEffect)(()=>{
        return ()=>{
            if (!allowTextSelectionOnPress) // eslint-disable-next-line react-hooks/exhaustive-deps
            (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(ref.current.target);
        };
    }, [
        allowTextSelectionOnPress
    ]);
    return {
        isPressed: isPressedProp || isPressed,
        pressProps: (0, $goTMa$reactariautils.mergeProps)(domProps, pressProps)
    };
}
function $0294ea432cd92340$var$isHTMLAnchorLink(target) {
    return target.tagName === "A" && target.hasAttribute("href");
}
function $0294ea432cd92340$var$isValidKeyboardEvent(event, currentTarget) {
    const { key: key , code: code  } = event;
    const element = currentTarget;
    const role = element.getAttribute("role");
    // Accessibility for keyboards. Space and Enter only.
    // "Spacebar" is for IE 11
    return (key === "Enter" || key === " " || key === "Spacebar" || code === "Space") && !(element instanceof HTMLInputElement && !$0294ea432cd92340$var$isValidInputKey(element, key) || element instanceof HTMLTextAreaElement || element.isContentEditable) && // A link with a valid href should be handled natively,
    // unless it also has role='button' and was triggered using Space.
    (!$0294ea432cd92340$var$isHTMLAnchorLink(element) || role === "button" && key !== "Enter") && // An element with role='link' should only trigger with Enter key
    !(role === "link" && key !== "Enter");
}
function $0294ea432cd92340$var$getTouchFromEvent(event) {
    const { targetTouches: targetTouches  } = event;
    if (targetTouches.length > 0) return targetTouches[0];
    return null;
}
function $0294ea432cd92340$var$getTouchById(event, pointerId) {
    const changedTouches = event.changedTouches;
    for(let i = 0; i < changedTouches.length; i++){
        const touch = changedTouches[i];
        if (touch.identifier === pointerId) return touch;
    }
    return null;
}
function $0294ea432cd92340$var$createEvent(target, e) {
    return {
        currentTarget: target,
        shiftKey: e.shiftKey,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey
    };
}
function $0294ea432cd92340$var$getPointClientRect(point) {
    let offsetX = point.width / 2 || point.radiusX || 0;
    let offsetY = point.height / 2 || point.radiusY || 0;
    return {
        top: point.clientY - offsetY,
        right: point.clientX + offsetX,
        bottom: point.clientY + offsetY,
        left: point.clientX - offsetX
    };
}
function $0294ea432cd92340$var$areRectanglesOverlapping(a, b) {
    // check if they cannot overlap on x axis
    if (a.left > b.right || b.left > a.right) return false;
    // check if they cannot overlap on y axis
    if (a.top > b.bottom || b.top > a.bottom) return false;
    return true;
}
function $0294ea432cd92340$var$isOverTarget(point, target) {
    let rect = target.getBoundingClientRect();
    let pointRect = $0294ea432cd92340$var$getPointClientRect(point);
    return $0294ea432cd92340$var$areRectanglesOverlapping(rect, pointRect);
}
function $0294ea432cd92340$var$shouldPreventDefault(target) {
    // We cannot prevent default if the target is a draggable element.
    return !(target instanceof HTMLElement) || !target.draggable;
}
function $0294ea432cd92340$var$shouldPreventDefaultKeyboard(target, key) {
    if (target instanceof HTMLInputElement) return !$0294ea432cd92340$var$isValidInputKey(target, key);
    if (target instanceof HTMLButtonElement) return target.type !== "submit";
    return true;
}
const $0294ea432cd92340$var$nonTextInputTypes = new Set([
    "checkbox",
    "radio",
    "range",
    "color",
    "file",
    "image",
    "button",
    "submit",
    "reset"
]);
function $0294ea432cd92340$var$isValidInputKey(target, key) {
    // Only space should toggle checkboxes and radios, not enter.
    return target.type === "checkbox" || target.type === "radio" ? key === " " : $0294ea432cd92340$var$nonTextInputTypes.has(target.type);
}



const $e1dbec26039c051d$export$27c701ed9e449e99 = /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).forwardRef(({ children: children , ...props }, ref)=>{
    let newRef = (0, $goTMa$react.useRef)();
    ref = ref !== null && ref !== void 0 ? ref : newRef;
    let { pressProps: pressProps  } = (0, $0294ea432cd92340$export$45712eceda6fad21)({
        ...props,
        ref: ref
    });
    let child = (0, ($parcel$interopDefault($goTMa$react))).Children.only(children);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).cloneElement(child, // @ts-ignore
    {
        ref: ref,
        ...(0, $goTMa$reactariautils.mergeProps)(child.props, pressProps)
    });
});


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $3596bae48579386f$export$3351871ee4b288b8 = /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).forwardRef(({ children: children , ...props }, ref)=>{
    let isRegistered = (0, $goTMa$react.useRef)(false);
    let prevContext = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));
    let context = (0, $goTMa$reactariautils.mergeProps)(prevContext || {}, {
        ...props,
        ref: ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref),
        register () {
            isRegistered.current = true;
            if (prevContext) prevContext.register();
        }
    });
    (0, $goTMa$reactariautils.useSyncRef)(prevContext, ref);
    (0, $goTMa$react.useEffect)(()=>{
        if (!isRegistered.current) {
            console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.");
            isRegistered.current = true; // only warn once in strict mode.
        }
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).createElement((0, $01d3f539e91688c8$export$5165eccb35aaadb5).Provider, {
        value: context
    }, children);
});


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

class $625cf83917e112ad$export$905e7fc544a71f36 {
    isDefaultPrevented() {
        return this.nativeEvent.defaultPrevented;
    }
    preventDefault() {
        this.defaultPrevented = true;
        this.nativeEvent.preventDefault();
    }
    stopPropagation() {
        this.nativeEvent.stopPropagation();
        this.isPropagationStopped = ()=>true;
    }
    isPropagationStopped() {
        return false;
    }
    persist() {}
    constructor(type, nativeEvent){
        this.nativeEvent = nativeEvent;
        this.target = nativeEvent.target;
        this.currentTarget = nativeEvent.currentTarget;
        this.relatedTarget = nativeEvent.relatedTarget;
        this.bubbles = nativeEvent.bubbles;
        this.cancelable = nativeEvent.cancelable;
        this.defaultPrevented = nativeEvent.defaultPrevented;
        this.eventPhase = nativeEvent.eventPhase;
        this.isTrusted = nativeEvent.isTrusted;
        this.timeStamp = nativeEvent.timeStamp;
        this.type = type;
    }
}
function $625cf83917e112ad$export$715c682d09d639cc(onBlur) {
    let stateRef = (0, $goTMa$react.useRef)({
        isFocused: false,
        observer: null
    });
    // Clean up MutationObserver on unmount. See below.
    // eslint-disable-next-line arrow-body-style
    (0, $goTMa$reactariautils.useLayoutEffect)(()=>{
        const state = stateRef.current;
        return ()=>{
            if (state.observer) {
                state.observer.disconnect();
                state.observer = null;
            }
        };
    }, []);
    let dispatchBlur = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
    });
    // This function is called during a React onFocus event.
    return (0, $goTMa$react.useCallback)((e)=>{
        // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142
        // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a
        // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.
        // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.
        if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {
            stateRef.current.isFocused = true;
            let target = e.target;
            let onBlurHandler = (e)=>{
                stateRef.current.isFocused = false;
                if (target.disabled) // For backward compatibility, dispatch a (fake) React synthetic event.
                dispatchBlur(new $625cf83917e112ad$export$905e7fc544a71f36("blur", e));
                // We no longer need the MutationObserver once the target is blurred.
                if (stateRef.current.observer) {
                    stateRef.current.observer.disconnect();
                    stateRef.current.observer = null;
                }
            };
            target.addEventListener("focusout", onBlurHandler, {
                once: true
            });
            stateRef.current.observer = new MutationObserver(()=>{
                if (stateRef.current.isFocused && target.disabled) {
                    stateRef.current.observer.disconnect();
                    let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
                    target.dispatchEvent(new FocusEvent("blur", {
                        relatedTarget: relatedTargetEl
                    }));
                    target.dispatchEvent(new FocusEvent("focusout", {
                        bubbles: true,
                        relatedTarget: relatedTargetEl
                    }));
                }
            });
            stateRef.current.observer.observe(target, {
                attributes: true,
                attributeFilter: [
                    "disabled"
                ]
            });
        }
    }, [
        dispatchBlur
    ]);
}


function $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6(props) {
    let { isDisabled: isDisabled , onFocus: onFocusProp , onBlur: onBlurProp , onFocusChange: onFocusChange  } = props;
    const onBlur = (0, $goTMa$react.useCallback)((e)=>{
        if (e.target === e.currentTarget) {
            if (onBlurProp) onBlurProp(e);
            if (onFocusChange) onFocusChange(false);
            return true;
        }
    }, [
        onBlurProp,
        onFocusChange
    ]);
    const onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);
    const onFocus = (0, $goTMa$react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (e.target === e.currentTarget && document.activeElement === e.target) {
            if (onFocusProp) onFocusProp(e);
            if (onFocusChange) onFocusChange(true);
            onSyntheticFocus(e);
        }
    }, [
        onFocusChange,
        onFocusProp,
        onSyntheticFocus
    ]);
    return {
        focusProps: {
            onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,
            onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : undefined
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions



let $e77252a287ef94ab$var$currentModality = null;
let $e77252a287ef94ab$var$changeHandlers = new Set();
let $e77252a287ef94ab$var$hasSetupGlobalListeners = false;
let $e77252a287ef94ab$var$hasEventBeforeFocus = false;
let $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
// Only Tab or Esc keys will make focus visible on text input elements
const $e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS = {
    Tab: true,
    Escape: true
};
function $e77252a287ef94ab$var$triggerChangeHandlers(modality, e) {
    for (let handler of $e77252a287ef94ab$var$changeHandlers)handler(modality, e);
}
/**
 * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.
 */ function $e77252a287ef94ab$var$isValidKey(e) {
    // Control and Shift keys trigger when navigating back to the tab with keyboard.
    return !(e.metaKey || !(0, $goTMa$reactariautils.isMac)() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
function $e77252a287ef94ab$var$handleKeyboardEvent(e) {
    $e77252a287ef94ab$var$hasEventBeforeFocus = true;
    if ($e77252a287ef94ab$var$isValidKey(e)) {
        $e77252a287ef94ab$var$currentModality = "keyboard";
        $e77252a287ef94ab$var$triggerChangeHandlers("keyboard", e);
    }
}
function $e77252a287ef94ab$var$handlePointerEvent(e) {
    $e77252a287ef94ab$var$currentModality = "pointer";
    if (e.type === "mousedown" || e.type === "pointerdown") {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$triggerChangeHandlers("pointer", e);
    }
}
function $e77252a287ef94ab$var$handleClickEvent(e) {
    if ((0, $goTMa$reactariautils.isVirtualClick)(e)) {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$currentModality = "virtual";
    }
}
function $e77252a287ef94ab$var$handleFocusEvent(e) {
    // Firefox fires two extra focus events when the user first clicks into an iframe:
    // first on the window, then on the document. We ignore these events so they don't
    // cause keyboard focus rings to appear.
    if (e.target === window || e.target === document) return;
    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.
    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.
    if (!$e77252a287ef94ab$var$hasEventBeforeFocus && !$e77252a287ef94ab$var$hasBlurredWindowRecently) {
        $e77252a287ef94ab$var$currentModality = "virtual";
        $e77252a287ef94ab$var$triggerChangeHandlers("virtual", e);
    }
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
}
function $e77252a287ef94ab$var$handleWindowBlur() {
    // When the window is blurred, reset state. This is necessary when tabbing out of the window,
    // for example, since a subsequent focus event won't be fired.
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = true;
}
/**
 * Setup global event listeners to control when keyboard focus style should be visible.
 */ function $e77252a287ef94ab$var$setupGlobalFocusEvents() {
    if (typeof window === "undefined" || $e77252a287ef94ab$var$hasSetupGlobalListeners) return;
    // Programmatic focus() calls shouldn't affect the current input modality.
    // However, we need to detect other cases when a focus event occurs without
    // a preceding user event (e.g. screen reader focus). Overriding the focus
    // method on HTMLElement.prototype is a bit hacky, but works.
    let focus = HTMLElement.prototype.focus;
    HTMLElement.prototype.focus = function() {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        focus.apply(this, arguments);
    };
    document.addEventListener("keydown", $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener("keyup", $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener("click", $e77252a287ef94ab$var$handleClickEvent, true);
    // Register focus events on the window so they are sure to happen
    // before React's event listeners (registered on the document).
    window.addEventListener("focus", $e77252a287ef94ab$var$handleFocusEvent, true);
    window.addEventListener("blur", $e77252a287ef94ab$var$handleWindowBlur, false);
    if (typeof PointerEvent !== "undefined") {
        document.addEventListener("pointerdown", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("pointermove", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("pointerup", $e77252a287ef94ab$var$handlePointerEvent, true);
    } else {
        document.addEventListener("mousedown", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("mousemove", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("mouseup", $e77252a287ef94ab$var$handlePointerEvent, true);
    }
    $e77252a287ef94ab$var$hasSetupGlobalListeners = true;
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e77252a287ef94ab$var$setupGlobalFocusEvents();
    else document.addEventListener("DOMContentLoaded", $e77252a287ef94ab$var$setupGlobalFocusEvents);
}
function $e77252a287ef94ab$export$b9b3dfddab17db27() {
    return $e77252a287ef94ab$var$currentModality !== "pointer";
}
function $e77252a287ef94ab$export$630ff653c5ada6a9() {
    return $e77252a287ef94ab$var$currentModality;
}
function $e77252a287ef94ab$export$8397ddfc504fdb9a(modality) {
    $e77252a287ef94ab$var$currentModality = modality;
    $e77252a287ef94ab$var$triggerChangeHandlers(modality, null);
}
function $e77252a287ef94ab$export$98e20ec92f614cfe() {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    let [modality, setModality] = (0, $goTMa$react.useState)($e77252a287ef94ab$var$currentModality);
    (0, $goTMa$react.useEffect)(()=>{
        let handler = ()=>{
            setModality($e77252a287ef94ab$var$currentModality);
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    }, []);
    return (0, $goTMa$reactariassr.useIsSSR)() ? null : modality;
}
/**
 * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that
 * focus visible style can be properly set.
 */ function $e77252a287ef94ab$var$isKeyboardFocusEvent(isTextInput, modality, e) {
    return !(isTextInput && modality === "keyboard" && e instanceof KeyboardEvent && !$e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);
}
function $e77252a287ef94ab$export$ffd9e5021c1fb2d6(props = {}) {
    let { isTextInput: isTextInput , autoFocus: autoFocus  } = props;
    let [isFocusVisibleState, setFocusVisible] = (0, $goTMa$react.useState)(autoFocus || $e77252a287ef94ab$export$b9b3dfddab17db27());
    $e77252a287ef94ab$export$ec71b4b83ac08ec3((isFocusVisible)=>{
        setFocusVisible(isFocusVisible);
    }, [
        isTextInput
    ], {
        isTextInput: isTextInput
    });
    return {
        isFocusVisible: isFocusVisibleState
    };
}
function $e77252a287ef94ab$export$ec71b4b83ac08ec3(fn, deps, opts) {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    (0, $goTMa$react.useEffect)(()=>{
        let handler = (modality, e)=>{
            if (!$e77252a287ef94ab$var$isKeyboardFocusEvent(opts === null || opts === void 0 ? void 0 : opts.isTextInput, modality, e)) return;
            fn($e77252a287ef94ab$export$b9b3dfddab17db27());
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, deps);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $d16842bbd0359d1b$export$420e68273165f4ec(props) {
    let { isDisabled: isDisabled , onBlurWithin: onBlurWithin , onFocusWithin: onFocusWithin , onFocusWithinChange: onFocusWithinChange  } = props;
    let state = (0, $goTMa$react.useRef)({
        isFocusWithin: false
    });
    let onBlur = (0, $goTMa$react.useCallback)((e)=>{
        // We don't want to trigger onBlurWithin and then immediately onFocusWithin again
        // when moving focus inside the element. Only trigger if the currentTarget doesn't
        // include the relatedTarget (where focus is moving).
        if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {
            state.current.isFocusWithin = false;
            if (onBlurWithin) onBlurWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(false);
        }
    }, [
        onBlurWithin,
        onFocusWithinChange,
        state
    ]);
    let onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);
    let onFocus = (0, $goTMa$react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (!state.current.isFocusWithin && document.activeElement === e.target) {
            if (onFocusWithin) onFocusWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(true);
            state.current.isFocusWithin = true;
            onSyntheticFocus(e);
        }
    }, [
        onFocusWithin,
        onFocusWithinChange,
        onSyntheticFocus
    ]);
    if (isDisabled) return {
        focusWithinProps: {
            onFocus: null,
            onBlur: null
        }
    };
    return {
        focusWithinProps: {
            onFocus: onFocus,
            onBlur: onBlur
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

// iOS fires onPointerEnter twice: once with pointerType="touch" and again with pointerType="mouse".
// We want to ignore these emulated events so they do not trigger hover behavior.
// See https://bugs.webkit.org/show_bug.cgi?id=214609.
let $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
let $ffbc150311c75f01$var$hoverCount = 0;
function $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents() {
    $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = true;
    // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter
    // with pointerType="mouse" immediately after onPointerUp and before onFocus. On other
    // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in
    // the distant future because a user previously touched the element.
    setTimeout(()=>{
        $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
    }, 50);
}
function $ffbc150311c75f01$var$handleGlobalPointerEvent(e) {
    if (e.pointerType === "touch") $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $ffbc150311c75f01$var$setupGlobalTouchEvents() {
    if (typeof document === "undefined") return;
    if (typeof PointerEvent !== "undefined") document.addEventListener("pointerup", $ffbc150311c75f01$var$handleGlobalPointerEvent);
    else document.addEventListener("touchend", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    $ffbc150311c75f01$var$hoverCount++;
    return ()=>{
        $ffbc150311c75f01$var$hoverCount--;
        if ($ffbc150311c75f01$var$hoverCount > 0) return;
        if (typeof PointerEvent !== "undefined") document.removeEventListener("pointerup", $ffbc150311c75f01$var$handleGlobalPointerEvent);
        else document.removeEventListener("touchend", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    };
}
function $ffbc150311c75f01$export$ae780daf29e6d456(props) {
    let { onHoverStart: onHoverStart , onHoverChange: onHoverChange , onHoverEnd: onHoverEnd , isDisabled: isDisabled  } = props;
    let [isHovered, setHovered] = (0, $goTMa$react.useState)(false);
    let state = (0, $goTMa$react.useRef)({
        isHovered: false,
        ignoreEmulatedMouseEvents: false,
        pointerType: "",
        target: null
    }).current;
    (0, $goTMa$react.useEffect)($ffbc150311c75f01$var$setupGlobalTouchEvents, []);
    let { hoverProps: hoverProps , triggerHoverEnd: triggerHoverEnd  } = (0, $goTMa$react.useMemo)(()=>{
        let triggerHoverStart = (event, pointerType)=>{
            state.pointerType = pointerType;
            if (isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target)) return;
            state.isHovered = true;
            let target = event.currentTarget;
            state.target = target;
            if (onHoverStart) onHoverStart({
                type: "hoverstart",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(true);
            setHovered(true);
        };
        let triggerHoverEnd = (event, pointerType)=>{
            state.pointerType = "";
            state.target = null;
            if (pointerType === "touch" || !state.isHovered) return;
            state.isHovered = false;
            let target = event.currentTarget;
            if (onHoverEnd) onHoverEnd({
                type: "hoverend",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(false);
            setHovered(false);
        };
        let hoverProps = {};
        if (typeof PointerEvent !== "undefined") {
            hoverProps.onPointerEnter = (e)=>{
                if ($ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents && e.pointerType === "mouse") return;
                triggerHoverStart(e, e.pointerType);
            };
            hoverProps.onPointerLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);
            };
        } else {
            hoverProps.onTouchStart = ()=>{
                state.ignoreEmulatedMouseEvents = true;
            };
            hoverProps.onMouseEnter = (e)=>{
                if (!state.ignoreEmulatedMouseEvents && !$ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, "mouse");
                state.ignoreEmulatedMouseEvents = false;
            };
            hoverProps.onMouseLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, "mouse");
            };
        }
        return {
            hoverProps: hoverProps,
            triggerHoverEnd: triggerHoverEnd
        };
    }, [
        onHoverStart,
        onHoverChange,
        onHoverEnd,
        isDisabled,
        state
    ]);
    (0, $goTMa$react.useEffect)(()=>{
        // Call the triggerHoverEnd as soon as isDisabled changes to true
        // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering
        if (isDisabled) triggerHoverEnd({
            currentTarget: state.target
        }, state.pointerType);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        isDisabled
    ]);
    return {
        hoverProps: hoverProps,
        isHovered: isHovered
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $edcfa848c42f94f4$export$872b660ac5a1ff98(props) {
    let { ref: ref , onInteractOutside: onInteractOutside , isDisabled: isDisabled , onInteractOutsideStart: onInteractOutsideStart  } = props;
    let stateRef = (0, $goTMa$react.useRef)({
        isPointerDown: false,
        ignoreEmulatedMouseEvents: false
    });
    let onPointerDown = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (onInteractOutside && $edcfa848c42f94f4$var$isValidEvent(e, ref)) {
            if (onInteractOutsideStart) onInteractOutsideStart(e);
            stateRef.current.isPointerDown = true;
        }
    });
    let triggerInteractOutside = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (onInteractOutside) onInteractOutside(e);
    });
    (0, $goTMa$react.useEffect)(()=>{
        let state = stateRef.current;
        if (isDisabled) return;
        // Use pointer events if available. Otherwise, fall back to mouse and touch events.
        if (typeof PointerEvent !== "undefined") {
            let onPointerUp = (e)=>{
                if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            // changing these to capture phase fixed combobox
            document.addEventListener("pointerdown", onPointerDown, true);
            document.addEventListener("pointerup", onPointerUp, true);
            return ()=>{
                document.removeEventListener("pointerdown", onPointerDown, true);
                document.removeEventListener("pointerup", onPointerUp, true);
            };
        } else {
            let onMouseUp = (e)=>{
                if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;
                else if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            let onTouchEnd = (e)=>{
                state.ignoreEmulatedMouseEvents = true;
                if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            document.addEventListener("mousedown", onPointerDown, true);
            document.addEventListener("mouseup", onMouseUp, true);
            document.addEventListener("touchstart", onPointerDown, true);
            document.addEventListener("touchend", onTouchEnd, true);
            return ()=>{
                document.removeEventListener("mousedown", onPointerDown, true);
                document.removeEventListener("mouseup", onMouseUp, true);
                document.removeEventListener("touchstart", onPointerDown, true);
                document.removeEventListener("touchend", onTouchEnd, true);
            };
        }
    }, [
        ref,
        isDisabled,
        onPointerDown,
        triggerInteractOutside
    ]);
}
function $edcfa848c42f94f4$var$isValidEvent(event, ref) {
    if (event.button > 0) return false;
    if (event.target) {
        // if the event target is no longer in the document, ignore
        const ownerDocument = event.target.ownerDocument;
        if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;
        // If the target is within a top layer element (e.g. toasts), ignore.
        if (event.target.closest("[data-react-aria-top-layer]")) return false;
    }
    return ref.current && !ref.current.contains(event.target);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $951fbcbbca8db6ce$export$48d1ea6320830260(handler) {
    if (!handler) return;
    let shouldStopPropagation = true;
    return (e)=>{
        let event = {
            ...e,
            preventDefault () {
                e.preventDefault();
            },
            isDefaultPrevented () {
                return e.isDefaultPrevented();
            },
            stopPropagation () {
                console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
            },
            continuePropagation () {
                shouldStopPropagation = false;
            }
        };
        handler(event);
        if (shouldStopPropagation) e.stopPropagation();
    };
}


function $892d64db2a3c53b0$export$8f71654801c2f7cd(props) {
    return {
        keyboardProps: props.isDisabled ? {} : {
            onKeyDown: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyDown),
            onKeyUp: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyUp)
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $c09386fc48fa427d$export$36da96379f79f245(props) {
    let { onMoveStart: onMoveStart , onMove: onMove , onMoveEnd: onMoveEnd  } = props;
    let state = (0, $goTMa$react.useRef)({
        didMove: false,
        lastPosition: null,
        id: null
    });
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let move = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType, deltaX, deltaY)=>{
        if (deltaX === 0 && deltaY === 0) return;
        if (!state.current.didMove) {
            state.current.didMove = true;
            onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart({
                type: "movestart",
                pointerType: pointerType,
                shiftKey: originalEvent.shiftKey,
                metaKey: originalEvent.metaKey,
                ctrlKey: originalEvent.ctrlKey,
                altKey: originalEvent.altKey
            });
        }
        onMove({
            type: "move",
            pointerType: pointerType,
            deltaX: deltaX,
            deltaY: deltaY,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let end = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)();
        if (state.current.didMove) onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd({
            type: "moveend",
            pointerType: pointerType,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let moveProps = (0, $goTMa$react.useMemo)(()=>{
        let moveProps = {};
        let start = ()=>{
            (0, $f7e14e656343df57$export$16a4697467175487)();
            state.current.didMove = false;
        };
        if (typeof PointerEvent === "undefined") {
            let onMouseMove = (e)=>{
                if (e.button === 0) {
                    move(e, "mouse", e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onMouseUp = (e)=>{
                if (e.button === 0) {
                    end(e, "mouse");
                    removeGlobalListener(window, "mousemove", onMouseMove, false);
                    removeGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            moveProps.onMouseDown = (e)=>{
                if (e.button === 0) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    addGlobalListener(window, "mousemove", onMouseMove, false);
                    addGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            let onTouchMove = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id);
                if (touch >= 0) {
                    let { pageX: pageX , pageY: pageY  } = e.changedTouches[touch];
                    move(e, "touch", pageX - state.current.lastPosition.pageX, pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: pageX,
                        pageY: pageY
                    };
                }
            };
            let onTouchEnd = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id);
                if (touch >= 0) {
                    end(e, "touch");
                    state.current.id = null;
                    removeGlobalListener(window, "touchmove", onTouchMove);
                    removeGlobalListener(window, "touchend", onTouchEnd);
                    removeGlobalListener(window, "touchcancel", onTouchEnd);
                }
            };
            moveProps.onTouchStart = (e)=>{
                if (e.changedTouches.length === 0 || state.current.id != null) return;
                let { pageX: pageX , pageY: pageY , identifier: identifier  } = e.changedTouches[0];
                start();
                e.stopPropagation();
                e.preventDefault();
                state.current.lastPosition = {
                    pageX: pageX,
                    pageY: pageY
                };
                state.current.id = identifier;
                addGlobalListener(window, "touchmove", onTouchMove, false);
                addGlobalListener(window, "touchend", onTouchEnd, false);
                addGlobalListener(window, "touchcancel", onTouchEnd, false);
            };
        } else {
            let onPointerMove = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    // Problems with PointerEvent#movementX/movementY:
                    // 1. it is always 0 on macOS Safari.
                    // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS
                    move(e, pointerType, e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    end(e, pointerType);
                    state.current.id = null;
                    removeGlobalListener(window, "pointermove", onPointerMove, false);
                    removeGlobalListener(window, "pointerup", onPointerUp, false);
                    removeGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
            moveProps.onPointerDown = (e)=>{
                if (e.button === 0 && state.current.id == null) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    state.current.id = e.pointerId;
                    addGlobalListener(window, "pointermove", onPointerMove, false);
                    addGlobalListener(window, "pointerup", onPointerUp, false);
                    addGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
        }
        let triggerKeyboardMove = (e, deltaX, deltaY)=>{
            start();
            move(e, "keyboard", deltaX, deltaY);
            end(e, "keyboard");
        };
        moveProps.onKeyDown = (e)=>{
            switch(e.key){
                case "Left":
                case "ArrowLeft":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, -1, 0);
                    break;
                case "Right":
                case "ArrowRight":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 1, 0);
                    break;
                case "Up":
                case "ArrowUp":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, -1);
                    break;
                case "Down":
                case "ArrowDown":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, 1);
                    break;
            }
        };
        return moveProps;
    }, [
        state,
        addGlobalListener,
        removeGlobalListener,
        move,
        end
    ]);
    return {
        moveProps: moveProps
    };
}



/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $a3dbce0aed7087e2$export$2123ff2b87c81ca(props, ref) {
    let { onScroll: onScroll , isDisabled: isDisabled  } = props;
    let onScrollHandler = (0, $goTMa$react.useCallback)((e)=>{
        // If the ctrlKey is pressed, this is a zoom event, do nothing.
        if (e.ctrlKey) return;
        // stop scrolling the page
        e.preventDefault();
        e.stopPropagation();
        if (onScroll) onScroll({
            deltaX: e.deltaX,
            deltaY: e.deltaY
        });
    }, [
        onScroll
    ]);
    (0, $goTMa$reactariautils.useEvent)(ref, "wheel", isDisabled ? null : onScrollHandler);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD = 500;
function $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9(props) {
    let { isDisabled: isDisabled , onLongPressStart: onLongPressStart , onLongPressEnd: onLongPressEnd , onLongPress: onLongPress , threshold: threshold = $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD , accessibilityDescription: accessibilityDescription  } = props;
    const timeRef = (0, $goTMa$react.useRef)(null);
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let { pressProps: pressProps  } = (0, $0294ea432cd92340$export$45712eceda6fad21)({
        isDisabled: isDisabled,
        onPressStart (e) {
            if (e.pointerType === "mouse" || e.pointerType === "touch") {
                if (onLongPressStart) onLongPressStart({
                    ...e,
                    type: "longpressstart"
                });
                timeRef.current = setTimeout(()=>{
                    // Prevent other usePress handlers from also handling this event.
                    e.target.dispatchEvent(new PointerEvent("pointercancel", {
                        bubbles: true
                    }));
                    if (onLongPress) onLongPress({
                        ...e,
                        type: "longpress"
                    });
                    timeRef.current = null;
                }, threshold);
                // Prevent context menu, which may be opened on long press on touch devices
                if (e.pointerType === "touch") {
                    let onContextMenu = (e)=>{
                        e.preventDefault();
                    };
                    addGlobalListener(e.target, "contextmenu", onContextMenu, {
                        once: true
                    });
                    addGlobalListener(window, "pointerup", ()=>{
                        // If no contextmenu event is fired quickly after pointerup, remove the handler
                        // so future context menu events outside a long press are not prevented.
                        setTimeout(()=>{
                            removeGlobalListener(e.target, "contextmenu", onContextMenu);
                        }, 30);
                    }, {
                        once: true
                    });
                }
            }
        },
        onPressEnd (e) {
            if (timeRef.current) clearTimeout(timeRef.current);
            if (onLongPressEnd && (e.pointerType === "mouse" || e.pointerType === "touch")) onLongPressEnd({
                ...e,
                type: "longpressend"
            });
        }
    });
    let descriptionProps = (0, $goTMa$reactariautils.useDescription)(onLongPress && !isDisabled ? accessibilityDescription : null);
    return {
        longPressProps: (0, $goTMa$reactariautils.mergeProps)(pressProps, descriptionProps)
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 23221:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $4hxXn$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "SSRProvider", () => $29383e587d62412a$export$9f8ac96af4b1b2ae);
$parcel$export(module.exports, "useSSRSafeId", () => $29383e587d62412a$export$619500959fc48b26);
$parcel$export(module.exports, "useIsSSR", () => $29383e587d62412a$export$535bd6ca7f90a273);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We must avoid a circular dependency with @react-aria/utils, and this useLayoutEffect is
// guarded by a check that it only runs on the client side.
// eslint-disable-next-line rulesdir/useLayoutEffectRule

// Default context value to use in case there is no SSRProvider. This is fine for
// client-only apps. In order to support multiple copies of React Aria potentially
// being on the page at once, the prefix is set to a random number. SSRProvider
// will reset this to zero for consistency between server and client, so in the
// SSR case multiple copies of React Aria is not supported.
const $29383e587d62412a$var$defaultContext = {
    prefix: String(Math.round(Math.random() * 10000000000)),
    current: 0,
    isSSR: false
};
const $29383e587d62412a$var$SSRContext = /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createContext($29383e587d62412a$var$defaultContext);
// This is only used in React < 18.
function $29383e587d62412a$var$LegacySSRProvider(props) {
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let counter = $29383e587d62412a$var$useCounter(cur === $29383e587d62412a$var$defaultContext);
    let [isSSR, setIsSSR] = (0, $4hxXn$react.useState)(true);
    let value = (0, $4hxXn$react.useMemo)(()=>({
            // If this is the first SSRProvider, start with an empty string prefix, otherwise
            // append and increment the counter.
            prefix: cur === $29383e587d62412a$var$defaultContext ? "" : `${cur.prefix}-${counter}`,
            current: 0,
            isSSR: isSSR
        }), [
        cur,
        counter,
        isSSR
    ]);
    // If on the client, and the component was initially server rendered,
    // then schedule a layout effect to update the component after hydration.
    if (typeof window !== "undefined") // This if statement technically breaks the rules of hooks, but is safe
    // because the condition never changes after mounting.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, $4hxXn$react.useLayoutEffect)(()=>{
        setIsSSR(false);
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$SSRContext.Provider, {
        value: value
    }, props.children);
}
let $29383e587d62412a$var$warnedAboutSSRProvider = false;
function $29383e587d62412a$export$9f8ac96af4b1b2ae(props) {
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function") {
        if (!$29383e587d62412a$var$warnedAboutSSRProvider) {
            console.warn("In React 18, SSRProvider is not necessary and is a noop. You can remove it from your app.");
            $29383e587d62412a$var$warnedAboutSSRProvider = true;
        }
        return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement((0, ($parcel$interopDefault($4hxXn$react))).Fragment, null, props.children);
    }
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$LegacySSRProvider, props);
}
let $29383e587d62412a$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
let $29383e587d62412a$var$componentIds = new WeakMap();
function $29383e587d62412a$var$useCounter(isDisabled = false) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let ref = (0, $4hxXn$react.useRef)(null);
    // eslint-disable-next-line rulesdir/pure-render
    if (ref.current === null && !isDisabled) {
        var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner;
        // In strict mode, React renders components twice, and the ref will be reset to null on the second render.
        // This means our id counter will be incremented twice instead of once. This is a problem because on the
        // server, components are only rendered once and so ids generated on the server won't match the client.
        // In React 18, useId was introduced to solve this, but it is not available in older versions. So to solve this
        // we need to use some React internals to access the underlying Fiber instance, which is stable between renders.
        // This is exposed as ReactCurrentOwner in development, which is all we need since StrictMode only runs in development.
        // To ensure that we only increment the global counter once, we store the starting id for this component in
        // a weak map associated with the Fiber. On the second render, we reset the global counter to this value.
        // Since React runs the second render immediately after the first, this is safe.
        // @ts-ignore
        let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, ($parcel$interopDefault($4hxXn$react))).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;
        if (currentOwner) {
            let prevComponentValue = $29383e587d62412a$var$componentIds.get(currentOwner);
            if (prevComponentValue == null) // On the first render, and first call to useId, store the id and state in our weak map.
            $29383e587d62412a$var$componentIds.set(currentOwner, {
                id: ctx.current,
                state: currentOwner.memoizedState
            });
            else if (currentOwner.memoizedState !== prevComponentValue.state) {
                // On the second render, the memoizedState gets reset by React.
                // Reset the counter, and remove from the weak map so we don't
                // do this for subsequent useId calls.
                ctx.current = prevComponentValue.id;
                $29383e587d62412a$var$componentIds.delete(currentOwner);
            }
        }
        // eslint-disable-next-line rulesdir/pure-render
        ref.current = ++ctx.current;
    }
    // eslint-disable-next-line rulesdir/pure-render
    return ref.current;
}
function $29383e587d62412a$var$useLegacySSRSafeId(defaultId) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    // If we are rendering in a non-DOM environment, and there's no SSRProvider,
    // provide a warning to hint to the developer to add one.
    if (ctx === $29383e587d62412a$var$defaultContext && !$29383e587d62412a$var$canUseDOM) console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
    let counter = $29383e587d62412a$var$useCounter(!!defaultId);
    return defaultId || `react-aria${ctx.prefix}-${counter}`;
}
function $29383e587d62412a$var$useModernSSRSafeId(defaultId) {
    // @ts-ignore
    let id = (0, ($parcel$interopDefault($4hxXn$react))).useId();
    let [didSSR] = (0, $4hxXn$react.useState)($29383e587d62412a$export$535bd6ca7f90a273());
    let prefix = didSSR ? "react-aria" : `react-aria${$29383e587d62412a$var$defaultContext.prefix}`;
    return defaultId || `${prefix}-${id}`;
}
const $29383e587d62412a$export$619500959fc48b26 = typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function" ? $29383e587d62412a$var$useModernSSRSafeId : $29383e587d62412a$var$useLegacySSRSafeId;
function $29383e587d62412a$var$getSnapshot() {
    return false;
}
function $29383e587d62412a$var$getServerSnapshot() {
    return true;
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function $29383e587d62412a$var$subscribe(onStoreChange) {
    // noop
    return ()=>{};
}
function $29383e587d62412a$export$535bd6ca7f90a273() {
    // In React 18, we can use useSyncExternalStore to detect if we're server rendering or hydrating.
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"] === "function") return (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"]($29383e587d62412a$var$subscribe, $29383e587d62412a$var$getSnapshot, $29383e587d62412a$var$getServerSnapshot);
    // eslint-disable-next-line react-hooks/rules-of-hooks
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    return cur.isSSR;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 54494:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $1Yh1N$reactstatelyutils = __webpack_require__(12259);
var $1Yh1N$react = __webpack_require__(18038);
var $1Yh1N$reactariassr = __webpack_require__(23221);
var $1Yh1N$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useId", () => $8c61827343eed941$export$f680877a34711e37);
$parcel$export(module.exports, "mergeIds", () => $8c61827343eed941$export$cd8c9cb68f842629);
$parcel$export(module.exports, "useSlotId", () => $8c61827343eed941$export$b4cc09c592e8fdb8);
$parcel$export(module.exports, "chain", () => $1e2191638e54f613$export$e08e3b67e392101e);
$parcel$export(module.exports, "mergeProps", () => $f847cd1382ea7cd4$export$9d1611c77c2fe928);
$parcel$export(module.exports, "mergeRefs", () => $f05dc24eafaeb7e2$export$c9058316764c140e);
$parcel$export(module.exports, "filterDOMProps", () => $8d15d0e1797d4238$export$457c3d6518dd4c6f);
$parcel$export(module.exports, "focusWithoutScrolling", () => $1117b6c0d4c4c164$export$de79e2c695e052f3);
$parcel$export(module.exports, "getOffset", () => $16ec41ef3e36c19c$export$622cea445a1c5b7d);
$parcel$export(module.exports, "runAfterTransition", () => $e8117ebcab55be6a$export$24490316f764c430);
$parcel$export(module.exports, "useDrag1D", () => $28ed3fb20343b78b$export$7bbed75feba39706);
$parcel$export(module.exports, "useGlobalListeners", () => $4571ff54ac709100$export$4eaf04e54aa8eed6);
$parcel$export(module.exports, "useLabels", () => $6ec78bde395c477d$export$d6875122194c7b44);
$parcel$export(module.exports, "useObjectRef", () => $475b35fe72ba49b3$export$4338b53315abf666);
$parcel$export(module.exports, "useUpdateEffect", () => $29293a6f5c75b37e$export$496315a1608d9602);
$parcel$export(module.exports, "useLayoutEffect", () => $78605a5d7424e31b$export$e5c5a5f917a5871c);
$parcel$export(module.exports, "useResizeObserver", () => $37733e1652f47193$export$683480f191c0e3ea);
$parcel$export(module.exports, "useSyncRef", () => $6fc733991a9f977c$export$4debdb1a3f0fa79e);
$parcel$export(module.exports, "getScrollParent", () => $d796e7157ac96470$export$cfa2225e87938781);
$parcel$export(module.exports, "isScrollable", () => $d796e7157ac96470$export$2bb74740c4e19def);
$parcel$export(module.exports, "useViewportSize", () => $8b24bab62f5c65ad$export$d699905dd57c73ca);
$parcel$export(module.exports, "useDescription", () => $34da4502ea8120db$export$f8aeda7b10753fa1);
$parcel$export(module.exports, "isMac", () => $9e20cff0af27e8cc$export$9ac100e40613ea10);
$parcel$export(module.exports, "isIPhone", () => $9e20cff0af27e8cc$export$186c6964ca17d99);
$parcel$export(module.exports, "isIPad", () => $9e20cff0af27e8cc$export$7bef049ce92e4224);
$parcel$export(module.exports, "isIOS", () => $9e20cff0af27e8cc$export$fedb369cb70207f1);
$parcel$export(module.exports, "isAppleDevice", () => $9e20cff0af27e8cc$export$e1865c3bedcd822b);
$parcel$export(module.exports, "isWebKit", () => $9e20cff0af27e8cc$export$78551043582a6a98);
$parcel$export(module.exports, "isChrome", () => $9e20cff0af27e8cc$export$6446a186d09e379e);
$parcel$export(module.exports, "isAndroid", () => $9e20cff0af27e8cc$export$a11b0059900ceec8);
$parcel$export(module.exports, "useEvent", () => $2a8c0bb1629926c8$export$90fc3a17d93f704c);
$parcel$export(module.exports, "useValueEffect", () => $19a2307bfabafaf1$export$14d238f342723f25);
$parcel$export(module.exports, "scrollIntoView", () => $449412113267a1fe$export$53a0910f038337bd);
$parcel$export(module.exports, "scrollIntoViewport", () => $449412113267a1fe$export$c826860796309d1b);
$parcel$export(module.exports, "clamp", () => $1Yh1N$reactstatelyutils.clamp);
$parcel$export(module.exports, "snapValueToStep", () => $1Yh1N$reactstatelyutils.snapValueToStep);
$parcel$export(module.exports, "isVirtualClick", () => $577e795361f19be9$export$60278871457622de);
$parcel$export(module.exports, "isVirtualPointerEvent", () => $577e795361f19be9$export$29bf1b5f2c56cf63);
$parcel$export(module.exports, "useEffectEvent", () => $1254e5bb94ac8761$export$7f54fc3180508a52);
$parcel$export(module.exports, "useDeepMemo", () => $20e6e72fbf5dc81e$export$722debc0e56fea39);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $78605a5d7424e31b$export$e5c5a5f917a5871c = typeof window !== "undefined" ? (0, ($parcel$interopDefault($1Yh1N$react))).useLayoutEffect : ()=>{};



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $19a2307bfabafaf1$export$14d238f342723f25(defaultValue) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultValue);
    let valueRef = (0, $1Yh1N$react.useRef)(value);
    let effect = (0, $1Yh1N$react.useRef)(null);
    // Must be stable so that `queue` is stable.
    let nextIter = (0, $1Yh1N$react.useCallback)(()=>{
        // Run the generator to the next yield.
        let newValue = effect.current.next();
        while(!newValue.done && valueRef.current === newValue.value)// If the value is the same as the current value,
        // then continue to the next yield. Otherwise,
        // set the value in state and wait for the next layout effect.
        newValue = effect.current.next();
        // If the generator is done, reset the effect.
        if (newValue.done) {
            effect.current = null;
            return;
        }
        // Always update valueRef when setting the state.
        // This is needed because the function is not regenerated with the new state value since
        // they must be stable across renders. Instead, it gets carried in the ref, but the setState
        // is also needed in order to cause a rerender.
        setValue(newValue.value);
        valueRef.current = newValue.value;
    // this list of dependencies is stable, setState and refs never change after first render.
    }, [
        setValue,
        valueRef,
        effect
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        // If there is an effect currently running, continue to the next yield.
        if (effect.current) nextIter();
    });
    // queue must be a stable function, much like setState.
    let queue = (0, $1Yh1N$react.useCallback)((fn)=>{
        effect.current = fn(valueRef.current);
        nextIter();
    // this list of dependencies is stable, setState and refs never change after first render.
    // in addition, nextIter is stable as outlined above
    }, [
        nextIter,
        effect,
        valueRef
    ]);
    return [
        value,
        queue
    ];
}


let $8c61827343eed941$var$idsUpdaterMap = new Map();
function $8c61827343eed941$export$f680877a34711e37(defaultId) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultId);
    let nextId = (0, $1Yh1N$react.useRef)(null);
    let res = (0, $1Yh1N$reactariassr.useSSRSafeId)(value);
    let updateValue = (0, $1Yh1N$react.useCallback)((val)=>{
        nextId.current = val;
    }, []);
    $8c61827343eed941$var$idsUpdaterMap.set(res, updateValue);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        let r = res;
        return ()=>{
            $8c61827343eed941$var$idsUpdaterMap.delete(r);
        };
    }, [
        res
    ]);
    // This cannot cause an infinite loop because the ref is updated first.
    // eslint-disable-next-line
    (0, $1Yh1N$react.useEffect)(()=>{
        let newId = nextId.current;
        if (newId) {
            nextId.current = null;
            setValue(newId);
        }
    });
    return res;
}
function $8c61827343eed941$export$cd8c9cb68f842629(idA, idB) {
    if (idA === idB) return idA;
    let setIdA = $8c61827343eed941$var$idsUpdaterMap.get(idA);
    if (setIdA) {
        setIdA(idB);
        return idB;
    }
    let setIdB = $8c61827343eed941$var$idsUpdaterMap.get(idB);
    if (setIdB) {
        setIdB(idA);
        return idA;
    }
    return idB;
}
function $8c61827343eed941$export$b4cc09c592e8fdb8(depArray = []) {
    let id = $8c61827343eed941$export$f680877a34711e37();
    let [resolvedId, setResolvedId] = (0, $19a2307bfabafaf1$export$14d238f342723f25)(id);
    let updateId = (0, $1Yh1N$react.useCallback)(()=>{
        setResolvedId(function*() {
            yield id;
            yield document.getElementById(id) ? id : undefined;
        });
    }, [
        id,
        setResolvedId
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(updateId, [
        id,
        updateId,
        ...depArray
    ]);
    return resolvedId;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /**
 * Calls all functions in the order they were chained with the same arguments.
 */ function $1e2191638e54f613$export$e08e3b67e392101e(...callbacks) {
    return (...args)=>{
        for (let callback of callbacks)if (typeof callback === "function") callback(...args);
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $f847cd1382ea7cd4$export$9d1611c77c2fe928(...args) {
    // Start with a base clone of the first argument. This is a lot faster than starting
    // with an empty object and adding properties as we go.
    let result = {
        ...args[0]
    };
    for(let i = 1; i < args.length; i++){
        let props = args[i];
        for(let key in props){
            let a = result[key];
            let b = props[key];
            // Chain events
            if (typeof a === "function" && typeof b === "function" && // This is a lot faster than a regex.
            key[0] === "o" && key[1] === "n" && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = (0, $1e2191638e54f613$export$e08e3b67e392101e)(a, b);
            else if ((key === "className" || key === "UNSAFE_className") && typeof a === "string" && typeof b === "string") result[key] = (0, ($parcel$interopDefault($1Yh1N$clsx)))(a, b);
            else if (key === "id" && a && b) result.id = (0, $8c61827343eed941$export$cd8c9cb68f842629)(a, b);
            else result[key] = b !== undefined ? b : a;
        }
    }
    return result;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $f05dc24eafaeb7e2$export$c9058316764c140e(...refs) {
    if (refs.length === 1) return refs[0];
    return (value)=>{
        for (let ref of refs){
            if (typeof ref === "function") ref(value);
            else if (ref != null) ref.current = value;
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ const $8d15d0e1797d4238$var$DOMPropNames = new Set([
    "id"
]);
const $8d15d0e1797d4238$var$labelablePropNames = new Set([
    "aria-label",
    "aria-labelledby",
    "aria-describedby",
    "aria-details"
]);
const $8d15d0e1797d4238$var$propRe = /^(data-.*)$/;
function $8d15d0e1797d4238$export$457c3d6518dd4c6f(props, opts = {}) {
    let { labelable: labelable , propNames: propNames  } = opts;
    let filteredProps = {};
    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($8d15d0e1797d4238$var$DOMPropNames.has(prop) || labelable && $8d15d0e1797d4238$var$labelablePropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $8d15d0e1797d4238$var$propRe.test(prop))) filteredProps[prop] = props[prop];
    return filteredProps;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $1117b6c0d4c4c164$export$de79e2c695e052f3(element) {
    if ($1117b6c0d4c4c164$var$supportsPreventScroll()) element.focus({
        preventScroll: true
    });
    else {
        let scrollableElements = $1117b6c0d4c4c164$var$getScrollableElements(element);
        element.focus();
        $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements);
    }
}
let $1117b6c0d4c4c164$var$supportsPreventScrollCached = null;
function $1117b6c0d4c4c164$var$supportsPreventScroll() {
    if ($1117b6c0d4c4c164$var$supportsPreventScrollCached == null) {
        $1117b6c0d4c4c164$var$supportsPreventScrollCached = false;
        try {
            var focusElem = document.createElement("div");
            focusElem.focus({
                get preventScroll () {
                    $1117b6c0d4c4c164$var$supportsPreventScrollCached = true;
                    return true;
                }
            });
        } catch (e) {
        // Ignore
        }
    }
    return $1117b6c0d4c4c164$var$supportsPreventScrollCached;
}
function $1117b6c0d4c4c164$var$getScrollableElements(element) {
    var parent = element.parentNode;
    var scrollableElements = [];
    var rootScrollingElement = document.scrollingElement || document.documentElement;
    while(parent instanceof HTMLElement && parent !== rootScrollingElement){
        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({
            element: parent,
            scrollTop: parent.scrollTop,
            scrollLeft: parent.scrollLeft
        });
        parent = parent.parentNode;
    }
    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
        element: rootScrollingElement,
        scrollTop: rootScrollingElement.scrollTop,
        scrollLeft: rootScrollingElement.scrollLeft
    });
    return scrollableElements;
}
function $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements) {
    for (let { element: element , scrollTop: scrollTop , scrollLeft: scrollLeft  } of scrollableElements){
        element.scrollTop = scrollTop;
        element.scrollLeft = scrollLeft;
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $16ec41ef3e36c19c$export$622cea445a1c5b7d(element, reverse, orientation = "horizontal") {
    let rect = element.getBoundingClientRect();
    if (reverse) return orientation === "horizontal" ? rect.right : rect.bottom;
    return orientation === "horizontal" ? rect.left : rect.top;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We store a global list of elements that are currently transitioning,
// mapped to a set of CSS properties that are transitioning for that element.
// This is necessary rather than a simple count of transitions because of browser
// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather
// than one or the other. So we need to track what's actually transitioning so that
// we can ignore these duplicate events.
let $e8117ebcab55be6a$var$transitionsByElement = new Map();
// A list of callbacks to call once there are no transitioning elements.
let $e8117ebcab55be6a$var$transitionCallbacks = new Set();
function $e8117ebcab55be6a$var$setupGlobalEvents() {
    if (typeof window === "undefined") return;
    let onTransitionStart = (e)=>{
        // Add the transitioning property to the list for this element.
        let transitions = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!transitions) {
            transitions = new Set();
            $e8117ebcab55be6a$var$transitionsByElement.set(e.target, transitions);
            // The transitioncancel event must be registered on the element itself, rather than as a global
            // event. This enables us to handle when the node is deleted from the document while it is transitioning.
            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.
            e.target.addEventListener("transitioncancel", onTransitionEnd);
        }
        transitions.add(e.propertyName);
    };
    let onTransitionEnd = (e)=>{
        // Remove property from list of transitioning properties.
        let properties = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!properties) return;
        properties.delete(e.propertyName);
        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.
        if (properties.size === 0) {
            e.target.removeEventListener("transitioncancel", onTransitionEnd);
            $e8117ebcab55be6a$var$transitionsByElement.delete(e.target);
        }
        // If no transitioning elements, call all of the queued callbacks.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) {
            for (let cb of $e8117ebcab55be6a$var$transitionCallbacks)cb();
            $e8117ebcab55be6a$var$transitionCallbacks.clear();
        }
    };
    document.body.addEventListener("transitionrun", onTransitionStart);
    document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e8117ebcab55be6a$var$setupGlobalEvents();
    else document.addEventListener("DOMContentLoaded", $e8117ebcab55be6a$var$setupGlobalEvents);
}
function $e8117ebcab55be6a$export$24490316f764c430(fn) {
    // Wait one frame to see if an animation starts, e.g. a transition on mount.
    requestAnimationFrame(()=>{
        // If no transitions are running, call the function immediately.
        // Otherwise, add it to a list of callbacks to run at the end of the animation.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) fn();
        else $e8117ebcab55be6a$var$transitionCallbacks.add(fn);
    });
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 

// Keep track of elements that we are currently handling dragging for via useDrag1D.
// If there's an ancestor and a descendant both using useDrag1D(), and the user starts
// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.
const $28ed3fb20343b78b$var$draggingElements = [];
function $28ed3fb20343b78b$export$7bbed75feba39706(props) {
    console.warn("useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html");
    let { containerRef: containerRef , reverse: reverse , orientation: orientation , onHover: onHover , onDrag: onDrag , onPositionChange: onPositionChange , onIncrement: onIncrement , onDecrement: onDecrement , onIncrementToMax: onIncrementToMax , onDecrementToMin: onDecrementToMin , onCollapseToggle: onCollapseToggle  } = props;
    let getPosition = (e)=>orientation === "horizontal" ? e.clientX : e.clientY;
    let getNextOffset = (e)=>{
        let containerOffset = (0, $16ec41ef3e36c19c$export$622cea445a1c5b7d)(containerRef.current, reverse, orientation);
        let mouseOffset = getPosition(e);
        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;
        return nextOffset;
    };
    let dragging = (0, $1Yh1N$react.useRef)(false);
    let prevPosition = (0, $1Yh1N$react.useRef)(0);
    // Keep track of the current handlers in a ref so that the events can access them.
    let handlers = (0, $1Yh1N$react.useRef)({
        onPositionChange: onPositionChange,
        onDrag: onDrag
    });
    handlers.current.onDrag = onDrag;
    handlers.current.onPositionChange = onPositionChange;
    let onMouseDragged = (e)=>{
        e.preventDefault();
        let nextOffset = getNextOffset(e);
        if (!dragging.current) {
            dragging.current = true;
            if (handlers.current.onDrag) handlers.current.onDrag(true);
            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        }
        if (prevPosition.current === nextOffset) return;
        prevPosition.current = nextOffset;
        if (onPositionChange) onPositionChange(nextOffset);
    };
    let onMouseUp = (e)=>{
        const target = e.target;
        dragging.current = false;
        let nextOffset = getNextOffset(e);
        if (handlers.current.onDrag) handlers.current.onDrag(false);
        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        $28ed3fb20343b78b$var$draggingElements.splice($28ed3fb20343b78b$var$draggingElements.indexOf(target), 1);
        window.removeEventListener("mouseup", onMouseUp, false);
        window.removeEventListener("mousemove", onMouseDragged, false);
    };
    let onMouseDown = (e)=>{
        const target = e.currentTarget;
        // If we're already handling dragging on a descendant with useDrag1D, then
        // we don't want to handle the drag motion on this target as well.
        if ($28ed3fb20343b78b$var$draggingElements.some((elt)=>target.contains(elt))) return;
        $28ed3fb20343b78b$var$draggingElements.push(target);
        window.addEventListener("mousemove", onMouseDragged, false);
        window.addEventListener("mouseup", onMouseUp, false);
    };
    let onMouseEnter = ()=>{
        if (onHover) onHover(true);
    };
    let onMouseOut = ()=>{
        if (onHover) onHover(false);
    };
    let onKeyDown = (e)=>{
        switch(e.key){
            case "Left":
            case "ArrowLeft":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Up":
            case "ArrowUp":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Right":
            case "ArrowRight":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Down":
            case "ArrowDown":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Home":
                e.preventDefault();
                if (onDecrementToMin) onDecrementToMin();
                break;
            case "End":
                e.preventDefault();
                if (onIncrementToMax) onIncrementToMax();
                break;
            case "Enter":
                e.preventDefault();
                if (onCollapseToggle) onCollapseToggle();
                break;
        }
    };
    return {
        onMouseDown: onMouseDown,
        onMouseEnter: onMouseEnter,
        onMouseOut: onMouseOut,
        onKeyDown: onKeyDown
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $4571ff54ac709100$export$4eaf04e54aa8eed6() {
    let globalListeners = (0, $1Yh1N$react.useRef)(new Map());
    let addGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        // Make sure we remove the listener after it is called with the `once` option.
        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{
            globalListeners.current.delete(listener);
            listener(...args);
        } : listener;
        globalListeners.current.set(listener, {
            type: type,
            eventTarget: eventTarget,
            fn: fn,
            options: options
        });
        eventTarget.addEventListener(type, listener, options);
    }, []);
    let removeGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        var _globalListeners_current_get;
        let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
        eventTarget.removeEventListener(type, fn, options);
        globalListeners.current.delete(listener);
    }, []);
    let removeAllGlobalListeners = (0, $1Yh1N$react.useCallback)(()=>{
        globalListeners.current.forEach((value, key)=>{
            removeGlobalListener(value.eventTarget, value.type, key, value.options);
        });
    }, [
        removeGlobalListener
    ]);
    // eslint-disable-next-line arrow-body-style
    (0, $1Yh1N$react.useEffect)(()=>{
        return removeAllGlobalListeners;
    }, [
        removeAllGlobalListeners
    ]);
    return {
        addGlobalListener: addGlobalListener,
        removeGlobalListener: removeGlobalListener,
        removeAllGlobalListeners: removeAllGlobalListeners
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6ec78bde395c477d$export$d6875122194c7b44(props, defaultLabel) {
    let { id: id , "aria-label": label , "aria-labelledby": labelledBy  } = props;
    // If there is both an aria-label and aria-labelledby,
    // combine them by pointing to the element itself.
    id = (0, $8c61827343eed941$export$f680877a34711e37)(id);
    if (labelledBy && label) {
        let ids = new Set([
            id,
            ...labelledBy.trim().split(/\s+/)
        ]);
        labelledBy = [
            ...ids
        ].join(" ");
    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\s+/).join(" ");
    // If no labels are provided, use the default
    if (!label && !labelledBy && defaultLabel) label = defaultLabel;
    return {
        id: id,
        "aria-label": label,
        "aria-labelledby": labelledBy
    };
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $475b35fe72ba49b3$export$4338b53315abf666(forwardedRef) {
    const objRef = (0, $1Yh1N$react.useRef)();
    return (0, $1Yh1N$react.useMemo)(()=>({
            get current () {
                return objRef.current;
            },
            set current (value){
                objRef.current = value;
                if (typeof forwardedRef === "function") forwardedRef(value);
                else if (forwardedRef) forwardedRef.current = value;
            }
        }), [
        forwardedRef
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $29293a6f5c75b37e$export$496315a1608d9602(effect, dependencies) {
    const isInitialMount = (0, $1Yh1N$react.useRef)(true);
    const lastDeps = (0, $1Yh1N$react.useRef)(null);
    (0, $1Yh1N$react.useEffect)(()=>{
        isInitialMount.current = true;
        return ()=>{
            isInitialMount.current = false;
        };
    }, []);
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isInitialMount.current) isInitialMount.current = false;
        else if (!lastDeps.current || dependencies.some((dep, i)=>!Object.is(dep, lastDeps[i]))) effect();
        lastDeps.current = dependencies;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencies);
}




function $37733e1652f47193$var$hasResizeObserver() {
    return typeof window.ResizeObserver !== "undefined";
}
function $37733e1652f47193$export$683480f191c0e3ea(options) {
    const { ref: ref , onResize: onResize  } = options;
    (0, $1Yh1N$react.useEffect)(()=>{
        let element = ref === null || ref === void 0 ? void 0 : ref.current;
        if (!element) return;
        if (!$37733e1652f47193$var$hasResizeObserver()) {
            window.addEventListener("resize", onResize, false);
            return ()=>{
                window.removeEventListener("resize", onResize, false);
            };
        } else {
            const resizeObserverInstance = new window.ResizeObserver((entries)=>{
                if (!entries.length) return;
                onResize();
            });
            resizeObserverInstance.observe(element);
            return ()=>{
                if (element) resizeObserverInstance.unobserve(element);
            };
        }
    }, [
        onResize,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6fc733991a9f977c$export$4debdb1a3f0fa79e(context, ref) {
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (context && context.ref && ref) {
            context.ref.current = ref.current;
            return ()=>{
                context.ref.current = null;
            };
        }
    }, [
        context,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d796e7157ac96470$export$cfa2225e87938781(node) {
    if ($d796e7157ac96470$export$2bb74740c4e19def(node)) node = node.parentElement;
    while(node && !$d796e7157ac96470$export$2bb74740c4e19def(node))node = node.parentElement;
    return node || document.scrollingElement || document.documentElement;
}
function $d796e7157ac96470$export$2bb74740c4e19def(node) {
    let style = window.getComputedStyle(node);
    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// @ts-ignore
let $8b24bab62f5c65ad$var$visualViewport = typeof window !== "undefined" && window.visualViewport;
function $8b24bab62f5c65ad$export$d699905dd57c73ca() {
    let [size, setSize] = (0, $1Yh1N$react.useState)(()=>$8b24bab62f5c65ad$var$getViewportSize());
    (0, $1Yh1N$react.useEffect)(()=>{
        // Use visualViewport api to track available height even on iOS virtual keyboard opening
        let onResize = ()=>{
            setSize((size)=>{
                let newSize = $8b24bab62f5c65ad$var$getViewportSize();
                if (newSize.width === size.width && newSize.height === size.height) return size;
                return newSize;
            });
        };
        if (!$8b24bab62f5c65ad$var$visualViewport) window.addEventListener("resize", onResize);
        else $8b24bab62f5c65ad$var$visualViewport.addEventListener("resize", onResize);
        return ()=>{
            if (!$8b24bab62f5c65ad$var$visualViewport) window.removeEventListener("resize", onResize);
            else $8b24bab62f5c65ad$var$visualViewport.removeEventListener("resize", onResize);
        };
    }, []);
    return size;
}
function $8b24bab62f5c65ad$var$getViewportSize() {
    return {
        width: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.width) || window.innerWidth,
        height: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.height) || window.innerHeight
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

let $34da4502ea8120db$var$descriptionId = 0;
const $34da4502ea8120db$var$descriptionNodes = new Map();
function $34da4502ea8120db$export$f8aeda7b10753fa1(description) {
    let [id, setId] = (0, $1Yh1N$react.useState)(undefined);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (!description) return;
        let desc = $34da4502ea8120db$var$descriptionNodes.get(description);
        if (!desc) {
            let id = `react-aria-description-${$34da4502ea8120db$var$descriptionId++}`;
            setId(id);
            let node = document.createElement("div");
            node.id = id;
            node.style.display = "none";
            node.textContent = description;
            document.body.appendChild(node);
            desc = {
                refCount: 0,
                element: node
            };
            $34da4502ea8120db$var$descriptionNodes.set(description, desc);
        } else setId(desc.element.id);
        desc.refCount++;
        return ()=>{
            if (--desc.refCount === 0) {
                desc.element.remove();
                $34da4502ea8120db$var$descriptionNodes.delete(description);
            }
        };
    }, [
        description
    ]);
    return {
        "aria-describedby": description ? id : undefined
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $9e20cff0af27e8cc$var$testUserAgent(re) {
    var _window_navigator_userAgentData;
    if (typeof window === "undefined" || window.navigator == null) return false;
    return ((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand)=>re.test(brand.brand))) || re.test(window.navigator.userAgent);
}
function $9e20cff0af27e8cc$var$testPlatform(re) {
    var _window_navigator_userAgentData;
    return typeof window !== "undefined" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $9e20cff0af27e8cc$export$9ac100e40613ea10() {
    return $9e20cff0af27e8cc$var$testPlatform(/^Mac/i);
}
function $9e20cff0af27e8cc$export$186c6964ca17d99() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPhone/i);
}
function $9e20cff0af27e8cc$export$7bef049ce92e4224() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
    $9e20cff0af27e8cc$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
}
function $9e20cff0af27e8cc$export$fedb369cb70207f1() {
    return $9e20cff0af27e8cc$export$186c6964ca17d99() || $9e20cff0af27e8cc$export$7bef049ce92e4224();
}
function $9e20cff0af27e8cc$export$e1865c3bedcd822b() {
    return $9e20cff0af27e8cc$export$9ac100e40613ea10() || $9e20cff0af27e8cc$export$fedb369cb70207f1();
}
function $9e20cff0af27e8cc$export$78551043582a6a98() {
    return $9e20cff0af27e8cc$var$testUserAgent(/AppleWebKit/i) && !$9e20cff0af27e8cc$export$6446a186d09e379e();
}
function $9e20cff0af27e8cc$export$6446a186d09e379e() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Chrome/i);
}
function $9e20cff0af27e8cc$export$a11b0059900ceec8() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Android/i);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1254e5bb94ac8761$export$7f54fc3180508a52(fn) {
    const ref = (0, $1Yh1N$react.useRef)(null);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        ref.current = fn;
    }, [
        fn
    ]);
    return (0, $1Yh1N$react.useCallback)((...args)=>{
        const f = ref.current;
        return f(...args);
    }, []);
}


function $2a8c0bb1629926c8$export$90fc3a17d93f704c(ref, event, handler, options) {
    let handleEvent = (0, $1254e5bb94ac8761$export$7f54fc3180508a52)(handler);
    let isDisabled = handler == null;
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isDisabled) return;
        let element = ref.current;
        element.addEventListener(event, handleEvent, options);
        return ()=>{
            element.removeEventListener(event, handleEvent, options);
        };
    }, [
        ref,
        event,
        options,
        isDisabled,
        handleEvent
    ]);
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $449412113267a1fe$export$53a0910f038337bd(scrollView, element) {
    let offsetX = $449412113267a1fe$var$relativeOffset(scrollView, element, "left");
    let offsetY = $449412113267a1fe$var$relativeOffset(scrollView, element, "top");
    let width = element.offsetWidth;
    let height = element.offsetHeight;
    let x = scrollView.scrollLeft;
    let y = scrollView.scrollTop;
    // Account for top/left border offsetting the scroll top/Left
    let { borderTopWidth: borderTopWidth , borderLeftWidth: borderLeftWidth  } = getComputedStyle(scrollView);
    let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);
    let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);
    // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width
    let maxX = borderAdjustedX + scrollView.clientWidth;
    let maxY = borderAdjustedY + scrollView.clientHeight;
    if (offsetX <= x) x = offsetX - parseInt(borderLeftWidth, 10);
    else if (offsetX + width > maxX) x += offsetX + width - maxX;
    if (offsetY <= borderAdjustedY) y = offsetY - parseInt(borderTopWidth, 10);
    else if (offsetY + height > maxY) y += offsetY + height - maxY;
    scrollView.scrollLeft = x;
    scrollView.scrollTop = y;
}
/**
 * Computes the offset left or top from child to ancestor by accumulating
 * offsetLeft or offsetTop through intervening offsetParents.
 */ function $449412113267a1fe$var$relativeOffset(ancestor, child, axis) {
    const prop = axis === "left" ? "offsetLeft" : "offsetTop";
    let sum = 0;
    while(child.offsetParent){
        sum += child[prop];
        if (child.offsetParent === ancestor) break;
        else if (child.offsetParent.contains(ancestor)) {
            // If the ancestor is not `position:relative`, then we stop at
            // _its_ offset parent, and we subtract off _its_ offset, so that
            // we end up with the proper offset from child to ancestor.
            sum -= ancestor[prop];
            break;
        }
        child = child.offsetParent;
    }
    return sum;
}
function $449412113267a1fe$export$c826860796309d1b(targetElement, opts) {
    if (document.contains(targetElement)) {
        let root = document.scrollingElement || document.documentElement;
        let isScrollPrevented = window.getComputedStyle(root).overflow === "hidden";
        // If scrolling is not currently prevented then we aren’t in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view
        if (!isScrollPrevented) {
            var // use scrollIntoView({block: 'nearest'}) instead of .focus to check if the element is fully in view or not since .focus()
            // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically
            _targetElement_scrollIntoView;
            let { left: originalLeft , top: originalTop  } = targetElement.getBoundingClientRect();
            targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {
                block: "nearest"
            });
            let { left: newLeft , top: newTop  } = targetElement.getBoundingClientRect();
            // Account for sub pixel differences from rounding
            if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {
                var _opts_containingElement, _opts_containingElement_scrollIntoView, _targetElement_scrollIntoView1;
                opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {
                    block: "center",
                    inline: "center"
                });
                (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {
                    block: "nearest"
                });
            }
        } else {
            let scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.
            while(targetElement && scrollParent && targetElement !== root && scrollParent !== root){
                $449412113267a1fe$export$53a0910f038337bd(scrollParent, targetElement);
                targetElement = scrollParent;
                scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            }
        }
    }
}



/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $577e795361f19be9$export$60278871457622de(event) {
    // JAWS/NVDA with Firefox.
    if (event.mozInputSource === 0 && event.isTrusted) return true;
    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead
    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check
    // to detect TalkBack virtual clicks.
    if ((0, $9e20cff0af27e8cc$export$a11b0059900ceec8)() && event.pointerType) return event.type === "click" && event.buttons === 1;
    return event.detail === 0 && !event.pointerType;
}
function $577e795361f19be9$export$29bf1b5f2c56cf63(event) {
    // If the pointer size is zero, then we assume it's from a screen reader.
    // Android TalkBack double tap will sometimes return a event with width and height of 1
    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.
    // Cannot use "event.pressure === 0" as the sole check due to Safari pointer events always returning pressure === 0
    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush
    // Talkback double tap from Windows Firefox touch screen press
    return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse";
}



/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 
function $20e6e72fbf5dc81e$export$722debc0e56fea39(value, isEqual) {
    // Using a ref during render is ok here because it's only an optimization – both values are equivalent.
    // If a render is thrown away, it'll still work the same no matter if the next render is the same or not.
    let lastValue = (0, $1Yh1N$react.useRef)(null);
    if (value && lastValue.current && isEqual(value, lastValue.current)) value = lastValue.current;
    lastValue.current = value;
    return value;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 65444:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $4hxXn$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "SSRProvider", () => $29383e587d62412a$export$9f8ac96af4b1b2ae);
$parcel$export(module.exports, "useSSRSafeId", () => $29383e587d62412a$export$619500959fc48b26);
$parcel$export(module.exports, "useIsSSR", () => $29383e587d62412a$export$535bd6ca7f90a273);

// Default context value to use in case there is no SSRProvider. This is fine for
// client-only apps. In order to support multiple copies of React Aria potentially
// being on the page at once, the prefix is set to a random number. SSRProvider
// will reset this to zero for consistency between server and client, so in the
// SSR case multiple copies of React Aria is not supported.
const $29383e587d62412a$var$defaultContext = {
    prefix: String(Math.round(Math.random() * 10000000000)),
    current: 0
};
const $29383e587d62412a$var$SSRContext = /*#__PURE__*/ ($parcel$interopDefault($4hxXn$react)).createContext($29383e587d62412a$var$defaultContext);
function $29383e587d62412a$export$9f8ac96af4b1b2ae(props) {
    let cur = $4hxXn$react.useContext($29383e587d62412a$var$SSRContext);
    let value = $4hxXn$react.useMemo(()=>({
            // If this is the first SSRProvider, start with an empty string prefix, otherwise
            // append and increment the counter.
            prefix: cur === $29383e587d62412a$var$defaultContext ? '' : `${cur.prefix}-${++cur.current}`,
            current: 0
        })
    , [
        cur
    ]);
    return(/*#__PURE__*/ ($parcel$interopDefault($4hxXn$react)).createElement($29383e587d62412a$var$SSRContext.Provider, {
        value: value
    }, props.children));
}
let $29383e587d62412a$var$canUseDOM = Boolean(typeof window !== 'undefined' && window.document && window.document.createElement);
function $29383e587d62412a$export$619500959fc48b26(defaultId) {
    let ctx = $4hxXn$react.useContext($29383e587d62412a$var$SSRContext);
    // If we are rendering in a non-DOM environment, and there's no SSRProvider,
    // provide a warning to hint to the developer to add one.
    if (ctx === $29383e587d62412a$var$defaultContext && !$29383e587d62412a$var$canUseDOM) console.warn('When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.');
    return $4hxXn$react.useMemo(()=>defaultId || `react-aria${ctx.prefix}-${++ctx.current}`
    , [
        defaultId
    ]);
}
function $29383e587d62412a$export$535bd6ca7f90a273() {
    let cur = $4hxXn$react.useContext($29383e587d62412a$var$SSRContext);
    let isInSSRContext = cur !== $29383e587d62412a$var$defaultContext;
    let [isSSR, setIsSSR] = $4hxXn$react.useState(isInSSRContext);
    // If on the client, and the component was initially server rendered,
    // then schedule a layout effect to update the component after hydration.
    if (typeof window !== 'undefined' && isInSSRContext) // This if statement technically breaks the rules of hooks, but is safe
    // because the condition never changes after mounting.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    $4hxXn$react.useLayoutEffect(()=>{
        setIsSSR(false);
    }, []);
    return isSSR;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 46461:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $kJQf8$reactariagrid = __webpack_require__(61523);
var $kJQf8$reactarialiveannouncer = __webpack_require__(72356);
var $kJQf8$reactariautils = __webpack_require__(73233);
var $kJQf8$react = __webpack_require__(18038);
var $kJQf8$reactariai18n = __webpack_require__(2211);
var $kJQf8$reactariafocus = __webpack_require__(88514);
var $kJQf8$reactariainteractions = __webpack_require__(52115);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useTableRowGroup", () => $cd66afe5decb6adb$export$6fb1613bd7b28198);
$parcel$export(module.exports, "useTable", () => $25d14c0f8fad722e$export$25bceaac3c7e4dc7);
$parcel$export(module.exports, "useTableColumnHeader", () => $7669c34a63ef0113$export$9514819a8c81e960);
$parcel$export(module.exports, "useTableRow", () => $10b2115217af7c93$export$7f2f6ae19e707aa5);
$parcel$export(module.exports, "useTableHeaderRow", () => $eb16c38321a72835$export$1b95a7d2d517b841);
$parcel$export(module.exports, "useTableCell", () => $32387a1f2c61cda2$export$49571c903d73624c);
$parcel$export(module.exports, "useTableSelectionCheckbox", () => $0b394e4562ac57c9$export$16ea7f650bd7c1bb);
$parcel$export(module.exports, "useTableSelectAllCheckbox", () => $0b394e4562ac57c9$export$1003db6a7e384b99);
$parcel$export(module.exports, "useTableColumnResize", () => $16d645f9e2153641$export$52994e973806c219);



const $6acf696f746f932c$export$552312adfd451dab = new WeakMap();
function $6acf696f746f932c$var$normalizeKey(key) {
    if (typeof key === 'string') return key.replace(/\s*/g, '');
    return '' + key;
}
function $6acf696f746f932c$export$37cd4213f2ad742e(state, columnKey) {
    let gridId = $6acf696f746f932c$export$552312adfd451dab.get(state);
    if (!gridId) throw new Error('Unknown grid');
    return `${gridId}-${$6acf696f746f932c$var$normalizeKey(columnKey)}`;
}
function $6acf696f746f932c$export$19baff3266315d44(state, rowKey, columnKey) {
    let gridId = $6acf696f746f932c$export$552312adfd451dab.get(state);
    if (!gridId) throw new Error('Unknown grid');
    return `${gridId}-${$6acf696f746f932c$var$normalizeKey(rowKey)}-${$6acf696f746f932c$var$normalizeKey(columnKey)}`;
}
function $6acf696f746f932c$export$85069b70317f543(state, rowKey) {
    // A row is labelled by it's row headers.
    return [
        ...state.collection.rowHeaderColumnKeys
    ].map((columnKey)=>$6acf696f746f932c$export$19baff3266315d44(state, rowKey, columnKey)
    ).join(' ');
}


var $41fef89bf1034745$exports = {};
var $ca0f93ae476efcee$exports = {};
$ca0f93ae476efcee$exports = {
    "ascending": `تصاعدي`,
    "ascendingSort": (args)=>`ترتيب حسب العمود ${args.columnName} بترتيب تصاعدي`
    ,
    "columnSize": (args)=>`${args.value} بالبكسل`
    ,
    "descending": `تنازلي`,
    "descendingSort": (args)=>`ترتيب حسب العمود ${args.columnName} بترتيب تنازلي`
    ,
    "select": `تحديد`,
    "selectAll": `تحديد الكل`,
    "sortable": `عمود قابل للترتيب`
};


var $8fcf86b24fd399a9$exports = {};
$8fcf86b24fd399a9$exports = {
    "ascending": `възходящ`,
    "ascendingSort": (args)=>`сортирано по колона ${args.columnName} във възходящ ред`
    ,
    "columnSize": (args)=>`${args.value} пиксела`
    ,
    "descending": `низходящ`,
    "descendingSort": (args)=>`сортирано по колона ${args.columnName} в низходящ ред`
    ,
    "select": `Изберете`,
    "selectAll": `Изберете всичко`,
    "sortable": `сортираща колона`
};


var $146712099a722811$exports = {};
$146712099a722811$exports = {
    "ascending": `vzestupně`,
    "ascendingSort": (args)=>`řazeno vzestupně podle sloupce ${args.columnName}`
    ,
    "columnSize": (args)=>`${args.value} pixelů`
    ,
    "descending": `sestupně`,
    "descendingSort": (args)=>`řazeno sestupně podle sloupce ${args.columnName}`
    ,
    "select": `Vybrat`,
    "selectAll": `Vybrat vše`,
    "sortable": `sloupec s možností řazení`
};


var $2735c96991aebe53$exports = {};
$2735c96991aebe53$exports = {
    "ascending": `stigende`,
    "ascendingSort": (args)=>`sorteret efter kolonne ${args.columnName} i stigende rækkefølge`
    ,
    "columnSize": (args)=>`${args.value} pixels`
    ,
    "descending": `faldende`,
    "descendingSort": (args)=>`sorteret efter kolonne ${args.columnName} i faldende rækkefølge`
    ,
    "select": `Vælg`,
    "selectAll": `Vælg alle`,
    "sortable": `sorterbar kolonne`
};


var $d85ed0c826146b1e$exports = {};
$d85ed0c826146b1e$exports = {
    "ascending": `aufsteigend`,
    "ascendingSort": (args)=>`sortiert nach Spalte ${args.columnName} in aufsteigender Reihenfolge`
    ,
    "columnSize": (args)=>`${args.value} Pixel`
    ,
    "descending": `absteigend`,
    "descendingSort": (args)=>`sortiert nach Spalte ${args.columnName} in absteigender Reihenfolge`
    ,
    "select": `Auswählen`,
    "selectAll": `Alles auswählen`,
    "sortable": `sortierbare Spalte`
};


var $1aecf8df24cd2c6e$exports = {};
$1aecf8df24cd2c6e$exports = {
    "ascending": `αύξουσα`,
    "ascendingSort": (args)=>`διαλογή ανά στήλη ${args.columnName} σε αύξουσα σειρά`
    ,
    "columnSize": (args)=>`${args.value} pixel`
    ,
    "descending": `φθίνουσα`,
    "descendingSort": (args)=>`διαλογή ανά στήλη ${args.columnName} σε φθίνουσα σειρά`
    ,
    "select": `Επιλογή`,
    "selectAll": `Επιλογή όλων`,
    "sortable": `Στήλη διαλογής`
};


var $8629e38d73986227$exports = {};
$8629e38d73986227$exports = {
    "select": `Select`,
    "selectAll": `Select All`,
    "sortable": `sortable column`,
    "ascending": `ascending`,
    "descending": `descending`,
    "ascendingSort": (args)=>`sorted by column ${args.columnName} in ascending order`
    ,
    "descendingSort": (args)=>`sorted by column ${args.columnName} in descending order`
    ,
    "columnSize": (args)=>`${args.value} pixels`
};


var $219ef73190fd7b54$exports = {};
$219ef73190fd7b54$exports = {
    "ascending": `de subida`,
    "ascendingSort": (args)=>`ordenado por columna ${args.columnName} en orden de subida`
    ,
    "columnSize": (args)=>`${args.value} píxeles`
    ,
    "descending": `de bajada`,
    "descendingSort": (args)=>`ordenado por columna ${args.columnName} en orden de bajada`
    ,
    "select": `Seleccionar`,
    "selectAll": `Seleccionar todos`,
    "sortable": `columna ordenable`
};


var $28e4d12b64c559fe$exports = {};
$28e4d12b64c559fe$exports = {
    "ascending": `tõusev järjestus`,
    "ascendingSort": (args)=>`sorditud veeru järgi ${args.columnName} tõusvas järjestuses`
    ,
    "columnSize": (args)=>`${args.value} pikslit`
    ,
    "descending": `laskuv järjestus`,
    "descendingSort": (args)=>`sorditud veeru järgi ${args.columnName} laskuvas järjestuses`
    ,
    "select": `Vali`,
    "selectAll": `Vali kõik`,
    "sortable": `sorditav veerg`
};


var $d443cdd0bb14863a$exports = {};
$d443cdd0bb14863a$exports = {
    "ascending": `nouseva`,
    "ascendingSort": (args)=>`lajiteltu sarakkeen ${args.columnName} mukaan nousevassa järjestyksessä`
    ,
    "columnSize": (args)=>`${args.value} pikseliä`
    ,
    "descending": `laskeva`,
    "descendingSort": (args)=>`lajiteltu sarakkeen ${args.columnName} mukaan laskevassa järjestyksessä`
    ,
    "select": `Valitse`,
    "selectAll": `Valitse kaikki`,
    "sortable": `lajiteltava sarake`
};


var $e7b61bd0e93b97c5$exports = {};
$e7b61bd0e93b97c5$exports = {
    "ascending": `croissant`,
    "ascendingSort": (args)=>`trié en fonction de la colonne ${args.columnName} par ordre croissant`
    ,
    "columnSize": (args)=>`${args.value} pixels`
    ,
    "descending": `décroissant`,
    "descendingSort": (args)=>`trié en fonction de la colonne ${args.columnName} par ordre décroissant`
    ,
    "select": `Sélectionner`,
    "selectAll": `Sélectionner tout`,
    "sortable": `colonne triable`
};


var $b09d12ffa0a56a3e$exports = {};
$b09d12ffa0a56a3e$exports = {
    "ascending": `עולה`,
    "ascendingSort": (args)=>`מוין לפי עמודה ${args.columnName} בסדר עולה`
    ,
    "columnSize": (args)=>`${args.value} פיקסלים`
    ,
    "descending": `יורד`,
    "descendingSort": (args)=>`מוין לפי עמודה ${args.columnName} בסדר יורד`
    ,
    "select": `בחר`,
    "selectAll": `בחר הכול`,
    "sortable": `עמודה שניתן למיין`
};


var $c3d9f76f15300329$exports = {};
$c3d9f76f15300329$exports = {
    "ascending": `rastući`,
    "ascendingSort": (args)=>`razvrstano po stupcima ${args.columnName} rastućem redoslijedom`
    ,
    "columnSize": (args)=>`${args.value} piksela`
    ,
    "descending": `padajući`,
    "descendingSort": (args)=>`razvrstano po stupcima ${args.columnName} padajućim redoslijedom`
    ,
    "select": `Odaberite`,
    "selectAll": `Odaberite sve`,
    "sortable": `stupac koji se može razvrstati`
};


var $9904561a995a328e$exports = {};
$9904561a995a328e$exports = {
    "ascending": `növekvő`,
    "ascendingSort": (args)=>`rendezve a(z) ${args.columnName} oszlop szerint, növekvő sorrendben`
    ,
    "columnSize": (args)=>`${args.value} képpont`
    ,
    "descending": `csökkenő`,
    "descendingSort": (args)=>`rendezve a(z) ${args.columnName} oszlop szerint, csökkenő sorrendben`
    ,
    "select": `Kijelölés`,
    "selectAll": `Összes kijelölése`,
    "sortable": `rendezendő oszlop`
};


var $b63a88a974650d19$exports = {};
$b63a88a974650d19$exports = {
    "ascending": `crescente`,
    "ascendingSort": (args)=>`in ordine crescente in base alla colonna ${args.columnName}`
    ,
    "columnSize": (args)=>`${args.value} pixel`
    ,
    "descending": `decrescente`,
    "descendingSort": (args)=>`in ordine decrescente in base alla colonna ${args.columnName}`
    ,
    "select": `Seleziona`,
    "selectAll": `Seleziona tutto`,
    "sortable": `colonna ordinabile`
};


var $f79114b6f7838962$exports = {};
$f79114b6f7838962$exports = {
    "ascending": `昇順`,
    "ascendingSort": (args)=>`列 ${args.columnName} を昇順で並べ替え`
    ,
    "columnSize": (args)=>`${args.value} ピクセル`
    ,
    "descending": `降順`,
    "descendingSort": (args)=>`列 ${args.columnName} を降順で並べ替え`
    ,
    "select": `選択`,
    "selectAll": `すべて選択`,
    "sortable": `並べ替え可能な列`
};


var $305e358db516b233$exports = {};
$305e358db516b233$exports = {
    "ascending": `오름차순`,
    "ascendingSort": (args)=>`${args.columnName} 열을 기준으로 오름차순으로 정렬됨`
    ,
    "columnSize": (args)=>`${args.value} 픽셀`
    ,
    "descending": `내림차순`,
    "descendingSort": (args)=>`${args.columnName} 열을 기준으로 내림차순으로 정렬됨`
    ,
    "select": `선택`,
    "selectAll": `모두 선택`,
    "sortable": `정렬 가능한 열`
};


var $c37a95c245032ee0$exports = {};
$c37a95c245032ee0$exports = {
    "ascending": `didėjančia tvarka`,
    "ascendingSort": (args)=>`surikiuota pagal stulpelį ${args.columnName} didėjančia tvarka`
    ,
    "columnSize": (args)=>`${args.value} piks.`
    ,
    "descending": `mažėjančia tvarka`,
    "descendingSort": (args)=>`surikiuota pagal stulpelį ${args.columnName} mažėjančia tvarka`
    ,
    "select": `Pasirinkti`,
    "selectAll": `Pasirinkti viską`,
    "sortable": `rikiuojamas stulpelis`
};


var $0d99b6662f72a76d$exports = {};
$0d99b6662f72a76d$exports = {
    "ascending": `augošā secībā`,
    "ascendingSort": (args)=>`kārtots pēc kolonnas ${args.columnName} augošā secībā`
    ,
    "columnSize": (args)=>`${args.value} pikseļi`
    ,
    "descending": `dilstošā secībā`,
    "descendingSort": (args)=>`kārtots pēc kolonnas ${args.columnName} dilstošā secībā`
    ,
    "select": `Atlasīt`,
    "selectAll": `Atlasīt visu`,
    "sortable": `kārtojamā kolonna`
};


var $b350dd154e1c203e$exports = {};
$b350dd154e1c203e$exports = {
    "ascending": `stigende`,
    "ascendingSort": (args)=>`sortert etter kolonne ${args.columnName} i stigende rekkefølge`
    ,
    "columnSize": (args)=>`${args.value} piksler`
    ,
    "descending": `synkende`,
    "descendingSort": (args)=>`sortert etter kolonne ${args.columnName} i synkende rekkefølge`
    ,
    "select": `Velg`,
    "selectAll": `Velg alle`,
    "sortable": `kolonne som kan sorteres`
};


var $94dcc10598f2ecbe$exports = {};
$94dcc10598f2ecbe$exports = {
    "ascending": `oplopend`,
    "ascendingSort": (args)=>`gesorteerd in oplopende volgorde in kolom ${args.columnName}`
    ,
    "columnSize": (args)=>`${args.value} pixels`
    ,
    "descending": `aflopend`,
    "descendingSort": (args)=>`gesorteerd in aflopende volgorde in kolom ${args.columnName}`
    ,
    "select": `Selecteren`,
    "selectAll": `Alles selecteren`,
    "sortable": `sorteerbare kolom`
};


var $847263ec44d85feb$exports = {};
$847263ec44d85feb$exports = {
    "ascending": `rosnąco`,
    "ascendingSort": (args)=>`posortowano według kolumny ${args.columnName} w porządku rosnącym`
    ,
    "columnSize": (args)=>`Liczba pikseli: ${args.value}`
    ,
    "descending": `malejąco`,
    "descendingSort": (args)=>`posortowano według kolumny ${args.columnName} w porządku malejącym`
    ,
    "select": `Zaznacz`,
    "selectAll": `Zaznacz wszystko`,
    "sortable": `kolumna z możliwością sortowania`
};


var $649f25af616381b6$exports = {};
$649f25af616381b6$exports = {
    "ascending": `crescente`,
    "ascendingSort": (args)=>`classificado pela coluna ${args.columnName} em ordem crescente`
    ,
    "columnSize": (args)=>`${args.value} pixels`
    ,
    "descending": `decrescente`,
    "descendingSort": (args)=>`classificado pela coluna ${args.columnName} em ordem decrescente`
    ,
    "select": `Selecionar`,
    "selectAll": `Selecionar tudo`,
    "sortable": `coluna classificável`
};


var $63863f752f22090b$exports = {};
$63863f752f22090b$exports = {
    "ascending": `ascendente`,
    "ascendingSort": (args)=>`Ordenar por coluna ${args.columnName} em ordem ascendente`
    ,
    "columnSize": (args)=>`${args.value} pixels`
    ,
    "descending": `descendente`,
    "descendingSort": (args)=>`Ordenar por coluna ${args.columnName} em ordem descendente`
    ,
    "select": `Selecionar`,
    "selectAll": `Selecionar tudo`,
    "sortable": `Coluna ordenável`
};


var $1011caef6838d0cf$exports = {};
$1011caef6838d0cf$exports = {
    "ascending": `crescătoare`,
    "ascendingSort": (args)=>`sortate după coloana ${args.columnName} în ordine crescătoare`
    ,
    "columnSize": (args)=>`${args.value} pixeli`
    ,
    "descending": `descrescătoare`,
    "descendingSort": (args)=>`sortate după coloana ${args.columnName} în ordine descrescătoare`
    ,
    "select": `Selectare`,
    "selectAll": `Selectare totală`,
    "sortable": `coloană sortabilă`
};


var $5c0e71883f016b2f$exports = {};
$5c0e71883f016b2f$exports = {
    "ascending": `возрастание`,
    "ascendingSort": (args)=>`сортировать столбец ${args.columnName} в порядке возрастания`
    ,
    "columnSize": (args)=>`${args.value} пикс.`
    ,
    "descending": `убывание`,
    "descendingSort": (args)=>`сортировать столбец ${args.columnName} в порядке убывания`
    ,
    "select": `Выбрать`,
    "selectAll": `Выбрать все`,
    "sortable": `сортируемый столбец`
};


var $9799788df99a536e$exports = {};
$9799788df99a536e$exports = {
    "ascending": `vzostupne`,
    "ascendingSort": (args)=>`zoradené zostupne podľa stĺpca ${args.columnName}`
    ,
    "columnSize": (args)=>`Počet pixelov: ${args.value}`
    ,
    "descending": `zostupne`,
    "descendingSort": (args)=>`zoradené zostupne podľa stĺpca ${args.columnName}`
    ,
    "select": `Vybrať`,
    "selectAll": `Vybrať všetko`,
    "sortable": `zoraditeľný stĺpec`
};


var $79bf9bea0e0b8579$exports = {};
$79bf9bea0e0b8579$exports = {
    "ascending": `naraščajoče`,
    "ascendingSort": (args)=>`razvrščeno po stolpcu ${args.columnName} v naraščajočem vrstnem redu`
    ,
    "columnSize": (args)=>`${args.value} slikovnih pik`
    ,
    "descending": `padajoče`,
    "descendingSort": (args)=>`razvrščeno po stolpcu ${args.columnName} v padajočem vrstnem redu`
    ,
    "select": `Izberite`,
    "selectAll": `Izberite vse`,
    "sortable": `razvrstljivi stolpec`
};


var $374736afc1a4c11c$exports = {};
$374736afc1a4c11c$exports = {
    "ascending": `rastući`,
    "ascendingSort": (args)=>`sortirano po kolonama ${args.columnName} rastućim redosledom`
    ,
    "descending": `padajući`,
    "descendingSort": (args)=>`sortirano po kolonama ${args.columnName} padajućim redosledom`
    ,
    "select": `Izaberite`,
    "selectAll": `Izaberite sve`,
    "sortable": `kolona koja se može sortirati`
};


var $948317bce9061901$exports = {};
$948317bce9061901$exports = {
    "ascending": `stigande`,
    "ascendingSort": (args)=>`sorterat på kolumn ${args.columnName} i stigande ordning`
    ,
    "columnSize": (args)=>`${args.value} pixlar`
    ,
    "descending": `fallande`,
    "descendingSort": (args)=>`sorterat på kolumn ${args.columnName} i fallande ordning`
    ,
    "select": `Markera`,
    "selectAll": `Markera allt`,
    "sortable": `sorterbar kolumn`
};


var $73e2289d5a9ac4de$exports = {};
$73e2289d5a9ac4de$exports = {
    "ascending": `artan sırada`,
    "ascendingSort": (args)=>`${args.columnName} sütuna göre artan düzende sırala`
    ,
    "columnSize": (args)=>`${args.value} piksel`
    ,
    "descending": `azalan sırada`,
    "descendingSort": (args)=>`${args.columnName} sütuna göre azalan düzende sırala`
    ,
    "select": `Seç`,
    "selectAll": `Tümünü Seç`,
    "sortable": `Sıralanabilir sütun`
};


var $aca57efccc60ebb1$exports = {};
$aca57efccc60ebb1$exports = {
    "ascending": `висхідний`,
    "ascendingSort": (args)=>`відсортовано за стовпцем ${args.columnName} у висхідному порядку`
    ,
    "columnSize": (args)=>`${args.value} пікс.`
    ,
    "descending": `низхідний`,
    "descendingSort": (args)=>`відсортовано за стовпцем ${args.columnName} у низхідному порядку`
    ,
    "select": `Вибрати`,
    "selectAll": `Вибрати все`,
    "sortable": `сортувальний стовпець`
};


var $ccd86abad329f871$exports = {};
$ccd86abad329f871$exports = {
    "ascending": `升序`,
    "ascendingSort": (args)=>`按列 ${args.columnName} 升序排序`
    ,
    "columnSize": (args)=>`${args.value} 像素`
    ,
    "descending": `降序`,
    "descendingSort": (args)=>`按列 ${args.columnName} 降序排序`
    ,
    "select": `选择`,
    "selectAll": `全选`,
    "sortable": `可排序的列`
};


var $ad6eb5efb83fe2f8$exports = {};
$ad6eb5efb83fe2f8$exports = {
    "ascending": `遞增`,
    "ascendingSort": (args)=>`已依據「${args.columnName}」欄遞增排序`
    ,
    "columnSize": (args)=>`${args.value} 像素`
    ,
    "descending": `遞減`,
    "descendingSort": (args)=>`已依據「${args.columnName}」欄遞減排序`
    ,
    "select": `選取`,
    "selectAll": `全選`,
    "sortable": `可排序的欄`
};


$41fef89bf1034745$exports = {
    "ar-AE": $ca0f93ae476efcee$exports,
    "bg-BG": $8fcf86b24fd399a9$exports,
    "cs-CZ": $146712099a722811$exports,
    "da-DK": $2735c96991aebe53$exports,
    "de-DE": $d85ed0c826146b1e$exports,
    "el-GR": $1aecf8df24cd2c6e$exports,
    "en-US": $8629e38d73986227$exports,
    "es-ES": $219ef73190fd7b54$exports,
    "et-EE": $28e4d12b64c559fe$exports,
    "fi-FI": $d443cdd0bb14863a$exports,
    "fr-FR": $e7b61bd0e93b97c5$exports,
    "he-IL": $b09d12ffa0a56a3e$exports,
    "hr-HR": $c3d9f76f15300329$exports,
    "hu-HU": $9904561a995a328e$exports,
    "it-IT": $b63a88a974650d19$exports,
    "ja-JP": $f79114b6f7838962$exports,
    "ko-KR": $305e358db516b233$exports,
    "lt-LT": $c37a95c245032ee0$exports,
    "lv-LV": $0d99b6662f72a76d$exports,
    "nb-NO": $b350dd154e1c203e$exports,
    "nl-NL": $94dcc10598f2ecbe$exports,
    "pl-PL": $847263ec44d85feb$exports,
    "pt-BR": $649f25af616381b6$exports,
    "pt-PT": $63863f752f22090b$exports,
    "ro-RO": $1011caef6838d0cf$exports,
    "ru-RU": $5c0e71883f016b2f$exports,
    "sk-SK": $9799788df99a536e$exports,
    "sl-SI": $79bf9bea0e0b8579$exports,
    "sr-SP": $374736afc1a4c11c$exports,
    "sv-SE": $948317bce9061901$exports,
    "tr-TR": $73e2289d5a9ac4de$exports,
    "uk-UA": $aca57efccc60ebb1$exports,
    "zh-CN": $ccd86abad329f871$exports,
    "zh-TW": $ad6eb5efb83fe2f8$exports
};





class $a911ff492b884835$export$da43f8f5cb04028d extends $kJQf8$reactariagrid.GridKeyboardDelegate {
    isCell(node) {
        return node.type === 'cell' || node.type === 'rowheader' || node.type === 'column';
    }
    getKeyBelow(key) {
        let startItem = this.collection.getItem(key);
        if (!startItem) return;
        // If focus was on a column, then focus the first child column if any,
        // or find the corresponding cell in the first row.
        if (startItem.type === 'column') {
            let child = [
                ...startItem.childNodes
            ][0];
            if (child) return child.key;
            let firstKey = this.getFirstKey();
            if (firstKey == null) return;
            let firstItem = this.collection.getItem(firstKey);
            return [
                ...firstItem.childNodes
            ][startItem.index].key;
        }
        return super.getKeyBelow(key);
    }
    getKeyAbove(key) {
        let startItem = this.collection.getItem(key);
        if (!startItem) return;
        // If focus was on a column, focus the parent column if any
        if (startItem.type === 'column') {
            let parent = this.collection.getItem(startItem.parentKey);
            if (parent && parent.type === 'column') return parent.key;
            return;
        }
        // only return above row key if not header row
        let superKey = super.getKeyAbove(key);
        if (superKey != null && this.collection.getItem(superKey).type !== 'headerrow') return superKey;
        // If no item was found, and focus was on a cell, then focus the
        // corresponding column header.
        if (this.isCell(startItem)) return this.collection.columns[startItem.index].key;
        // If focus was on a row, then focus the first column header.
        return this.collection.columns[0].key;
    }
    findNextColumnKey(column) {
        // Search following columns
        let key = this.findNextKey(column.key, (item)=>item.type === 'column'
        );
        if (key != null) return key;
        // Wrap around to the first column
        let row = this.collection.headerRows[column.level];
        for (let item1 of row.childNodes){
            if (item1.type === 'column') return item1.key;
        }
    }
    findPreviousColumnKey(column) {
        // Search previous columns
        let key = this.findPreviousKey(column.key, (item)=>item.type === 'column'
        );
        if (key != null) return key;
        // Wrap around to the last column
        let row = this.collection.headerRows[column.level];
        let childNodes = [
            ...row.childNodes
        ];
        for(let i = childNodes.length - 1; i >= 0; i--){
            let item = childNodes[i];
            if (item.type === 'column') return item.key;
        }
    }
    getKeyRightOf(key) {
        let item = this.collection.getItem(key);
        if (!item) return;
        // If focus was on a column, then focus the next column
        if (item.type === 'column') return this.direction === 'rtl' ? this.findPreviousColumnKey(item) : this.findNextColumnKey(item);
        return super.getKeyRightOf(key);
    }
    getKeyLeftOf(key) {
        let item = this.collection.getItem(key);
        if (!item) return;
        // If focus was on a column, then focus the previous column
        if (item.type === 'column') return this.direction === 'rtl' ? this.findNextColumnKey(item) : this.findPreviousColumnKey(item);
        return super.getKeyLeftOf(key);
    }
    getKeyForSearch(search, fromKey) {
        if (!this.collator) return null;
        let collection = this.collection;
        let key = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();
        if (key == null) return null;
        // If the starting key is a cell, search from its parent row.
        let startItem = collection.getItem(key);
        if (startItem.type === 'cell') key = startItem.parentKey;
        let hasWrapped = false;
        while(key != null){
            let item = collection.getItem(key);
            // Check each of the row header cells in this row for a match
            for (let cell of item.childNodes){
                let column = collection.columns[cell.index];
                if (collection.rowHeaderColumnKeys.has(column.key) && cell.textValue) {
                    let substring = cell.textValue.slice(0, search.length);
                    if (this.collator.compare(substring, search) === 0) {
                        // If we started on a cell, end on the matching cell. Otherwise, end on the row.
                        let fromItem = fromKey != null ? collection.getItem(fromKey) : startItem;
                        return fromItem.type === 'cell' ? cell.key : item.key;
                    }
                }
            }
            key = this.getKeyBelow(key);
            // Wrap around when reaching the end of the collection
            if (key == null && !hasWrapped) {
                key = this.getFirstKey();
                hasWrapped = true;
            }
        }
        return null;
    }
}




function $25d14c0f8fad722e$export$25bceaac3c7e4dc7(props, state, ref1) {
    let { keyboardDelegate: keyboardDelegate , isVirtualized: isVirtualized , layout: layout  } = props;
    // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
    // When virtualized, the layout object will be passed in as a prop and override this.
    let collator = $kJQf8$reactariai18n.useCollator({
        usage: 'search',
        sensitivity: 'base'
    });
    let { direction: direction  } = $kJQf8$reactariai18n.useLocale();
    let delegate = $kJQf8$react.useMemo(()=>keyboardDelegate || new $a911ff492b884835$export$da43f8f5cb04028d({
            collection: state.collection,
            disabledKeys: state.disabledKeys,
            ref: ref1,
            direction: direction,
            collator: collator,
            layout: layout
        })
    , [
        keyboardDelegate,
        state.collection,
        state.disabledKeys,
        ref1,
        direction,
        collator,
        layout
    ]);
    let id = $kJQf8$reactariautils.useId(props.id);
    $6acf696f746f932c$export$552312adfd451dab.set(state, id);
    let { gridProps: gridProps  } = $kJQf8$reactariagrid.useGrid({
        ...props,
        id: id,
        keyboardDelegate: delegate,
        getRowText (key) {
            let added = state.collection.getItem(key);
            if (!added) return '';
            // If the row has a textValue, use that.
            if (added.textValue != null) return added.textValue;
            // Otherwise combine the text of each of the row header columns.
            let rowHeaderColumnKeys = state.collection.rowHeaderColumnKeys;
            if (rowHeaderColumnKeys) {
                let text = [];
                for (let cell of added.childNodes){
                    let column = state.collection.columns[cell.index];
                    if (rowHeaderColumnKeys.has(column.key) && cell.textValue) text.push(cell.textValue);
                    if (text.length === rowHeaderColumnKeys.size) break;
                }
                return text.join(' ');
            }
            return '';
        }
    }, state, ref1);
    // Override to include header rows
    if (isVirtualized) gridProps['aria-rowcount'] = state.collection.size + state.collection.headerRows.length;
    let { column: column1 , direction: sortDirection  } = state.sortDescriptor || {
    };
    let stringFormatter = $kJQf8$reactariai18n.useLocalizedStringFormatter((/*@__PURE__*/$parcel$interopDefault($41fef89bf1034745$exports)));
    let sortDescription = $kJQf8$react.useMemo(()=>{
        var ref;
        let columnName = (ref = state.collection.columns.find((c)=>c.key === column1
        )) === null || ref === void 0 ? void 0 : ref.textValue;
        return sortDirection && column1 ? stringFormatter.format(`${sortDirection}Sort`, {
            columnName: columnName
        }) : undefined;
    }, [
        sortDirection,
        column1,
        state.collection.columns
    ]);
    let descriptionProps = $kJQf8$reactariautils.useDescription(sortDescription);
    // Only announce after initial render, tabbing to the table will tell you the initial sort info already
    $kJQf8$reactariautils.useUpdateEffect(()=>{
        $kJQf8$reactarialiveannouncer.announce(sortDescription, 'assertive', 500);
    }, [
        sortDescription
    ]);
    return {
        gridProps: $kJQf8$reactariautils.mergeProps(gridProps, descriptionProps, // If table is empty, make sure the table is tabbable
        state.collection.size === 0 && {
            tabIndex: 0
        }, {
            // merge sort description with long press information
            'aria-describedby': [
                descriptionProps['aria-describedby'],
                gridProps['aria-describedby']
            ].filter(Boolean).join(' ')
        })
    };
}









function $7669c34a63ef0113$export$9514819a8c81e960(props, state, ref) {
    var ref1, ref2;
    let { node: node  } = props;
    let allowsSorting = node.props.allowsSorting;
    // the selection cell column header needs to focus the checkbox within it but the other columns should focus the cell so that focus doesn't land on the resizer
    let { gridCellProps: gridCellProps  } = $kJQf8$reactariagrid.useGridCell({
        ...props,
        focusMode: node.props.isSelectionCell || props.hasMenu || node.props.allowsSorting ? 'child' : 'cell'
    }, state, ref);
    let isSelectionCellDisabled = node.props.isSelectionCell && state.selectionManager.selectionMode === 'single';
    let { pressProps: pressProps  } = $kJQf8$reactariainteractions.usePress({
        isDisabled: !allowsSorting || isSelectionCellDisabled,
        onPress () {
            state.sort(node.key);
        },
        ref: ref
    });
    // Needed to pick up the focusable context, enabling things like Tooltips for example
    let { focusableProps: focusableProps  } = $kJQf8$reactariafocus.useFocusable({
    }, ref);
    if (props.hasMenu) pressProps = {
    };
    let ariaSort = null;
    let isSortedColumn = ((ref1 = state.sortDescriptor) === null || ref1 === void 0 ? void 0 : ref1.column) === node.key;
    let sortDirection = (ref2 = state.sortDescriptor) === null || ref2 === void 0 ? void 0 : ref2.direction;
    // aria-sort not supported in Android Talkback
    if (node.props.allowsSorting && !$kJQf8$reactariautils.isAndroid()) ariaSort = isSortedColumn ? sortDirection : 'none';
    let stringFormatter = $kJQf8$reactariai18n.useLocalizedStringFormatter((/*@__PURE__*/$parcel$interopDefault($41fef89bf1034745$exports)));
    let sortDescription;
    if (allowsSorting) {
        sortDescription = `${stringFormatter.format('sortable')}`;
        // Android Talkback doesn't support aria-sort so we add sort order details to the aria-described by here
        if (isSortedColumn && sortDirection && $kJQf8$reactariautils.isAndroid()) sortDescription = `${sortDescription}, ${stringFormatter.format(sortDirection)}`;
    }
    let descriptionProps = $kJQf8$reactariautils.useDescription(sortDescription);
    return {
        columnHeaderProps: {
            ...$kJQf8$reactariautils.mergeProps(gridCellProps, pressProps, focusableProps, descriptionProps, // If the table is empty, make all column headers untabbable or programatically focusable
            state.collection.size === 0 && {
                tabIndex: null
            }),
            role: 'columnheader',
            id: $6acf696f746f932c$export$37cd4213f2ad742e(state, node.key),
            'aria-colspan': node.colspan && node.colspan > 1 ? node.colspan : null,
            'aria-sort': ariaSort
        }
    };
}




function $10b2115217af7c93$export$7f2f6ae19e707aa5(props, state, ref) {
    let { node: node  } = props;
    let { rowProps: rowProps , isPressed: isPressed  } = $kJQf8$reactariagrid.useGridRow(props, state, ref);
    return {
        rowProps: {
            ...rowProps,
            'aria-labelledby': $6acf696f746f932c$export$85069b70317f543(state, node.key)
        },
        isPressed: isPressed
    };
}


function $eb16c38321a72835$export$1b95a7d2d517b841(props, state, ref) {
    let { node: node , isVirtualized: isVirtualized  } = props;
    let rowProps = {
        role: 'row'
    };
    if (isVirtualized) rowProps['aria-rowindex'] = node.index + 1; // aria-rowindex is 1 based
    return {
        rowProps: rowProps
    };
}




function $32387a1f2c61cda2$export$49571c903d73624c(props, state, ref) {
    let { gridCellProps: gridCellProps , isPressed: isPressed  } = $kJQf8$reactariagrid.useGridCell(props, state, ref);
    let columnKey = props.node.column.key;
    if (state.collection.rowHeaderColumnKeys.has(columnKey)) {
        gridCellProps.role = 'rowheader';
        gridCellProps.id = $6acf696f746f932c$export$19baff3266315d44(state, props.node.parentKey, columnKey);
    }
    return {
        gridCellProps: gridCellProps,
        isPressed: isPressed
    };
}






function $0b394e4562ac57c9$export$16ea7f650bd7c1bb(props, state) {
    let { key: key  } = props;
    const { checkboxProps: checkboxProps  } = $kJQf8$reactariagrid.useGridSelectionCheckbox(props, state);
    return {
        checkboxProps: {
            ...checkboxProps,
            'aria-labelledby': `${checkboxProps.id} ${$6acf696f746f932c$export$85069b70317f543(state, key)}`
        }
    };
}
function $0b394e4562ac57c9$export$1003db6a7e384b99(state) {
    let { isEmpty: isEmpty , isSelectAll: isSelectAll , selectionMode: selectionMode  } = state.selectionManager;
    const stringFormatter = $kJQf8$reactariai18n.useLocalizedStringFormatter((/*@__PURE__*/$parcel$interopDefault($41fef89bf1034745$exports)));
    return {
        checkboxProps: {
            'aria-label': stringFormatter.format(selectionMode === 'single' ? 'select' : 'selectAll'),
            isSelected: isSelectAll,
            isDisabled: selectionMode !== 'multiple' || state.collection.size === 0,
            isIndeterminate: !isEmpty && !isSelectAll,
            onChange: ()=>state.selectionManager.toggleSelectAll()
        }
    };
}









function $16d645f9e2153641$export$52994e973806c219(props, state, columnState, ref) {
    let { column: item , triggerRef: triggerRef , isDisabled: isDisabled  } = props;
    const stateRef = $kJQf8$react.useRef(null);
    stateRef.current = columnState;
    const stringFormatter = $kJQf8$reactariai18n.useLocalizedStringFormatter((/*@__PURE__*/$parcel$interopDefault($41fef89bf1034745$exports)));
    let id = $kJQf8$reactariautils.useId();
    let { direction: direction  } = $kJQf8$reactariai18n.useLocale();
    let { keyboardProps: keyboardProps  } = $kJQf8$reactariainteractions.useKeyboard({
        onKeyDown: (e)=>{
            if (e.key === 'Escape' || e.key === 'Enter' || e.key === ' ' || e.key === 'Tab') {
                e.preventDefault();
                // switch focus back to the column header on anything that ends edit mode
                $kJQf8$reactariafocus.focusSafely(triggerRef.current);
            }
        }
    });
    const columnResizeWidthRef = $kJQf8$react.useRef(0);
    const { moveProps: moveProps  } = $kJQf8$reactariainteractions.useMove({
        onMoveStart () {
            columnResizeWidthRef.current = stateRef.current.getColumnWidth(item.key);
            stateRef.current.onColumnResizeStart(item);
        },
        onMove (e) {
            let { deltaX: deltaX , deltaY: deltaY , pointerType: pointerType  } = e;
            if (direction === 'rtl') deltaX *= -1;
            if (pointerType === 'keyboard') {
                if (deltaY !== 0 && deltaX === 0) deltaX = deltaY * -1;
                deltaX *= 10;
            }
            // if moving up/down only, no need to resize
            if (deltaX !== 0) {
                columnResizeWidthRef.current += deltaX;
                stateRef.current.onColumnResize(item, columnResizeWidthRef.current);
                props.onMove(e);
            }
        },
        onMoveEnd (e) {
            let { pointerType: pointerType  } = e;
            columnResizeWidthRef.current = 0;
            props.onMoveEnd(e);
            if (pointerType === 'mouse') stateRef.current.onColumnResizeEnd(item);
        }
    });
    let min = Math.floor(stateRef.current.getColumnMinWidth(item.key));
    let max = Math.floor(stateRef.current.getColumnMaxWidth(item.key));
    if (max === Infinity) max = Number.MAX_SAFE_INTEGER;
    let value = Math.floor(stateRef.current.getColumnWidth(item.key));
    let ariaProps = {
        'aria-label': props.label,
        'aria-orientation': 'horizontal',
        'aria-labelledby': `${id} ${$6acf696f746f932c$export$37cd4213f2ad742e(state, item.key)}`,
        'aria-valuetext': stringFormatter.format('columnSize', {
            value: value
        }),
        min: min,
        max: max,
        value: value
    };
    const focusInput = $kJQf8$react.useCallback(()=>{
        if (ref.current) $kJQf8$reactariautils.focusWithoutScrolling(ref.current);
    }, [
        ref
    ]);
    let onChange = (e)=>{
        let currentWidth = stateRef.current.getColumnWidth(item.key);
        let nextValue = parseFloat(e.target.value);
        if (nextValue > currentWidth) nextValue = currentWidth + 10;
        else nextValue = currentWidth - 10;
        stateRef.current.onColumnResize(item, nextValue);
    };
    let { pressProps: pressProps  } = $kJQf8$reactariainteractions.usePress({
        onPressStart: (e)=>{
            if (e.ctrlKey || e.altKey || e.metaKey || e.shiftKey || e.pointerType === 'keyboard') return;
            if (e.pointerType === 'virtual' && columnState.currentlyResizingColumn != null) {
                stateRef.current.onColumnResizeEnd(item);
                $kJQf8$reactariafocus.focusSafely(triggerRef.current);
                return;
            }
            focusInput();
        },
        onPress: (e)=>{
            if (e.pointerType === 'touch') focusInput();
            else if (e.pointerType !== 'virtual') $kJQf8$reactariafocus.focusSafely(triggerRef.current);
        }
    });
    return {
        resizerProps: $kJQf8$reactariautils.mergeProps(keyboardProps, moveProps, pressProps),
        inputProps: $kJQf8$reactariautils.mergeProps({
            id: id,
            onFocus: ()=>{
                // useMove calls onMoveStart for every keypress, but we want resize start to only be called when we start resize mode
                // call instead during focus and blur
                stateRef.current.onColumnResizeStart(item);
                state.setKeyboardNavigationDisabled(true);
            },
            onBlur: ()=>{
                stateRef.current.onColumnResizeEnd(item);
                state.setKeyboardNavigationDisabled(false);
            },
            onChange: onChange,
            disabled: isDisabled
        }, ariaProps)
    };
}


function $cd66afe5decb6adb$export$6fb1613bd7b28198() {
    return $kJQf8$reactariagrid.useGridRowGroup();
}


//# sourceMappingURL=main.js.map


/***/ }),

/***/ 88514:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $aB6Cp$react = __webpack_require__(18038);
var $aB6Cp$reactariautils = __webpack_require__(73233);
var $aB6Cp$reactariainteractions = __webpack_require__(52115);
var $aB6Cp$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "FocusScope", () => $a7a032acae3ddda9$export$20e40289641fbbb6);
$parcel$export(module.exports, "useFocusManager", () => $a7a032acae3ddda9$export$10c5169755ce7bd7);
$parcel$export(module.exports, "getFocusableTreeWalker", () => $a7a032acae3ddda9$export$2d6ec8fc375ceafa);
$parcel$export(module.exports, "createFocusManager", () => $a7a032acae3ddda9$export$c5251b9e124bf29);
$parcel$export(module.exports, "isElementInChildOfActiveScope", () => $a7a032acae3ddda9$export$1258395f99bf9cbf);
$parcel$export(module.exports, "FocusRing", () => $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d);
$parcel$export(module.exports, "FocusableProvider", () => $fb504d83237fd6ac$export$13f3202a3e5ddd5);
$parcel$export(module.exports, "useFocusable", () => $fb504d83237fd6ac$export$4c014de7c8940b4c);
$parcel$export(module.exports, "useFocusRing", () => $581a96d6eb128c1b$export$4e328f61c538687f);
$parcel$export(module.exports, "focusSafely", () => $1c7f9157d722357d$export$80f3e147d781571c);
$parcel$export(module.exports, "useHasTabbableChild", () => $259c6413a286f2e6$export$eac1895992b9f3d6);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1c7f9157d722357d$export$80f3e147d781571c(element) {
    // If the user is interacting with a virtual cursor, e.g. screen reader, then
    // wait until after any animated transitions that are currently occurring on
    // the page before shifting focus. This avoids issues with VoiceOver on iOS
    // causing the page to scroll when moving focus if the element is transitioning
    // from off the screen.
    if ((0, $aB6Cp$reactariainteractions.getInteractionModality)() === "virtual") {
        let lastFocusedElement = document.activeElement;
        (0, $aB6Cp$reactariautils.runAfterTransition)(()=>{
            // If focus did not move and the element is still in the document, focus it.
            if (document.activeElement === lastFocusedElement && document.contains(element)) (0, $aB6Cp$reactariautils.focusWithoutScrolling)(element);
        });
    } else (0, $aB6Cp$reactariautils.focusWithoutScrolling)(element);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d5156037ad898a4d$var$isStyleVisible(element) {
    if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) return false;
    let { display: display , visibility: visibility  } = element.style;
    let isVisible = display !== "none" && visibility !== "hidden" && visibility !== "collapse";
    if (isVisible) {
        const { getComputedStyle: getComputedStyle  } = element.ownerDocument.defaultView;
        let { display: computedDisplay , visibility: computedVisibility  } = getComputedStyle(element);
        isVisible = computedDisplay !== "none" && computedVisibility !== "hidden" && computedVisibility !== "collapse";
    }
    return isVisible;
}
function $d5156037ad898a4d$var$isAttributeVisible(element, childElement) {
    return !element.hasAttribute("hidden") && (element.nodeName === "DETAILS" && childElement && childElement.nodeName !== "SUMMARY" ? element.hasAttribute("open") : true);
}
function $d5156037ad898a4d$export$e989c0fffaa6b27a(element, childElement) {
    return element.nodeName !== "#comment" && $d5156037ad898a4d$var$isStyleVisible(element) && $d5156037ad898a4d$var$isAttributeVisible(element, childElement) && (!element.parentElement || $d5156037ad898a4d$export$e989c0fffaa6b27a(element.parentElement, element));
}




const $a7a032acae3ddda9$var$FocusContext = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createContext(null);
let $a7a032acae3ddda9$var$activeScope = null;
function $a7a032acae3ddda9$export$20e40289641fbbb6(props) {
    let { children: children , contain: contain , restoreFocus: restoreFocus , autoFocus: autoFocus  } = props;
    let startRef = (0, $aB6Cp$react.useRef)();
    let endRef = (0, $aB6Cp$react.useRef)();
    let scopeRef = (0, $aB6Cp$react.useRef)([]);
    let { parentNode: parentNode  } = (0, $aB6Cp$react.useContext)($a7a032acae3ddda9$var$FocusContext) || {};
    // Create a tree node here so we can add children to it even before it is added to the tree.
    let node = (0, $aB6Cp$react.useMemo)(()=>new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: scopeRef
        }), [
        scopeRef
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),
        // use the active scope as the parent instead of the parent from context. Layout effects run bottom
        // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope
        // that is being added should get the activeScope as its parent.
        let parent = parentNode || $a7a032acae3ddda9$export$d06fae2ee68b101e.root;
        if ($a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(parent.scopeRef) && $a7a032acae3ddda9$var$activeScope && !$a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, parent.scopeRef)) {
            let activeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
            if (activeNode) parent = activeNode;
        }
        // Add the node to the parent, and to the tree.
        parent.addChild(node);
        $a7a032acae3ddda9$export$d06fae2ee68b101e.addNode(node);
    }, [
        node,
        parentNode
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let node = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef);
        node.contain = contain;
    }, [
        contain
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        // Find all rendered nodes between the sentinels and add them to the scope.
        let node = startRef.current.nextSibling;
        let nodes = [];
        while(node && node !== endRef.current){
            nodes.push(node);
            node = node.nextSibling;
        }
        scopeRef.current = nodes;
    }, [
        children
    ]);
    $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain);
    $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus);
    // this layout effect needs to run last so that focusScopeTree cleanup happens at the last moment possible
    (0, $aB6Cp$react.useEffect)(()=>{
        if (scopeRef) {
            let activeElement = document.activeElement;
            let scope = null;
            // In strict mode, active scope is incorrectly updated since cleanup will run even though scope hasn't unmounted.
            // To fix this, we need to update the actual activeScope here
            if ($a7a032acae3ddda9$var$isElementInScope(activeElement, scopeRef.current)) {
                // Since useLayoutEffect runs for children first, we need to traverse the focusScope tree and find the bottom most scope that
                // contains the active element and set that as the activeScope
                for (let node of $a7a032acae3ddda9$export$d06fae2ee68b101e.traverse())if ($a7a032acae3ddda9$var$isElementInScope(activeElement, node.scopeRef.current)) scope = node;
                if (scope === $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef)) $a7a032acae3ddda9$var$activeScope = scope.scopeRef;
            }
            return ()=>{
                // Scope may have been re-parented.
                let parentScope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).parent.scopeRef;
                // Restore the active scope on unmount if this scope or a descendant scope is active.
                // Parent effect cleanups run before children, so we need to check if the
                // parent scope actually still exists before restoring the active scope to it.
                if ((scopeRef === $a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope(scopeRef, $a7a032acae3ddda9$var$activeScope)) && (!parentScope || $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(parentScope))) $a7a032acae3ddda9$var$activeScope = parentScope;
                $a7a032acae3ddda9$export$d06fae2ee68b101e.removeTreeNode(scopeRef);
            };
        }
    }, [
        scopeRef
    ]);
    let focusManager = (0, $aB6Cp$react.useMemo)(()=>$a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef), []);
    let value = (0, $aB6Cp$react.useMemo)(()=>({
            focusManager: focusManager,
            parentNode: node
        }), [
        node,
        focusManager
    ]);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement($a7a032acae3ddda9$var$FocusContext.Provider, {
        value: value
    }, /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement("span", {
        "data-focus-scope-start": true,
        hidden: true,
        ref: startRef
    }), children, /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement("span", {
        "data-focus-scope-end": true,
        hidden: true,
        ref: endRef
    }));
}
function $a7a032acae3ddda9$export$10c5169755ce7bd7() {
    var _useContext;
    return (_useContext = (0, $aB6Cp$react.useContext)($a7a032acae3ddda9$var$FocusContext)) === null || _useContext === void 0 ? void 0 : _useContext.focusManager;
}
function $a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef) {
    return {
        focusNext (opts = {}) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[0].previousElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = sentinel;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = {}) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[scope.length - 1].nextElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = sentinel;
                previousNode = walker.previousNode();
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = {}) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[0].previousElementSibling;
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = {}) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[scope.length - 1].nextElementSibling;
            let previousNode = walker.previousNode();
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        }
    };
}
const $a7a032acae3ddda9$var$focusableElements = [
    "input:not([disabled]):not([type=hidden])",
    "select:not([disabled])",
    "textarea:not([disabled])",
    "button:not([disabled])",
    "a[href]",
    "area[href]",
    "summary",
    "iframe",
    "object",
    "embed",
    "audio[controls]",
    "video[controls]",
    "[contenteditable]"
];
const $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
$a7a032acae3ddda9$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(':not([hidden]):not([tabindex="-1"]),');
function $a7a032acae3ddda9$var$getScopeRoot(scope) {
    return scope[0].parentElement;
}
function $a7a032acae3ddda9$var$shouldContainFocus(scopeRef) {
    let scope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
    while(scope && scope.scopeRef !== scopeRef){
        if (scope.contain) return false;
        scope = scope.parent;
    }
    return true;
}
function $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain) {
    let focusedNode = (0, $aB6Cp$react.useRef)();
    let raf = (0, $aB6Cp$react.useRef)(null);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let scope = scopeRef.current;
        if (!contain) {
            // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment
            if (raf.current) {
                cancelAnimationFrame(raf.current);
                raf.current = null;
            }
            return;
        }
        // Handle the Tab key to contain focus within the scope
        let onKeyDown = (e)=>{
            if (e.key !== "Tab" || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) return;
            let focusedElement = document.activeElement;
            let scope = scopeRef.current;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scope)) return;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: true
            }, scope);
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!nextElement) {
                walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;
                nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            }
            e.preventDefault();
            if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
        };
        let onFocus = (e)=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if ((!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) && $a7a032acae3ddda9$var$isElementInScope(e.target, scopeRef.current)) {
                $a7a032acae3ddda9$var$activeScope = scopeRef;
                focusedNode.current = e.target;
            } else if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(e.target, scopeRef)) {
                // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),
                // restore focus to the previously focused node or the first tabbable element in the active scope.
                if (focusedNode.current) focusedNode.current.focus();
                else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
            } else if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) focusedNode.current = e.target;
        };
        let onBlur = (e)=>{
            // Firefox doesn't shift focus back to the Dialog properly without this
            if (raf.current) cancelAnimationFrame(raf.current);
            raf.current = requestAnimationFrame(()=>{
                // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe
                if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(document.activeElement, scopeRef)) {
                    $a7a032acae3ddda9$var$activeScope = scopeRef;
                    if (document.body.contains(e.target)) {
                        focusedNode.current = e.target;
                        focusedNode.current.focus();
                    } else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
                }
            });
        };
        document.addEventListener("keydown", onKeyDown, false);
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        scope.forEach((element)=>element.addEventListener("focusout", onBlur, false));
        return ()=>{
            document.removeEventListener("keydown", onKeyDown, false);
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
            scope.forEach((element)=>element.removeEventListener("focusout", onBlur, false));
        };
    }, [
        scopeRef,
        contain
    ]);
    // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur
    // eslint-disable-next-line arrow-body-style
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        return ()=>{
            if (raf.current) cancelAnimationFrame(raf.current);
        };
    }, [
        raf
    ]);
}
function $a7a032acae3ddda9$var$isElementInAnyScope(element) {
    return $a7a032acae3ddda9$var$isElementInChildScope(element);
}
function $a7a032acae3ddda9$var$isElementInScope(element, scope) {
    return scope.some((node)=>node.contains(element));
}
function $a7a032acae3ddda9$var$isElementInChildScope(element, scope = null) {
    // If the element is within a top layer element (e.g. toasts), always allow moving focus there.
    if (element instanceof Element && element.closest("[data-react-aria-top-layer]")) return true;
    // node.contains in isElementInScope covers child scopes that are also DOM children,
    // but does not cover child scopes in portals.
    for (let { scopeRef: s  } of $a7a032acae3ddda9$export$d06fae2ee68b101e.traverse($a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scope))){
        if ($a7a032acae3ddda9$var$isElementInScope(element, s.current)) return true;
    }
    return false;
}
function $a7a032acae3ddda9$export$1258395f99bf9cbf(element) {
    return $a7a032acae3ddda9$var$isElementInChildScope(element, $a7a032acae3ddda9$var$activeScope);
}
function $a7a032acae3ddda9$var$isAncestorScope(ancestor, scope) {
    var _focusScopeTree_getTreeNode;
    let parent = (_focusScopeTree_getTreeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scope)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : _focusScopeTree_getTreeNode.parent;
    while(parent){
        if (parent.scopeRef === ancestor) return true;
        parent = parent.parent;
    }
    return false;
}
function $a7a032acae3ddda9$var$focusElement(element, scroll = false) {
    if (element != null && !scroll) try {
        (0, $1c7f9157d722357d$export$80f3e147d781571c)(element);
    } catch (err) {
    // ignore
    }
    else if (element != null) try {
        element.focus();
    } catch (err) {
    // ignore
    }
}
function $a7a032acae3ddda9$var$focusFirstInScope(scope, tabbable = true) {
    let sentinel = scope[0].previousElementSibling;
    let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
        tabbable: tabbable
    }, scope);
    walker.currentNode = sentinel;
    let nextNode = walker.nextNode();
    // If the scope does not contain a tabbable element, use the first focusable element.
    if (tabbable && !nextNode) {
        walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
            tabbable: false
        }, scope);
        walker.currentNode = sentinel;
        nextNode = walker.nextNode();
    }
    $a7a032acae3ddda9$var$focusElement(nextNode);
}
function $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus) {
    const autoFocusRef = (0, ($parcel$interopDefault($aB6Cp$react))).useRef(autoFocus);
    (0, $aB6Cp$react.useEffect)(()=>{
        if (autoFocusRef.current) {
            $a7a032acae3ddda9$var$activeScope = scopeRef;
            if (!$a7a032acae3ddda9$var$isElementInScope(document.activeElement, $a7a032acae3ddda9$var$activeScope.current)) $a7a032acae3ddda9$var$focusFirstInScope(scopeRef.current);
        }
        autoFocusRef.current = false;
    }, [
        scopeRef
    ]);
}
function $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restore, contain) {
    // tracks the active scope, in case restore and contain are both false.
    // if either are true, this is tracked in useRestoreFocus or useFocusContainment.
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if (restore || contain) return;
        let scope = scopeRef.current;
        let onFocus = (e)=>{
            let target = e.target;
            if ($a7a032acae3ddda9$var$isElementInScope(target, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
            else if (!$a7a032acae3ddda9$var$isElementInAnyScope(target)) $a7a032acae3ddda9$var$activeScope = null;
        };
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        return ()=>{
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
        };
    }, [
        scopeRef,
        restore,
        contain
    ]);
}
function $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef) {
    let scope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
    while(scope && scope.scopeRef !== scopeRef){
        if (scope.nodeToRestore) return false;
        scope = scope.parent;
    }
    return (scope === null || scope === void 0 ? void 0 : scope.scopeRef) === scopeRef;
}
function $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
    // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.
    const nodeToRestoreRef = (0, $aB6Cp$react.useRef)(typeof document !== "undefined" ? document.activeElement : null);
    // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus
    // restoring-non-containing scopes should only care if they become active so they can perform the restore
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let scope = scopeRef.current;
        if (!restoreFocus || contain) return;
        let onFocus = ()=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if ((!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) && $a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
        };
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        return ()=>{
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        scopeRef,
        contain
    ]);
    // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if (!restoreFocus) return;
        $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = nodeToRestoreRef.current;
        // Handle the Tab key so that tabbing out of the scope goes to the next element
        // after the node that had focus when the scope mounted. This is important when
        // using portals for overlays, so that focus goes to the expected element when
        // tabbing out of the overlay.
        let onKeyDown = (e)=>{
            if (e.key !== "Tab" || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) return;
            let focusedElement = document.activeElement;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scopeRef.current)) return;
            let nodeToRestore = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;
            // Create a DOM tree walker that matches all tabbable elements
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(document.body, {
                tabbable: true
            });
            // Find the next tabbable element after the currently focused element
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!document.body.contains(nodeToRestore) || nodeToRestore === document.body) {
                nodeToRestore = null;
                $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = null;
            }
            // If there is no next element, or it is outside the current scope, move focus to the
            // next element after the node to restore to instead.
            if ((!nextElement || !$a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {
                walker.currentNode = nodeToRestore;
                // Skip over elements within the scope, in case the scope immediately follows the node to restore.
                do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
                while ($a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current));
                e.preventDefault();
                e.stopPropagation();
                if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
                else // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)
                // then move focus to the body.
                // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)
                if (!$a7a032acae3ddda9$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();
                else $a7a032acae3ddda9$var$focusElement(nodeToRestore, true);
            }
        };
        if (!contain) document.addEventListener("keydown", onKeyDown, true);
        return ()=>{
            if (!contain) document.removeEventListener("keydown", onKeyDown, true);
            let nodeToRestore = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;
            // if we already lost focus to the body and this was the active scope, then we should attempt to restore
            if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps
            ($a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current) || document.activeElement === document.body && $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef))) {
                // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it
                let clonedTree = $a7a032acae3ddda9$export$d06fae2ee68b101e.clone();
                requestAnimationFrame(()=>{
                    // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere
                    if (document.activeElement === document.body) {
                        // look up the tree starting with our scope to find a nodeToRestore still in the DOM
                        let treeNode = clonedTree.getTreeNode(scopeRef);
                        while(treeNode){
                            if (treeNode.nodeToRestore && document.body.contains(treeNode.nodeToRestore)) {
                                $a7a032acae3ddda9$var$focusElement(treeNode.nodeToRestore);
                                return;
                            }
                            treeNode = treeNode.parent;
                        }
                        // If no nodeToRestore was found, focus the first element in the nearest
                        // ancestor scope that is still in the tree.
                        treeNode = clonedTree.getTreeNode(scopeRef);
                        while(treeNode){
                            if (treeNode.scopeRef && $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(treeNode.scopeRef)) {
                                $a7a032acae3ddda9$var$focusFirstInScope(treeNode.scopeRef.current, true);
                                return;
                            }
                            treeNode = treeNode.parent;
                        }
                    }
                });
            }
        };
    }, [
        scopeRef,
        restoreFocus,
        contain
    ]);
}
function $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, opts, scope) {
    let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR : $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR;
    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode (node) {
            var _opts_from;
            // Skip nodes inside the starting node.
            if (opts === null || opts === void 0 ? void 0 : (_opts_from = opts.from) === null || _opts_from === void 0 ? void 0 : _opts_from.contains(node)) return NodeFilter.FILTER_REJECT;
            if (node.matches(selector) && (0, $d5156037ad898a4d$export$e989c0fffaa6b27a)(node) && (!scope || $a7a032acae3ddda9$var$isElementInScope(node, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node))) return NodeFilter.FILTER_ACCEPT;
            return NodeFilter.FILTER_SKIP;
        }
    });
    if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;
    return walker;
}
function $a7a032acae3ddda9$export$c5251b9e124bf29(ref, defaultOptions = {}) {
    return {
        focusNext (opts = {}) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = root;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            else {
                let next = $a7a032acae3ddda9$var$last(walker);
                if (next) $a7a032acae3ddda9$var$focusElement(next, true);
                return next;
            }
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = root;
                previousNode = $a7a032acae3ddda9$var$last(walker);
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let next = $a7a032acae3ddda9$var$last(walker);
            if (next) $a7a032acae3ddda9$var$focusElement(next, true);
            return next;
        }
    };
}
function $a7a032acae3ddda9$var$last(walker) {
    let next;
    let last;
    do {
        last = walker.lastChild();
        if (last) next = last;
    }while (last);
    return next;
}
class $a7a032acae3ddda9$var$Tree {
    get size() {
        return this.fastMap.size;
    }
    getTreeNode(data) {
        return this.fastMap.get(data);
    }
    addTreeNode(scopeRef, parent, nodeToRestore) {
        let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);
        let node = new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: scopeRef
        });
        parentNode.addChild(node);
        node.parent = parentNode;
        this.fastMap.set(scopeRef, node);
        if (nodeToRestore) node.nodeToRestore = nodeToRestore;
    }
    addNode(node) {
        this.fastMap.set(node.scopeRef, node);
    }
    removeTreeNode(scopeRef) {
        // never remove the root
        if (scopeRef === null) return;
        let node = this.fastMap.get(scopeRef);
        let parentNode = node.parent;
        // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing
        // if we are, then replace the siblings restore with the restore from the scope we're removing
        for (let current of this.traverse())if (current !== node && node.nodeToRestore && current.nodeToRestore && node.scopeRef.current && $a7a032acae3ddda9$var$isElementInScope(current.nodeToRestore, node.scopeRef.current)) current.nodeToRestore = node.nodeToRestore;
        let children = node.children;
        parentNode.removeChild(node);
        if (children.size > 0) children.forEach((child)=>parentNode.addChild(child));
        this.fastMap.delete(node.scopeRef);
    }
    // Pre Order Depth First
    *traverse(node = this.root) {
        if (node.scopeRef != null) yield node;
        if (node.children.size > 0) for (let child of node.children)yield* this.traverse(child);
    }
    clone() {
        let newTree = new $a7a032acae3ddda9$var$Tree();
        for (let node of this.traverse())newTree.addTreeNode(node.scopeRef, node.parent.scopeRef, node.nodeToRestore);
        return newTree;
    }
    constructor(){
        this.fastMap = new Map();
        this.root = new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: null
        });
        this.fastMap.set(null, this.root);
    }
}
class $a7a032acae3ddda9$var$TreeNode {
    addChild(node) {
        this.children.add(node);
        node.parent = this;
    }
    removeChild(node) {
        this.children.delete(node);
        node.parent = undefined;
    }
    constructor(props){
        this.children = new Set();
        this.contain = false;
        this.scopeRef = props.scopeRef;
    }
}
let $a7a032acae3ddda9$export$d06fae2ee68b101e = new $a7a032acae3ddda9$var$Tree();


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 




function $581a96d6eb128c1b$export$4e328f61c538687f(props = {}) {
    let { autoFocus: autoFocus = false , isTextInput: isTextInput , within: within  } = props;
    let state = (0, $aB6Cp$react.useRef)({
        isFocused: false,
        isFocusVisible: autoFocus || (0, $aB6Cp$reactariainteractions.isFocusVisible)()
    });
    let [isFocused, setFocused] = (0, $aB6Cp$react.useState)(false);
    let [isFocusVisibleState, setFocusVisible] = (0, $aB6Cp$react.useState)(()=>state.current.isFocused && state.current.isFocusVisible);
    let updateState = (0, $aB6Cp$react.useCallback)(()=>setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
    let onFocusChange = (0, $aB6Cp$react.useCallback)((isFocused)=>{
        state.current.isFocused = isFocused;
        setFocused(isFocused);
        updateState();
    }, [
        updateState
    ]);
    (0, $aB6Cp$reactariainteractions.useFocusVisibleListener)((isFocusVisible)=>{
        state.current.isFocusVisible = isFocusVisible;
        updateState();
    }, [], {
        isTextInput: isTextInput
    });
    let { focusProps: focusProps  } = (0, $aB6Cp$reactariainteractions.useFocus)({
        isDisabled: within,
        onFocusChange: onFocusChange
    });
    let { focusWithinProps: focusWithinProps  } = (0, $aB6Cp$reactariainteractions.useFocusWithin)({
        isDisabled: !within,
        onFocusWithinChange: onFocusChange
    });
    return {
        isFocused: isFocused,
        isFocusVisible: isFocusVisibleState,
        focusProps: within ? focusWithinProps : focusProps
    };
}


function $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d(props) {
    let { children: children , focusClass: focusClass , focusRingClass: focusRingClass  } = props;
    let { isFocused: isFocused , isFocusVisible: isFocusVisible , focusProps: focusProps  } = (0, $581a96d6eb128c1b$export$4e328f61c538687f)(props);
    let child = (0, ($parcel$interopDefault($aB6Cp$react))).Children.only(children);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).cloneElement(child, (0, $aB6Cp$reactariautils.mergeProps)(child.props, {
        ...focusProps,
        className: (0, ($parcel$interopDefault($aB6Cp$clsx)))({
            [focusClass || ""]: isFocused,
            [focusRingClass || ""]: isFocusVisible
        })
    }));
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



let $fb504d83237fd6ac$var$FocusableContext = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createContext(null);
function $fb504d83237fd6ac$var$useFocusableContext(ref) {
    let context = (0, $aB6Cp$react.useContext)($fb504d83237fd6ac$var$FocusableContext) || {};
    (0, $aB6Cp$reactariautils.useSyncRef)(context, ref);
    // eslint-disable-next-line
    let { ref: _ , ...otherProps } = context;
    return otherProps;
}
/**
 * Provides DOM props to the nearest focusable child.
 */ function $fb504d83237fd6ac$var$FocusableProvider(props, ref) {
    let { children: children , ...otherProps } = props;
    let context = {
        ...otherProps,
        ref: ref
    };
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement($fb504d83237fd6ac$var$FocusableContext.Provider, {
        value: context
    }, children);
}
let $fb504d83237fd6ac$export$13f3202a3e5ddd5 = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).forwardRef($fb504d83237fd6ac$var$FocusableProvider);
function $fb504d83237fd6ac$export$4c014de7c8940b4c(props, domRef) {
    let { focusProps: focusProps  } = (0, $aB6Cp$reactariainteractions.useFocus)(props);
    let { keyboardProps: keyboardProps  } = (0, $aB6Cp$reactariainteractions.useKeyboard)(props);
    let interactions = (0, $aB6Cp$reactariautils.mergeProps)(focusProps, keyboardProps);
    let domProps = $fb504d83237fd6ac$var$useFocusableContext(domRef);
    let interactionProps = props.isDisabled ? {} : domProps;
    let autoFocusRef = (0, $aB6Cp$react.useRef)(props.autoFocus);
    (0, $aB6Cp$react.useEffect)(()=>{
        if (autoFocusRef.current && domRef.current) (0, $1c7f9157d722357d$export$80f3e147d781571c)(domRef.current);
        autoFocusRef.current = false;
    }, [
        domRef
    ]);
    return {
        focusableProps: (0, $aB6Cp$reactariautils.mergeProps)({
            ...interactions,
            tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined
        }, interactionProps)
    };
}




/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $259c6413a286f2e6$export$eac1895992b9f3d6(ref, options) {
    let isDisabled = options === null || options === void 0 ? void 0 : options.isDisabled;
    let [hasTabbableChild, setHasTabbableChild] = (0, $aB6Cp$react.useState)(false);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if ((ref === null || ref === void 0 ? void 0 : ref.current) && !isDisabled) {
            let update = ()=>{
                if (ref.current) {
                    let walker = (0, $a7a032acae3ddda9$export$2d6ec8fc375ceafa)(ref.current, {
                        tabbable: true
                    });
                    setHasTabbableChild(!!walker.nextNode());
                }
            };
            update();
            // Update when new elements are inserted, or the tabIndex/disabled attribute updates.
            let observer = new MutationObserver(update);
            observer.observe(ref.current, {
                subtree: true,
                childList: true,
                attributes: true,
                attributeFilter: [
                    "tabIndex",
                    "disabled"
                ]
            });
            return ()=>{
                // Disconnect mutation observer when a React update occurs on the top-level component
                // so we update synchronously after re-rendering. Otherwise React will emit act warnings
                // in tests since mutation observers fire asynchronously. The mutation observer is necessary
                // so we also update if a child component re-renders and adds/removes something tabbable.
                observer.disconnect();
            };
        }
    });
    return isDisabled ? false : hasTabbableChild;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 52115:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $goTMa$reactariautils = __webpack_require__(73233);
var $goTMa$react = __webpack_require__(18038);
var $goTMa$reactariassr = __webpack_require__(88381);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "Pressable", () => $e1dbec26039c051d$export$27c701ed9e449e99);
$parcel$export(module.exports, "PressResponder", () => $3596bae48579386f$export$3351871ee4b288b8);
$parcel$export(module.exports, "useFocus", () => $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6);
$parcel$export(module.exports, "isFocusVisible", () => $e77252a287ef94ab$export$b9b3dfddab17db27);
$parcel$export(module.exports, "getInteractionModality", () => $e77252a287ef94ab$export$630ff653c5ada6a9);
$parcel$export(module.exports, "setInteractionModality", () => $e77252a287ef94ab$export$8397ddfc504fdb9a);
$parcel$export(module.exports, "useInteractionModality", () => $e77252a287ef94ab$export$98e20ec92f614cfe);
$parcel$export(module.exports, "useFocusVisible", () => $e77252a287ef94ab$export$ffd9e5021c1fb2d6);
$parcel$export(module.exports, "useFocusVisibleListener", () => $e77252a287ef94ab$export$ec71b4b83ac08ec3);
$parcel$export(module.exports, "useFocusWithin", () => $d16842bbd0359d1b$export$420e68273165f4ec);
$parcel$export(module.exports, "useHover", () => $ffbc150311c75f01$export$ae780daf29e6d456);
$parcel$export(module.exports, "useInteractOutside", () => $edcfa848c42f94f4$export$872b660ac5a1ff98);
$parcel$export(module.exports, "useKeyboard", () => $892d64db2a3c53b0$export$8f71654801c2f7cd);
$parcel$export(module.exports, "useMove", () => $c09386fc48fa427d$export$36da96379f79f245);
$parcel$export(module.exports, "usePress", () => $0294ea432cd92340$export$45712eceda6fad21);
$parcel$export(module.exports, "useScrollWheel", () => $a3dbce0aed7087e2$export$2123ff2b87c81ca);
$parcel$export(module.exports, "useLongPress", () => $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element
// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually
let $f7e14e656343df57$var$state = "default";
let $f7e14e656343df57$var$savedUserSelect = "";
let $f7e14e656343df57$var$modifiedElementMap = new WeakMap();
function $f7e14e656343df57$export$16a4697467175487(target) {
    if ((0, $goTMa$reactariautils.isIOS)()) {
        if ($f7e14e656343df57$var$state === "default") {
            $f7e14e656343df57$var$savedUserSelect = document.documentElement.style.webkitUserSelect;
            document.documentElement.style.webkitUserSelect = "none";
        }
        $f7e14e656343df57$var$state = "disabled";
    } else if (target instanceof HTMLElement || target instanceof SVGElement) {
        // If not iOS, store the target's original user-select and change to user-select: none
        // Ignore state since it doesn't apply for non iOS
        $f7e14e656343df57$var$modifiedElementMap.set(target, target.style.userSelect);
        target.style.userSelect = "none";
    }
}
function $f7e14e656343df57$export$b0d6fa1ab32e3295(target) {
    if ((0, $goTMa$reactariautils.isIOS)()) {
        // If the state is already default, there's nothing to do.
        // If it is restoring, then there's no need to queue a second restore.
        if ($f7e14e656343df57$var$state !== "disabled") return;
        $f7e14e656343df57$var$state = "restoring";
        // There appears to be a delay on iOS where selection still might occur
        // after pointer up, so wait a bit before removing user-select.
        setTimeout(()=>{
            // Wait for any CSS transitions to complete so we don't recompute style
            // for the whole page in the middle of the animation and cause jank.
            (0, $goTMa$reactariautils.runAfterTransition)(()=>{
                // Avoid race conditions
                if ($f7e14e656343df57$var$state === "restoring") {
                    if (document.documentElement.style.webkitUserSelect === "none") document.documentElement.style.webkitUserSelect = $f7e14e656343df57$var$savedUserSelect || "";
                    $f7e14e656343df57$var$savedUserSelect = "";
                    $f7e14e656343df57$var$state = "default";
                }
            });
        }, 300);
    } else if (target instanceof HTMLElement || target instanceof SVGElement) // If not iOS, restore the target's original user-select if any
    // Ignore state since it doesn't apply for non iOS
    {
        if (target && $f7e14e656343df57$var$modifiedElementMap.has(target)) {
            let targetOldUserSelect = $f7e14e656343df57$var$modifiedElementMap.get(target);
            if (target.style.userSelect === "none") target.style.userSelect = targetOldUserSelect;
            if (target.getAttribute("style") === "") target.removeAttribute("style");
            $f7e14e656343df57$var$modifiedElementMap.delete(target);
        }
    }
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $01d3f539e91688c8$export$5165eccb35aaadb5 = (0, ($parcel$interopDefault($goTMa$react))).createContext(null);
$01d3f539e91688c8$export$5165eccb35aaadb5.displayName = "PressResponderContext";



function $0294ea432cd92340$var$usePressResponderContext(props) {
    // Consume context from <PressResponder> and merge with props.
    let context = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));
    if (context) {
        let { register: register , ...contextProps } = context;
        props = (0, $goTMa$reactariautils.mergeProps)(contextProps, props);
        register();
    }
    (0, $goTMa$reactariautils.useSyncRef)(context, props.ref);
    return props;
}
function $0294ea432cd92340$export$45712eceda6fad21(props) {
    let { onPress: onPress , onPressChange: onPressChange , onPressStart: onPressStart , onPressEnd: onPressEnd , onPressUp: onPressUp , isDisabled: isDisabled , isPressed: isPressedProp , preventFocusOnPress: preventFocusOnPress , shouldCancelOnPointerExit: shouldCancelOnPointerExit , allowTextSelectionOnPress: allowTextSelectionOnPress , // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: _ , ...domProps } = $0294ea432cd92340$var$usePressResponderContext(props);
    let [isPressed, setPressed] = (0, $goTMa$react.useState)(false);
    let ref = (0, $goTMa$react.useRef)({
        isPressed: false,
        ignoreEmulatedMouseEvents: false,
        ignoreClickAfterPress: false,
        didFirePressStart: false,
        activePointerId: null,
        target: null,
        isOverTarget: false,
        pointerType: null
    });
    let { addGlobalListener: addGlobalListener , removeAllGlobalListeners: removeAllGlobalListeners  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let triggerPressStart = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        let state = ref.current;
        if (isDisabled || state.didFirePressStart) return;
        if (onPressStart) onPressStart({
            type: "pressstart",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
        if (onPressChange) onPressChange(true);
        state.didFirePressStart = true;
        setPressed(true);
    });
    let triggerPressEnd = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType, wasPressed = true)=>{
        let state = ref.current;
        if (!state.didFirePressStart) return;
        state.ignoreClickAfterPress = true;
        state.didFirePressStart = false;
        if (onPressEnd) onPressEnd({
            type: "pressend",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
        if (onPressChange) onPressChange(false);
        setPressed(false);
        if (onPress && wasPressed && !isDisabled) onPress({
            type: "press",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let triggerPressUp = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        if (isDisabled) return;
        if (onPressUp) onPressUp({
            type: "pressup",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let cancel = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        let state = ref.current;
        if (state.isPressed) {
            if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
            state.isPressed = false;
            state.isOverTarget = false;
            state.activePointerId = null;
            state.pointerType = null;
            removeAllGlobalListeners();
            if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
        }
    });
    let cancelOnPointerExit = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (shouldCancelOnPointerExit) cancel(e);
    });
    let pressProps = (0, $goTMa$react.useMemo)(()=>{
        let state = ref.current;
        let pressProps = {
            onKeyDown (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {
                    if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                    e.stopPropagation();
                    // If the event is repeating, it may have started on a different element
                    // after which focus moved to the current element. Ignore these events and
                    // only handle the first key down event.
                    if (!state.isPressed && !e.repeat) {
                        state.target = e.currentTarget;
                        state.isPressed = true;
                        triggerPressStart(e, "keyboard");
                        // Focus may move before the key up event, so register the event on the document
                        // instead of the same element where the key down event occurred.
                        addGlobalListener(document, "keyup", onKeyUp, false);
                    }
                } else if (e.key === "Enter" && $0294ea432cd92340$var$isHTMLAnchorLink(e.currentTarget)) // If the target is a link, we won't have handled this above because we want the default
                // browser behavior to open the link when pressing Enter. But we still need to prevent
                // default so that elements above do not also handle it (e.g. table row).
                e.stopPropagation();
            },
            onKeyUp (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target)) triggerPressUp($0294ea432cd92340$var$createEvent(state.target, e), "keyboard");
            },
            onClick (e) {
                if (e && !e.currentTarget.contains(e.target)) return;
                if (e && e.button === 0) {
                    e.stopPropagation();
                    if (isDisabled) e.preventDefault();
                    // If triggered from a screen reader or by using element.click(),
                    // trigger as if it were a keyboard click.
                    if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && (state.pointerType === "virtual" || (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent))) {
                        // Ensure the element receives focus (VoiceOver on iOS does not do this)
                        if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                        triggerPressStart(e, "virtual");
                        triggerPressUp(e, "virtual");
                        triggerPressEnd(e, "virtual");
                    }
                    state.ignoreEmulatedMouseEvents = false;
                    state.ignoreClickAfterPress = false;
                }
            }
        };
        let onKeyUp = (e)=>{
            if (state.isPressed && $0294ea432cd92340$var$isValidKeyboardEvent(e, state.target)) {
                if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                e.stopPropagation();
                state.isPressed = false;
                let target = e.target;
                triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), "keyboard", state.target.contains(target));
                removeAllGlobalListeners();
                // If the target is a link, trigger the click method to open the URL,
                // but defer triggering pressEnd until onClick event handler.
                if (state.target instanceof HTMLElement && state.target.contains(target) && ($0294ea432cd92340$var$isHTMLAnchorLink(state.target) || state.target.getAttribute("role") === "link")) state.target.click();
            }
        };
        if (typeof PointerEvent !== "undefined") {
            pressProps.onPointerDown = (e)=>{
                // Only handle left clicks, and ignore events that bubbled through portals.
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.
                // Ignore and let the onClick handler take care of it instead.
                // https://bugs.webkit.org/show_bug.cgi?id=222627
                // https://bugs.webkit.org/show_bug.cgi?id=223202
                if ((0, $goTMa$reactariautils.isVirtualPointerEvent)(e.nativeEvent)) {
                    state.pointerType = "virtual";
                    return;
                }
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on pointer down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                state.pointerType = e.pointerType;
                e.stopPropagation();
                if (!state.isPressed) {
                    state.isPressed = true;
                    state.isOverTarget = true;
                    state.activePointerId = e.pointerId;
                    state.target = e.currentTarget;
                    if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                    if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);
                    triggerPressStart(e, state.pointerType);
                    addGlobalListener(document, "pointermove", onPointerMove, false);
                    addGlobalListener(document, "pointerup", onPointerUp, false);
                    addGlobalListener(document, "pointercancel", onPointerCancel, false);
                }
            };
            pressProps.onMouseDown = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (e.button === 0) {
                    // Chrome and Firefox on touch Windows devices require mouse down events
                    // to be canceled in addition to pointer events, or an extra asynchronous
                    // focus event will be fired.
                    if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                    e.stopPropagation();
                }
            };
            pressProps.onPointerUp = (e)=>{
                // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.
                if (!e.currentTarget.contains(e.target) || state.pointerType === "virtual") return;
                // Only handle left clicks
                // Safari on iOS sometimes fires pointerup events, even
                // when the touch isn't over the target, so double check.
                if (e.button === 0 && $0294ea432cd92340$var$isOverTarget(e, e.currentTarget)) triggerPressUp(e, state.pointerType || e.pointerType);
            };
            // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.
            // Use pointer move events instead to implement our own hit testing.
            // See https://bugs.webkit.org/show_bug.cgi?id=199803
            let onPointerMove = (e)=>{
                if (e.pointerId !== state.activePointerId) return;
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0) {
                    if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    state.isPressed = false;
                    state.isOverTarget = false;
                    state.activePointerId = null;
                    state.pointerType = null;
                    removeAllGlobalListeners();
                    if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
                }
            };
            let onPointerCancel = (e)=>{
                cancel(e);
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.
                cancel(e);
            };
        } else {
            pressProps.onMouseDown = (e)=>{
                // Only handle left clicks
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on mouse down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                e.stopPropagation();
                if (state.ignoreEmulatedMouseEvents) return;
                state.isPressed = true;
                state.isOverTarget = true;
                state.target = e.currentTarget;
                state.pointerType = (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent) ? "virtual" : "mouse";
                if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(document, "mouseup", onMouseUp, false);
            };
            pressProps.onMouseEnter = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = true;
                    triggerPressStart(e, state.pointerType);
                }
            };
            pressProps.onMouseLeave = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            pressProps.onMouseUp = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType);
            };
            let onMouseUp = (e)=>{
                // Only handle left clicks
                if (e.button !== 0) return;
                state.isPressed = false;
                removeAllGlobalListeners();
                if (state.ignoreEmulatedMouseEvents) {
                    state.ignoreEmulatedMouseEvents = false;
                    return;
                }
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                state.isOverTarget = false;
            };
            pressProps.onTouchStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                let touch = $0294ea432cd92340$var$getTouchFromEvent(e.nativeEvent);
                if (!touch) return;
                state.activePointerId = touch.identifier;
                state.ignoreEmulatedMouseEvents = true;
                state.isOverTarget = true;
                state.isPressed = true;
                state.target = e.currentTarget;
                state.pointerType = "touch";
                // Due to browser inconsistencies, especially on mobile browsers, we prevent default
                // on the emulated mouse event and handle focusing the pressable element ourselves.
                if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(window, "scroll", onScroll, true);
            };
            pressProps.onTouchMove = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart(e, state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            pressProps.onTouchEnd = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    triggerPressUp(e, state.pointerType);
                    triggerPressEnd(e, state.pointerType);
                } else if (state.isOverTarget) triggerPressEnd(e, state.pointerType, false);
                state.isPressed = false;
                state.activePointerId = null;
                state.isOverTarget = false;
                state.ignoreEmulatedMouseEvents = true;
                if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
                removeAllGlobalListeners();
            };
            pressProps.onTouchCancel = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed) cancel(e);
            };
            let onScroll = (e)=>{
                if (state.isPressed && e.target.contains(state.target)) cancel({
                    currentTarget: state.target,
                    shiftKey: false,
                    ctrlKey: false,
                    metaKey: false,
                    altKey: false
                });
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                cancel(e);
            };
        }
        return pressProps;
    }, [
        addGlobalListener,
        isDisabled,
        preventFocusOnPress,
        removeAllGlobalListeners,
        allowTextSelectionOnPress,
        cancel,
        cancelOnPointerExit,
        triggerPressEnd,
        triggerPressStart,
        triggerPressUp
    ]);
    // Remove user-select: none in case component unmounts immediately after pressStart
    // eslint-disable-next-line arrow-body-style
    (0, $goTMa$react.useEffect)(()=>{
        return ()=>{
            if (!allowTextSelectionOnPress) // eslint-disable-next-line react-hooks/exhaustive-deps
            (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(ref.current.target);
        };
    }, [
        allowTextSelectionOnPress
    ]);
    return {
        isPressed: isPressedProp || isPressed,
        pressProps: (0, $goTMa$reactariautils.mergeProps)(domProps, pressProps)
    };
}
function $0294ea432cd92340$var$isHTMLAnchorLink(target) {
    return target.tagName === "A" && target.hasAttribute("href");
}
function $0294ea432cd92340$var$isValidKeyboardEvent(event, currentTarget) {
    const { key: key , code: code  } = event;
    const element = currentTarget;
    const role = element.getAttribute("role");
    // Accessibility for keyboards. Space and Enter only.
    // "Spacebar" is for IE 11
    return (key === "Enter" || key === " " || key === "Spacebar" || code === "Space") && !(element instanceof HTMLInputElement && !$0294ea432cd92340$var$isValidInputKey(element, key) || element instanceof HTMLTextAreaElement || element.isContentEditable) && // A link with a valid href should be handled natively,
    // unless it also has role='button' and was triggered using Space.
    (!$0294ea432cd92340$var$isHTMLAnchorLink(element) || role === "button" && key !== "Enter") && // An element with role='link' should only trigger with Enter key
    !(role === "link" && key !== "Enter");
}
function $0294ea432cd92340$var$getTouchFromEvent(event) {
    const { targetTouches: targetTouches  } = event;
    if (targetTouches.length > 0) return targetTouches[0];
    return null;
}
function $0294ea432cd92340$var$getTouchById(event, pointerId) {
    const changedTouches = event.changedTouches;
    for(let i = 0; i < changedTouches.length; i++){
        const touch = changedTouches[i];
        if (touch.identifier === pointerId) return touch;
    }
    return null;
}
function $0294ea432cd92340$var$createEvent(target, e) {
    return {
        currentTarget: target,
        shiftKey: e.shiftKey,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey
    };
}
function $0294ea432cd92340$var$getPointClientRect(point) {
    let offsetX = point.width / 2 || point.radiusX || 0;
    let offsetY = point.height / 2 || point.radiusY || 0;
    return {
        top: point.clientY - offsetY,
        right: point.clientX + offsetX,
        bottom: point.clientY + offsetY,
        left: point.clientX - offsetX
    };
}
function $0294ea432cd92340$var$areRectanglesOverlapping(a, b) {
    // check if they cannot overlap on x axis
    if (a.left > b.right || b.left > a.right) return false;
    // check if they cannot overlap on y axis
    if (a.top > b.bottom || b.top > a.bottom) return false;
    return true;
}
function $0294ea432cd92340$var$isOverTarget(point, target) {
    let rect = target.getBoundingClientRect();
    let pointRect = $0294ea432cd92340$var$getPointClientRect(point);
    return $0294ea432cd92340$var$areRectanglesOverlapping(rect, pointRect);
}
function $0294ea432cd92340$var$shouldPreventDefault(target) {
    // We cannot prevent default if the target is a draggable element.
    return !(target instanceof HTMLElement) || !target.draggable;
}
function $0294ea432cd92340$var$shouldPreventDefaultKeyboard(target, key) {
    if (target instanceof HTMLInputElement) return !$0294ea432cd92340$var$isValidInputKey(target, key);
    if (target instanceof HTMLButtonElement) return target.type !== "submit";
    return true;
}
const $0294ea432cd92340$var$nonTextInputTypes = new Set([
    "checkbox",
    "radio",
    "range",
    "color",
    "file",
    "image",
    "button",
    "submit",
    "reset"
]);
function $0294ea432cd92340$var$isValidInputKey(target, key) {
    // Only space should toggle checkboxes and radios, not enter.
    return target.type === "checkbox" || target.type === "radio" ? key === " " : $0294ea432cd92340$var$nonTextInputTypes.has(target.type);
}



const $e1dbec26039c051d$export$27c701ed9e449e99 = /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).forwardRef(({ children: children , ...props }, ref)=>{
    let newRef = (0, $goTMa$react.useRef)();
    ref = ref !== null && ref !== void 0 ? ref : newRef;
    let { pressProps: pressProps  } = (0, $0294ea432cd92340$export$45712eceda6fad21)({
        ...props,
        ref: ref
    });
    let child = (0, ($parcel$interopDefault($goTMa$react))).Children.only(children);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).cloneElement(child, // @ts-ignore
    {
        ref: ref,
        ...(0, $goTMa$reactariautils.mergeProps)(child.props, pressProps)
    });
});


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $3596bae48579386f$export$3351871ee4b288b8 = /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).forwardRef(({ children: children , ...props }, ref)=>{
    let isRegistered = (0, $goTMa$react.useRef)(false);
    let prevContext = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));
    let context = (0, $goTMa$reactariautils.mergeProps)(prevContext || {}, {
        ...props,
        ref: ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref),
        register () {
            isRegistered.current = true;
            if (prevContext) prevContext.register();
        }
    });
    (0, $goTMa$reactariautils.useSyncRef)(prevContext, ref);
    (0, $goTMa$react.useEffect)(()=>{
        if (!isRegistered.current) {
            console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.");
            isRegistered.current = true; // only warn once in strict mode.
        }
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).createElement((0, $01d3f539e91688c8$export$5165eccb35aaadb5).Provider, {
        value: context
    }, children);
});


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

class $625cf83917e112ad$export$905e7fc544a71f36 {
    isDefaultPrevented() {
        return this.nativeEvent.defaultPrevented;
    }
    preventDefault() {
        this.defaultPrevented = true;
        this.nativeEvent.preventDefault();
    }
    stopPropagation() {
        this.nativeEvent.stopPropagation();
        this.isPropagationStopped = ()=>true;
    }
    isPropagationStopped() {
        return false;
    }
    persist() {}
    constructor(type, nativeEvent){
        this.nativeEvent = nativeEvent;
        this.target = nativeEvent.target;
        this.currentTarget = nativeEvent.currentTarget;
        this.relatedTarget = nativeEvent.relatedTarget;
        this.bubbles = nativeEvent.bubbles;
        this.cancelable = nativeEvent.cancelable;
        this.defaultPrevented = nativeEvent.defaultPrevented;
        this.eventPhase = nativeEvent.eventPhase;
        this.isTrusted = nativeEvent.isTrusted;
        this.timeStamp = nativeEvent.timeStamp;
        this.type = type;
    }
}
function $625cf83917e112ad$export$715c682d09d639cc(onBlur) {
    let stateRef = (0, $goTMa$react.useRef)({
        isFocused: false,
        observer: null
    });
    // Clean up MutationObserver on unmount. See below.
    // eslint-disable-next-line arrow-body-style
    (0, $goTMa$reactariautils.useLayoutEffect)(()=>{
        const state = stateRef.current;
        return ()=>{
            if (state.observer) {
                state.observer.disconnect();
                state.observer = null;
            }
        };
    }, []);
    let dispatchBlur = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
    });
    // This function is called during a React onFocus event.
    return (0, $goTMa$react.useCallback)((e)=>{
        // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142
        // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a
        // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.
        // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.
        if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {
            stateRef.current.isFocused = true;
            let target = e.target;
            let onBlurHandler = (e)=>{
                stateRef.current.isFocused = false;
                if (target.disabled) // For backward compatibility, dispatch a (fake) React synthetic event.
                dispatchBlur(new $625cf83917e112ad$export$905e7fc544a71f36("blur", e));
                // We no longer need the MutationObserver once the target is blurred.
                if (stateRef.current.observer) {
                    stateRef.current.observer.disconnect();
                    stateRef.current.observer = null;
                }
            };
            target.addEventListener("focusout", onBlurHandler, {
                once: true
            });
            stateRef.current.observer = new MutationObserver(()=>{
                if (stateRef.current.isFocused && target.disabled) {
                    stateRef.current.observer.disconnect();
                    let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
                    target.dispatchEvent(new FocusEvent("blur", {
                        relatedTarget: relatedTargetEl
                    }));
                    target.dispatchEvent(new FocusEvent("focusout", {
                        bubbles: true,
                        relatedTarget: relatedTargetEl
                    }));
                }
            });
            stateRef.current.observer.observe(target, {
                attributes: true,
                attributeFilter: [
                    "disabled"
                ]
            });
        }
    }, [
        dispatchBlur
    ]);
}


function $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6(props) {
    let { isDisabled: isDisabled , onFocus: onFocusProp , onBlur: onBlurProp , onFocusChange: onFocusChange  } = props;
    const onBlur = (0, $goTMa$react.useCallback)((e)=>{
        if (e.target === e.currentTarget) {
            if (onBlurProp) onBlurProp(e);
            if (onFocusChange) onFocusChange(false);
            return true;
        }
    }, [
        onBlurProp,
        onFocusChange
    ]);
    const onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);
    const onFocus = (0, $goTMa$react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (e.target === e.currentTarget && document.activeElement === e.target) {
            if (onFocusProp) onFocusProp(e);
            if (onFocusChange) onFocusChange(true);
            onSyntheticFocus(e);
        }
    }, [
        onFocusChange,
        onFocusProp,
        onSyntheticFocus
    ]);
    return {
        focusProps: {
            onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,
            onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : undefined
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions



let $e77252a287ef94ab$var$currentModality = null;
let $e77252a287ef94ab$var$changeHandlers = new Set();
let $e77252a287ef94ab$var$hasSetupGlobalListeners = false;
let $e77252a287ef94ab$var$hasEventBeforeFocus = false;
let $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
// Only Tab or Esc keys will make focus visible on text input elements
const $e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS = {
    Tab: true,
    Escape: true
};
function $e77252a287ef94ab$var$triggerChangeHandlers(modality, e) {
    for (let handler of $e77252a287ef94ab$var$changeHandlers)handler(modality, e);
}
/**
 * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.
 */ function $e77252a287ef94ab$var$isValidKey(e) {
    // Control and Shift keys trigger when navigating back to the tab with keyboard.
    return !(e.metaKey || !(0, $goTMa$reactariautils.isMac)() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
function $e77252a287ef94ab$var$handleKeyboardEvent(e) {
    $e77252a287ef94ab$var$hasEventBeforeFocus = true;
    if ($e77252a287ef94ab$var$isValidKey(e)) {
        $e77252a287ef94ab$var$currentModality = "keyboard";
        $e77252a287ef94ab$var$triggerChangeHandlers("keyboard", e);
    }
}
function $e77252a287ef94ab$var$handlePointerEvent(e) {
    $e77252a287ef94ab$var$currentModality = "pointer";
    if (e.type === "mousedown" || e.type === "pointerdown") {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$triggerChangeHandlers("pointer", e);
    }
}
function $e77252a287ef94ab$var$handleClickEvent(e) {
    if ((0, $goTMa$reactariautils.isVirtualClick)(e)) {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$currentModality = "virtual";
    }
}
function $e77252a287ef94ab$var$handleFocusEvent(e) {
    // Firefox fires two extra focus events when the user first clicks into an iframe:
    // first on the window, then on the document. We ignore these events so they don't
    // cause keyboard focus rings to appear.
    if (e.target === window || e.target === document) return;
    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.
    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.
    if (!$e77252a287ef94ab$var$hasEventBeforeFocus && !$e77252a287ef94ab$var$hasBlurredWindowRecently) {
        $e77252a287ef94ab$var$currentModality = "virtual";
        $e77252a287ef94ab$var$triggerChangeHandlers("virtual", e);
    }
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
}
function $e77252a287ef94ab$var$handleWindowBlur() {
    // When the window is blurred, reset state. This is necessary when tabbing out of the window,
    // for example, since a subsequent focus event won't be fired.
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = true;
}
/**
 * Setup global event listeners to control when keyboard focus style should be visible.
 */ function $e77252a287ef94ab$var$setupGlobalFocusEvents() {
    if (typeof window === "undefined" || $e77252a287ef94ab$var$hasSetupGlobalListeners) return;
    // Programmatic focus() calls shouldn't affect the current input modality.
    // However, we need to detect other cases when a focus event occurs without
    // a preceding user event (e.g. screen reader focus). Overriding the focus
    // method on HTMLElement.prototype is a bit hacky, but works.
    let focus = HTMLElement.prototype.focus;
    HTMLElement.prototype.focus = function() {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        focus.apply(this, arguments);
    };
    document.addEventListener("keydown", $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener("keyup", $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener("click", $e77252a287ef94ab$var$handleClickEvent, true);
    // Register focus events on the window so they are sure to happen
    // before React's event listeners (registered on the document).
    window.addEventListener("focus", $e77252a287ef94ab$var$handleFocusEvent, true);
    window.addEventListener("blur", $e77252a287ef94ab$var$handleWindowBlur, false);
    if (typeof PointerEvent !== "undefined") {
        document.addEventListener("pointerdown", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("pointermove", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("pointerup", $e77252a287ef94ab$var$handlePointerEvent, true);
    } else {
        document.addEventListener("mousedown", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("mousemove", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("mouseup", $e77252a287ef94ab$var$handlePointerEvent, true);
    }
    $e77252a287ef94ab$var$hasSetupGlobalListeners = true;
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e77252a287ef94ab$var$setupGlobalFocusEvents();
    else document.addEventListener("DOMContentLoaded", $e77252a287ef94ab$var$setupGlobalFocusEvents);
}
function $e77252a287ef94ab$export$b9b3dfddab17db27() {
    return $e77252a287ef94ab$var$currentModality !== "pointer";
}
function $e77252a287ef94ab$export$630ff653c5ada6a9() {
    return $e77252a287ef94ab$var$currentModality;
}
function $e77252a287ef94ab$export$8397ddfc504fdb9a(modality) {
    $e77252a287ef94ab$var$currentModality = modality;
    $e77252a287ef94ab$var$triggerChangeHandlers(modality, null);
}
function $e77252a287ef94ab$export$98e20ec92f614cfe() {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    let [modality, setModality] = (0, $goTMa$react.useState)($e77252a287ef94ab$var$currentModality);
    (0, $goTMa$react.useEffect)(()=>{
        let handler = ()=>{
            setModality($e77252a287ef94ab$var$currentModality);
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    }, []);
    return (0, $goTMa$reactariassr.useIsSSR)() ? null : modality;
}
/**
 * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that
 * focus visible style can be properly set.
 */ function $e77252a287ef94ab$var$isKeyboardFocusEvent(isTextInput, modality, e) {
    return !(isTextInput && modality === "keyboard" && e instanceof KeyboardEvent && !$e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);
}
function $e77252a287ef94ab$export$ffd9e5021c1fb2d6(props = {}) {
    let { isTextInput: isTextInput , autoFocus: autoFocus  } = props;
    let [isFocusVisibleState, setFocusVisible] = (0, $goTMa$react.useState)(autoFocus || $e77252a287ef94ab$export$b9b3dfddab17db27());
    $e77252a287ef94ab$export$ec71b4b83ac08ec3((isFocusVisible)=>{
        setFocusVisible(isFocusVisible);
    }, [
        isTextInput
    ], {
        isTextInput: isTextInput
    });
    return {
        isFocusVisible: isFocusVisibleState
    };
}
function $e77252a287ef94ab$export$ec71b4b83ac08ec3(fn, deps, opts) {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    (0, $goTMa$react.useEffect)(()=>{
        let handler = (modality, e)=>{
            if (!$e77252a287ef94ab$var$isKeyboardFocusEvent(opts === null || opts === void 0 ? void 0 : opts.isTextInput, modality, e)) return;
            fn($e77252a287ef94ab$export$b9b3dfddab17db27());
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, deps);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $d16842bbd0359d1b$export$420e68273165f4ec(props) {
    let { isDisabled: isDisabled , onBlurWithin: onBlurWithin , onFocusWithin: onFocusWithin , onFocusWithinChange: onFocusWithinChange  } = props;
    let state = (0, $goTMa$react.useRef)({
        isFocusWithin: false
    });
    let onBlur = (0, $goTMa$react.useCallback)((e)=>{
        // We don't want to trigger onBlurWithin and then immediately onFocusWithin again
        // when moving focus inside the element. Only trigger if the currentTarget doesn't
        // include the relatedTarget (where focus is moving).
        if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {
            state.current.isFocusWithin = false;
            if (onBlurWithin) onBlurWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(false);
        }
    }, [
        onBlurWithin,
        onFocusWithinChange,
        state
    ]);
    let onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);
    let onFocus = (0, $goTMa$react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (!state.current.isFocusWithin && document.activeElement === e.target) {
            if (onFocusWithin) onFocusWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(true);
            state.current.isFocusWithin = true;
            onSyntheticFocus(e);
        }
    }, [
        onFocusWithin,
        onFocusWithinChange,
        onSyntheticFocus
    ]);
    if (isDisabled) return {
        focusWithinProps: {
            onFocus: null,
            onBlur: null
        }
    };
    return {
        focusWithinProps: {
            onFocus: onFocus,
            onBlur: onBlur
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

// iOS fires onPointerEnter twice: once with pointerType="touch" and again with pointerType="mouse".
// We want to ignore these emulated events so they do not trigger hover behavior.
// See https://bugs.webkit.org/show_bug.cgi?id=214609.
let $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
let $ffbc150311c75f01$var$hoverCount = 0;
function $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents() {
    $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = true;
    // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter
    // with pointerType="mouse" immediately after onPointerUp and before onFocus. On other
    // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in
    // the distant future because a user previously touched the element.
    setTimeout(()=>{
        $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
    }, 50);
}
function $ffbc150311c75f01$var$handleGlobalPointerEvent(e) {
    if (e.pointerType === "touch") $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $ffbc150311c75f01$var$setupGlobalTouchEvents() {
    if (typeof document === "undefined") return;
    if (typeof PointerEvent !== "undefined") document.addEventListener("pointerup", $ffbc150311c75f01$var$handleGlobalPointerEvent);
    else document.addEventListener("touchend", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    $ffbc150311c75f01$var$hoverCount++;
    return ()=>{
        $ffbc150311c75f01$var$hoverCount--;
        if ($ffbc150311c75f01$var$hoverCount > 0) return;
        if (typeof PointerEvent !== "undefined") document.removeEventListener("pointerup", $ffbc150311c75f01$var$handleGlobalPointerEvent);
        else document.removeEventListener("touchend", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    };
}
function $ffbc150311c75f01$export$ae780daf29e6d456(props) {
    let { onHoverStart: onHoverStart , onHoverChange: onHoverChange , onHoverEnd: onHoverEnd , isDisabled: isDisabled  } = props;
    let [isHovered, setHovered] = (0, $goTMa$react.useState)(false);
    let state = (0, $goTMa$react.useRef)({
        isHovered: false,
        ignoreEmulatedMouseEvents: false,
        pointerType: "",
        target: null
    }).current;
    (0, $goTMa$react.useEffect)($ffbc150311c75f01$var$setupGlobalTouchEvents, []);
    let { hoverProps: hoverProps , triggerHoverEnd: triggerHoverEnd  } = (0, $goTMa$react.useMemo)(()=>{
        let triggerHoverStart = (event, pointerType)=>{
            state.pointerType = pointerType;
            if (isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target)) return;
            state.isHovered = true;
            let target = event.currentTarget;
            state.target = target;
            if (onHoverStart) onHoverStart({
                type: "hoverstart",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(true);
            setHovered(true);
        };
        let triggerHoverEnd = (event, pointerType)=>{
            state.pointerType = "";
            state.target = null;
            if (pointerType === "touch" || !state.isHovered) return;
            state.isHovered = false;
            let target = event.currentTarget;
            if (onHoverEnd) onHoverEnd({
                type: "hoverend",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(false);
            setHovered(false);
        };
        let hoverProps = {};
        if (typeof PointerEvent !== "undefined") {
            hoverProps.onPointerEnter = (e)=>{
                if ($ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents && e.pointerType === "mouse") return;
                triggerHoverStart(e, e.pointerType);
            };
            hoverProps.onPointerLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);
            };
        } else {
            hoverProps.onTouchStart = ()=>{
                state.ignoreEmulatedMouseEvents = true;
            };
            hoverProps.onMouseEnter = (e)=>{
                if (!state.ignoreEmulatedMouseEvents && !$ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, "mouse");
                state.ignoreEmulatedMouseEvents = false;
            };
            hoverProps.onMouseLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, "mouse");
            };
        }
        return {
            hoverProps: hoverProps,
            triggerHoverEnd: triggerHoverEnd
        };
    }, [
        onHoverStart,
        onHoverChange,
        onHoverEnd,
        isDisabled,
        state
    ]);
    (0, $goTMa$react.useEffect)(()=>{
        // Call the triggerHoverEnd as soon as isDisabled changes to true
        // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering
        if (isDisabled) triggerHoverEnd({
            currentTarget: state.target
        }, state.pointerType);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        isDisabled
    ]);
    return {
        hoverProps: hoverProps,
        isHovered: isHovered
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $edcfa848c42f94f4$export$872b660ac5a1ff98(props) {
    let { ref: ref , onInteractOutside: onInteractOutside , isDisabled: isDisabled , onInteractOutsideStart: onInteractOutsideStart  } = props;
    let stateRef = (0, $goTMa$react.useRef)({
        isPointerDown: false,
        ignoreEmulatedMouseEvents: false
    });
    let onPointerDown = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (onInteractOutside && $edcfa848c42f94f4$var$isValidEvent(e, ref)) {
            if (onInteractOutsideStart) onInteractOutsideStart(e);
            stateRef.current.isPointerDown = true;
        }
    });
    let triggerInteractOutside = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (onInteractOutside) onInteractOutside(e);
    });
    (0, $goTMa$react.useEffect)(()=>{
        let state = stateRef.current;
        if (isDisabled) return;
        // Use pointer events if available. Otherwise, fall back to mouse and touch events.
        if (typeof PointerEvent !== "undefined") {
            let onPointerUp = (e)=>{
                if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            // changing these to capture phase fixed combobox
            document.addEventListener("pointerdown", onPointerDown, true);
            document.addEventListener("pointerup", onPointerUp, true);
            return ()=>{
                document.removeEventListener("pointerdown", onPointerDown, true);
                document.removeEventListener("pointerup", onPointerUp, true);
            };
        } else {
            let onMouseUp = (e)=>{
                if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;
                else if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            let onTouchEnd = (e)=>{
                state.ignoreEmulatedMouseEvents = true;
                if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            document.addEventListener("mousedown", onPointerDown, true);
            document.addEventListener("mouseup", onMouseUp, true);
            document.addEventListener("touchstart", onPointerDown, true);
            document.addEventListener("touchend", onTouchEnd, true);
            return ()=>{
                document.removeEventListener("mousedown", onPointerDown, true);
                document.removeEventListener("mouseup", onMouseUp, true);
                document.removeEventListener("touchstart", onPointerDown, true);
                document.removeEventListener("touchend", onTouchEnd, true);
            };
        }
    }, [
        ref,
        isDisabled,
        onPointerDown,
        triggerInteractOutside
    ]);
}
function $edcfa848c42f94f4$var$isValidEvent(event, ref) {
    if (event.button > 0) return false;
    if (event.target) {
        // if the event target is no longer in the document, ignore
        const ownerDocument = event.target.ownerDocument;
        if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;
        // If the target is within a top layer element (e.g. toasts), ignore.
        if (event.target.closest("[data-react-aria-top-layer]")) return false;
    }
    return ref.current && !ref.current.contains(event.target);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $951fbcbbca8db6ce$export$48d1ea6320830260(handler) {
    if (!handler) return;
    let shouldStopPropagation = true;
    return (e)=>{
        let event = {
            ...e,
            preventDefault () {
                e.preventDefault();
            },
            isDefaultPrevented () {
                return e.isDefaultPrevented();
            },
            stopPropagation () {
                console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
            },
            continuePropagation () {
                shouldStopPropagation = false;
            }
        };
        handler(event);
        if (shouldStopPropagation) e.stopPropagation();
    };
}


function $892d64db2a3c53b0$export$8f71654801c2f7cd(props) {
    return {
        keyboardProps: props.isDisabled ? {} : {
            onKeyDown: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyDown),
            onKeyUp: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyUp)
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $c09386fc48fa427d$export$36da96379f79f245(props) {
    let { onMoveStart: onMoveStart , onMove: onMove , onMoveEnd: onMoveEnd  } = props;
    let state = (0, $goTMa$react.useRef)({
        didMove: false,
        lastPosition: null,
        id: null
    });
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let move = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType, deltaX, deltaY)=>{
        if (deltaX === 0 && deltaY === 0) return;
        if (!state.current.didMove) {
            state.current.didMove = true;
            onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart({
                type: "movestart",
                pointerType: pointerType,
                shiftKey: originalEvent.shiftKey,
                metaKey: originalEvent.metaKey,
                ctrlKey: originalEvent.ctrlKey,
                altKey: originalEvent.altKey
            });
        }
        onMove({
            type: "move",
            pointerType: pointerType,
            deltaX: deltaX,
            deltaY: deltaY,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let end = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)();
        if (state.current.didMove) onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd({
            type: "moveend",
            pointerType: pointerType,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let moveProps = (0, $goTMa$react.useMemo)(()=>{
        let moveProps = {};
        let start = ()=>{
            (0, $f7e14e656343df57$export$16a4697467175487)();
            state.current.didMove = false;
        };
        if (typeof PointerEvent === "undefined") {
            let onMouseMove = (e)=>{
                if (e.button === 0) {
                    move(e, "mouse", e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onMouseUp = (e)=>{
                if (e.button === 0) {
                    end(e, "mouse");
                    removeGlobalListener(window, "mousemove", onMouseMove, false);
                    removeGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            moveProps.onMouseDown = (e)=>{
                if (e.button === 0) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    addGlobalListener(window, "mousemove", onMouseMove, false);
                    addGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            let onTouchMove = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id);
                if (touch >= 0) {
                    let { pageX: pageX , pageY: pageY  } = e.changedTouches[touch];
                    move(e, "touch", pageX - state.current.lastPosition.pageX, pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: pageX,
                        pageY: pageY
                    };
                }
            };
            let onTouchEnd = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id);
                if (touch >= 0) {
                    end(e, "touch");
                    state.current.id = null;
                    removeGlobalListener(window, "touchmove", onTouchMove);
                    removeGlobalListener(window, "touchend", onTouchEnd);
                    removeGlobalListener(window, "touchcancel", onTouchEnd);
                }
            };
            moveProps.onTouchStart = (e)=>{
                if (e.changedTouches.length === 0 || state.current.id != null) return;
                let { pageX: pageX , pageY: pageY , identifier: identifier  } = e.changedTouches[0];
                start();
                e.stopPropagation();
                e.preventDefault();
                state.current.lastPosition = {
                    pageX: pageX,
                    pageY: pageY
                };
                state.current.id = identifier;
                addGlobalListener(window, "touchmove", onTouchMove, false);
                addGlobalListener(window, "touchend", onTouchEnd, false);
                addGlobalListener(window, "touchcancel", onTouchEnd, false);
            };
        } else {
            let onPointerMove = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    // Problems with PointerEvent#movementX/movementY:
                    // 1. it is always 0 on macOS Safari.
                    // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS
                    move(e, pointerType, e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    end(e, pointerType);
                    state.current.id = null;
                    removeGlobalListener(window, "pointermove", onPointerMove, false);
                    removeGlobalListener(window, "pointerup", onPointerUp, false);
                    removeGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
            moveProps.onPointerDown = (e)=>{
                if (e.button === 0 && state.current.id == null) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    state.current.id = e.pointerId;
                    addGlobalListener(window, "pointermove", onPointerMove, false);
                    addGlobalListener(window, "pointerup", onPointerUp, false);
                    addGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
        }
        let triggerKeyboardMove = (e, deltaX, deltaY)=>{
            start();
            move(e, "keyboard", deltaX, deltaY);
            end(e, "keyboard");
        };
        moveProps.onKeyDown = (e)=>{
            switch(e.key){
                case "Left":
                case "ArrowLeft":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, -1, 0);
                    break;
                case "Right":
                case "ArrowRight":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 1, 0);
                    break;
                case "Up":
                case "ArrowUp":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, -1);
                    break;
                case "Down":
                case "ArrowDown":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, 1);
                    break;
            }
        };
        return moveProps;
    }, [
        state,
        addGlobalListener,
        removeGlobalListener,
        move,
        end
    ]);
    return {
        moveProps: moveProps
    };
}



/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $a3dbce0aed7087e2$export$2123ff2b87c81ca(props, ref) {
    let { onScroll: onScroll , isDisabled: isDisabled  } = props;
    let onScrollHandler = (0, $goTMa$react.useCallback)((e)=>{
        // If the ctrlKey is pressed, this is a zoom event, do nothing.
        if (e.ctrlKey) return;
        // stop scrolling the page
        e.preventDefault();
        e.stopPropagation();
        if (onScroll) onScroll({
            deltaX: e.deltaX,
            deltaY: e.deltaY
        });
    }, [
        onScroll
    ]);
    (0, $goTMa$reactariautils.useEvent)(ref, "wheel", isDisabled ? null : onScrollHandler);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD = 500;
function $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9(props) {
    let { isDisabled: isDisabled , onLongPressStart: onLongPressStart , onLongPressEnd: onLongPressEnd , onLongPress: onLongPress , threshold: threshold = $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD , accessibilityDescription: accessibilityDescription  } = props;
    const timeRef = (0, $goTMa$react.useRef)(null);
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let { pressProps: pressProps  } = (0, $0294ea432cd92340$export$45712eceda6fad21)({
        isDisabled: isDisabled,
        onPressStart (e) {
            if (e.pointerType === "mouse" || e.pointerType === "touch") {
                if (onLongPressStart) onLongPressStart({
                    ...e,
                    type: "longpressstart"
                });
                timeRef.current = setTimeout(()=>{
                    // Prevent other usePress handlers from also handling this event.
                    e.target.dispatchEvent(new PointerEvent("pointercancel", {
                        bubbles: true
                    }));
                    if (onLongPress) onLongPress({
                        ...e,
                        type: "longpress"
                    });
                    timeRef.current = null;
                }, threshold);
                // Prevent context menu, which may be opened on long press on touch devices
                if (e.pointerType === "touch") {
                    let onContextMenu = (e)=>{
                        e.preventDefault();
                    };
                    addGlobalListener(e.target, "contextmenu", onContextMenu, {
                        once: true
                    });
                    addGlobalListener(window, "pointerup", ()=>{
                        // If no contextmenu event is fired quickly after pointerup, remove the handler
                        // so future context menu events outside a long press are not prevented.
                        setTimeout(()=>{
                            removeGlobalListener(e.target, "contextmenu", onContextMenu);
                        }, 30);
                    }, {
                        once: true
                    });
                }
            }
        },
        onPressEnd (e) {
            if (timeRef.current) clearTimeout(timeRef.current);
            if (onLongPressEnd && (e.pointerType === "mouse" || e.pointerType === "touch")) onLongPressEnd({
                ...e,
                type: "longpressend"
            });
        }
    });
    let descriptionProps = (0, $goTMa$reactariautils.useDescription)(onLongPress && !isDisabled ? accessibilityDescription : null);
    return {
        longPressProps: (0, $goTMa$reactariautils.mergeProps)(pressProps, descriptionProps)
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 88381:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $4hxXn$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "SSRProvider", () => $29383e587d62412a$export$9f8ac96af4b1b2ae);
$parcel$export(module.exports, "useSSRSafeId", () => $29383e587d62412a$export$619500959fc48b26);
$parcel$export(module.exports, "useIsSSR", () => $29383e587d62412a$export$535bd6ca7f90a273);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We must avoid a circular dependency with @react-aria/utils, and this useLayoutEffect is
// guarded by a check that it only runs on the client side.
// eslint-disable-next-line rulesdir/useLayoutEffectRule

// Default context value to use in case there is no SSRProvider. This is fine for
// client-only apps. In order to support multiple copies of React Aria potentially
// being on the page at once, the prefix is set to a random number. SSRProvider
// will reset this to zero for consistency between server and client, so in the
// SSR case multiple copies of React Aria is not supported.
const $29383e587d62412a$var$defaultContext = {
    prefix: String(Math.round(Math.random() * 10000000000)),
    current: 0,
    isSSR: false
};
const $29383e587d62412a$var$SSRContext = /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createContext($29383e587d62412a$var$defaultContext);
// This is only used in React < 18.
function $29383e587d62412a$var$LegacySSRProvider(props) {
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let counter = $29383e587d62412a$var$useCounter(cur === $29383e587d62412a$var$defaultContext);
    let [isSSR, setIsSSR] = (0, $4hxXn$react.useState)(true);
    let value = (0, $4hxXn$react.useMemo)(()=>({
            // If this is the first SSRProvider, start with an empty string prefix, otherwise
            // append and increment the counter.
            prefix: cur === $29383e587d62412a$var$defaultContext ? "" : `${cur.prefix}-${counter}`,
            current: 0,
            isSSR: isSSR
        }), [
        cur,
        counter,
        isSSR
    ]);
    // If on the client, and the component was initially server rendered,
    // then schedule a layout effect to update the component after hydration.
    if (typeof window !== "undefined") // This if statement technically breaks the rules of hooks, but is safe
    // because the condition never changes after mounting.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, $4hxXn$react.useLayoutEffect)(()=>{
        setIsSSR(false);
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$SSRContext.Provider, {
        value: value
    }, props.children);
}
let $29383e587d62412a$var$warnedAboutSSRProvider = false;
function $29383e587d62412a$export$9f8ac96af4b1b2ae(props) {
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function") {
        if (!$29383e587d62412a$var$warnedAboutSSRProvider) {
            console.warn("In React 18, SSRProvider is not necessary and is a noop. You can remove it from your app.");
            $29383e587d62412a$var$warnedAboutSSRProvider = true;
        }
        return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement((0, ($parcel$interopDefault($4hxXn$react))).Fragment, null, props.children);
    }
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$LegacySSRProvider, props);
}
let $29383e587d62412a$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
let $29383e587d62412a$var$componentIds = new WeakMap();
function $29383e587d62412a$var$useCounter(isDisabled = false) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let ref = (0, $4hxXn$react.useRef)(null);
    // eslint-disable-next-line rulesdir/pure-render
    if (ref.current === null && !isDisabled) {
        var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner;
        // In strict mode, React renders components twice, and the ref will be reset to null on the second render.
        // This means our id counter will be incremented twice instead of once. This is a problem because on the
        // server, components are only rendered once and so ids generated on the server won't match the client.
        // In React 18, useId was introduced to solve this, but it is not available in older versions. So to solve this
        // we need to use some React internals to access the underlying Fiber instance, which is stable between renders.
        // This is exposed as ReactCurrentOwner in development, which is all we need since StrictMode only runs in development.
        // To ensure that we only increment the global counter once, we store the starting id for this component in
        // a weak map associated with the Fiber. On the second render, we reset the global counter to this value.
        // Since React runs the second render immediately after the first, this is safe.
        // @ts-ignore
        let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, ($parcel$interopDefault($4hxXn$react))).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;
        if (currentOwner) {
            let prevComponentValue = $29383e587d62412a$var$componentIds.get(currentOwner);
            if (prevComponentValue == null) // On the first render, and first call to useId, store the id and state in our weak map.
            $29383e587d62412a$var$componentIds.set(currentOwner, {
                id: ctx.current,
                state: currentOwner.memoizedState
            });
            else if (currentOwner.memoizedState !== prevComponentValue.state) {
                // On the second render, the memoizedState gets reset by React.
                // Reset the counter, and remove from the weak map so we don't
                // do this for subsequent useId calls.
                ctx.current = prevComponentValue.id;
                $29383e587d62412a$var$componentIds.delete(currentOwner);
            }
        }
        // eslint-disable-next-line rulesdir/pure-render
        ref.current = ++ctx.current;
    }
    // eslint-disable-next-line rulesdir/pure-render
    return ref.current;
}
function $29383e587d62412a$var$useLegacySSRSafeId(defaultId) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    // If we are rendering in a non-DOM environment, and there's no SSRProvider,
    // provide a warning to hint to the developer to add one.
    if (ctx === $29383e587d62412a$var$defaultContext && !$29383e587d62412a$var$canUseDOM) console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
    let counter = $29383e587d62412a$var$useCounter(!!defaultId);
    return defaultId || `react-aria${ctx.prefix}-${counter}`;
}
function $29383e587d62412a$var$useModernSSRSafeId(defaultId) {
    // @ts-ignore
    let id = (0, ($parcel$interopDefault($4hxXn$react))).useId();
    let [didSSR] = (0, $4hxXn$react.useState)($29383e587d62412a$export$535bd6ca7f90a273());
    let prefix = didSSR ? "react-aria" : `react-aria${$29383e587d62412a$var$defaultContext.prefix}`;
    return defaultId || `${prefix}-${id}`;
}
const $29383e587d62412a$export$619500959fc48b26 = typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function" ? $29383e587d62412a$var$useModernSSRSafeId : $29383e587d62412a$var$useLegacySSRSafeId;
function $29383e587d62412a$var$getSnapshot() {
    return false;
}
function $29383e587d62412a$var$getServerSnapshot() {
    return true;
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function $29383e587d62412a$var$subscribe(onStoreChange) {
    // noop
    return ()=>{};
}
function $29383e587d62412a$export$535bd6ca7f90a273() {
    // In React 18, we can use useSyncExternalStore to detect if we're server rendering or hydrating.
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"] === "function") return (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"]($29383e587d62412a$var$subscribe, $29383e587d62412a$var$getSnapshot, $29383e587d62412a$var$getServerSnapshot);
    // eslint-disable-next-line react-hooks/rules-of-hooks
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    return cur.isSSR;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 73233:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $1Yh1N$reactstatelyutils = __webpack_require__(12259);
var $1Yh1N$react = __webpack_require__(18038);
var $1Yh1N$reactariassr = __webpack_require__(88381);
var $1Yh1N$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useId", () => $8c61827343eed941$export$f680877a34711e37);
$parcel$export(module.exports, "mergeIds", () => $8c61827343eed941$export$cd8c9cb68f842629);
$parcel$export(module.exports, "useSlotId", () => $8c61827343eed941$export$b4cc09c592e8fdb8);
$parcel$export(module.exports, "chain", () => $1e2191638e54f613$export$e08e3b67e392101e);
$parcel$export(module.exports, "mergeProps", () => $f847cd1382ea7cd4$export$9d1611c77c2fe928);
$parcel$export(module.exports, "mergeRefs", () => $f05dc24eafaeb7e2$export$c9058316764c140e);
$parcel$export(module.exports, "filterDOMProps", () => $8d15d0e1797d4238$export$457c3d6518dd4c6f);
$parcel$export(module.exports, "focusWithoutScrolling", () => $1117b6c0d4c4c164$export$de79e2c695e052f3);
$parcel$export(module.exports, "getOffset", () => $16ec41ef3e36c19c$export$622cea445a1c5b7d);
$parcel$export(module.exports, "runAfterTransition", () => $e8117ebcab55be6a$export$24490316f764c430);
$parcel$export(module.exports, "useDrag1D", () => $28ed3fb20343b78b$export$7bbed75feba39706);
$parcel$export(module.exports, "useGlobalListeners", () => $4571ff54ac709100$export$4eaf04e54aa8eed6);
$parcel$export(module.exports, "useLabels", () => $6ec78bde395c477d$export$d6875122194c7b44);
$parcel$export(module.exports, "useObjectRef", () => $475b35fe72ba49b3$export$4338b53315abf666);
$parcel$export(module.exports, "useUpdateEffect", () => $29293a6f5c75b37e$export$496315a1608d9602);
$parcel$export(module.exports, "useLayoutEffect", () => $78605a5d7424e31b$export$e5c5a5f917a5871c);
$parcel$export(module.exports, "useResizeObserver", () => $37733e1652f47193$export$683480f191c0e3ea);
$parcel$export(module.exports, "useSyncRef", () => $6fc733991a9f977c$export$4debdb1a3f0fa79e);
$parcel$export(module.exports, "getScrollParent", () => $d796e7157ac96470$export$cfa2225e87938781);
$parcel$export(module.exports, "isScrollable", () => $d796e7157ac96470$export$2bb74740c4e19def);
$parcel$export(module.exports, "useViewportSize", () => $8b24bab62f5c65ad$export$d699905dd57c73ca);
$parcel$export(module.exports, "useDescription", () => $34da4502ea8120db$export$f8aeda7b10753fa1);
$parcel$export(module.exports, "isMac", () => $9e20cff0af27e8cc$export$9ac100e40613ea10);
$parcel$export(module.exports, "isIPhone", () => $9e20cff0af27e8cc$export$186c6964ca17d99);
$parcel$export(module.exports, "isIPad", () => $9e20cff0af27e8cc$export$7bef049ce92e4224);
$parcel$export(module.exports, "isIOS", () => $9e20cff0af27e8cc$export$fedb369cb70207f1);
$parcel$export(module.exports, "isAppleDevice", () => $9e20cff0af27e8cc$export$e1865c3bedcd822b);
$parcel$export(module.exports, "isWebKit", () => $9e20cff0af27e8cc$export$78551043582a6a98);
$parcel$export(module.exports, "isChrome", () => $9e20cff0af27e8cc$export$6446a186d09e379e);
$parcel$export(module.exports, "isAndroid", () => $9e20cff0af27e8cc$export$a11b0059900ceec8);
$parcel$export(module.exports, "useEvent", () => $2a8c0bb1629926c8$export$90fc3a17d93f704c);
$parcel$export(module.exports, "useValueEffect", () => $19a2307bfabafaf1$export$14d238f342723f25);
$parcel$export(module.exports, "scrollIntoView", () => $449412113267a1fe$export$53a0910f038337bd);
$parcel$export(module.exports, "scrollIntoViewport", () => $449412113267a1fe$export$c826860796309d1b);
$parcel$export(module.exports, "clamp", () => $1Yh1N$reactstatelyutils.clamp);
$parcel$export(module.exports, "snapValueToStep", () => $1Yh1N$reactstatelyutils.snapValueToStep);
$parcel$export(module.exports, "isVirtualClick", () => $577e795361f19be9$export$60278871457622de);
$parcel$export(module.exports, "isVirtualPointerEvent", () => $577e795361f19be9$export$29bf1b5f2c56cf63);
$parcel$export(module.exports, "useEffectEvent", () => $1254e5bb94ac8761$export$7f54fc3180508a52);
$parcel$export(module.exports, "useDeepMemo", () => $20e6e72fbf5dc81e$export$722debc0e56fea39);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $78605a5d7424e31b$export$e5c5a5f917a5871c = typeof window !== "undefined" ? (0, ($parcel$interopDefault($1Yh1N$react))).useLayoutEffect : ()=>{};



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $19a2307bfabafaf1$export$14d238f342723f25(defaultValue) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultValue);
    let valueRef = (0, $1Yh1N$react.useRef)(value);
    let effect = (0, $1Yh1N$react.useRef)(null);
    // Must be stable so that `queue` is stable.
    let nextIter = (0, $1Yh1N$react.useCallback)(()=>{
        // Run the generator to the next yield.
        let newValue = effect.current.next();
        while(!newValue.done && valueRef.current === newValue.value)// If the value is the same as the current value,
        // then continue to the next yield. Otherwise,
        // set the value in state and wait for the next layout effect.
        newValue = effect.current.next();
        // If the generator is done, reset the effect.
        if (newValue.done) {
            effect.current = null;
            return;
        }
        // Always update valueRef when setting the state.
        // This is needed because the function is not regenerated with the new state value since
        // they must be stable across renders. Instead, it gets carried in the ref, but the setState
        // is also needed in order to cause a rerender.
        setValue(newValue.value);
        valueRef.current = newValue.value;
    // this list of dependencies is stable, setState and refs never change after first render.
    }, [
        setValue,
        valueRef,
        effect
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        // If there is an effect currently running, continue to the next yield.
        if (effect.current) nextIter();
    });
    // queue must be a stable function, much like setState.
    let queue = (0, $1Yh1N$react.useCallback)((fn)=>{
        effect.current = fn(valueRef.current);
        nextIter();
    // this list of dependencies is stable, setState and refs never change after first render.
    // in addition, nextIter is stable as outlined above
    }, [
        nextIter,
        effect,
        valueRef
    ]);
    return [
        value,
        queue
    ];
}


let $8c61827343eed941$var$idsUpdaterMap = new Map();
function $8c61827343eed941$export$f680877a34711e37(defaultId) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultId);
    let nextId = (0, $1Yh1N$react.useRef)(null);
    let res = (0, $1Yh1N$reactariassr.useSSRSafeId)(value);
    let updateValue = (0, $1Yh1N$react.useCallback)((val)=>{
        nextId.current = val;
    }, []);
    $8c61827343eed941$var$idsUpdaterMap.set(res, updateValue);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        let r = res;
        return ()=>{
            $8c61827343eed941$var$idsUpdaterMap.delete(r);
        };
    }, [
        res
    ]);
    // This cannot cause an infinite loop because the ref is updated first.
    // eslint-disable-next-line
    (0, $1Yh1N$react.useEffect)(()=>{
        let newId = nextId.current;
        if (newId) {
            nextId.current = null;
            setValue(newId);
        }
    });
    return res;
}
function $8c61827343eed941$export$cd8c9cb68f842629(idA, idB) {
    if (idA === idB) return idA;
    let setIdA = $8c61827343eed941$var$idsUpdaterMap.get(idA);
    if (setIdA) {
        setIdA(idB);
        return idB;
    }
    let setIdB = $8c61827343eed941$var$idsUpdaterMap.get(idB);
    if (setIdB) {
        setIdB(idA);
        return idA;
    }
    return idB;
}
function $8c61827343eed941$export$b4cc09c592e8fdb8(depArray = []) {
    let id = $8c61827343eed941$export$f680877a34711e37();
    let [resolvedId, setResolvedId] = (0, $19a2307bfabafaf1$export$14d238f342723f25)(id);
    let updateId = (0, $1Yh1N$react.useCallback)(()=>{
        setResolvedId(function*() {
            yield id;
            yield document.getElementById(id) ? id : undefined;
        });
    }, [
        id,
        setResolvedId
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(updateId, [
        id,
        updateId,
        ...depArray
    ]);
    return resolvedId;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /**
 * Calls all functions in the order they were chained with the same arguments.
 */ function $1e2191638e54f613$export$e08e3b67e392101e(...callbacks) {
    return (...args)=>{
        for (let callback of callbacks)if (typeof callback === "function") callback(...args);
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $f847cd1382ea7cd4$export$9d1611c77c2fe928(...args) {
    // Start with a base clone of the first argument. This is a lot faster than starting
    // with an empty object and adding properties as we go.
    let result = {
        ...args[0]
    };
    for(let i = 1; i < args.length; i++){
        let props = args[i];
        for(let key in props){
            let a = result[key];
            let b = props[key];
            // Chain events
            if (typeof a === "function" && typeof b === "function" && // This is a lot faster than a regex.
            key[0] === "o" && key[1] === "n" && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = (0, $1e2191638e54f613$export$e08e3b67e392101e)(a, b);
            else if ((key === "className" || key === "UNSAFE_className") && typeof a === "string" && typeof b === "string") result[key] = (0, ($parcel$interopDefault($1Yh1N$clsx)))(a, b);
            else if (key === "id" && a && b) result.id = (0, $8c61827343eed941$export$cd8c9cb68f842629)(a, b);
            else result[key] = b !== undefined ? b : a;
        }
    }
    return result;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $f05dc24eafaeb7e2$export$c9058316764c140e(...refs) {
    if (refs.length === 1) return refs[0];
    return (value)=>{
        for (let ref of refs){
            if (typeof ref === "function") ref(value);
            else if (ref != null) ref.current = value;
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ const $8d15d0e1797d4238$var$DOMPropNames = new Set([
    "id"
]);
const $8d15d0e1797d4238$var$labelablePropNames = new Set([
    "aria-label",
    "aria-labelledby",
    "aria-describedby",
    "aria-details"
]);
const $8d15d0e1797d4238$var$propRe = /^(data-.*)$/;
function $8d15d0e1797d4238$export$457c3d6518dd4c6f(props, opts = {}) {
    let { labelable: labelable , propNames: propNames  } = opts;
    let filteredProps = {};
    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($8d15d0e1797d4238$var$DOMPropNames.has(prop) || labelable && $8d15d0e1797d4238$var$labelablePropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $8d15d0e1797d4238$var$propRe.test(prop))) filteredProps[prop] = props[prop];
    return filteredProps;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $1117b6c0d4c4c164$export$de79e2c695e052f3(element) {
    if ($1117b6c0d4c4c164$var$supportsPreventScroll()) element.focus({
        preventScroll: true
    });
    else {
        let scrollableElements = $1117b6c0d4c4c164$var$getScrollableElements(element);
        element.focus();
        $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements);
    }
}
let $1117b6c0d4c4c164$var$supportsPreventScrollCached = null;
function $1117b6c0d4c4c164$var$supportsPreventScroll() {
    if ($1117b6c0d4c4c164$var$supportsPreventScrollCached == null) {
        $1117b6c0d4c4c164$var$supportsPreventScrollCached = false;
        try {
            var focusElem = document.createElement("div");
            focusElem.focus({
                get preventScroll () {
                    $1117b6c0d4c4c164$var$supportsPreventScrollCached = true;
                    return true;
                }
            });
        } catch (e) {
        // Ignore
        }
    }
    return $1117b6c0d4c4c164$var$supportsPreventScrollCached;
}
function $1117b6c0d4c4c164$var$getScrollableElements(element) {
    var parent = element.parentNode;
    var scrollableElements = [];
    var rootScrollingElement = document.scrollingElement || document.documentElement;
    while(parent instanceof HTMLElement && parent !== rootScrollingElement){
        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({
            element: parent,
            scrollTop: parent.scrollTop,
            scrollLeft: parent.scrollLeft
        });
        parent = parent.parentNode;
    }
    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
        element: rootScrollingElement,
        scrollTop: rootScrollingElement.scrollTop,
        scrollLeft: rootScrollingElement.scrollLeft
    });
    return scrollableElements;
}
function $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements) {
    for (let { element: element , scrollTop: scrollTop , scrollLeft: scrollLeft  } of scrollableElements){
        element.scrollTop = scrollTop;
        element.scrollLeft = scrollLeft;
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $16ec41ef3e36c19c$export$622cea445a1c5b7d(element, reverse, orientation = "horizontal") {
    let rect = element.getBoundingClientRect();
    if (reverse) return orientation === "horizontal" ? rect.right : rect.bottom;
    return orientation === "horizontal" ? rect.left : rect.top;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We store a global list of elements that are currently transitioning,
// mapped to a set of CSS properties that are transitioning for that element.
// This is necessary rather than a simple count of transitions because of browser
// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather
// than one or the other. So we need to track what's actually transitioning so that
// we can ignore these duplicate events.
let $e8117ebcab55be6a$var$transitionsByElement = new Map();
// A list of callbacks to call once there are no transitioning elements.
let $e8117ebcab55be6a$var$transitionCallbacks = new Set();
function $e8117ebcab55be6a$var$setupGlobalEvents() {
    if (typeof window === "undefined") return;
    let onTransitionStart = (e)=>{
        // Add the transitioning property to the list for this element.
        let transitions = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!transitions) {
            transitions = new Set();
            $e8117ebcab55be6a$var$transitionsByElement.set(e.target, transitions);
            // The transitioncancel event must be registered on the element itself, rather than as a global
            // event. This enables us to handle when the node is deleted from the document while it is transitioning.
            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.
            e.target.addEventListener("transitioncancel", onTransitionEnd);
        }
        transitions.add(e.propertyName);
    };
    let onTransitionEnd = (e)=>{
        // Remove property from list of transitioning properties.
        let properties = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!properties) return;
        properties.delete(e.propertyName);
        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.
        if (properties.size === 0) {
            e.target.removeEventListener("transitioncancel", onTransitionEnd);
            $e8117ebcab55be6a$var$transitionsByElement.delete(e.target);
        }
        // If no transitioning elements, call all of the queued callbacks.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) {
            for (let cb of $e8117ebcab55be6a$var$transitionCallbacks)cb();
            $e8117ebcab55be6a$var$transitionCallbacks.clear();
        }
    };
    document.body.addEventListener("transitionrun", onTransitionStart);
    document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e8117ebcab55be6a$var$setupGlobalEvents();
    else document.addEventListener("DOMContentLoaded", $e8117ebcab55be6a$var$setupGlobalEvents);
}
function $e8117ebcab55be6a$export$24490316f764c430(fn) {
    // Wait one frame to see if an animation starts, e.g. a transition on mount.
    requestAnimationFrame(()=>{
        // If no transitions are running, call the function immediately.
        // Otherwise, add it to a list of callbacks to run at the end of the animation.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) fn();
        else $e8117ebcab55be6a$var$transitionCallbacks.add(fn);
    });
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 

// Keep track of elements that we are currently handling dragging for via useDrag1D.
// If there's an ancestor and a descendant both using useDrag1D(), and the user starts
// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.
const $28ed3fb20343b78b$var$draggingElements = [];
function $28ed3fb20343b78b$export$7bbed75feba39706(props) {
    console.warn("useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html");
    let { containerRef: containerRef , reverse: reverse , orientation: orientation , onHover: onHover , onDrag: onDrag , onPositionChange: onPositionChange , onIncrement: onIncrement , onDecrement: onDecrement , onIncrementToMax: onIncrementToMax , onDecrementToMin: onDecrementToMin , onCollapseToggle: onCollapseToggle  } = props;
    let getPosition = (e)=>orientation === "horizontal" ? e.clientX : e.clientY;
    let getNextOffset = (e)=>{
        let containerOffset = (0, $16ec41ef3e36c19c$export$622cea445a1c5b7d)(containerRef.current, reverse, orientation);
        let mouseOffset = getPosition(e);
        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;
        return nextOffset;
    };
    let dragging = (0, $1Yh1N$react.useRef)(false);
    let prevPosition = (0, $1Yh1N$react.useRef)(0);
    // Keep track of the current handlers in a ref so that the events can access them.
    let handlers = (0, $1Yh1N$react.useRef)({
        onPositionChange: onPositionChange,
        onDrag: onDrag
    });
    handlers.current.onDrag = onDrag;
    handlers.current.onPositionChange = onPositionChange;
    let onMouseDragged = (e)=>{
        e.preventDefault();
        let nextOffset = getNextOffset(e);
        if (!dragging.current) {
            dragging.current = true;
            if (handlers.current.onDrag) handlers.current.onDrag(true);
            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        }
        if (prevPosition.current === nextOffset) return;
        prevPosition.current = nextOffset;
        if (onPositionChange) onPositionChange(nextOffset);
    };
    let onMouseUp = (e)=>{
        const target = e.target;
        dragging.current = false;
        let nextOffset = getNextOffset(e);
        if (handlers.current.onDrag) handlers.current.onDrag(false);
        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        $28ed3fb20343b78b$var$draggingElements.splice($28ed3fb20343b78b$var$draggingElements.indexOf(target), 1);
        window.removeEventListener("mouseup", onMouseUp, false);
        window.removeEventListener("mousemove", onMouseDragged, false);
    };
    let onMouseDown = (e)=>{
        const target = e.currentTarget;
        // If we're already handling dragging on a descendant with useDrag1D, then
        // we don't want to handle the drag motion on this target as well.
        if ($28ed3fb20343b78b$var$draggingElements.some((elt)=>target.contains(elt))) return;
        $28ed3fb20343b78b$var$draggingElements.push(target);
        window.addEventListener("mousemove", onMouseDragged, false);
        window.addEventListener("mouseup", onMouseUp, false);
    };
    let onMouseEnter = ()=>{
        if (onHover) onHover(true);
    };
    let onMouseOut = ()=>{
        if (onHover) onHover(false);
    };
    let onKeyDown = (e)=>{
        switch(e.key){
            case "Left":
            case "ArrowLeft":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Up":
            case "ArrowUp":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Right":
            case "ArrowRight":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Down":
            case "ArrowDown":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Home":
                e.preventDefault();
                if (onDecrementToMin) onDecrementToMin();
                break;
            case "End":
                e.preventDefault();
                if (onIncrementToMax) onIncrementToMax();
                break;
            case "Enter":
                e.preventDefault();
                if (onCollapseToggle) onCollapseToggle();
                break;
        }
    };
    return {
        onMouseDown: onMouseDown,
        onMouseEnter: onMouseEnter,
        onMouseOut: onMouseOut,
        onKeyDown: onKeyDown
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $4571ff54ac709100$export$4eaf04e54aa8eed6() {
    let globalListeners = (0, $1Yh1N$react.useRef)(new Map());
    let addGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        // Make sure we remove the listener after it is called with the `once` option.
        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{
            globalListeners.current.delete(listener);
            listener(...args);
        } : listener;
        globalListeners.current.set(listener, {
            type: type,
            eventTarget: eventTarget,
            fn: fn,
            options: options
        });
        eventTarget.addEventListener(type, listener, options);
    }, []);
    let removeGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        var _globalListeners_current_get;
        let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
        eventTarget.removeEventListener(type, fn, options);
        globalListeners.current.delete(listener);
    }, []);
    let removeAllGlobalListeners = (0, $1Yh1N$react.useCallback)(()=>{
        globalListeners.current.forEach((value, key)=>{
            removeGlobalListener(value.eventTarget, value.type, key, value.options);
        });
    }, [
        removeGlobalListener
    ]);
    // eslint-disable-next-line arrow-body-style
    (0, $1Yh1N$react.useEffect)(()=>{
        return removeAllGlobalListeners;
    }, [
        removeAllGlobalListeners
    ]);
    return {
        addGlobalListener: addGlobalListener,
        removeGlobalListener: removeGlobalListener,
        removeAllGlobalListeners: removeAllGlobalListeners
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6ec78bde395c477d$export$d6875122194c7b44(props, defaultLabel) {
    let { id: id , "aria-label": label , "aria-labelledby": labelledBy  } = props;
    // If there is both an aria-label and aria-labelledby,
    // combine them by pointing to the element itself.
    id = (0, $8c61827343eed941$export$f680877a34711e37)(id);
    if (labelledBy && label) {
        let ids = new Set([
            id,
            ...labelledBy.trim().split(/\s+/)
        ]);
        labelledBy = [
            ...ids
        ].join(" ");
    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\s+/).join(" ");
    // If no labels are provided, use the default
    if (!label && !labelledBy && defaultLabel) label = defaultLabel;
    return {
        id: id,
        "aria-label": label,
        "aria-labelledby": labelledBy
    };
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $475b35fe72ba49b3$export$4338b53315abf666(forwardedRef) {
    const objRef = (0, $1Yh1N$react.useRef)();
    return (0, $1Yh1N$react.useMemo)(()=>({
            get current () {
                return objRef.current;
            },
            set current (value){
                objRef.current = value;
                if (typeof forwardedRef === "function") forwardedRef(value);
                else if (forwardedRef) forwardedRef.current = value;
            }
        }), [
        forwardedRef
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $29293a6f5c75b37e$export$496315a1608d9602(effect, dependencies) {
    const isInitialMount = (0, $1Yh1N$react.useRef)(true);
    const lastDeps = (0, $1Yh1N$react.useRef)(null);
    (0, $1Yh1N$react.useEffect)(()=>{
        isInitialMount.current = true;
        return ()=>{
            isInitialMount.current = false;
        };
    }, []);
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isInitialMount.current) isInitialMount.current = false;
        else if (!lastDeps.current || dependencies.some((dep, i)=>!Object.is(dep, lastDeps[i]))) effect();
        lastDeps.current = dependencies;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencies);
}




function $37733e1652f47193$var$hasResizeObserver() {
    return typeof window.ResizeObserver !== "undefined";
}
function $37733e1652f47193$export$683480f191c0e3ea(options) {
    const { ref: ref , onResize: onResize  } = options;
    (0, $1Yh1N$react.useEffect)(()=>{
        let element = ref === null || ref === void 0 ? void 0 : ref.current;
        if (!element) return;
        if (!$37733e1652f47193$var$hasResizeObserver()) {
            window.addEventListener("resize", onResize, false);
            return ()=>{
                window.removeEventListener("resize", onResize, false);
            };
        } else {
            const resizeObserverInstance = new window.ResizeObserver((entries)=>{
                if (!entries.length) return;
                onResize();
            });
            resizeObserverInstance.observe(element);
            return ()=>{
                if (element) resizeObserverInstance.unobserve(element);
            };
        }
    }, [
        onResize,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6fc733991a9f977c$export$4debdb1a3f0fa79e(context, ref) {
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (context && context.ref && ref) {
            context.ref.current = ref.current;
            return ()=>{
                context.ref.current = null;
            };
        }
    }, [
        context,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d796e7157ac96470$export$cfa2225e87938781(node) {
    if ($d796e7157ac96470$export$2bb74740c4e19def(node)) node = node.parentElement;
    while(node && !$d796e7157ac96470$export$2bb74740c4e19def(node))node = node.parentElement;
    return node || document.scrollingElement || document.documentElement;
}
function $d796e7157ac96470$export$2bb74740c4e19def(node) {
    let style = window.getComputedStyle(node);
    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// @ts-ignore
let $8b24bab62f5c65ad$var$visualViewport = typeof window !== "undefined" && window.visualViewport;
function $8b24bab62f5c65ad$export$d699905dd57c73ca() {
    let [size, setSize] = (0, $1Yh1N$react.useState)(()=>$8b24bab62f5c65ad$var$getViewportSize());
    (0, $1Yh1N$react.useEffect)(()=>{
        // Use visualViewport api to track available height even on iOS virtual keyboard opening
        let onResize = ()=>{
            setSize((size)=>{
                let newSize = $8b24bab62f5c65ad$var$getViewportSize();
                if (newSize.width === size.width && newSize.height === size.height) return size;
                return newSize;
            });
        };
        if (!$8b24bab62f5c65ad$var$visualViewport) window.addEventListener("resize", onResize);
        else $8b24bab62f5c65ad$var$visualViewport.addEventListener("resize", onResize);
        return ()=>{
            if (!$8b24bab62f5c65ad$var$visualViewport) window.removeEventListener("resize", onResize);
            else $8b24bab62f5c65ad$var$visualViewport.removeEventListener("resize", onResize);
        };
    }, []);
    return size;
}
function $8b24bab62f5c65ad$var$getViewportSize() {
    return {
        width: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.width) || window.innerWidth,
        height: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.height) || window.innerHeight
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

let $34da4502ea8120db$var$descriptionId = 0;
const $34da4502ea8120db$var$descriptionNodes = new Map();
function $34da4502ea8120db$export$f8aeda7b10753fa1(description) {
    let [id, setId] = (0, $1Yh1N$react.useState)(undefined);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (!description) return;
        let desc = $34da4502ea8120db$var$descriptionNodes.get(description);
        if (!desc) {
            let id = `react-aria-description-${$34da4502ea8120db$var$descriptionId++}`;
            setId(id);
            let node = document.createElement("div");
            node.id = id;
            node.style.display = "none";
            node.textContent = description;
            document.body.appendChild(node);
            desc = {
                refCount: 0,
                element: node
            };
            $34da4502ea8120db$var$descriptionNodes.set(description, desc);
        } else setId(desc.element.id);
        desc.refCount++;
        return ()=>{
            if (--desc.refCount === 0) {
                desc.element.remove();
                $34da4502ea8120db$var$descriptionNodes.delete(description);
            }
        };
    }, [
        description
    ]);
    return {
        "aria-describedby": description ? id : undefined
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $9e20cff0af27e8cc$var$testUserAgent(re) {
    var _window_navigator_userAgentData;
    if (typeof window === "undefined" || window.navigator == null) return false;
    return ((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand)=>re.test(brand.brand))) || re.test(window.navigator.userAgent);
}
function $9e20cff0af27e8cc$var$testPlatform(re) {
    var _window_navigator_userAgentData;
    return typeof window !== "undefined" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $9e20cff0af27e8cc$export$9ac100e40613ea10() {
    return $9e20cff0af27e8cc$var$testPlatform(/^Mac/i);
}
function $9e20cff0af27e8cc$export$186c6964ca17d99() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPhone/i);
}
function $9e20cff0af27e8cc$export$7bef049ce92e4224() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
    $9e20cff0af27e8cc$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
}
function $9e20cff0af27e8cc$export$fedb369cb70207f1() {
    return $9e20cff0af27e8cc$export$186c6964ca17d99() || $9e20cff0af27e8cc$export$7bef049ce92e4224();
}
function $9e20cff0af27e8cc$export$e1865c3bedcd822b() {
    return $9e20cff0af27e8cc$export$9ac100e40613ea10() || $9e20cff0af27e8cc$export$fedb369cb70207f1();
}
function $9e20cff0af27e8cc$export$78551043582a6a98() {
    return $9e20cff0af27e8cc$var$testUserAgent(/AppleWebKit/i) && !$9e20cff0af27e8cc$export$6446a186d09e379e();
}
function $9e20cff0af27e8cc$export$6446a186d09e379e() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Chrome/i);
}
function $9e20cff0af27e8cc$export$a11b0059900ceec8() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Android/i);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1254e5bb94ac8761$export$7f54fc3180508a52(fn) {
    const ref = (0, $1Yh1N$react.useRef)(null);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        ref.current = fn;
    }, [
        fn
    ]);
    return (0, $1Yh1N$react.useCallback)((...args)=>{
        const f = ref.current;
        return f(...args);
    }, []);
}


function $2a8c0bb1629926c8$export$90fc3a17d93f704c(ref, event, handler, options) {
    let handleEvent = (0, $1254e5bb94ac8761$export$7f54fc3180508a52)(handler);
    let isDisabled = handler == null;
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isDisabled) return;
        let element = ref.current;
        element.addEventListener(event, handleEvent, options);
        return ()=>{
            element.removeEventListener(event, handleEvent, options);
        };
    }, [
        ref,
        event,
        options,
        isDisabled,
        handleEvent
    ]);
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $449412113267a1fe$export$53a0910f038337bd(scrollView, element) {
    let offsetX = $449412113267a1fe$var$relativeOffset(scrollView, element, "left");
    let offsetY = $449412113267a1fe$var$relativeOffset(scrollView, element, "top");
    let width = element.offsetWidth;
    let height = element.offsetHeight;
    let x = scrollView.scrollLeft;
    let y = scrollView.scrollTop;
    // Account for top/left border offsetting the scroll top/Left
    let { borderTopWidth: borderTopWidth , borderLeftWidth: borderLeftWidth  } = getComputedStyle(scrollView);
    let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);
    let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);
    // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width
    let maxX = borderAdjustedX + scrollView.clientWidth;
    let maxY = borderAdjustedY + scrollView.clientHeight;
    if (offsetX <= x) x = offsetX - parseInt(borderLeftWidth, 10);
    else if (offsetX + width > maxX) x += offsetX + width - maxX;
    if (offsetY <= borderAdjustedY) y = offsetY - parseInt(borderTopWidth, 10);
    else if (offsetY + height > maxY) y += offsetY + height - maxY;
    scrollView.scrollLeft = x;
    scrollView.scrollTop = y;
}
/**
 * Computes the offset left or top from child to ancestor by accumulating
 * offsetLeft or offsetTop through intervening offsetParents.
 */ function $449412113267a1fe$var$relativeOffset(ancestor, child, axis) {
    const prop = axis === "left" ? "offsetLeft" : "offsetTop";
    let sum = 0;
    while(child.offsetParent){
        sum += child[prop];
        if (child.offsetParent === ancestor) break;
        else if (child.offsetParent.contains(ancestor)) {
            // If the ancestor is not `position:relative`, then we stop at
            // _its_ offset parent, and we subtract off _its_ offset, so that
            // we end up with the proper offset from child to ancestor.
            sum -= ancestor[prop];
            break;
        }
        child = child.offsetParent;
    }
    return sum;
}
function $449412113267a1fe$export$c826860796309d1b(targetElement, opts) {
    if (document.contains(targetElement)) {
        let root = document.scrollingElement || document.documentElement;
        let isScrollPrevented = window.getComputedStyle(root).overflow === "hidden";
        // If scrolling is not currently prevented then we aren’t in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view
        if (!isScrollPrevented) {
            var // use scrollIntoView({block: 'nearest'}) instead of .focus to check if the element is fully in view or not since .focus()
            // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically
            _targetElement_scrollIntoView;
            let { left: originalLeft , top: originalTop  } = targetElement.getBoundingClientRect();
            targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {
                block: "nearest"
            });
            let { left: newLeft , top: newTop  } = targetElement.getBoundingClientRect();
            // Account for sub pixel differences from rounding
            if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {
                var _opts_containingElement, _opts_containingElement_scrollIntoView, _targetElement_scrollIntoView1;
                opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {
                    block: "center",
                    inline: "center"
                });
                (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {
                    block: "nearest"
                });
            }
        } else {
            let scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.
            while(targetElement && scrollParent && targetElement !== root && scrollParent !== root){
                $449412113267a1fe$export$53a0910f038337bd(scrollParent, targetElement);
                targetElement = scrollParent;
                scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            }
        }
    }
}



/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $577e795361f19be9$export$60278871457622de(event) {
    // JAWS/NVDA with Firefox.
    if (event.mozInputSource === 0 && event.isTrusted) return true;
    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead
    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check
    // to detect TalkBack virtual clicks.
    if ((0, $9e20cff0af27e8cc$export$a11b0059900ceec8)() && event.pointerType) return event.type === "click" && event.buttons === 1;
    return event.detail === 0 && !event.pointerType;
}
function $577e795361f19be9$export$29bf1b5f2c56cf63(event) {
    // If the pointer size is zero, then we assume it's from a screen reader.
    // Android TalkBack double tap will sometimes return a event with width and height of 1
    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.
    // Cannot use "event.pressure === 0" as the sole check due to Safari pointer events always returning pressure === 0
    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush
    // Talkback double tap from Windows Firefox touch screen press
    return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse";
}



/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 
function $20e6e72fbf5dc81e$export$722debc0e56fea39(value, isEqual) {
    // Using a ref during render is ok here because it's only an optimization – both values are equivalent.
    // If a render is thrown away, it'll still work the same no matter if the next render is the same or not.
    let lastValue = (0, $1Yh1N$react.useRef)(null);
    if (value && lastValue.current && isEqual(value, lastValue.current)) value = lastValue.current;
    lastValue.current = value;
    return value;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 3788:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $7WOm2$reactariautils = __webpack_require__(92538);
var $7WOm2$reactariafocus = __webpack_require__(28626);
var $7WOm2$reactariainteractions = __webpack_require__(11984);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useToggle", () => $ee1b638d33c90dcc$export$cbe85ee05b554577);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $ee1b638d33c90dcc$export$cbe85ee05b554577(props, state, ref) {
    let { isDisabled: isDisabled = false , isRequired: isRequired = false , isReadOnly: isReadOnly = false , value: value , name: name , children: children , "aria-label": ariaLabel , "aria-labelledby": ariaLabelledby , validationState: validationState = "valid"  } = props;
    let onChange = (e)=>{
        // since we spread props on label, onChange will end up there as well as in here.
        // so we have to stop propagation at the lowest level that we care about
        e.stopPropagation();
        state.setSelected(e.target.checked);
    };
    let hasChildren = children != null;
    let hasAriaLabel = ariaLabel != null || ariaLabelledby != null;
    if (!hasChildren && !hasAriaLabel) console.warn("If you do not provide children, you must specify an aria-label for accessibility");
    // This handles focusing the input on pointer down, which Safari does not do by default.
    let { pressProps: pressProps , isPressed: isPressed  } = (0, $7WOm2$reactariainteractions.usePress)({
        isDisabled: isDisabled
    });
    let { focusableProps: focusableProps  } = (0, $7WOm2$reactariafocus.useFocusable)(props, ref);
    let interactions = (0, $7WOm2$reactariautils.mergeProps)(pressProps, focusableProps);
    let domProps = (0, $7WOm2$reactariautils.filterDOMProps)(props, {
        labelable: true
    });
    return {
        inputProps: (0, $7WOm2$reactariautils.mergeProps)(domProps, {
            "aria-invalid": validationState === "invalid" || undefined,
            "aria-errormessage": props["aria-errormessage"],
            "aria-controls": props["aria-controls"],
            "aria-readonly": isReadOnly || undefined,
            "aria-required": isRequired || undefined,
            onChange: onChange,
            disabled: isDisabled,
            ...value == null ? {} : {
                value: value
            },
            name: name,
            type: "checkbox",
            ...interactions
        }),
        isSelected: state.isSelected,
        isPressed: isPressed,
        isDisabled: isDisabled,
        isReadOnly: isReadOnly
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 28626:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $aB6Cp$react = __webpack_require__(18038);
var $aB6Cp$reactariautils = __webpack_require__(92538);
var $aB6Cp$reactariainteractions = __webpack_require__(11984);
var $aB6Cp$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "FocusScope", () => $a7a032acae3ddda9$export$20e40289641fbbb6);
$parcel$export(module.exports, "useFocusManager", () => $a7a032acae3ddda9$export$10c5169755ce7bd7);
$parcel$export(module.exports, "getFocusableTreeWalker", () => $a7a032acae3ddda9$export$2d6ec8fc375ceafa);
$parcel$export(module.exports, "createFocusManager", () => $a7a032acae3ddda9$export$c5251b9e124bf29);
$parcel$export(module.exports, "isElementInChildOfActiveScope", () => $a7a032acae3ddda9$export$1258395f99bf9cbf);
$parcel$export(module.exports, "FocusRing", () => $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d);
$parcel$export(module.exports, "FocusableProvider", () => $fb504d83237fd6ac$export$13f3202a3e5ddd5);
$parcel$export(module.exports, "useFocusable", () => $fb504d83237fd6ac$export$4c014de7c8940b4c);
$parcel$export(module.exports, "useFocusRing", () => $581a96d6eb128c1b$export$4e328f61c538687f);
$parcel$export(module.exports, "focusSafely", () => $1c7f9157d722357d$export$80f3e147d781571c);
$parcel$export(module.exports, "useHasTabbableChild", () => $259c6413a286f2e6$export$eac1895992b9f3d6);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1c7f9157d722357d$export$80f3e147d781571c(element) {
    // If the user is interacting with a virtual cursor, e.g. screen reader, then
    // wait until after any animated transitions that are currently occurring on
    // the page before shifting focus. This avoids issues with VoiceOver on iOS
    // causing the page to scroll when moving focus if the element is transitioning
    // from off the screen.
    if ((0, $aB6Cp$reactariainteractions.getInteractionModality)() === "virtual") {
        let lastFocusedElement = document.activeElement;
        (0, $aB6Cp$reactariautils.runAfterTransition)(()=>{
            // If focus did not move and the element is still in the document, focus it.
            if (document.activeElement === lastFocusedElement && document.contains(element)) (0, $aB6Cp$reactariautils.focusWithoutScrolling)(element);
        });
    } else (0, $aB6Cp$reactariautils.focusWithoutScrolling)(element);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d5156037ad898a4d$var$isStyleVisible(element) {
    if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) return false;
    let { display: display , visibility: visibility  } = element.style;
    let isVisible = display !== "none" && visibility !== "hidden" && visibility !== "collapse";
    if (isVisible) {
        const { getComputedStyle: getComputedStyle  } = element.ownerDocument.defaultView;
        let { display: computedDisplay , visibility: computedVisibility  } = getComputedStyle(element);
        isVisible = computedDisplay !== "none" && computedVisibility !== "hidden" && computedVisibility !== "collapse";
    }
    return isVisible;
}
function $d5156037ad898a4d$var$isAttributeVisible(element, childElement) {
    return !element.hasAttribute("hidden") && (element.nodeName === "DETAILS" && childElement && childElement.nodeName !== "SUMMARY" ? element.hasAttribute("open") : true);
}
function $d5156037ad898a4d$export$e989c0fffaa6b27a(element, childElement) {
    return element.nodeName !== "#comment" && $d5156037ad898a4d$var$isStyleVisible(element) && $d5156037ad898a4d$var$isAttributeVisible(element, childElement) && (!element.parentElement || $d5156037ad898a4d$export$e989c0fffaa6b27a(element.parentElement, element));
}




const $a7a032acae3ddda9$var$FocusContext = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createContext(null);
let $a7a032acae3ddda9$var$activeScope = null;
function $a7a032acae3ddda9$export$20e40289641fbbb6(props) {
    let { children: children , contain: contain , restoreFocus: restoreFocus , autoFocus: autoFocus  } = props;
    let startRef = (0, $aB6Cp$react.useRef)();
    let endRef = (0, $aB6Cp$react.useRef)();
    let scopeRef = (0, $aB6Cp$react.useRef)([]);
    let { parentNode: parentNode  } = (0, $aB6Cp$react.useContext)($a7a032acae3ddda9$var$FocusContext) || {};
    // Create a tree node here so we can add children to it even before it is added to the tree.
    let node = (0, $aB6Cp$react.useMemo)(()=>new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: scopeRef
        }), [
        scopeRef
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),
        // use the active scope as the parent instead of the parent from context. Layout effects run bottom
        // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope
        // that is being added should get the activeScope as its parent.
        let parent = parentNode || $a7a032acae3ddda9$export$d06fae2ee68b101e.root;
        if ($a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(parent.scopeRef) && $a7a032acae3ddda9$var$activeScope && !$a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, parent.scopeRef)) {
            let activeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
            if (activeNode) parent = activeNode;
        }
        // Add the node to the parent, and to the tree.
        parent.addChild(node);
        $a7a032acae3ddda9$export$d06fae2ee68b101e.addNode(node);
    }, [
        node,
        parentNode
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let node = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef);
        node.contain = contain;
    }, [
        contain
    ]);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        // Find all rendered nodes between the sentinels and add them to the scope.
        let node = startRef.current.nextSibling;
        let nodes = [];
        while(node && node !== endRef.current){
            nodes.push(node);
            node = node.nextSibling;
        }
        scopeRef.current = nodes;
    }, [
        children
    ]);
    $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain);
    $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain);
    $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus);
    // this layout effect needs to run last so that focusScopeTree cleanup happens at the last moment possible
    (0, $aB6Cp$react.useEffect)(()=>{
        if (scopeRef) {
            let activeElement = document.activeElement;
            let scope = null;
            // In strict mode, active scope is incorrectly updated since cleanup will run even though scope hasn't unmounted.
            // To fix this, we need to update the actual activeScope here
            if ($a7a032acae3ddda9$var$isElementInScope(activeElement, scopeRef.current)) {
                // Since useLayoutEffect runs for children first, we need to traverse the focusScope tree and find the bottom most scope that
                // contains the active element and set that as the activeScope
                for (let node of $a7a032acae3ddda9$export$d06fae2ee68b101e.traverse())if ($a7a032acae3ddda9$var$isElementInScope(activeElement, node.scopeRef.current)) scope = node;
                if (scope === $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef)) $a7a032acae3ddda9$var$activeScope = scope.scopeRef;
            }
            return ()=>{
                // Scope may have been re-parented.
                let parentScope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).parent.scopeRef;
                // Restore the active scope on unmount if this scope or a descendant scope is active.
                // Parent effect cleanups run before children, so we need to check if the
                // parent scope actually still exists before restoring the active scope to it.
                if ((scopeRef === $a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope(scopeRef, $a7a032acae3ddda9$var$activeScope)) && (!parentScope || $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(parentScope))) $a7a032acae3ddda9$var$activeScope = parentScope;
                $a7a032acae3ddda9$export$d06fae2ee68b101e.removeTreeNode(scopeRef);
            };
        }
    }, [
        scopeRef
    ]);
    let focusManager = (0, $aB6Cp$react.useMemo)(()=>$a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef), []);
    let value = (0, $aB6Cp$react.useMemo)(()=>({
            focusManager: focusManager,
            parentNode: node
        }), [
        node,
        focusManager
    ]);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement($a7a032acae3ddda9$var$FocusContext.Provider, {
        value: value
    }, /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement("span", {
        "data-focus-scope-start": true,
        hidden: true,
        ref: startRef
    }), children, /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement("span", {
        "data-focus-scope-end": true,
        hidden: true,
        ref: endRef
    }));
}
function $a7a032acae3ddda9$export$10c5169755ce7bd7() {
    var _useContext;
    return (_useContext = (0, $aB6Cp$react.useContext)($a7a032acae3ddda9$var$FocusContext)) === null || _useContext === void 0 ? void 0 : _useContext.focusManager;
}
function $a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef) {
    return {
        focusNext (opts = {}) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[0].previousElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = sentinel;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = {}) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[scope.length - 1].nextElementSibling;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = $a7a032acae3ddda9$var$isElementInScope(node, scope) ? node : sentinel;
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = sentinel;
                previousNode = walker.previousNode();
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = {}) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[0].previousElementSibling;
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = {}) {
            let scope = scopeRef.current;
            let { tabbable: tabbable , accept: accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: tabbable,
                accept: accept
            }, scope);
            walker.currentNode = scope[scope.length - 1].nextElementSibling;
            let previousNode = walker.previousNode();
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        }
    };
}
const $a7a032acae3ddda9$var$focusableElements = [
    "input:not([disabled]):not([type=hidden])",
    "select:not([disabled])",
    "textarea:not([disabled])",
    "button:not([disabled])",
    "a[href]",
    "area[href]",
    "summary",
    "iframe",
    "object",
    "embed",
    "audio[controls]",
    "video[controls]",
    "[contenteditable]"
];
const $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
$a7a032acae3ddda9$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR = $a7a032acae3ddda9$var$focusableElements.join(':not([hidden]):not([tabindex="-1"]),');
function $a7a032acae3ddda9$var$getScopeRoot(scope) {
    return scope[0].parentElement;
}
function $a7a032acae3ddda9$var$shouldContainFocus(scopeRef) {
    let scope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
    while(scope && scope.scopeRef !== scopeRef){
        if (scope.contain) return false;
        scope = scope.parent;
    }
    return true;
}
function $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain) {
    let focusedNode = (0, $aB6Cp$react.useRef)();
    let raf = (0, $aB6Cp$react.useRef)(null);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let scope = scopeRef.current;
        if (!contain) {
            // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment
            if (raf.current) {
                cancelAnimationFrame(raf.current);
                raf.current = null;
            }
            return;
        }
        // Handle the Tab key to contain focus within the scope
        let onKeyDown = (e)=>{
            if (e.key !== "Tab" || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) return;
            let focusedElement = document.activeElement;
            let scope = scopeRef.current;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scope)) return;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
                tabbable: true
            }, scope);
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!nextElement) {
                walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;
                nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            }
            e.preventDefault();
            if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
        };
        let onFocus = (e)=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if ((!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) && $a7a032acae3ddda9$var$isElementInScope(e.target, scopeRef.current)) {
                $a7a032acae3ddda9$var$activeScope = scopeRef;
                focusedNode.current = e.target;
            } else if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(e.target, scopeRef)) {
                // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),
                // restore focus to the previously focused node or the first tabbable element in the active scope.
                if (focusedNode.current) focusedNode.current.focus();
                else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
            } else if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) focusedNode.current = e.target;
        };
        let onBlur = (e)=>{
            // Firefox doesn't shift focus back to the Dialog properly without this
            if (raf.current) cancelAnimationFrame(raf.current);
            raf.current = requestAnimationFrame(()=>{
                // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe
                if ($a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(document.activeElement, scopeRef)) {
                    $a7a032acae3ddda9$var$activeScope = scopeRef;
                    if (document.body.contains(e.target)) {
                        focusedNode.current = e.target;
                        focusedNode.current.focus();
                    } else if ($a7a032acae3ddda9$var$activeScope) $a7a032acae3ddda9$var$focusFirstInScope($a7a032acae3ddda9$var$activeScope.current);
                }
            });
        };
        document.addEventListener("keydown", onKeyDown, false);
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        scope.forEach((element)=>element.addEventListener("focusout", onBlur, false));
        return ()=>{
            document.removeEventListener("keydown", onKeyDown, false);
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
            scope.forEach((element)=>element.removeEventListener("focusout", onBlur, false));
        };
    }, [
        scopeRef,
        contain
    ]);
    // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur
    // eslint-disable-next-line arrow-body-style
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        return ()=>{
            if (raf.current) cancelAnimationFrame(raf.current);
        };
    }, [
        raf
    ]);
}
function $a7a032acae3ddda9$var$isElementInAnyScope(element) {
    return $a7a032acae3ddda9$var$isElementInChildScope(element);
}
function $a7a032acae3ddda9$var$isElementInScope(element, scope) {
    return scope.some((node)=>node.contains(element));
}
function $a7a032acae3ddda9$var$isElementInChildScope(element, scope = null) {
    // If the element is within a top layer element (e.g. toasts), always allow moving focus there.
    if (element instanceof Element && element.closest("[data-react-aria-top-layer]")) return true;
    // node.contains in isElementInScope covers child scopes that are also DOM children,
    // but does not cover child scopes in portals.
    for (let { scopeRef: s  } of $a7a032acae3ddda9$export$d06fae2ee68b101e.traverse($a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scope))){
        if ($a7a032acae3ddda9$var$isElementInScope(element, s.current)) return true;
    }
    return false;
}
function $a7a032acae3ddda9$export$1258395f99bf9cbf(element) {
    return $a7a032acae3ddda9$var$isElementInChildScope(element, $a7a032acae3ddda9$var$activeScope);
}
function $a7a032acae3ddda9$var$isAncestorScope(ancestor, scope) {
    var _focusScopeTree_getTreeNode;
    let parent = (_focusScopeTree_getTreeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scope)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : _focusScopeTree_getTreeNode.parent;
    while(parent){
        if (parent.scopeRef === ancestor) return true;
        parent = parent.parent;
    }
    return false;
}
function $a7a032acae3ddda9$var$focusElement(element, scroll = false) {
    if (element != null && !scroll) try {
        (0, $1c7f9157d722357d$export$80f3e147d781571c)(element);
    } catch (err) {
    // ignore
    }
    else if (element != null) try {
        element.focus();
    } catch (err) {
    // ignore
    }
}
function $a7a032acae3ddda9$var$focusFirstInScope(scope, tabbable = true) {
    let sentinel = scope[0].previousElementSibling;
    let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
        tabbable: tabbable
    }, scope);
    walker.currentNode = sentinel;
    let nextNode = walker.nextNode();
    // If the scope does not contain a tabbable element, use the first focusable element.
    if (tabbable && !nextNode) {
        walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa($a7a032acae3ddda9$var$getScopeRoot(scope), {
            tabbable: false
        }, scope);
        walker.currentNode = sentinel;
        nextNode = walker.nextNode();
    }
    $a7a032acae3ddda9$var$focusElement(nextNode);
}
function $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus) {
    const autoFocusRef = (0, ($parcel$interopDefault($aB6Cp$react))).useRef(autoFocus);
    (0, $aB6Cp$react.useEffect)(()=>{
        if (autoFocusRef.current) {
            $a7a032acae3ddda9$var$activeScope = scopeRef;
            if (!$a7a032acae3ddda9$var$isElementInScope(document.activeElement, $a7a032acae3ddda9$var$activeScope.current)) $a7a032acae3ddda9$var$focusFirstInScope(scopeRef.current);
        }
        autoFocusRef.current = false;
    }, [
        scopeRef
    ]);
}
function $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restore, contain) {
    // tracks the active scope, in case restore and contain are both false.
    // if either are true, this is tracked in useRestoreFocus or useFocusContainment.
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if (restore || contain) return;
        let scope = scopeRef.current;
        let onFocus = (e)=>{
            let target = e.target;
            if ($a7a032acae3ddda9$var$isElementInScope(target, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
            else if (!$a7a032acae3ddda9$var$isElementInAnyScope(target)) $a7a032acae3ddda9$var$activeScope = null;
        };
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        return ()=>{
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
        };
    }, [
        scopeRef,
        restore,
        contain
    ]);
}
function $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef) {
    let scope = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode($a7a032acae3ddda9$var$activeScope);
    while(scope && scope.scopeRef !== scopeRef){
        if (scope.nodeToRestore) return false;
        scope = scope.parent;
    }
    return (scope === null || scope === void 0 ? void 0 : scope.scopeRef) === scopeRef;
}
function $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
    // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.
    const nodeToRestoreRef = (0, $aB6Cp$react.useRef)(typeof document !== "undefined" ? document.activeElement : null);
    // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus
    // restoring-non-containing scopes should only care if they become active so they can perform the restore
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        let scope = scopeRef.current;
        if (!restoreFocus || contain) return;
        let onFocus = ()=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if ((!$a7a032acae3ddda9$var$activeScope || $a7a032acae3ddda9$var$isAncestorScope($a7a032acae3ddda9$var$activeScope, scopeRef)) && $a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
        };
        document.addEventListener("focusin", onFocus, false);
        scope.forEach((element)=>element.addEventListener("focusin", onFocus, false));
        return ()=>{
            document.removeEventListener("focusin", onFocus, false);
            scope.forEach((element)=>element.removeEventListener("focusin", onFocus, false));
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        scopeRef,
        contain
    ]);
    // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if (!restoreFocus) return;
        $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = nodeToRestoreRef.current;
        // Handle the Tab key so that tabbing out of the scope goes to the next element
        // after the node that had focus when the scope mounted. This is important when
        // using portals for overlays, so that focus goes to the expected element when
        // tabbing out of the overlay.
        let onKeyDown = (e)=>{
            if (e.key !== "Tab" || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef)) return;
            let focusedElement = document.activeElement;
            if (!$a7a032acae3ddda9$var$isElementInScope(focusedElement, scopeRef.current)) return;
            let nodeToRestore = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;
            // Create a DOM tree walker that matches all tabbable elements
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(document.body, {
                tabbable: true
            });
            // Find the next tabbable element after the currently focused element
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!document.body.contains(nodeToRestore) || nodeToRestore === document.body) {
                nodeToRestore = null;
                $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = null;
            }
            // If there is no next element, or it is outside the current scope, move focus to the
            // next element after the node to restore to instead.
            if ((!nextElement || !$a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {
                walker.currentNode = nodeToRestore;
                // Skip over elements within the scope, in case the scope immediately follows the node to restore.
                do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
                while ($a7a032acae3ddda9$var$isElementInScope(nextElement, scopeRef.current));
                e.preventDefault();
                e.stopPropagation();
                if (nextElement) $a7a032acae3ddda9$var$focusElement(nextElement, true);
                else // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)
                // then move focus to the body.
                // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)
                if (!$a7a032acae3ddda9$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();
                else $a7a032acae3ddda9$var$focusElement(nodeToRestore, true);
            }
        };
        if (!contain) document.addEventListener("keydown", onKeyDown, true);
        return ()=>{
            if (!contain) document.removeEventListener("keydown", onKeyDown, true);
            let nodeToRestore = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;
            // if we already lost focus to the body and this was the active scope, then we should attempt to restore
            if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps
            ($a7a032acae3ddda9$var$isElementInScope(document.activeElement, scopeRef.current) || document.activeElement === document.body && $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef))) {
                // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it
                let clonedTree = $a7a032acae3ddda9$export$d06fae2ee68b101e.clone();
                requestAnimationFrame(()=>{
                    // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere
                    if (document.activeElement === document.body) {
                        // look up the tree starting with our scope to find a nodeToRestore still in the DOM
                        let treeNode = clonedTree.getTreeNode(scopeRef);
                        while(treeNode){
                            if (treeNode.nodeToRestore && document.body.contains(treeNode.nodeToRestore)) {
                                $a7a032acae3ddda9$var$focusElement(treeNode.nodeToRestore);
                                return;
                            }
                            treeNode = treeNode.parent;
                        }
                        // If no nodeToRestore was found, focus the first element in the nearest
                        // ancestor scope that is still in the tree.
                        treeNode = clonedTree.getTreeNode(scopeRef);
                        while(treeNode){
                            if (treeNode.scopeRef && $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(treeNode.scopeRef)) {
                                $a7a032acae3ddda9$var$focusFirstInScope(treeNode.scopeRef.current, true);
                                return;
                            }
                            treeNode = treeNode.parent;
                        }
                    }
                });
            }
        };
    }, [
        scopeRef,
        restoreFocus,
        contain
    ]);
}
function $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, opts, scope) {
    let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR : $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR;
    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode (node) {
            var _opts_from;
            // Skip nodes inside the starting node.
            if (opts === null || opts === void 0 ? void 0 : (_opts_from = opts.from) === null || _opts_from === void 0 ? void 0 : _opts_from.contains(node)) return NodeFilter.FILTER_REJECT;
            if (node.matches(selector) && (0, $d5156037ad898a4d$export$e989c0fffaa6b27a)(node) && (!scope || $a7a032acae3ddda9$var$isElementInScope(node, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node))) return NodeFilter.FILTER_ACCEPT;
            return NodeFilter.FILTER_SKIP;
        }
    });
    if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;
    return walker;
}
function $a7a032acae3ddda9$export$c5251b9e124bf29(ref, defaultOptions = {}) {
    return {
        focusNext (opts = {}) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = root;
                nextNode = walker.nextNode();
            }
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;
            let node = from || document.activeElement;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            if (root.contains(node)) walker.currentNode = node;
            else {
                let next = $a7a032acae3ddda9$var$last(walker);
                if (next) $a7a032acae3ddda9$var$focusElement(next, true);
                return next;
            }
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = root;
                previousNode = $a7a032acae3ddda9$var$last(walker);
            }
            if (previousNode) $a7a032acae3ddda9$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let nextNode = walker.nextNode();
            if (nextNode) $a7a032acae3ddda9$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = defaultOptions) {
            let root = ref.current;
            if (!root) return;
            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;
            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable,
                accept: accept
            });
            let next = $a7a032acae3ddda9$var$last(walker);
            if (next) $a7a032acae3ddda9$var$focusElement(next, true);
            return next;
        }
    };
}
function $a7a032acae3ddda9$var$last(walker) {
    let next;
    let last;
    do {
        last = walker.lastChild();
        if (last) next = last;
    }while (last);
    return next;
}
class $a7a032acae3ddda9$var$Tree {
    get size() {
        return this.fastMap.size;
    }
    getTreeNode(data) {
        return this.fastMap.get(data);
    }
    addTreeNode(scopeRef, parent, nodeToRestore) {
        let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);
        let node = new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: scopeRef
        });
        parentNode.addChild(node);
        node.parent = parentNode;
        this.fastMap.set(scopeRef, node);
        if (nodeToRestore) node.nodeToRestore = nodeToRestore;
    }
    addNode(node) {
        this.fastMap.set(node.scopeRef, node);
    }
    removeTreeNode(scopeRef) {
        // never remove the root
        if (scopeRef === null) return;
        let node = this.fastMap.get(scopeRef);
        let parentNode = node.parent;
        // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing
        // if we are, then replace the siblings restore with the restore from the scope we're removing
        for (let current of this.traverse())if (current !== node && node.nodeToRestore && current.nodeToRestore && node.scopeRef.current && $a7a032acae3ddda9$var$isElementInScope(current.nodeToRestore, node.scopeRef.current)) current.nodeToRestore = node.nodeToRestore;
        let children = node.children;
        parentNode.removeChild(node);
        if (children.size > 0) children.forEach((child)=>parentNode.addChild(child));
        this.fastMap.delete(node.scopeRef);
    }
    // Pre Order Depth First
    *traverse(node = this.root) {
        if (node.scopeRef != null) yield node;
        if (node.children.size > 0) for (let child of node.children)yield* this.traverse(child);
    }
    clone() {
        let newTree = new $a7a032acae3ddda9$var$Tree();
        for (let node of this.traverse())newTree.addTreeNode(node.scopeRef, node.parent.scopeRef, node.nodeToRestore);
        return newTree;
    }
    constructor(){
        this.fastMap = new Map();
        this.root = new $a7a032acae3ddda9$var$TreeNode({
            scopeRef: null
        });
        this.fastMap.set(null, this.root);
    }
}
class $a7a032acae3ddda9$var$TreeNode {
    addChild(node) {
        this.children.add(node);
        node.parent = this;
    }
    removeChild(node) {
        this.children.delete(node);
        node.parent = undefined;
    }
    constructor(props){
        this.children = new Set();
        this.contain = false;
        this.scopeRef = props.scopeRef;
    }
}
let $a7a032acae3ddda9$export$d06fae2ee68b101e = new $a7a032acae3ddda9$var$Tree();


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 




function $581a96d6eb128c1b$export$4e328f61c538687f(props = {}) {
    let { autoFocus: autoFocus = false , isTextInput: isTextInput , within: within  } = props;
    let state = (0, $aB6Cp$react.useRef)({
        isFocused: false,
        isFocusVisible: autoFocus || (0, $aB6Cp$reactariainteractions.isFocusVisible)()
    });
    let [isFocused, setFocused] = (0, $aB6Cp$react.useState)(false);
    let [isFocusVisibleState, setFocusVisible] = (0, $aB6Cp$react.useState)(()=>state.current.isFocused && state.current.isFocusVisible);
    let updateState = (0, $aB6Cp$react.useCallback)(()=>setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
    let onFocusChange = (0, $aB6Cp$react.useCallback)((isFocused)=>{
        state.current.isFocused = isFocused;
        setFocused(isFocused);
        updateState();
    }, [
        updateState
    ]);
    (0, $aB6Cp$reactariainteractions.useFocusVisibleListener)((isFocusVisible)=>{
        state.current.isFocusVisible = isFocusVisible;
        updateState();
    }, [], {
        isTextInput: isTextInput
    });
    let { focusProps: focusProps  } = (0, $aB6Cp$reactariainteractions.useFocus)({
        isDisabled: within,
        onFocusChange: onFocusChange
    });
    let { focusWithinProps: focusWithinProps  } = (0, $aB6Cp$reactariainteractions.useFocusWithin)({
        isDisabled: !within,
        onFocusWithinChange: onFocusChange
    });
    return {
        isFocused: isFocused,
        isFocusVisible: isFocusVisibleState,
        focusProps: within ? focusWithinProps : focusProps
    };
}


function $dfd8c70b928eb1b3$export$1a38b4ad7f578e1d(props) {
    let { children: children , focusClass: focusClass , focusRingClass: focusRingClass  } = props;
    let { isFocused: isFocused , isFocusVisible: isFocusVisible , focusProps: focusProps  } = (0, $581a96d6eb128c1b$export$4e328f61c538687f)(props);
    let child = (0, ($parcel$interopDefault($aB6Cp$react))).Children.only(children);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).cloneElement(child, (0, $aB6Cp$reactariautils.mergeProps)(child.props, {
        ...focusProps,
        className: (0, ($parcel$interopDefault($aB6Cp$clsx)))({
            [focusClass || ""]: isFocused,
            [focusRingClass || ""]: isFocusVisible
        })
    }));
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



let $fb504d83237fd6ac$var$FocusableContext = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createContext(null);
function $fb504d83237fd6ac$var$useFocusableContext(ref) {
    let context = (0, $aB6Cp$react.useContext)($fb504d83237fd6ac$var$FocusableContext) || {};
    (0, $aB6Cp$reactariautils.useSyncRef)(context, ref);
    // eslint-disable-next-line
    let { ref: _ , ...otherProps } = context;
    return otherProps;
}
/**
 * Provides DOM props to the nearest focusable child.
 */ function $fb504d83237fd6ac$var$FocusableProvider(props, ref) {
    let { children: children , ...otherProps } = props;
    let context = {
        ...otherProps,
        ref: ref
    };
    return /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).createElement($fb504d83237fd6ac$var$FocusableContext.Provider, {
        value: context
    }, children);
}
let $fb504d83237fd6ac$export$13f3202a3e5ddd5 = /*#__PURE__*/ (0, ($parcel$interopDefault($aB6Cp$react))).forwardRef($fb504d83237fd6ac$var$FocusableProvider);
function $fb504d83237fd6ac$export$4c014de7c8940b4c(props, domRef) {
    let { focusProps: focusProps  } = (0, $aB6Cp$reactariainteractions.useFocus)(props);
    let { keyboardProps: keyboardProps  } = (0, $aB6Cp$reactariainteractions.useKeyboard)(props);
    let interactions = (0, $aB6Cp$reactariautils.mergeProps)(focusProps, keyboardProps);
    let domProps = $fb504d83237fd6ac$var$useFocusableContext(domRef);
    let interactionProps = props.isDisabled ? {} : domProps;
    let autoFocusRef = (0, $aB6Cp$react.useRef)(props.autoFocus);
    (0, $aB6Cp$react.useEffect)(()=>{
        if (autoFocusRef.current && domRef.current) (0, $1c7f9157d722357d$export$80f3e147d781571c)(domRef.current);
        autoFocusRef.current = false;
    }, [
        domRef
    ]);
    return {
        focusableProps: (0, $aB6Cp$reactariautils.mergeProps)({
            ...interactions,
            tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined
        }, interactionProps)
    };
}




/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $259c6413a286f2e6$export$eac1895992b9f3d6(ref, options) {
    let isDisabled = options === null || options === void 0 ? void 0 : options.isDisabled;
    let [hasTabbableChild, setHasTabbableChild] = (0, $aB6Cp$react.useState)(false);
    (0, $aB6Cp$reactariautils.useLayoutEffect)(()=>{
        if ((ref === null || ref === void 0 ? void 0 : ref.current) && !isDisabled) {
            let update = ()=>{
                if (ref.current) {
                    let walker = (0, $a7a032acae3ddda9$export$2d6ec8fc375ceafa)(ref.current, {
                        tabbable: true
                    });
                    setHasTabbableChild(!!walker.nextNode());
                }
            };
            update();
            // Update when new elements are inserted, or the tabIndex/disabled attribute updates.
            let observer = new MutationObserver(update);
            observer.observe(ref.current, {
                subtree: true,
                childList: true,
                attributes: true,
                attributeFilter: [
                    "tabIndex",
                    "disabled"
                ]
            });
            return ()=>{
                // Disconnect mutation observer when a React update occurs on the top-level component
                // so we update synchronously after re-rendering. Otherwise React will emit act warnings
                // in tests since mutation observers fire asynchronously. The mutation observer is necessary
                // so we also update if a child component re-renders and adds/removes something tabbable.
                observer.disconnect();
            };
        }
    });
    return isDisabled ? false : hasTabbableChild;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 11984:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $goTMa$reactariautils = __webpack_require__(92538);
var $goTMa$react = __webpack_require__(18038);
var $goTMa$reactariassr = __webpack_require__(79452);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "Pressable", () => $e1dbec26039c051d$export$27c701ed9e449e99);
$parcel$export(module.exports, "PressResponder", () => $3596bae48579386f$export$3351871ee4b288b8);
$parcel$export(module.exports, "useFocus", () => $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6);
$parcel$export(module.exports, "isFocusVisible", () => $e77252a287ef94ab$export$b9b3dfddab17db27);
$parcel$export(module.exports, "getInteractionModality", () => $e77252a287ef94ab$export$630ff653c5ada6a9);
$parcel$export(module.exports, "setInteractionModality", () => $e77252a287ef94ab$export$8397ddfc504fdb9a);
$parcel$export(module.exports, "useInteractionModality", () => $e77252a287ef94ab$export$98e20ec92f614cfe);
$parcel$export(module.exports, "useFocusVisible", () => $e77252a287ef94ab$export$ffd9e5021c1fb2d6);
$parcel$export(module.exports, "useFocusVisibleListener", () => $e77252a287ef94ab$export$ec71b4b83ac08ec3);
$parcel$export(module.exports, "useFocusWithin", () => $d16842bbd0359d1b$export$420e68273165f4ec);
$parcel$export(module.exports, "useHover", () => $ffbc150311c75f01$export$ae780daf29e6d456);
$parcel$export(module.exports, "useInteractOutside", () => $edcfa848c42f94f4$export$872b660ac5a1ff98);
$parcel$export(module.exports, "useKeyboard", () => $892d64db2a3c53b0$export$8f71654801c2f7cd);
$parcel$export(module.exports, "useMove", () => $c09386fc48fa427d$export$36da96379f79f245);
$parcel$export(module.exports, "usePress", () => $0294ea432cd92340$export$45712eceda6fad21);
$parcel$export(module.exports, "useScrollWheel", () => $a3dbce0aed7087e2$export$2123ff2b87c81ca);
$parcel$export(module.exports, "useLongPress", () => $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element
// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually
let $f7e14e656343df57$var$state = "default";
let $f7e14e656343df57$var$savedUserSelect = "";
let $f7e14e656343df57$var$modifiedElementMap = new WeakMap();
function $f7e14e656343df57$export$16a4697467175487(target) {
    if ((0, $goTMa$reactariautils.isIOS)()) {
        if ($f7e14e656343df57$var$state === "default") {
            $f7e14e656343df57$var$savedUserSelect = document.documentElement.style.webkitUserSelect;
            document.documentElement.style.webkitUserSelect = "none";
        }
        $f7e14e656343df57$var$state = "disabled";
    } else if (target instanceof HTMLElement || target instanceof SVGElement) {
        // If not iOS, store the target's original user-select and change to user-select: none
        // Ignore state since it doesn't apply for non iOS
        $f7e14e656343df57$var$modifiedElementMap.set(target, target.style.userSelect);
        target.style.userSelect = "none";
    }
}
function $f7e14e656343df57$export$b0d6fa1ab32e3295(target) {
    if ((0, $goTMa$reactariautils.isIOS)()) {
        // If the state is already default, there's nothing to do.
        // If it is restoring, then there's no need to queue a second restore.
        if ($f7e14e656343df57$var$state !== "disabled") return;
        $f7e14e656343df57$var$state = "restoring";
        // There appears to be a delay on iOS where selection still might occur
        // after pointer up, so wait a bit before removing user-select.
        setTimeout(()=>{
            // Wait for any CSS transitions to complete so we don't recompute style
            // for the whole page in the middle of the animation and cause jank.
            (0, $goTMa$reactariautils.runAfterTransition)(()=>{
                // Avoid race conditions
                if ($f7e14e656343df57$var$state === "restoring") {
                    if (document.documentElement.style.webkitUserSelect === "none") document.documentElement.style.webkitUserSelect = $f7e14e656343df57$var$savedUserSelect || "";
                    $f7e14e656343df57$var$savedUserSelect = "";
                    $f7e14e656343df57$var$state = "default";
                }
            });
        }, 300);
    } else if (target instanceof HTMLElement || target instanceof SVGElement) // If not iOS, restore the target's original user-select if any
    // Ignore state since it doesn't apply for non iOS
    {
        if (target && $f7e14e656343df57$var$modifiedElementMap.has(target)) {
            let targetOldUserSelect = $f7e14e656343df57$var$modifiedElementMap.get(target);
            if (target.style.userSelect === "none") target.style.userSelect = targetOldUserSelect;
            if (target.getAttribute("style") === "") target.removeAttribute("style");
            $f7e14e656343df57$var$modifiedElementMap.delete(target);
        }
    }
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $01d3f539e91688c8$export$5165eccb35aaadb5 = (0, ($parcel$interopDefault($goTMa$react))).createContext(null);
$01d3f539e91688c8$export$5165eccb35aaadb5.displayName = "PressResponderContext";



function $0294ea432cd92340$var$usePressResponderContext(props) {
    // Consume context from <PressResponder> and merge with props.
    let context = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));
    if (context) {
        let { register: register , ...contextProps } = context;
        props = (0, $goTMa$reactariautils.mergeProps)(contextProps, props);
        register();
    }
    (0, $goTMa$reactariautils.useSyncRef)(context, props.ref);
    return props;
}
function $0294ea432cd92340$export$45712eceda6fad21(props) {
    let { onPress: onPress , onPressChange: onPressChange , onPressStart: onPressStart , onPressEnd: onPressEnd , onPressUp: onPressUp , isDisabled: isDisabled , isPressed: isPressedProp , preventFocusOnPress: preventFocusOnPress , shouldCancelOnPointerExit: shouldCancelOnPointerExit , allowTextSelectionOnPress: allowTextSelectionOnPress , // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: _ , ...domProps } = $0294ea432cd92340$var$usePressResponderContext(props);
    let [isPressed, setPressed] = (0, $goTMa$react.useState)(false);
    let ref = (0, $goTMa$react.useRef)({
        isPressed: false,
        ignoreEmulatedMouseEvents: false,
        ignoreClickAfterPress: false,
        didFirePressStart: false,
        activePointerId: null,
        target: null,
        isOverTarget: false,
        pointerType: null
    });
    let { addGlobalListener: addGlobalListener , removeAllGlobalListeners: removeAllGlobalListeners  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let triggerPressStart = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        let state = ref.current;
        if (isDisabled || state.didFirePressStart) return;
        if (onPressStart) onPressStart({
            type: "pressstart",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
        if (onPressChange) onPressChange(true);
        state.didFirePressStart = true;
        setPressed(true);
    });
    let triggerPressEnd = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType, wasPressed = true)=>{
        let state = ref.current;
        if (!state.didFirePressStart) return;
        state.ignoreClickAfterPress = true;
        state.didFirePressStart = false;
        if (onPressEnd) onPressEnd({
            type: "pressend",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
        if (onPressChange) onPressChange(false);
        setPressed(false);
        if (onPress && wasPressed && !isDisabled) onPress({
            type: "press",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let triggerPressUp = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        if (isDisabled) return;
        if (onPressUp) onPressUp({
            type: "pressup",
            pointerType: pointerType,
            target: originalEvent.currentTarget,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let cancel = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        let state = ref.current;
        if (state.isPressed) {
            if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
            state.isPressed = false;
            state.isOverTarget = false;
            state.activePointerId = null;
            state.pointerType = null;
            removeAllGlobalListeners();
            if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
        }
    });
    let cancelOnPointerExit = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (shouldCancelOnPointerExit) cancel(e);
    });
    let pressProps = (0, $goTMa$react.useMemo)(()=>{
        let state = ref.current;
        let pressProps = {
            onKeyDown (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {
                    if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                    e.stopPropagation();
                    // If the event is repeating, it may have started on a different element
                    // after which focus moved to the current element. Ignore these events and
                    // only handle the first key down event.
                    if (!state.isPressed && !e.repeat) {
                        state.target = e.currentTarget;
                        state.isPressed = true;
                        triggerPressStart(e, "keyboard");
                        // Focus may move before the key up event, so register the event on the document
                        // instead of the same element where the key down event occurred.
                        addGlobalListener(document, "keyup", onKeyUp, false);
                    }
                } else if (e.key === "Enter" && $0294ea432cd92340$var$isHTMLAnchorLink(e.currentTarget)) // If the target is a link, we won't have handled this above because we want the default
                // browser behavior to open the link when pressing Enter. But we still need to prevent
                // default so that elements above do not also handle it (e.g. table row).
                e.stopPropagation();
            },
            onKeyUp (e) {
                if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target)) triggerPressUp($0294ea432cd92340$var$createEvent(state.target, e), "keyboard");
            },
            onClick (e) {
                if (e && !e.currentTarget.contains(e.target)) return;
                if (e && e.button === 0) {
                    e.stopPropagation();
                    if (isDisabled) e.preventDefault();
                    // If triggered from a screen reader or by using element.click(),
                    // trigger as if it were a keyboard click.
                    if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && (state.pointerType === "virtual" || (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent))) {
                        // Ensure the element receives focus (VoiceOver on iOS does not do this)
                        if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                        triggerPressStart(e, "virtual");
                        triggerPressUp(e, "virtual");
                        triggerPressEnd(e, "virtual");
                    }
                    state.ignoreEmulatedMouseEvents = false;
                    state.ignoreClickAfterPress = false;
                }
            }
        };
        let onKeyUp = (e)=>{
            if (state.isPressed && $0294ea432cd92340$var$isValidKeyboardEvent(e, state.target)) {
                if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                e.stopPropagation();
                state.isPressed = false;
                let target = e.target;
                triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), "keyboard", state.target.contains(target));
                removeAllGlobalListeners();
                // If the target is a link, trigger the click method to open the URL,
                // but defer triggering pressEnd until onClick event handler.
                if (state.target instanceof HTMLElement && state.target.contains(target) && ($0294ea432cd92340$var$isHTMLAnchorLink(state.target) || state.target.getAttribute("role") === "link")) state.target.click();
            }
        };
        if (typeof PointerEvent !== "undefined") {
            pressProps.onPointerDown = (e)=>{
                // Only handle left clicks, and ignore events that bubbled through portals.
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.
                // Ignore and let the onClick handler take care of it instead.
                // https://bugs.webkit.org/show_bug.cgi?id=222627
                // https://bugs.webkit.org/show_bug.cgi?id=223202
                if ((0, $goTMa$reactariautils.isVirtualPointerEvent)(e.nativeEvent)) {
                    state.pointerType = "virtual";
                    return;
                }
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on pointer down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                state.pointerType = e.pointerType;
                e.stopPropagation();
                if (!state.isPressed) {
                    state.isPressed = true;
                    state.isOverTarget = true;
                    state.activePointerId = e.pointerId;
                    state.target = e.currentTarget;
                    if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                    if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);
                    triggerPressStart(e, state.pointerType);
                    addGlobalListener(document, "pointermove", onPointerMove, false);
                    addGlobalListener(document, "pointerup", onPointerUp, false);
                    addGlobalListener(document, "pointercancel", onPointerCancel, false);
                }
            };
            pressProps.onMouseDown = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (e.button === 0) {
                    // Chrome and Firefox on touch Windows devices require mouse down events
                    // to be canceled in addition to pointer events, or an extra asynchronous
                    // focus event will be fired.
                    if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                    e.stopPropagation();
                }
            };
            pressProps.onPointerUp = (e)=>{
                // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.
                if (!e.currentTarget.contains(e.target) || state.pointerType === "virtual") return;
                // Only handle left clicks
                // Safari on iOS sometimes fires pointerup events, even
                // when the touch isn't over the target, so double check.
                if (e.button === 0 && $0294ea432cd92340$var$isOverTarget(e, e.currentTarget)) triggerPressUp(e, state.pointerType || e.pointerType);
            };
            // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.
            // Use pointer move events instead to implement our own hit testing.
            // See https://bugs.webkit.org/show_bug.cgi?id=199803
            let onPointerMove = (e)=>{
                if (e.pointerId !== state.activePointerId) return;
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0) {
                    if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                    else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                    state.isPressed = false;
                    state.isOverTarget = false;
                    state.activePointerId = null;
                    state.pointerType = null;
                    removeAllGlobalListeners();
                    if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
                }
            };
            let onPointerCancel = (e)=>{
                cancel(e);
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.
                cancel(e);
            };
        } else {
            pressProps.onMouseDown = (e)=>{
                // Only handle left clicks
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on mouse down and handle focusing the pressable element ourselves.
                if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                e.stopPropagation();
                if (state.ignoreEmulatedMouseEvents) return;
                state.isPressed = true;
                state.isOverTarget = true;
                state.target = e.currentTarget;
                state.pointerType = (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent) ? "virtual" : "mouse";
                if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(document, "mouseup", onMouseUp, false);
            };
            pressProps.onMouseEnter = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = true;
                    triggerPressStart(e, state.pointerType);
                }
            };
            pressProps.onMouseLeave = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            pressProps.onMouseUp = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType);
            };
            let onMouseUp = (e)=>{
                // Only handle left clicks
                if (e.button !== 0) return;
                state.isPressed = false;
                removeAllGlobalListeners();
                if (state.ignoreEmulatedMouseEvents) {
                    state.ignoreEmulatedMouseEvents = false;
                    return;
                }
                if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);
                else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);
                state.isOverTarget = false;
            };
            pressProps.onTouchStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                let touch = $0294ea432cd92340$var$getTouchFromEvent(e.nativeEvent);
                if (!touch) return;
                state.activePointerId = touch.identifier;
                state.ignoreEmulatedMouseEvents = true;
                state.isOverTarget = true;
                state.isPressed = true;
                state.target = e.currentTarget;
                state.pointerType = "touch";
                // Due to browser inconsistencies, especially on mobile browsers, we prevent default
                // on the emulated mouse event and handle focusing the pressable element ourselves.
                if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);
                if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);
                triggerPressStart(e, state.pointerType);
                addGlobalListener(window, "scroll", onScroll, true);
            };
            pressProps.onTouchMove = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    if (!state.isOverTarget) {
                        state.isOverTarget = true;
                        triggerPressStart(e, state.pointerType);
                    }
                } else if (state.isOverTarget) {
                    state.isOverTarget = false;
                    triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            pressProps.onTouchEnd = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (!state.isPressed) return;
                let touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);
                if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {
                    triggerPressUp(e, state.pointerType);
                    triggerPressEnd(e, state.pointerType);
                } else if (state.isOverTarget) triggerPressEnd(e, state.pointerType, false);
                state.isPressed = false;
                state.activePointerId = null;
                state.isOverTarget = false;
                state.ignoreEmulatedMouseEvents = true;
                if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);
                removeAllGlobalListeners();
            };
            pressProps.onTouchCancel = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed) cancel(e);
            };
            let onScroll = (e)=>{
                if (state.isPressed && e.target.contains(state.target)) cancel({
                    currentTarget: state.target,
                    shiftKey: false,
                    ctrlKey: false,
                    metaKey: false,
                    altKey: false
                });
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                cancel(e);
            };
        }
        return pressProps;
    }, [
        addGlobalListener,
        isDisabled,
        preventFocusOnPress,
        removeAllGlobalListeners,
        allowTextSelectionOnPress,
        cancel,
        cancelOnPointerExit,
        triggerPressEnd,
        triggerPressStart,
        triggerPressUp
    ]);
    // Remove user-select: none in case component unmounts immediately after pressStart
    // eslint-disable-next-line arrow-body-style
    (0, $goTMa$react.useEffect)(()=>{
        return ()=>{
            if (!allowTextSelectionOnPress) // eslint-disable-next-line react-hooks/exhaustive-deps
            (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(ref.current.target);
        };
    }, [
        allowTextSelectionOnPress
    ]);
    return {
        isPressed: isPressedProp || isPressed,
        pressProps: (0, $goTMa$reactariautils.mergeProps)(domProps, pressProps)
    };
}
function $0294ea432cd92340$var$isHTMLAnchorLink(target) {
    return target.tagName === "A" && target.hasAttribute("href");
}
function $0294ea432cd92340$var$isValidKeyboardEvent(event, currentTarget) {
    const { key: key , code: code  } = event;
    const element = currentTarget;
    const role = element.getAttribute("role");
    // Accessibility for keyboards. Space and Enter only.
    // "Spacebar" is for IE 11
    return (key === "Enter" || key === " " || key === "Spacebar" || code === "Space") && !(element instanceof HTMLInputElement && !$0294ea432cd92340$var$isValidInputKey(element, key) || element instanceof HTMLTextAreaElement || element.isContentEditable) && // A link with a valid href should be handled natively,
    // unless it also has role='button' and was triggered using Space.
    (!$0294ea432cd92340$var$isHTMLAnchorLink(element) || role === "button" && key !== "Enter") && // An element with role='link' should only trigger with Enter key
    !(role === "link" && key !== "Enter");
}
function $0294ea432cd92340$var$getTouchFromEvent(event) {
    const { targetTouches: targetTouches  } = event;
    if (targetTouches.length > 0) return targetTouches[0];
    return null;
}
function $0294ea432cd92340$var$getTouchById(event, pointerId) {
    const changedTouches = event.changedTouches;
    for(let i = 0; i < changedTouches.length; i++){
        const touch = changedTouches[i];
        if (touch.identifier === pointerId) return touch;
    }
    return null;
}
function $0294ea432cd92340$var$createEvent(target, e) {
    return {
        currentTarget: target,
        shiftKey: e.shiftKey,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey
    };
}
function $0294ea432cd92340$var$getPointClientRect(point) {
    let offsetX = point.width / 2 || point.radiusX || 0;
    let offsetY = point.height / 2 || point.radiusY || 0;
    return {
        top: point.clientY - offsetY,
        right: point.clientX + offsetX,
        bottom: point.clientY + offsetY,
        left: point.clientX - offsetX
    };
}
function $0294ea432cd92340$var$areRectanglesOverlapping(a, b) {
    // check if they cannot overlap on x axis
    if (a.left > b.right || b.left > a.right) return false;
    // check if they cannot overlap on y axis
    if (a.top > b.bottom || b.top > a.bottom) return false;
    return true;
}
function $0294ea432cd92340$var$isOverTarget(point, target) {
    let rect = target.getBoundingClientRect();
    let pointRect = $0294ea432cd92340$var$getPointClientRect(point);
    return $0294ea432cd92340$var$areRectanglesOverlapping(rect, pointRect);
}
function $0294ea432cd92340$var$shouldPreventDefault(target) {
    // We cannot prevent default if the target is a draggable element.
    return !(target instanceof HTMLElement) || !target.draggable;
}
function $0294ea432cd92340$var$shouldPreventDefaultKeyboard(target, key) {
    if (target instanceof HTMLInputElement) return !$0294ea432cd92340$var$isValidInputKey(target, key);
    if (target instanceof HTMLButtonElement) return target.type !== "submit";
    return true;
}
const $0294ea432cd92340$var$nonTextInputTypes = new Set([
    "checkbox",
    "radio",
    "range",
    "color",
    "file",
    "image",
    "button",
    "submit",
    "reset"
]);
function $0294ea432cd92340$var$isValidInputKey(target, key) {
    // Only space should toggle checkboxes and radios, not enter.
    return target.type === "checkbox" || target.type === "radio" ? key === " " : $0294ea432cd92340$var$nonTextInputTypes.has(target.type);
}



const $e1dbec26039c051d$export$27c701ed9e449e99 = /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).forwardRef(({ children: children , ...props }, ref)=>{
    let newRef = (0, $goTMa$react.useRef)();
    ref = ref !== null && ref !== void 0 ? ref : newRef;
    let { pressProps: pressProps  } = (0, $0294ea432cd92340$export$45712eceda6fad21)({
        ...props,
        ref: ref
    });
    let child = (0, ($parcel$interopDefault($goTMa$react))).Children.only(children);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).cloneElement(child, // @ts-ignore
    {
        ref: ref,
        ...(0, $goTMa$reactariautils.mergeProps)(child.props, pressProps)
    });
});


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $3596bae48579386f$export$3351871ee4b288b8 = /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).forwardRef(({ children: children , ...props }, ref)=>{
    let isRegistered = (0, $goTMa$react.useRef)(false);
    let prevContext = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));
    let context = (0, $goTMa$reactariautils.mergeProps)(prevContext || {}, {
        ...props,
        ref: ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref),
        register () {
            isRegistered.current = true;
            if (prevContext) prevContext.register();
        }
    });
    (0, $goTMa$reactariautils.useSyncRef)(prevContext, ref);
    (0, $goTMa$react.useEffect)(()=>{
        if (!isRegistered.current) {
            console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.");
            isRegistered.current = true; // only warn once in strict mode.
        }
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($goTMa$react))).createElement((0, $01d3f539e91688c8$export$5165eccb35aaadb5).Provider, {
        value: context
    }, children);
});


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

class $625cf83917e112ad$export$905e7fc544a71f36 {
    isDefaultPrevented() {
        return this.nativeEvent.defaultPrevented;
    }
    preventDefault() {
        this.defaultPrevented = true;
        this.nativeEvent.preventDefault();
    }
    stopPropagation() {
        this.nativeEvent.stopPropagation();
        this.isPropagationStopped = ()=>true;
    }
    isPropagationStopped() {
        return false;
    }
    persist() {}
    constructor(type, nativeEvent){
        this.nativeEvent = nativeEvent;
        this.target = nativeEvent.target;
        this.currentTarget = nativeEvent.currentTarget;
        this.relatedTarget = nativeEvent.relatedTarget;
        this.bubbles = nativeEvent.bubbles;
        this.cancelable = nativeEvent.cancelable;
        this.defaultPrevented = nativeEvent.defaultPrevented;
        this.eventPhase = nativeEvent.eventPhase;
        this.isTrusted = nativeEvent.isTrusted;
        this.timeStamp = nativeEvent.timeStamp;
        this.type = type;
    }
}
function $625cf83917e112ad$export$715c682d09d639cc(onBlur) {
    let stateRef = (0, $goTMa$react.useRef)({
        isFocused: false,
        observer: null
    });
    // Clean up MutationObserver on unmount. See below.
    // eslint-disable-next-line arrow-body-style
    (0, $goTMa$reactariautils.useLayoutEffect)(()=>{
        const state = stateRef.current;
        return ()=>{
            if (state.observer) {
                state.observer.disconnect();
                state.observer = null;
            }
        };
    }, []);
    let dispatchBlur = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
    });
    // This function is called during a React onFocus event.
    return (0, $goTMa$react.useCallback)((e)=>{
        // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142
        // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a
        // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.
        // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.
        if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {
            stateRef.current.isFocused = true;
            let target = e.target;
            let onBlurHandler = (e)=>{
                stateRef.current.isFocused = false;
                if (target.disabled) // For backward compatibility, dispatch a (fake) React synthetic event.
                dispatchBlur(new $625cf83917e112ad$export$905e7fc544a71f36("blur", e));
                // We no longer need the MutationObserver once the target is blurred.
                if (stateRef.current.observer) {
                    stateRef.current.observer.disconnect();
                    stateRef.current.observer = null;
                }
            };
            target.addEventListener("focusout", onBlurHandler, {
                once: true
            });
            stateRef.current.observer = new MutationObserver(()=>{
                if (stateRef.current.isFocused && target.disabled) {
                    stateRef.current.observer.disconnect();
                    let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
                    target.dispatchEvent(new FocusEvent("blur", {
                        relatedTarget: relatedTargetEl
                    }));
                    target.dispatchEvent(new FocusEvent("focusout", {
                        bubbles: true,
                        relatedTarget: relatedTargetEl
                    }));
                }
            });
            stateRef.current.observer.observe(target, {
                attributes: true,
                attributeFilter: [
                    "disabled"
                ]
            });
        }
    }, [
        dispatchBlur
    ]);
}


function $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6(props) {
    let { isDisabled: isDisabled , onFocus: onFocusProp , onBlur: onBlurProp , onFocusChange: onFocusChange  } = props;
    const onBlur = (0, $goTMa$react.useCallback)((e)=>{
        if (e.target === e.currentTarget) {
            if (onBlurProp) onBlurProp(e);
            if (onFocusChange) onFocusChange(false);
            return true;
        }
    }, [
        onBlurProp,
        onFocusChange
    ]);
    const onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);
    const onFocus = (0, $goTMa$react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (e.target === e.currentTarget && document.activeElement === e.target) {
            if (onFocusProp) onFocusProp(e);
            if (onFocusChange) onFocusChange(true);
            onSyntheticFocus(e);
        }
    }, [
        onFocusChange,
        onFocusProp,
        onSyntheticFocus
    ]);
    return {
        focusProps: {
            onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,
            onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : undefined
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions



let $e77252a287ef94ab$var$currentModality = null;
let $e77252a287ef94ab$var$changeHandlers = new Set();
let $e77252a287ef94ab$var$hasSetupGlobalListeners = false;
let $e77252a287ef94ab$var$hasEventBeforeFocus = false;
let $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
// Only Tab or Esc keys will make focus visible on text input elements
const $e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS = {
    Tab: true,
    Escape: true
};
function $e77252a287ef94ab$var$triggerChangeHandlers(modality, e) {
    for (let handler of $e77252a287ef94ab$var$changeHandlers)handler(modality, e);
}
/**
 * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.
 */ function $e77252a287ef94ab$var$isValidKey(e) {
    // Control and Shift keys trigger when navigating back to the tab with keyboard.
    return !(e.metaKey || !(0, $goTMa$reactariautils.isMac)() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
function $e77252a287ef94ab$var$handleKeyboardEvent(e) {
    $e77252a287ef94ab$var$hasEventBeforeFocus = true;
    if ($e77252a287ef94ab$var$isValidKey(e)) {
        $e77252a287ef94ab$var$currentModality = "keyboard";
        $e77252a287ef94ab$var$triggerChangeHandlers("keyboard", e);
    }
}
function $e77252a287ef94ab$var$handlePointerEvent(e) {
    $e77252a287ef94ab$var$currentModality = "pointer";
    if (e.type === "mousedown" || e.type === "pointerdown") {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$triggerChangeHandlers("pointer", e);
    }
}
function $e77252a287ef94ab$var$handleClickEvent(e) {
    if ((0, $goTMa$reactariautils.isVirtualClick)(e)) {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        $e77252a287ef94ab$var$currentModality = "virtual";
    }
}
function $e77252a287ef94ab$var$handleFocusEvent(e) {
    // Firefox fires two extra focus events when the user first clicks into an iframe:
    // first on the window, then on the document. We ignore these events so they don't
    // cause keyboard focus rings to appear.
    if (e.target === window || e.target === document) return;
    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.
    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.
    if (!$e77252a287ef94ab$var$hasEventBeforeFocus && !$e77252a287ef94ab$var$hasBlurredWindowRecently) {
        $e77252a287ef94ab$var$currentModality = "virtual";
        $e77252a287ef94ab$var$triggerChangeHandlers("virtual", e);
    }
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = false;
}
function $e77252a287ef94ab$var$handleWindowBlur() {
    // When the window is blurred, reset state. This is necessary when tabbing out of the window,
    // for example, since a subsequent focus event won't be fired.
    $e77252a287ef94ab$var$hasEventBeforeFocus = false;
    $e77252a287ef94ab$var$hasBlurredWindowRecently = true;
}
/**
 * Setup global event listeners to control when keyboard focus style should be visible.
 */ function $e77252a287ef94ab$var$setupGlobalFocusEvents() {
    if (typeof window === "undefined" || $e77252a287ef94ab$var$hasSetupGlobalListeners) return;
    // Programmatic focus() calls shouldn't affect the current input modality.
    // However, we need to detect other cases when a focus event occurs without
    // a preceding user event (e.g. screen reader focus). Overriding the focus
    // method on HTMLElement.prototype is a bit hacky, but works.
    let focus = HTMLElement.prototype.focus;
    HTMLElement.prototype.focus = function() {
        $e77252a287ef94ab$var$hasEventBeforeFocus = true;
        focus.apply(this, arguments);
    };
    document.addEventListener("keydown", $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener("keyup", $e77252a287ef94ab$var$handleKeyboardEvent, true);
    document.addEventListener("click", $e77252a287ef94ab$var$handleClickEvent, true);
    // Register focus events on the window so they are sure to happen
    // before React's event listeners (registered on the document).
    window.addEventListener("focus", $e77252a287ef94ab$var$handleFocusEvent, true);
    window.addEventListener("blur", $e77252a287ef94ab$var$handleWindowBlur, false);
    if (typeof PointerEvent !== "undefined") {
        document.addEventListener("pointerdown", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("pointermove", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("pointerup", $e77252a287ef94ab$var$handlePointerEvent, true);
    } else {
        document.addEventListener("mousedown", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("mousemove", $e77252a287ef94ab$var$handlePointerEvent, true);
        document.addEventListener("mouseup", $e77252a287ef94ab$var$handlePointerEvent, true);
    }
    $e77252a287ef94ab$var$hasSetupGlobalListeners = true;
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e77252a287ef94ab$var$setupGlobalFocusEvents();
    else document.addEventListener("DOMContentLoaded", $e77252a287ef94ab$var$setupGlobalFocusEvents);
}
function $e77252a287ef94ab$export$b9b3dfddab17db27() {
    return $e77252a287ef94ab$var$currentModality !== "pointer";
}
function $e77252a287ef94ab$export$630ff653c5ada6a9() {
    return $e77252a287ef94ab$var$currentModality;
}
function $e77252a287ef94ab$export$8397ddfc504fdb9a(modality) {
    $e77252a287ef94ab$var$currentModality = modality;
    $e77252a287ef94ab$var$triggerChangeHandlers(modality, null);
}
function $e77252a287ef94ab$export$98e20ec92f614cfe() {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    let [modality, setModality] = (0, $goTMa$react.useState)($e77252a287ef94ab$var$currentModality);
    (0, $goTMa$react.useEffect)(()=>{
        let handler = ()=>{
            setModality($e77252a287ef94ab$var$currentModality);
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    }, []);
    return (0, $goTMa$reactariassr.useIsSSR)() ? null : modality;
}
/**
 * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that
 * focus visible style can be properly set.
 */ function $e77252a287ef94ab$var$isKeyboardFocusEvent(isTextInput, modality, e) {
    return !(isTextInput && modality === "keyboard" && e instanceof KeyboardEvent && !$e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);
}
function $e77252a287ef94ab$export$ffd9e5021c1fb2d6(props = {}) {
    let { isTextInput: isTextInput , autoFocus: autoFocus  } = props;
    let [isFocusVisibleState, setFocusVisible] = (0, $goTMa$react.useState)(autoFocus || $e77252a287ef94ab$export$b9b3dfddab17db27());
    $e77252a287ef94ab$export$ec71b4b83ac08ec3((isFocusVisible)=>{
        setFocusVisible(isFocusVisible);
    }, [
        isTextInput
    ], {
        isTextInput: isTextInput
    });
    return {
        isFocusVisible: isFocusVisibleState
    };
}
function $e77252a287ef94ab$export$ec71b4b83ac08ec3(fn, deps, opts) {
    $e77252a287ef94ab$var$setupGlobalFocusEvents();
    (0, $goTMa$react.useEffect)(()=>{
        let handler = (modality, e)=>{
            if (!$e77252a287ef94ab$var$isKeyboardFocusEvent(opts === null || opts === void 0 ? void 0 : opts.isTextInput, modality, e)) return;
            fn($e77252a287ef94ab$export$b9b3dfddab17db27());
        };
        $e77252a287ef94ab$var$changeHandlers.add(handler);
        return ()=>{
            $e77252a287ef94ab$var$changeHandlers.delete(handler);
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, deps);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $d16842bbd0359d1b$export$420e68273165f4ec(props) {
    let { isDisabled: isDisabled , onBlurWithin: onBlurWithin , onFocusWithin: onFocusWithin , onFocusWithinChange: onFocusWithinChange  } = props;
    let state = (0, $goTMa$react.useRef)({
        isFocusWithin: false
    });
    let onBlur = (0, $goTMa$react.useCallback)((e)=>{
        // We don't want to trigger onBlurWithin and then immediately onFocusWithin again
        // when moving focus inside the element. Only trigger if the currentTarget doesn't
        // include the relatedTarget (where focus is moving).
        if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {
            state.current.isFocusWithin = false;
            if (onBlurWithin) onBlurWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(false);
        }
    }, [
        onBlurWithin,
        onFocusWithinChange,
        state
    ]);
    let onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);
    let onFocus = (0, $goTMa$react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (!state.current.isFocusWithin && document.activeElement === e.target) {
            if (onFocusWithin) onFocusWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(true);
            state.current.isFocusWithin = true;
            onSyntheticFocus(e);
        }
    }, [
        onFocusWithin,
        onFocusWithinChange,
        onSyntheticFocus
    ]);
    if (isDisabled) return {
        focusWithinProps: {
            onFocus: null,
            onBlur: null
        }
    };
    return {
        focusWithinProps: {
            onFocus: onFocus,
            onBlur: onBlur
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

// iOS fires onPointerEnter twice: once with pointerType="touch" and again with pointerType="mouse".
// We want to ignore these emulated events so they do not trigger hover behavior.
// See https://bugs.webkit.org/show_bug.cgi?id=214609.
let $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
let $ffbc150311c75f01$var$hoverCount = 0;
function $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents() {
    $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = true;
    // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter
    // with pointerType="mouse" immediately after onPointerUp and before onFocus. On other
    // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in
    // the distant future because a user previously touched the element.
    setTimeout(()=>{
        $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;
    }, 50);
}
function $ffbc150311c75f01$var$handleGlobalPointerEvent(e) {
    if (e.pointerType === "touch") $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $ffbc150311c75f01$var$setupGlobalTouchEvents() {
    if (typeof document === "undefined") return;
    if (typeof PointerEvent !== "undefined") document.addEventListener("pointerup", $ffbc150311c75f01$var$handleGlobalPointerEvent);
    else document.addEventListener("touchend", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    $ffbc150311c75f01$var$hoverCount++;
    return ()=>{
        $ffbc150311c75f01$var$hoverCount--;
        if ($ffbc150311c75f01$var$hoverCount > 0) return;
        if (typeof PointerEvent !== "undefined") document.removeEventListener("pointerup", $ffbc150311c75f01$var$handleGlobalPointerEvent);
        else document.removeEventListener("touchend", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);
    };
}
function $ffbc150311c75f01$export$ae780daf29e6d456(props) {
    let { onHoverStart: onHoverStart , onHoverChange: onHoverChange , onHoverEnd: onHoverEnd , isDisabled: isDisabled  } = props;
    let [isHovered, setHovered] = (0, $goTMa$react.useState)(false);
    let state = (0, $goTMa$react.useRef)({
        isHovered: false,
        ignoreEmulatedMouseEvents: false,
        pointerType: "",
        target: null
    }).current;
    (0, $goTMa$react.useEffect)($ffbc150311c75f01$var$setupGlobalTouchEvents, []);
    let { hoverProps: hoverProps , triggerHoverEnd: triggerHoverEnd  } = (0, $goTMa$react.useMemo)(()=>{
        let triggerHoverStart = (event, pointerType)=>{
            state.pointerType = pointerType;
            if (isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target)) return;
            state.isHovered = true;
            let target = event.currentTarget;
            state.target = target;
            if (onHoverStart) onHoverStart({
                type: "hoverstart",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(true);
            setHovered(true);
        };
        let triggerHoverEnd = (event, pointerType)=>{
            state.pointerType = "";
            state.target = null;
            if (pointerType === "touch" || !state.isHovered) return;
            state.isHovered = false;
            let target = event.currentTarget;
            if (onHoverEnd) onHoverEnd({
                type: "hoverend",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(false);
            setHovered(false);
        };
        let hoverProps = {};
        if (typeof PointerEvent !== "undefined") {
            hoverProps.onPointerEnter = (e)=>{
                if ($ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents && e.pointerType === "mouse") return;
                triggerHoverStart(e, e.pointerType);
            };
            hoverProps.onPointerLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);
            };
        } else {
            hoverProps.onTouchStart = ()=>{
                state.ignoreEmulatedMouseEvents = true;
            };
            hoverProps.onMouseEnter = (e)=>{
                if (!state.ignoreEmulatedMouseEvents && !$ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, "mouse");
                state.ignoreEmulatedMouseEvents = false;
            };
            hoverProps.onMouseLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, "mouse");
            };
        }
        return {
            hoverProps: hoverProps,
            triggerHoverEnd: triggerHoverEnd
        };
    }, [
        onHoverStart,
        onHoverChange,
        onHoverEnd,
        isDisabled,
        state
    ]);
    (0, $goTMa$react.useEffect)(()=>{
        // Call the triggerHoverEnd as soon as isDisabled changes to true
        // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering
        if (isDisabled) triggerHoverEnd({
            currentTarget: state.target
        }, state.pointerType);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        isDisabled
    ]);
    return {
        hoverProps: hoverProps,
        isHovered: isHovered
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $edcfa848c42f94f4$export$872b660ac5a1ff98(props) {
    let { ref: ref , onInteractOutside: onInteractOutside , isDisabled: isDisabled , onInteractOutsideStart: onInteractOutsideStart  } = props;
    let stateRef = (0, $goTMa$react.useRef)({
        isPointerDown: false,
        ignoreEmulatedMouseEvents: false
    });
    let onPointerDown = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (onInteractOutside && $edcfa848c42f94f4$var$isValidEvent(e, ref)) {
            if (onInteractOutsideStart) onInteractOutsideStart(e);
            stateRef.current.isPointerDown = true;
        }
    });
    let triggerInteractOutside = (0, $goTMa$reactariautils.useEffectEvent)((e)=>{
        if (onInteractOutside) onInteractOutside(e);
    });
    (0, $goTMa$react.useEffect)(()=>{
        let state = stateRef.current;
        if (isDisabled) return;
        // Use pointer events if available. Otherwise, fall back to mouse and touch events.
        if (typeof PointerEvent !== "undefined") {
            let onPointerUp = (e)=>{
                if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            // changing these to capture phase fixed combobox
            document.addEventListener("pointerdown", onPointerDown, true);
            document.addEventListener("pointerup", onPointerUp, true);
            return ()=>{
                document.removeEventListener("pointerdown", onPointerDown, true);
                document.removeEventListener("pointerup", onPointerUp, true);
            };
        } else {
            let onMouseUp = (e)=>{
                if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;
                else if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            let onTouchEnd = (e)=>{
                state.ignoreEmulatedMouseEvents = true;
                if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            document.addEventListener("mousedown", onPointerDown, true);
            document.addEventListener("mouseup", onMouseUp, true);
            document.addEventListener("touchstart", onPointerDown, true);
            document.addEventListener("touchend", onTouchEnd, true);
            return ()=>{
                document.removeEventListener("mousedown", onPointerDown, true);
                document.removeEventListener("mouseup", onMouseUp, true);
                document.removeEventListener("touchstart", onPointerDown, true);
                document.removeEventListener("touchend", onTouchEnd, true);
            };
        }
    }, [
        ref,
        isDisabled,
        onPointerDown,
        triggerInteractOutside
    ]);
}
function $edcfa848c42f94f4$var$isValidEvent(event, ref) {
    if (event.button > 0) return false;
    if (event.target) {
        // if the event target is no longer in the document, ignore
        const ownerDocument = event.target.ownerDocument;
        if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;
        // If the target is within a top layer element (e.g. toasts), ignore.
        if (event.target.closest("[data-react-aria-top-layer]")) return false;
    }
    return ref.current && !ref.current.contains(event.target);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $951fbcbbca8db6ce$export$48d1ea6320830260(handler) {
    if (!handler) return;
    let shouldStopPropagation = true;
    return (e)=>{
        let event = {
            ...e,
            preventDefault () {
                e.preventDefault();
            },
            isDefaultPrevented () {
                return e.isDefaultPrevented();
            },
            stopPropagation () {
                console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
            },
            continuePropagation () {
                shouldStopPropagation = false;
            }
        };
        handler(event);
        if (shouldStopPropagation) e.stopPropagation();
    };
}


function $892d64db2a3c53b0$export$8f71654801c2f7cd(props) {
    return {
        keyboardProps: props.isDisabled ? {} : {
            onKeyDown: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyDown),
            onKeyUp: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyUp)
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $c09386fc48fa427d$export$36da96379f79f245(props) {
    let { onMoveStart: onMoveStart , onMove: onMove , onMoveEnd: onMoveEnd  } = props;
    let state = (0, $goTMa$react.useRef)({
        didMove: false,
        lastPosition: null,
        id: null
    });
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let move = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType, deltaX, deltaY)=>{
        if (deltaX === 0 && deltaY === 0) return;
        if (!state.current.didMove) {
            state.current.didMove = true;
            onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart({
                type: "movestart",
                pointerType: pointerType,
                shiftKey: originalEvent.shiftKey,
                metaKey: originalEvent.metaKey,
                ctrlKey: originalEvent.ctrlKey,
                altKey: originalEvent.altKey
            });
        }
        onMove({
            type: "move",
            pointerType: pointerType,
            deltaX: deltaX,
            deltaY: deltaY,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let end = (0, $goTMa$reactariautils.useEffectEvent)((originalEvent, pointerType)=>{
        (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)();
        if (state.current.didMove) onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd({
            type: "moveend",
            pointerType: pointerType,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let moveProps = (0, $goTMa$react.useMemo)(()=>{
        let moveProps = {};
        let start = ()=>{
            (0, $f7e14e656343df57$export$16a4697467175487)();
            state.current.didMove = false;
        };
        if (typeof PointerEvent === "undefined") {
            let onMouseMove = (e)=>{
                if (e.button === 0) {
                    move(e, "mouse", e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onMouseUp = (e)=>{
                if (e.button === 0) {
                    end(e, "mouse");
                    removeGlobalListener(window, "mousemove", onMouseMove, false);
                    removeGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            moveProps.onMouseDown = (e)=>{
                if (e.button === 0) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    addGlobalListener(window, "mousemove", onMouseMove, false);
                    addGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            let onTouchMove = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id);
                if (touch >= 0) {
                    let { pageX: pageX , pageY: pageY  } = e.changedTouches[touch];
                    move(e, "touch", pageX - state.current.lastPosition.pageX, pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: pageX,
                        pageY: pageY
                    };
                }
            };
            let onTouchEnd = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id);
                if (touch >= 0) {
                    end(e, "touch");
                    state.current.id = null;
                    removeGlobalListener(window, "touchmove", onTouchMove);
                    removeGlobalListener(window, "touchend", onTouchEnd);
                    removeGlobalListener(window, "touchcancel", onTouchEnd);
                }
            };
            moveProps.onTouchStart = (e)=>{
                if (e.changedTouches.length === 0 || state.current.id != null) return;
                let { pageX: pageX , pageY: pageY , identifier: identifier  } = e.changedTouches[0];
                start();
                e.stopPropagation();
                e.preventDefault();
                state.current.lastPosition = {
                    pageX: pageX,
                    pageY: pageY
                };
                state.current.id = identifier;
                addGlobalListener(window, "touchmove", onTouchMove, false);
                addGlobalListener(window, "touchend", onTouchEnd, false);
                addGlobalListener(window, "touchcancel", onTouchEnd, false);
            };
        } else {
            let onPointerMove = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    // Problems with PointerEvent#movementX/movementY:
                    // 1. it is always 0 on macOS Safari.
                    // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS
                    move(e, pointerType, e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    end(e, pointerType);
                    state.current.id = null;
                    removeGlobalListener(window, "pointermove", onPointerMove, false);
                    removeGlobalListener(window, "pointerup", onPointerUp, false);
                    removeGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
            moveProps.onPointerDown = (e)=>{
                if (e.button === 0 && state.current.id == null) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    state.current.id = e.pointerId;
                    addGlobalListener(window, "pointermove", onPointerMove, false);
                    addGlobalListener(window, "pointerup", onPointerUp, false);
                    addGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
        }
        let triggerKeyboardMove = (e, deltaX, deltaY)=>{
            start();
            move(e, "keyboard", deltaX, deltaY);
            end(e, "keyboard");
        };
        moveProps.onKeyDown = (e)=>{
            switch(e.key){
                case "Left":
                case "ArrowLeft":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, -1, 0);
                    break;
                case "Right":
                case "ArrowRight":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 1, 0);
                    break;
                case "Up":
                case "ArrowUp":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, -1);
                    break;
                case "Down":
                case "ArrowDown":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, 1);
                    break;
            }
        };
        return moveProps;
    }, [
        state,
        addGlobalListener,
        removeGlobalListener,
        move,
        end
    ]);
    return {
        moveProps: moveProps
    };
}



/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $a3dbce0aed7087e2$export$2123ff2b87c81ca(props, ref) {
    let { onScroll: onScroll , isDisabled: isDisabled  } = props;
    let onScrollHandler = (0, $goTMa$react.useCallback)((e)=>{
        // If the ctrlKey is pressed, this is a zoom event, do nothing.
        if (e.ctrlKey) return;
        // stop scrolling the page
        e.preventDefault();
        e.stopPropagation();
        if (onScroll) onScroll({
            deltaX: e.deltaX,
            deltaY: e.deltaY
        });
    }, [
        onScroll
    ]);
    (0, $goTMa$reactariautils.useEvent)(ref, "wheel", isDisabled ? null : onScrollHandler);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD = 500;
function $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9(props) {
    let { isDisabled: isDisabled , onLongPressStart: onLongPressStart , onLongPressEnd: onLongPressEnd , onLongPress: onLongPress , threshold: threshold = $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD , accessibilityDescription: accessibilityDescription  } = props;
    const timeRef = (0, $goTMa$react.useRef)(null);
    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = (0, $goTMa$reactariautils.useGlobalListeners)();
    let { pressProps: pressProps  } = (0, $0294ea432cd92340$export$45712eceda6fad21)({
        isDisabled: isDisabled,
        onPressStart (e) {
            if (e.pointerType === "mouse" || e.pointerType === "touch") {
                if (onLongPressStart) onLongPressStart({
                    ...e,
                    type: "longpressstart"
                });
                timeRef.current = setTimeout(()=>{
                    // Prevent other usePress handlers from also handling this event.
                    e.target.dispatchEvent(new PointerEvent("pointercancel", {
                        bubbles: true
                    }));
                    if (onLongPress) onLongPress({
                        ...e,
                        type: "longpress"
                    });
                    timeRef.current = null;
                }, threshold);
                // Prevent context menu, which may be opened on long press on touch devices
                if (e.pointerType === "touch") {
                    let onContextMenu = (e)=>{
                        e.preventDefault();
                    };
                    addGlobalListener(e.target, "contextmenu", onContextMenu, {
                        once: true
                    });
                    addGlobalListener(window, "pointerup", ()=>{
                        // If no contextmenu event is fired quickly after pointerup, remove the handler
                        // so future context menu events outside a long press are not prevented.
                        setTimeout(()=>{
                            removeGlobalListener(e.target, "contextmenu", onContextMenu);
                        }, 30);
                    }, {
                        once: true
                    });
                }
            }
        },
        onPressEnd (e) {
            if (timeRef.current) clearTimeout(timeRef.current);
            if (onLongPressEnd && (e.pointerType === "mouse" || e.pointerType === "touch")) onLongPressEnd({
                ...e,
                type: "longpressend"
            });
        }
    });
    let descriptionProps = (0, $goTMa$reactariautils.useDescription)(onLongPress && !isDisabled ? accessibilityDescription : null);
    return {
        longPressProps: (0, $goTMa$reactariautils.mergeProps)(pressProps, descriptionProps)
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 79452:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $4hxXn$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "SSRProvider", () => $29383e587d62412a$export$9f8ac96af4b1b2ae);
$parcel$export(module.exports, "useSSRSafeId", () => $29383e587d62412a$export$619500959fc48b26);
$parcel$export(module.exports, "useIsSSR", () => $29383e587d62412a$export$535bd6ca7f90a273);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We must avoid a circular dependency with @react-aria/utils, and this useLayoutEffect is
// guarded by a check that it only runs on the client side.
// eslint-disable-next-line rulesdir/useLayoutEffectRule

// Default context value to use in case there is no SSRProvider. This is fine for
// client-only apps. In order to support multiple copies of React Aria potentially
// being on the page at once, the prefix is set to a random number. SSRProvider
// will reset this to zero for consistency between server and client, so in the
// SSR case multiple copies of React Aria is not supported.
const $29383e587d62412a$var$defaultContext = {
    prefix: String(Math.round(Math.random() * 10000000000)),
    current: 0,
    isSSR: false
};
const $29383e587d62412a$var$SSRContext = /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createContext($29383e587d62412a$var$defaultContext);
// This is only used in React < 18.
function $29383e587d62412a$var$LegacySSRProvider(props) {
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let counter = $29383e587d62412a$var$useCounter(cur === $29383e587d62412a$var$defaultContext);
    let [isSSR, setIsSSR] = (0, $4hxXn$react.useState)(true);
    let value = (0, $4hxXn$react.useMemo)(()=>({
            // If this is the first SSRProvider, start with an empty string prefix, otherwise
            // append and increment the counter.
            prefix: cur === $29383e587d62412a$var$defaultContext ? "" : `${cur.prefix}-${counter}`,
            current: 0,
            isSSR: isSSR
        }), [
        cur,
        counter,
        isSSR
    ]);
    // If on the client, and the component was initially server rendered,
    // then schedule a layout effect to update the component after hydration.
    if (typeof window !== "undefined") // This if statement technically breaks the rules of hooks, but is safe
    // because the condition never changes after mounting.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, $4hxXn$react.useLayoutEffect)(()=>{
        setIsSSR(false);
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$SSRContext.Provider, {
        value: value
    }, props.children);
}
let $29383e587d62412a$var$warnedAboutSSRProvider = false;
function $29383e587d62412a$export$9f8ac96af4b1b2ae(props) {
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function") {
        if (!$29383e587d62412a$var$warnedAboutSSRProvider) {
            console.warn("In React 18, SSRProvider is not necessary and is a noop. You can remove it from your app.");
            $29383e587d62412a$var$warnedAboutSSRProvider = true;
        }
        return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement((0, ($parcel$interopDefault($4hxXn$react))).Fragment, null, props.children);
    }
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$LegacySSRProvider, props);
}
let $29383e587d62412a$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
let $29383e587d62412a$var$componentIds = new WeakMap();
function $29383e587d62412a$var$useCounter(isDisabled = false) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let ref = (0, $4hxXn$react.useRef)(null);
    // eslint-disable-next-line rulesdir/pure-render
    if (ref.current === null && !isDisabled) {
        var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner;
        // In strict mode, React renders components twice, and the ref will be reset to null on the second render.
        // This means our id counter will be incremented twice instead of once. This is a problem because on the
        // server, components are only rendered once and so ids generated on the server won't match the client.
        // In React 18, useId was introduced to solve this, but it is not available in older versions. So to solve this
        // we need to use some React internals to access the underlying Fiber instance, which is stable between renders.
        // This is exposed as ReactCurrentOwner in development, which is all we need since StrictMode only runs in development.
        // To ensure that we only increment the global counter once, we store the starting id for this component in
        // a weak map associated with the Fiber. On the second render, we reset the global counter to this value.
        // Since React runs the second render immediately after the first, this is safe.
        // @ts-ignore
        let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, ($parcel$interopDefault($4hxXn$react))).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;
        if (currentOwner) {
            let prevComponentValue = $29383e587d62412a$var$componentIds.get(currentOwner);
            if (prevComponentValue == null) // On the first render, and first call to useId, store the id and state in our weak map.
            $29383e587d62412a$var$componentIds.set(currentOwner, {
                id: ctx.current,
                state: currentOwner.memoizedState
            });
            else if (currentOwner.memoizedState !== prevComponentValue.state) {
                // On the second render, the memoizedState gets reset by React.
                // Reset the counter, and remove from the weak map so we don't
                // do this for subsequent useId calls.
                ctx.current = prevComponentValue.id;
                $29383e587d62412a$var$componentIds.delete(currentOwner);
            }
        }
        // eslint-disable-next-line rulesdir/pure-render
        ref.current = ++ctx.current;
    }
    // eslint-disable-next-line rulesdir/pure-render
    return ref.current;
}
function $29383e587d62412a$var$useLegacySSRSafeId(defaultId) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    // If we are rendering in a non-DOM environment, and there's no SSRProvider,
    // provide a warning to hint to the developer to add one.
    if (ctx === $29383e587d62412a$var$defaultContext && !$29383e587d62412a$var$canUseDOM) console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
    let counter = $29383e587d62412a$var$useCounter(!!defaultId);
    return defaultId || `react-aria${ctx.prefix}-${counter}`;
}
function $29383e587d62412a$var$useModernSSRSafeId(defaultId) {
    // @ts-ignore
    let id = (0, ($parcel$interopDefault($4hxXn$react))).useId();
    let [didSSR] = (0, $4hxXn$react.useState)($29383e587d62412a$export$535bd6ca7f90a273());
    let prefix = didSSR ? "react-aria" : `react-aria${$29383e587d62412a$var$defaultContext.prefix}`;
    return defaultId || `${prefix}-${id}`;
}
const $29383e587d62412a$export$619500959fc48b26 = typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function" ? $29383e587d62412a$var$useModernSSRSafeId : $29383e587d62412a$var$useLegacySSRSafeId;
function $29383e587d62412a$var$getSnapshot() {
    return false;
}
function $29383e587d62412a$var$getServerSnapshot() {
    return true;
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function $29383e587d62412a$var$subscribe(onStoreChange) {
    // noop
    return ()=>{};
}
function $29383e587d62412a$export$535bd6ca7f90a273() {
    // In React 18, we can use useSyncExternalStore to detect if we're server rendering or hydrating.
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"] === "function") return (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"]($29383e587d62412a$var$subscribe, $29383e587d62412a$var$getSnapshot, $29383e587d62412a$var$getServerSnapshot);
    // eslint-disable-next-line react-hooks/rules-of-hooks
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    return cur.isSSR;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 92538:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $1Yh1N$reactstatelyutils = __webpack_require__(12259);
var $1Yh1N$react = __webpack_require__(18038);
var $1Yh1N$reactariassr = __webpack_require__(79452);
var $1Yh1N$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useId", () => $8c61827343eed941$export$f680877a34711e37);
$parcel$export(module.exports, "mergeIds", () => $8c61827343eed941$export$cd8c9cb68f842629);
$parcel$export(module.exports, "useSlotId", () => $8c61827343eed941$export$b4cc09c592e8fdb8);
$parcel$export(module.exports, "chain", () => $1e2191638e54f613$export$e08e3b67e392101e);
$parcel$export(module.exports, "mergeProps", () => $f847cd1382ea7cd4$export$9d1611c77c2fe928);
$parcel$export(module.exports, "mergeRefs", () => $f05dc24eafaeb7e2$export$c9058316764c140e);
$parcel$export(module.exports, "filterDOMProps", () => $8d15d0e1797d4238$export$457c3d6518dd4c6f);
$parcel$export(module.exports, "focusWithoutScrolling", () => $1117b6c0d4c4c164$export$de79e2c695e052f3);
$parcel$export(module.exports, "getOffset", () => $16ec41ef3e36c19c$export$622cea445a1c5b7d);
$parcel$export(module.exports, "runAfterTransition", () => $e8117ebcab55be6a$export$24490316f764c430);
$parcel$export(module.exports, "useDrag1D", () => $28ed3fb20343b78b$export$7bbed75feba39706);
$parcel$export(module.exports, "useGlobalListeners", () => $4571ff54ac709100$export$4eaf04e54aa8eed6);
$parcel$export(module.exports, "useLabels", () => $6ec78bde395c477d$export$d6875122194c7b44);
$parcel$export(module.exports, "useObjectRef", () => $475b35fe72ba49b3$export$4338b53315abf666);
$parcel$export(module.exports, "useUpdateEffect", () => $29293a6f5c75b37e$export$496315a1608d9602);
$parcel$export(module.exports, "useLayoutEffect", () => $78605a5d7424e31b$export$e5c5a5f917a5871c);
$parcel$export(module.exports, "useResizeObserver", () => $37733e1652f47193$export$683480f191c0e3ea);
$parcel$export(module.exports, "useSyncRef", () => $6fc733991a9f977c$export$4debdb1a3f0fa79e);
$parcel$export(module.exports, "getScrollParent", () => $d796e7157ac96470$export$cfa2225e87938781);
$parcel$export(module.exports, "isScrollable", () => $d796e7157ac96470$export$2bb74740c4e19def);
$parcel$export(module.exports, "useViewportSize", () => $8b24bab62f5c65ad$export$d699905dd57c73ca);
$parcel$export(module.exports, "useDescription", () => $34da4502ea8120db$export$f8aeda7b10753fa1);
$parcel$export(module.exports, "isMac", () => $9e20cff0af27e8cc$export$9ac100e40613ea10);
$parcel$export(module.exports, "isIPhone", () => $9e20cff0af27e8cc$export$186c6964ca17d99);
$parcel$export(module.exports, "isIPad", () => $9e20cff0af27e8cc$export$7bef049ce92e4224);
$parcel$export(module.exports, "isIOS", () => $9e20cff0af27e8cc$export$fedb369cb70207f1);
$parcel$export(module.exports, "isAppleDevice", () => $9e20cff0af27e8cc$export$e1865c3bedcd822b);
$parcel$export(module.exports, "isWebKit", () => $9e20cff0af27e8cc$export$78551043582a6a98);
$parcel$export(module.exports, "isChrome", () => $9e20cff0af27e8cc$export$6446a186d09e379e);
$parcel$export(module.exports, "isAndroid", () => $9e20cff0af27e8cc$export$a11b0059900ceec8);
$parcel$export(module.exports, "useEvent", () => $2a8c0bb1629926c8$export$90fc3a17d93f704c);
$parcel$export(module.exports, "useValueEffect", () => $19a2307bfabafaf1$export$14d238f342723f25);
$parcel$export(module.exports, "scrollIntoView", () => $449412113267a1fe$export$53a0910f038337bd);
$parcel$export(module.exports, "scrollIntoViewport", () => $449412113267a1fe$export$c826860796309d1b);
$parcel$export(module.exports, "clamp", () => $1Yh1N$reactstatelyutils.clamp);
$parcel$export(module.exports, "snapValueToStep", () => $1Yh1N$reactstatelyutils.snapValueToStep);
$parcel$export(module.exports, "isVirtualClick", () => $577e795361f19be9$export$60278871457622de);
$parcel$export(module.exports, "isVirtualPointerEvent", () => $577e795361f19be9$export$29bf1b5f2c56cf63);
$parcel$export(module.exports, "useEffectEvent", () => $1254e5bb94ac8761$export$7f54fc3180508a52);
$parcel$export(module.exports, "useDeepMemo", () => $20e6e72fbf5dc81e$export$722debc0e56fea39);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $78605a5d7424e31b$export$e5c5a5f917a5871c = typeof window !== "undefined" ? (0, ($parcel$interopDefault($1Yh1N$react))).useLayoutEffect : ()=>{};



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $19a2307bfabafaf1$export$14d238f342723f25(defaultValue) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultValue);
    let valueRef = (0, $1Yh1N$react.useRef)(value);
    let effect = (0, $1Yh1N$react.useRef)(null);
    // Must be stable so that `queue` is stable.
    let nextIter = (0, $1Yh1N$react.useCallback)(()=>{
        // Run the generator to the next yield.
        let newValue = effect.current.next();
        while(!newValue.done && valueRef.current === newValue.value)// If the value is the same as the current value,
        // then continue to the next yield. Otherwise,
        // set the value in state and wait for the next layout effect.
        newValue = effect.current.next();
        // If the generator is done, reset the effect.
        if (newValue.done) {
            effect.current = null;
            return;
        }
        // Always update valueRef when setting the state.
        // This is needed because the function is not regenerated with the new state value since
        // they must be stable across renders. Instead, it gets carried in the ref, but the setState
        // is also needed in order to cause a rerender.
        setValue(newValue.value);
        valueRef.current = newValue.value;
    // this list of dependencies is stable, setState and refs never change after first render.
    }, [
        setValue,
        valueRef,
        effect
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        // If there is an effect currently running, continue to the next yield.
        if (effect.current) nextIter();
    });
    // queue must be a stable function, much like setState.
    let queue = (0, $1Yh1N$react.useCallback)((fn)=>{
        effect.current = fn(valueRef.current);
        nextIter();
    // this list of dependencies is stable, setState and refs never change after first render.
    // in addition, nextIter is stable as outlined above
    }, [
        nextIter,
        effect,
        valueRef
    ]);
    return [
        value,
        queue
    ];
}


let $8c61827343eed941$var$idsUpdaterMap = new Map();
function $8c61827343eed941$export$f680877a34711e37(defaultId) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultId);
    let nextId = (0, $1Yh1N$react.useRef)(null);
    let res = (0, $1Yh1N$reactariassr.useSSRSafeId)(value);
    let updateValue = (0, $1Yh1N$react.useCallback)((val)=>{
        nextId.current = val;
    }, []);
    $8c61827343eed941$var$idsUpdaterMap.set(res, updateValue);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        let r = res;
        return ()=>{
            $8c61827343eed941$var$idsUpdaterMap.delete(r);
        };
    }, [
        res
    ]);
    // This cannot cause an infinite loop because the ref is updated first.
    // eslint-disable-next-line
    (0, $1Yh1N$react.useEffect)(()=>{
        let newId = nextId.current;
        if (newId) {
            nextId.current = null;
            setValue(newId);
        }
    });
    return res;
}
function $8c61827343eed941$export$cd8c9cb68f842629(idA, idB) {
    if (idA === idB) return idA;
    let setIdA = $8c61827343eed941$var$idsUpdaterMap.get(idA);
    if (setIdA) {
        setIdA(idB);
        return idB;
    }
    let setIdB = $8c61827343eed941$var$idsUpdaterMap.get(idB);
    if (setIdB) {
        setIdB(idA);
        return idA;
    }
    return idB;
}
function $8c61827343eed941$export$b4cc09c592e8fdb8(depArray = []) {
    let id = $8c61827343eed941$export$f680877a34711e37();
    let [resolvedId, setResolvedId] = (0, $19a2307bfabafaf1$export$14d238f342723f25)(id);
    let updateId = (0, $1Yh1N$react.useCallback)(()=>{
        setResolvedId(function*() {
            yield id;
            yield document.getElementById(id) ? id : undefined;
        });
    }, [
        id,
        setResolvedId
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(updateId, [
        id,
        updateId,
        ...depArray
    ]);
    return resolvedId;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /**
 * Calls all functions in the order they were chained with the same arguments.
 */ function $1e2191638e54f613$export$e08e3b67e392101e(...callbacks) {
    return (...args)=>{
        for (let callback of callbacks)if (typeof callback === "function") callback(...args);
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $f847cd1382ea7cd4$export$9d1611c77c2fe928(...args) {
    // Start with a base clone of the first argument. This is a lot faster than starting
    // with an empty object and adding properties as we go.
    let result = {
        ...args[0]
    };
    for(let i = 1; i < args.length; i++){
        let props = args[i];
        for(let key in props){
            let a = result[key];
            let b = props[key];
            // Chain events
            if (typeof a === "function" && typeof b === "function" && // This is a lot faster than a regex.
            key[0] === "o" && key[1] === "n" && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = (0, $1e2191638e54f613$export$e08e3b67e392101e)(a, b);
            else if ((key === "className" || key === "UNSAFE_className") && typeof a === "string" && typeof b === "string") result[key] = (0, ($parcel$interopDefault($1Yh1N$clsx)))(a, b);
            else if (key === "id" && a && b) result.id = (0, $8c61827343eed941$export$cd8c9cb68f842629)(a, b);
            else result[key] = b !== undefined ? b : a;
        }
    }
    return result;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $f05dc24eafaeb7e2$export$c9058316764c140e(...refs) {
    if (refs.length === 1) return refs[0];
    return (value)=>{
        for (let ref of refs){
            if (typeof ref === "function") ref(value);
            else if (ref != null) ref.current = value;
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ const $8d15d0e1797d4238$var$DOMPropNames = new Set([
    "id"
]);
const $8d15d0e1797d4238$var$labelablePropNames = new Set([
    "aria-label",
    "aria-labelledby",
    "aria-describedby",
    "aria-details"
]);
const $8d15d0e1797d4238$var$propRe = /^(data-.*)$/;
function $8d15d0e1797d4238$export$457c3d6518dd4c6f(props, opts = {}) {
    let { labelable: labelable , propNames: propNames  } = opts;
    let filteredProps = {};
    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($8d15d0e1797d4238$var$DOMPropNames.has(prop) || labelable && $8d15d0e1797d4238$var$labelablePropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $8d15d0e1797d4238$var$propRe.test(prop))) filteredProps[prop] = props[prop];
    return filteredProps;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $1117b6c0d4c4c164$export$de79e2c695e052f3(element) {
    if ($1117b6c0d4c4c164$var$supportsPreventScroll()) element.focus({
        preventScroll: true
    });
    else {
        let scrollableElements = $1117b6c0d4c4c164$var$getScrollableElements(element);
        element.focus();
        $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements);
    }
}
let $1117b6c0d4c4c164$var$supportsPreventScrollCached = null;
function $1117b6c0d4c4c164$var$supportsPreventScroll() {
    if ($1117b6c0d4c4c164$var$supportsPreventScrollCached == null) {
        $1117b6c0d4c4c164$var$supportsPreventScrollCached = false;
        try {
            var focusElem = document.createElement("div");
            focusElem.focus({
                get preventScroll () {
                    $1117b6c0d4c4c164$var$supportsPreventScrollCached = true;
                    return true;
                }
            });
        } catch (e) {
        // Ignore
        }
    }
    return $1117b6c0d4c4c164$var$supportsPreventScrollCached;
}
function $1117b6c0d4c4c164$var$getScrollableElements(element) {
    var parent = element.parentNode;
    var scrollableElements = [];
    var rootScrollingElement = document.scrollingElement || document.documentElement;
    while(parent instanceof HTMLElement && parent !== rootScrollingElement){
        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({
            element: parent,
            scrollTop: parent.scrollTop,
            scrollLeft: parent.scrollLeft
        });
        parent = parent.parentNode;
    }
    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
        element: rootScrollingElement,
        scrollTop: rootScrollingElement.scrollTop,
        scrollLeft: rootScrollingElement.scrollLeft
    });
    return scrollableElements;
}
function $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements) {
    for (let { element: element , scrollTop: scrollTop , scrollLeft: scrollLeft  } of scrollableElements){
        element.scrollTop = scrollTop;
        element.scrollLeft = scrollLeft;
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $16ec41ef3e36c19c$export$622cea445a1c5b7d(element, reverse, orientation = "horizontal") {
    let rect = element.getBoundingClientRect();
    if (reverse) return orientation === "horizontal" ? rect.right : rect.bottom;
    return orientation === "horizontal" ? rect.left : rect.top;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We store a global list of elements that are currently transitioning,
// mapped to a set of CSS properties that are transitioning for that element.
// This is necessary rather than a simple count of transitions because of browser
// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather
// than one or the other. So we need to track what's actually transitioning so that
// we can ignore these duplicate events.
let $e8117ebcab55be6a$var$transitionsByElement = new Map();
// A list of callbacks to call once there are no transitioning elements.
let $e8117ebcab55be6a$var$transitionCallbacks = new Set();
function $e8117ebcab55be6a$var$setupGlobalEvents() {
    if (typeof window === "undefined") return;
    let onTransitionStart = (e)=>{
        // Add the transitioning property to the list for this element.
        let transitions = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!transitions) {
            transitions = new Set();
            $e8117ebcab55be6a$var$transitionsByElement.set(e.target, transitions);
            // The transitioncancel event must be registered on the element itself, rather than as a global
            // event. This enables us to handle when the node is deleted from the document while it is transitioning.
            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.
            e.target.addEventListener("transitioncancel", onTransitionEnd);
        }
        transitions.add(e.propertyName);
    };
    let onTransitionEnd = (e)=>{
        // Remove property from list of transitioning properties.
        let properties = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!properties) return;
        properties.delete(e.propertyName);
        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.
        if (properties.size === 0) {
            e.target.removeEventListener("transitioncancel", onTransitionEnd);
            $e8117ebcab55be6a$var$transitionsByElement.delete(e.target);
        }
        // If no transitioning elements, call all of the queued callbacks.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) {
            for (let cb of $e8117ebcab55be6a$var$transitionCallbacks)cb();
            $e8117ebcab55be6a$var$transitionCallbacks.clear();
        }
    };
    document.body.addEventListener("transitionrun", onTransitionStart);
    document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e8117ebcab55be6a$var$setupGlobalEvents();
    else document.addEventListener("DOMContentLoaded", $e8117ebcab55be6a$var$setupGlobalEvents);
}
function $e8117ebcab55be6a$export$24490316f764c430(fn) {
    // Wait one frame to see if an animation starts, e.g. a transition on mount.
    requestAnimationFrame(()=>{
        // If no transitions are running, call the function immediately.
        // Otherwise, add it to a list of callbacks to run at the end of the animation.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) fn();
        else $e8117ebcab55be6a$var$transitionCallbacks.add(fn);
    });
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 

// Keep track of elements that we are currently handling dragging for via useDrag1D.
// If there's an ancestor and a descendant both using useDrag1D(), and the user starts
// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.
const $28ed3fb20343b78b$var$draggingElements = [];
function $28ed3fb20343b78b$export$7bbed75feba39706(props) {
    console.warn("useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html");
    let { containerRef: containerRef , reverse: reverse , orientation: orientation , onHover: onHover , onDrag: onDrag , onPositionChange: onPositionChange , onIncrement: onIncrement , onDecrement: onDecrement , onIncrementToMax: onIncrementToMax , onDecrementToMin: onDecrementToMin , onCollapseToggle: onCollapseToggle  } = props;
    let getPosition = (e)=>orientation === "horizontal" ? e.clientX : e.clientY;
    let getNextOffset = (e)=>{
        let containerOffset = (0, $16ec41ef3e36c19c$export$622cea445a1c5b7d)(containerRef.current, reverse, orientation);
        let mouseOffset = getPosition(e);
        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;
        return nextOffset;
    };
    let dragging = (0, $1Yh1N$react.useRef)(false);
    let prevPosition = (0, $1Yh1N$react.useRef)(0);
    // Keep track of the current handlers in a ref so that the events can access them.
    let handlers = (0, $1Yh1N$react.useRef)({
        onPositionChange: onPositionChange,
        onDrag: onDrag
    });
    handlers.current.onDrag = onDrag;
    handlers.current.onPositionChange = onPositionChange;
    let onMouseDragged = (e)=>{
        e.preventDefault();
        let nextOffset = getNextOffset(e);
        if (!dragging.current) {
            dragging.current = true;
            if (handlers.current.onDrag) handlers.current.onDrag(true);
            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        }
        if (prevPosition.current === nextOffset) return;
        prevPosition.current = nextOffset;
        if (onPositionChange) onPositionChange(nextOffset);
    };
    let onMouseUp = (e)=>{
        const target = e.target;
        dragging.current = false;
        let nextOffset = getNextOffset(e);
        if (handlers.current.onDrag) handlers.current.onDrag(false);
        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        $28ed3fb20343b78b$var$draggingElements.splice($28ed3fb20343b78b$var$draggingElements.indexOf(target), 1);
        window.removeEventListener("mouseup", onMouseUp, false);
        window.removeEventListener("mousemove", onMouseDragged, false);
    };
    let onMouseDown = (e)=>{
        const target = e.currentTarget;
        // If we're already handling dragging on a descendant with useDrag1D, then
        // we don't want to handle the drag motion on this target as well.
        if ($28ed3fb20343b78b$var$draggingElements.some((elt)=>target.contains(elt))) return;
        $28ed3fb20343b78b$var$draggingElements.push(target);
        window.addEventListener("mousemove", onMouseDragged, false);
        window.addEventListener("mouseup", onMouseUp, false);
    };
    let onMouseEnter = ()=>{
        if (onHover) onHover(true);
    };
    let onMouseOut = ()=>{
        if (onHover) onHover(false);
    };
    let onKeyDown = (e)=>{
        switch(e.key){
            case "Left":
            case "ArrowLeft":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Up":
            case "ArrowUp":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Right":
            case "ArrowRight":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Down":
            case "ArrowDown":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Home":
                e.preventDefault();
                if (onDecrementToMin) onDecrementToMin();
                break;
            case "End":
                e.preventDefault();
                if (onIncrementToMax) onIncrementToMax();
                break;
            case "Enter":
                e.preventDefault();
                if (onCollapseToggle) onCollapseToggle();
                break;
        }
    };
    return {
        onMouseDown: onMouseDown,
        onMouseEnter: onMouseEnter,
        onMouseOut: onMouseOut,
        onKeyDown: onKeyDown
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $4571ff54ac709100$export$4eaf04e54aa8eed6() {
    let globalListeners = (0, $1Yh1N$react.useRef)(new Map());
    let addGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        // Make sure we remove the listener after it is called with the `once` option.
        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{
            globalListeners.current.delete(listener);
            listener(...args);
        } : listener;
        globalListeners.current.set(listener, {
            type: type,
            eventTarget: eventTarget,
            fn: fn,
            options: options
        });
        eventTarget.addEventListener(type, listener, options);
    }, []);
    let removeGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        var _globalListeners_current_get;
        let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
        eventTarget.removeEventListener(type, fn, options);
        globalListeners.current.delete(listener);
    }, []);
    let removeAllGlobalListeners = (0, $1Yh1N$react.useCallback)(()=>{
        globalListeners.current.forEach((value, key)=>{
            removeGlobalListener(value.eventTarget, value.type, key, value.options);
        });
    }, [
        removeGlobalListener
    ]);
    // eslint-disable-next-line arrow-body-style
    (0, $1Yh1N$react.useEffect)(()=>{
        return removeAllGlobalListeners;
    }, [
        removeAllGlobalListeners
    ]);
    return {
        addGlobalListener: addGlobalListener,
        removeGlobalListener: removeGlobalListener,
        removeAllGlobalListeners: removeAllGlobalListeners
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6ec78bde395c477d$export$d6875122194c7b44(props, defaultLabel) {
    let { id: id , "aria-label": label , "aria-labelledby": labelledBy  } = props;
    // If there is both an aria-label and aria-labelledby,
    // combine them by pointing to the element itself.
    id = (0, $8c61827343eed941$export$f680877a34711e37)(id);
    if (labelledBy && label) {
        let ids = new Set([
            id,
            ...labelledBy.trim().split(/\s+/)
        ]);
        labelledBy = [
            ...ids
        ].join(" ");
    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\s+/).join(" ");
    // If no labels are provided, use the default
    if (!label && !labelledBy && defaultLabel) label = defaultLabel;
    return {
        id: id,
        "aria-label": label,
        "aria-labelledby": labelledBy
    };
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $475b35fe72ba49b3$export$4338b53315abf666(forwardedRef) {
    const objRef = (0, $1Yh1N$react.useRef)();
    return (0, $1Yh1N$react.useMemo)(()=>({
            get current () {
                return objRef.current;
            },
            set current (value){
                objRef.current = value;
                if (typeof forwardedRef === "function") forwardedRef(value);
                else if (forwardedRef) forwardedRef.current = value;
            }
        }), [
        forwardedRef
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $29293a6f5c75b37e$export$496315a1608d9602(effect, dependencies) {
    const isInitialMount = (0, $1Yh1N$react.useRef)(true);
    const lastDeps = (0, $1Yh1N$react.useRef)(null);
    (0, $1Yh1N$react.useEffect)(()=>{
        isInitialMount.current = true;
        return ()=>{
            isInitialMount.current = false;
        };
    }, []);
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isInitialMount.current) isInitialMount.current = false;
        else if (!lastDeps.current || dependencies.some((dep, i)=>!Object.is(dep, lastDeps[i]))) effect();
        lastDeps.current = dependencies;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencies);
}




function $37733e1652f47193$var$hasResizeObserver() {
    return typeof window.ResizeObserver !== "undefined";
}
function $37733e1652f47193$export$683480f191c0e3ea(options) {
    const { ref: ref , onResize: onResize  } = options;
    (0, $1Yh1N$react.useEffect)(()=>{
        let element = ref === null || ref === void 0 ? void 0 : ref.current;
        if (!element) return;
        if (!$37733e1652f47193$var$hasResizeObserver()) {
            window.addEventListener("resize", onResize, false);
            return ()=>{
                window.removeEventListener("resize", onResize, false);
            };
        } else {
            const resizeObserverInstance = new window.ResizeObserver((entries)=>{
                if (!entries.length) return;
                onResize();
            });
            resizeObserverInstance.observe(element);
            return ()=>{
                if (element) resizeObserverInstance.unobserve(element);
            };
        }
    }, [
        onResize,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6fc733991a9f977c$export$4debdb1a3f0fa79e(context, ref) {
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (context && context.ref && ref) {
            context.ref.current = ref.current;
            return ()=>{
                context.ref.current = null;
            };
        }
    }, [
        context,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d796e7157ac96470$export$cfa2225e87938781(node) {
    if ($d796e7157ac96470$export$2bb74740c4e19def(node)) node = node.parentElement;
    while(node && !$d796e7157ac96470$export$2bb74740c4e19def(node))node = node.parentElement;
    return node || document.scrollingElement || document.documentElement;
}
function $d796e7157ac96470$export$2bb74740c4e19def(node) {
    let style = window.getComputedStyle(node);
    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// @ts-ignore
let $8b24bab62f5c65ad$var$visualViewport = typeof window !== "undefined" && window.visualViewport;
function $8b24bab62f5c65ad$export$d699905dd57c73ca() {
    let [size, setSize] = (0, $1Yh1N$react.useState)(()=>$8b24bab62f5c65ad$var$getViewportSize());
    (0, $1Yh1N$react.useEffect)(()=>{
        // Use visualViewport api to track available height even on iOS virtual keyboard opening
        let onResize = ()=>{
            setSize((size)=>{
                let newSize = $8b24bab62f5c65ad$var$getViewportSize();
                if (newSize.width === size.width && newSize.height === size.height) return size;
                return newSize;
            });
        };
        if (!$8b24bab62f5c65ad$var$visualViewport) window.addEventListener("resize", onResize);
        else $8b24bab62f5c65ad$var$visualViewport.addEventListener("resize", onResize);
        return ()=>{
            if (!$8b24bab62f5c65ad$var$visualViewport) window.removeEventListener("resize", onResize);
            else $8b24bab62f5c65ad$var$visualViewport.removeEventListener("resize", onResize);
        };
    }, []);
    return size;
}
function $8b24bab62f5c65ad$var$getViewportSize() {
    return {
        width: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.width) || window.innerWidth,
        height: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.height) || window.innerHeight
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

let $34da4502ea8120db$var$descriptionId = 0;
const $34da4502ea8120db$var$descriptionNodes = new Map();
function $34da4502ea8120db$export$f8aeda7b10753fa1(description) {
    let [id, setId] = (0, $1Yh1N$react.useState)(undefined);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (!description) return;
        let desc = $34da4502ea8120db$var$descriptionNodes.get(description);
        if (!desc) {
            let id = `react-aria-description-${$34da4502ea8120db$var$descriptionId++}`;
            setId(id);
            let node = document.createElement("div");
            node.id = id;
            node.style.display = "none";
            node.textContent = description;
            document.body.appendChild(node);
            desc = {
                refCount: 0,
                element: node
            };
            $34da4502ea8120db$var$descriptionNodes.set(description, desc);
        } else setId(desc.element.id);
        desc.refCount++;
        return ()=>{
            if (--desc.refCount === 0) {
                desc.element.remove();
                $34da4502ea8120db$var$descriptionNodes.delete(description);
            }
        };
    }, [
        description
    ]);
    return {
        "aria-describedby": description ? id : undefined
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $9e20cff0af27e8cc$var$testUserAgent(re) {
    var _window_navigator_userAgentData;
    if (typeof window === "undefined" || window.navigator == null) return false;
    return ((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand)=>re.test(brand.brand))) || re.test(window.navigator.userAgent);
}
function $9e20cff0af27e8cc$var$testPlatform(re) {
    var _window_navigator_userAgentData;
    return typeof window !== "undefined" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $9e20cff0af27e8cc$export$9ac100e40613ea10() {
    return $9e20cff0af27e8cc$var$testPlatform(/^Mac/i);
}
function $9e20cff0af27e8cc$export$186c6964ca17d99() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPhone/i);
}
function $9e20cff0af27e8cc$export$7bef049ce92e4224() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
    $9e20cff0af27e8cc$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
}
function $9e20cff0af27e8cc$export$fedb369cb70207f1() {
    return $9e20cff0af27e8cc$export$186c6964ca17d99() || $9e20cff0af27e8cc$export$7bef049ce92e4224();
}
function $9e20cff0af27e8cc$export$e1865c3bedcd822b() {
    return $9e20cff0af27e8cc$export$9ac100e40613ea10() || $9e20cff0af27e8cc$export$fedb369cb70207f1();
}
function $9e20cff0af27e8cc$export$78551043582a6a98() {
    return $9e20cff0af27e8cc$var$testUserAgent(/AppleWebKit/i) && !$9e20cff0af27e8cc$export$6446a186d09e379e();
}
function $9e20cff0af27e8cc$export$6446a186d09e379e() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Chrome/i);
}
function $9e20cff0af27e8cc$export$a11b0059900ceec8() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Android/i);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1254e5bb94ac8761$export$7f54fc3180508a52(fn) {
    const ref = (0, $1Yh1N$react.useRef)(null);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        ref.current = fn;
    }, [
        fn
    ]);
    return (0, $1Yh1N$react.useCallback)((...args)=>{
        const f = ref.current;
        return f(...args);
    }, []);
}


function $2a8c0bb1629926c8$export$90fc3a17d93f704c(ref, event, handler, options) {
    let handleEvent = (0, $1254e5bb94ac8761$export$7f54fc3180508a52)(handler);
    let isDisabled = handler == null;
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isDisabled) return;
        let element = ref.current;
        element.addEventListener(event, handleEvent, options);
        return ()=>{
            element.removeEventListener(event, handleEvent, options);
        };
    }, [
        ref,
        event,
        options,
        isDisabled,
        handleEvent
    ]);
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $449412113267a1fe$export$53a0910f038337bd(scrollView, element) {
    let offsetX = $449412113267a1fe$var$relativeOffset(scrollView, element, "left");
    let offsetY = $449412113267a1fe$var$relativeOffset(scrollView, element, "top");
    let width = element.offsetWidth;
    let height = element.offsetHeight;
    let x = scrollView.scrollLeft;
    let y = scrollView.scrollTop;
    // Account for top/left border offsetting the scroll top/Left
    let { borderTopWidth: borderTopWidth , borderLeftWidth: borderLeftWidth  } = getComputedStyle(scrollView);
    let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);
    let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);
    // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width
    let maxX = borderAdjustedX + scrollView.clientWidth;
    let maxY = borderAdjustedY + scrollView.clientHeight;
    if (offsetX <= x) x = offsetX - parseInt(borderLeftWidth, 10);
    else if (offsetX + width > maxX) x += offsetX + width - maxX;
    if (offsetY <= borderAdjustedY) y = offsetY - parseInt(borderTopWidth, 10);
    else if (offsetY + height > maxY) y += offsetY + height - maxY;
    scrollView.scrollLeft = x;
    scrollView.scrollTop = y;
}
/**
 * Computes the offset left or top from child to ancestor by accumulating
 * offsetLeft or offsetTop through intervening offsetParents.
 */ function $449412113267a1fe$var$relativeOffset(ancestor, child, axis) {
    const prop = axis === "left" ? "offsetLeft" : "offsetTop";
    let sum = 0;
    while(child.offsetParent){
        sum += child[prop];
        if (child.offsetParent === ancestor) break;
        else if (child.offsetParent.contains(ancestor)) {
            // If the ancestor is not `position:relative`, then we stop at
            // _its_ offset parent, and we subtract off _its_ offset, so that
            // we end up with the proper offset from child to ancestor.
            sum -= ancestor[prop];
            break;
        }
        child = child.offsetParent;
    }
    return sum;
}
function $449412113267a1fe$export$c826860796309d1b(targetElement, opts) {
    if (document.contains(targetElement)) {
        let root = document.scrollingElement || document.documentElement;
        let isScrollPrevented = window.getComputedStyle(root).overflow === "hidden";
        // If scrolling is not currently prevented then we aren’t in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view
        if (!isScrollPrevented) {
            var // use scrollIntoView({block: 'nearest'}) instead of .focus to check if the element is fully in view or not since .focus()
            // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically
            _targetElement_scrollIntoView;
            let { left: originalLeft , top: originalTop  } = targetElement.getBoundingClientRect();
            targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {
                block: "nearest"
            });
            let { left: newLeft , top: newTop  } = targetElement.getBoundingClientRect();
            // Account for sub pixel differences from rounding
            if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {
                var _opts_containingElement, _opts_containingElement_scrollIntoView, _targetElement_scrollIntoView1;
                opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {
                    block: "center",
                    inline: "center"
                });
                (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {
                    block: "nearest"
                });
            }
        } else {
            let scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.
            while(targetElement && scrollParent && targetElement !== root && scrollParent !== root){
                $449412113267a1fe$export$53a0910f038337bd(scrollParent, targetElement);
                targetElement = scrollParent;
                scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            }
        }
    }
}



/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $577e795361f19be9$export$60278871457622de(event) {
    // JAWS/NVDA with Firefox.
    if (event.mozInputSource === 0 && event.isTrusted) return true;
    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead
    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check
    // to detect TalkBack virtual clicks.
    if ((0, $9e20cff0af27e8cc$export$a11b0059900ceec8)() && event.pointerType) return event.type === "click" && event.buttons === 1;
    return event.detail === 0 && !event.pointerType;
}
function $577e795361f19be9$export$29bf1b5f2c56cf63(event) {
    // If the pointer size is zero, then we assume it's from a screen reader.
    // Android TalkBack double tap will sometimes return a event with width and height of 1
    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.
    // Cannot use "event.pressure === 0" as the sole check due to Safari pointer events always returning pressure === 0
    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush
    // Talkback double tap from Windows Firefox touch screen press
    return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse";
}



/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 
function $20e6e72fbf5dc81e$export$722debc0e56fea39(value, isEqual) {
    // Using a ref during render is ok here because it's only an optimization – both values are equivalent.
    // If a render is thrown away, it'll still work the same no matter if the next render is the same or not.
    let lastValue = (0, $1Yh1N$react.useRef)(null);
    if (value && lastValue.current && isEqual(value, lastValue.current)) value = lastValue.current;
    lastValue.current = value;
    return value;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 77335:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $1Yh1N$reactstatelyutils = __webpack_require__(12259);
var $1Yh1N$react = __webpack_require__(18038);
var $1Yh1N$reactariassr = __webpack_require__(65444);
var $1Yh1N$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useId", () => $8c61827343eed941$export$f680877a34711e37);
$parcel$export(module.exports, "mergeIds", () => $8c61827343eed941$export$cd8c9cb68f842629);
$parcel$export(module.exports, "useSlotId", () => $8c61827343eed941$export$b4cc09c592e8fdb8);
$parcel$export(module.exports, "chain", () => $1e2191638e54f613$export$e08e3b67e392101e);
$parcel$export(module.exports, "mergeProps", () => $f847cd1382ea7cd4$export$9d1611c77c2fe928);
$parcel$export(module.exports, "mergeRefs", () => $f05dc24eafaeb7e2$export$c9058316764c140e);
$parcel$export(module.exports, "filterDOMProps", () => $8d15d0e1797d4238$export$457c3d6518dd4c6f);
$parcel$export(module.exports, "focusWithoutScrolling", () => $1117b6c0d4c4c164$export$de79e2c695e052f3);
$parcel$export(module.exports, "getOffset", () => $16ec41ef3e36c19c$export$622cea445a1c5b7d);
$parcel$export(module.exports, "runAfterTransition", () => $e8117ebcab55be6a$export$24490316f764c430);
$parcel$export(module.exports, "useDrag1D", () => $28ed3fb20343b78b$export$7bbed75feba39706);
$parcel$export(module.exports, "useGlobalListeners", () => $4571ff54ac709100$export$4eaf04e54aa8eed6);
$parcel$export(module.exports, "useLabels", () => $6ec78bde395c477d$export$d6875122194c7b44);
$parcel$export(module.exports, "useObjectRef", () => $475b35fe72ba49b3$export$4338b53315abf666);
$parcel$export(module.exports, "useUpdateEffect", () => $29293a6f5c75b37e$export$496315a1608d9602);
$parcel$export(module.exports, "useLayoutEffect", () => $78605a5d7424e31b$export$e5c5a5f917a5871c);
$parcel$export(module.exports, "useResizeObserver", () => $37733e1652f47193$export$683480f191c0e3ea);
$parcel$export(module.exports, "useSyncRef", () => $6fc733991a9f977c$export$4debdb1a3f0fa79e);
$parcel$export(module.exports, "getScrollParent", () => $d796e7157ac96470$export$cfa2225e87938781);
$parcel$export(module.exports, "useViewportSize", () => $8b24bab62f5c65ad$export$d699905dd57c73ca);
$parcel$export(module.exports, "useDescription", () => $34da4502ea8120db$export$f8aeda7b10753fa1);
$parcel$export(module.exports, "isMac", () => $9e20cff0af27e8cc$export$9ac100e40613ea10);
$parcel$export(module.exports, "isIPhone", () => $9e20cff0af27e8cc$export$186c6964ca17d99);
$parcel$export(module.exports, "isIPad", () => $9e20cff0af27e8cc$export$7bef049ce92e4224);
$parcel$export(module.exports, "isIOS", () => $9e20cff0af27e8cc$export$fedb369cb70207f1);
$parcel$export(module.exports, "isAppleDevice", () => $9e20cff0af27e8cc$export$e1865c3bedcd822b);
$parcel$export(module.exports, "isWebKit", () => $9e20cff0af27e8cc$export$78551043582a6a98);
$parcel$export(module.exports, "isChrome", () => $9e20cff0af27e8cc$export$6446a186d09e379e);
$parcel$export(module.exports, "isAndroid", () => $9e20cff0af27e8cc$export$a11b0059900ceec8);
$parcel$export(module.exports, "useEvent", () => $2a8c0bb1629926c8$export$90fc3a17d93f704c);
$parcel$export(module.exports, "useValueEffect", () => $19a2307bfabafaf1$export$14d238f342723f25);
$parcel$export(module.exports, "scrollIntoView", () => $449412113267a1fe$export$53a0910f038337bd);
$parcel$export(module.exports, "clamp", () => $1Yh1N$reactstatelyutils.clamp);
$parcel$export(module.exports, "snapValueToStep", () => $1Yh1N$reactstatelyutils.snapValueToStep);
$parcel$export(module.exports, "isVirtualClick", () => $577e795361f19be9$export$60278871457622de);
$parcel$export(module.exports, "isVirtualPointerEvent", () => $577e795361f19be9$export$29bf1b5f2c56cf63);


const $78605a5d7424e31b$export$e5c5a5f917a5871c = typeof window !== 'undefined' ? ($parcel$interopDefault($1Yh1N$react)).useLayoutEffect : ()=>{
};




let $8c61827343eed941$var$idsUpdaterMap = new Map();
function $8c61827343eed941$export$f680877a34711e37(defaultId) {
    let [value, setValue] = $1Yh1N$react.useState(defaultId);
    let nextId = $1Yh1N$react.useRef(null);
    let res = $1Yh1N$reactariassr.useSSRSafeId(value);
    let updateValue = $1Yh1N$react.useCallback((val)=>{
        nextId.current = val;
    }, []);
    $8c61827343eed941$var$idsUpdaterMap.set(res, updateValue);
    $78605a5d7424e31b$export$e5c5a5f917a5871c(()=>{
        let r = res;
        return ()=>{
            $8c61827343eed941$var$idsUpdaterMap.delete(r);
        };
    }, [
        res
    ]);
    // This cannot cause an infinite loop because the ref is updated first.
    // eslint-disable-next-line
    $1Yh1N$react.useEffect(()=>{
        let newId = nextId.current;
        if (newId) {
            nextId.current = null;
            setValue(newId);
        }
    });
    return res;
}
function $8c61827343eed941$export$cd8c9cb68f842629(idA, idB) {
    if (idA === idB) return idA;
    let setIdA = $8c61827343eed941$var$idsUpdaterMap.get(idA);
    if (setIdA) {
        setIdA(idB);
        return idB;
    }
    let setIdB = $8c61827343eed941$var$idsUpdaterMap.get(idB);
    if (setIdB) {
        setIdB(idA);
        return idA;
    }
    return idB;
}
function $8c61827343eed941$export$b4cc09c592e8fdb8(depArray = []) {
    let id = $8c61827343eed941$export$f680877a34711e37();
    let [resolvedId, setResolvedId] = $19a2307bfabafaf1$export$14d238f342723f25(id);
    let updateId = $1Yh1N$react.useCallback(()=>{
        setResolvedId(function*() {
            yield id;
            yield document.getElementById(id) ? id : undefined;
        });
    }, [
        id,
        setResolvedId
    ]);
    $78605a5d7424e31b$export$e5c5a5f917a5871c(updateId, [
        id,
        updateId,
        ...depArray
    ]);
    return resolvedId;
}


function $1e2191638e54f613$export$e08e3b67e392101e(...callbacks) {
    return (...args)=>{
        for (let callback of callbacks)if (typeof callback === 'function') callback(...args);
    };
}





function $f847cd1382ea7cd4$export$9d1611c77c2fe928(...args) {
    // Start with a base clone of the first argument. This is a lot faster than starting
    // with an empty object and adding properties as we go.
    let result = {
        ...args[0]
    };
    for(let i = 1; i < args.length; i++){
        let props = args[i];
        for(let key in props){
            let a = result[key];
            let b = props[key];
            // Chain events
            if (typeof a === 'function' && typeof b === 'function' && // This is a lot faster than a regex.
            key[0] === 'o' && key[1] === 'n' && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = $1e2191638e54f613$export$e08e3b67e392101e(a, b);
            else if ((key === 'className' || key === 'UNSAFE_className') && typeof a === 'string' && typeof b === 'string') result[key] = ($parcel$interopDefault($1Yh1N$clsx))(a, b);
            else if (key === 'id' && a && b) result.id = $8c61827343eed941$export$cd8c9cb68f842629(a, b);
            else result[key] = b !== undefined ? b : a;
        }
    }
    return result;
}


function $f05dc24eafaeb7e2$export$c9058316764c140e(...refs) {
    return (value)=>{
        for (let ref of refs){
            if (typeof ref === 'function') ref(value);
            else if (ref != null) ref.current = value;
        }
    };
}


const $8d15d0e1797d4238$var$DOMPropNames = new Set([
    'id'
]);
const $8d15d0e1797d4238$var$labelablePropNames = new Set([
    'aria-label',
    'aria-labelledby',
    'aria-describedby',
    'aria-details'
]);
const $8d15d0e1797d4238$var$propRe = /^(data-.*)$/;
function $8d15d0e1797d4238$export$457c3d6518dd4c6f(props, opts = {
}) {
    let { labelable: labelable , propNames: propNames  } = opts;
    let filteredProps = {
    };
    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($8d15d0e1797d4238$var$DOMPropNames.has(prop) || labelable && $8d15d0e1797d4238$var$labelablePropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $8d15d0e1797d4238$var$propRe.test(prop))) filteredProps[prop] = props[prop];
    return filteredProps;
}


function $1117b6c0d4c4c164$export$de79e2c695e052f3(element) {
    if ($1117b6c0d4c4c164$var$supportsPreventScroll()) element.focus({
        preventScroll: true
    });
    else {
        let scrollableElements = $1117b6c0d4c4c164$var$getScrollableElements(element);
        element.focus();
        $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements);
    }
}
let $1117b6c0d4c4c164$var$supportsPreventScrollCached = null;
function $1117b6c0d4c4c164$var$supportsPreventScroll() {
    if ($1117b6c0d4c4c164$var$supportsPreventScrollCached == null) {
        $1117b6c0d4c4c164$var$supportsPreventScrollCached = false;
        try {
            var focusElem = document.createElement('div');
            focusElem.focus({
                get preventScroll () {
                    $1117b6c0d4c4c164$var$supportsPreventScrollCached = true;
                    return true;
                }
            });
        } catch (e) {
        // Ignore
        }
    }
    return $1117b6c0d4c4c164$var$supportsPreventScrollCached;
}
function $1117b6c0d4c4c164$var$getScrollableElements(element) {
    var parent = element.parentNode;
    var scrollableElements = [];
    var rootScrollingElement = document.scrollingElement || document.documentElement;
    while(parent instanceof HTMLElement && parent !== rootScrollingElement){
        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({
            element: parent,
            scrollTop: parent.scrollTop,
            scrollLeft: parent.scrollLeft
        });
        parent = parent.parentNode;
    }
    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
        element: rootScrollingElement,
        scrollTop: rootScrollingElement.scrollTop,
        scrollLeft: rootScrollingElement.scrollLeft
    });
    return scrollableElements;
}
function $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements) {
    for (let { element: element , scrollTop: scrollTop , scrollLeft: scrollLeft  } of scrollableElements){
        element.scrollTop = scrollTop;
        element.scrollLeft = scrollLeft;
    }
}


function $16ec41ef3e36c19c$export$622cea445a1c5b7d(element, reverse, orientation = 'horizontal') {
    let rect = element.getBoundingClientRect();
    if (reverse) return orientation === 'horizontal' ? rect.right : rect.bottom;
    return orientation === 'horizontal' ? rect.left : rect.top;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We store a global list of elements that are currently transitioning,
// mapped to a set of CSS properties that are transitioning for that element.
// This is necessary rather than a simple count of transitions because of browser
// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather
// than one or the other. So we need to track what's actually transitioning so that
// we can ignore these duplicate events.
let $e8117ebcab55be6a$var$transitionsByElement = new Map();
// A list of callbacks to call once there are no transitioning elements.
let $e8117ebcab55be6a$var$transitionCallbacks = new Set();
function $e8117ebcab55be6a$var$setupGlobalEvents() {
    if (typeof window === 'undefined') return;
    let onTransitionStart = (e)=>{
        // Add the transitioning property to the list for this element.
        let transitions = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!transitions) {
            transitions = new Set();
            $e8117ebcab55be6a$var$transitionsByElement.set(e.target, transitions);
            // The transitioncancel event must be registered on the element itself, rather than as a global
            // event. This enables us to handle when the node is deleted from the document while it is transitioning.
            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.
            e.target.addEventListener('transitioncancel', onTransitionEnd);
        }
        transitions.add(e.propertyName);
    };
    let onTransitionEnd = (e)=>{
        // Remove property from list of transitioning properties.
        let properties = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!properties) return;
        properties.delete(e.propertyName);
        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.
        if (properties.size === 0) {
            e.target.removeEventListener('transitioncancel', onTransitionEnd);
            $e8117ebcab55be6a$var$transitionsByElement.delete(e.target);
        }
        // If no transitioning elements, call all of the queued callbacks.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) {
            for (let cb of $e8117ebcab55be6a$var$transitionCallbacks)cb();
            $e8117ebcab55be6a$var$transitionCallbacks.clear();
        }
    };
    document.body.addEventListener('transitionrun', onTransitionStart);
    document.body.addEventListener('transitionend', onTransitionEnd);
}
if (typeof document !== 'undefined') {
    if (document.readyState !== 'loading') $e8117ebcab55be6a$var$setupGlobalEvents();
    else document.addEventListener('DOMContentLoaded', $e8117ebcab55be6a$var$setupGlobalEvents);
}
function $e8117ebcab55be6a$export$24490316f764c430(fn) {
    // Wait one frame to see if an animation starts, e.g. a transition on mount.
    requestAnimationFrame(()=>{
        // If no transitions are running, call the function immediately.
        // Otherwise, add it to a list of callbacks to run at the end of the animation.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) fn();
        else $e8117ebcab55be6a$var$transitionCallbacks.add(fn);
    });
}




// Keep track of elements that we are currently handling dragging for via useDrag1D.
// If there's an ancestor and a descendant both using useDrag1D(), and the user starts
// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.
const $28ed3fb20343b78b$var$draggingElements = [];
function $28ed3fb20343b78b$export$7bbed75feba39706(props) {
    console.warn('useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html');
    let { containerRef: containerRef , reverse: reverse , orientation: orientation , onHover: onHover , onDrag: onDrag , onPositionChange: onPositionChange , onIncrement: onIncrement , onDecrement: onDecrement , onIncrementToMax: onIncrementToMax , onDecrementToMin: onDecrementToMin , onCollapseToggle: onCollapseToggle  } = props;
    let getPosition = (e)=>orientation === 'horizontal' ? e.clientX : e.clientY
    ;
    let getNextOffset = (e)=>{
        let containerOffset = $16ec41ef3e36c19c$export$622cea445a1c5b7d(containerRef.current, reverse, orientation);
        let mouseOffset = getPosition(e);
        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;
        return nextOffset;
    };
    let dragging = $1Yh1N$react.useRef(false);
    let prevPosition = $1Yh1N$react.useRef(0);
    // Keep track of the current handlers in a ref so that the events can access them.
    let handlers = $1Yh1N$react.useRef({
        onPositionChange: onPositionChange,
        onDrag: onDrag
    });
    handlers.current.onDrag = onDrag;
    handlers.current.onPositionChange = onPositionChange;
    let onMouseDragged = (e)=>{
        e.preventDefault();
        let nextOffset = getNextOffset(e);
        if (!dragging.current) {
            dragging.current = true;
            if (handlers.current.onDrag) handlers.current.onDrag(true);
            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        }
        if (prevPosition.current === nextOffset) return;
        prevPosition.current = nextOffset;
        if (onPositionChange) onPositionChange(nextOffset);
    };
    let onMouseUp = (e)=>{
        const target = e.target;
        dragging.current = false;
        let nextOffset = getNextOffset(e);
        if (handlers.current.onDrag) handlers.current.onDrag(false);
        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        $28ed3fb20343b78b$var$draggingElements.splice($28ed3fb20343b78b$var$draggingElements.indexOf(target), 1);
        window.removeEventListener('mouseup', onMouseUp, false);
        window.removeEventListener('mousemove', onMouseDragged, false);
    };
    let onMouseDown = (e)=>{
        const target = e.currentTarget;
        // If we're already handling dragging on a descendant with useDrag1D, then
        // we don't want to handle the drag motion on this target as well.
        if ($28ed3fb20343b78b$var$draggingElements.some((elt)=>target.contains(elt)
        )) return;
        $28ed3fb20343b78b$var$draggingElements.push(target);
        window.addEventListener('mousemove', onMouseDragged, false);
        window.addEventListener('mouseup', onMouseUp, false);
    };
    let onMouseEnter = ()=>{
        if (onHover) onHover(true);
    };
    let onMouseOut = ()=>{
        if (onHover) onHover(false);
    };
    let onKeyDown = (e)=>{
        switch(e.key){
            case 'Left':
            case 'ArrowLeft':
                if (orientation === 'horizontal') {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case 'Up':
            case 'ArrowUp':
                if (orientation === 'vertical') {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case 'Right':
            case 'ArrowRight':
                if (orientation === 'horizontal') {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case 'Down':
            case 'ArrowDown':
                if (orientation === 'vertical') {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case 'Home':
                e.preventDefault();
                if (onDecrementToMin) onDecrementToMin();
                break;
            case 'End':
                e.preventDefault();
                if (onIncrementToMax) onIncrementToMax();
                break;
            case 'Enter':
                e.preventDefault();
                if (onCollapseToggle) onCollapseToggle();
                break;
        }
    };
    return {
        onMouseDown: onMouseDown,
        onMouseEnter: onMouseEnter,
        onMouseOut: onMouseOut,
        onKeyDown: onKeyDown
    };
}



function $4571ff54ac709100$export$4eaf04e54aa8eed6() {
    let globalListeners = $1Yh1N$react.useRef(new Map());
    let addGlobalListener = $1Yh1N$react.useCallback((eventTarget, type, listener, options)=>{
        // Make sure we remove the listener after it is called with the `once` option.
        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{
            globalListeners.current.delete(listener);
            listener(...args);
        } : listener;
        globalListeners.current.set(listener, {
            type: type,
            eventTarget: eventTarget,
            fn: fn,
            options: options
        });
        eventTarget.addEventListener(type, listener, options);
    }, []);
    let removeGlobalListener = $1Yh1N$react.useCallback((eventTarget, type, listener, options)=>{
        var ref;
        let fn = ((ref = globalListeners.current.get(listener)) === null || ref === void 0 ? void 0 : ref.fn) || listener;
        eventTarget.removeEventListener(type, fn, options);
        globalListeners.current.delete(listener);
    }, []);
    let removeAllGlobalListeners = $1Yh1N$react.useCallback(()=>{
        globalListeners.current.forEach((value, key)=>{
            removeGlobalListener(value.eventTarget, value.type, key, value.options);
        });
    }, [
        removeGlobalListener
    ]);
    // eslint-disable-next-line arrow-body-style
    $1Yh1N$react.useEffect(()=>{
        return removeAllGlobalListeners;
    }, [
        removeAllGlobalListeners
    ]);
    return {
        addGlobalListener: addGlobalListener,
        removeGlobalListener: removeGlobalListener,
        removeAllGlobalListeners: removeAllGlobalListeners
    };
}



function $6ec78bde395c477d$export$d6875122194c7b44(props, defaultLabel) {
    let { id: id , 'aria-label': label , 'aria-labelledby': labelledBy  } = props;
    // If there is both an aria-label and aria-labelledby,
    // combine them by pointing to the element itself.
    id = $8c61827343eed941$export$f680877a34711e37(id);
    if (labelledBy && label) {
        let ids = new Set([
            ...labelledBy.trim().split(/\s+/),
            id
        ]);
        labelledBy = [
            ...ids
        ].join(' ');
    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\s+/).join(' ');
    // If no labels are provided, use the default
    if (!label && !labelledBy && defaultLabel) label = defaultLabel;
    return {
        id: id,
        'aria-label': label,
        'aria-labelledby': labelledBy
    };
}




function $475b35fe72ba49b3$export$4338b53315abf666(forwardedRef) {
    const objRef = $1Yh1N$react.useRef();
    /**
   * We're using `useLayoutEffect` here instead of `useEffect` because we want
   * to make sure that the `ref` value is up to date before other places in the
   * the execution cycle try to read it.
   */ $78605a5d7424e31b$export$e5c5a5f917a5871c(()=>{
        if (!forwardedRef) return;
        if (typeof forwardedRef === 'function') forwardedRef(objRef.current);
        else forwardedRef.current = objRef.current;
    }, [
        forwardedRef
    ]);
    return objRef;
}



function $29293a6f5c75b37e$export$496315a1608d9602(effect, dependencies) {
    const isInitialMount = $1Yh1N$react.useRef(true);
    $1Yh1N$react.useEffect(()=>{
        if (isInitialMount.current) isInitialMount.current = false;
        else effect();
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencies);
}




function $37733e1652f47193$var$hasResizeObserver() {
    return typeof window.ResizeObserver !== 'undefined';
}
function $37733e1652f47193$export$683480f191c0e3ea(options) {
    const { ref: ref , onResize: onResize  } = options;
    $1Yh1N$react.useEffect(()=>{
        let element = ref === null || ref === void 0 ? void 0 : ref.current;
        if (!element) return;
        if (!$37733e1652f47193$var$hasResizeObserver()) {
            window.addEventListener('resize', onResize, false);
            return ()=>{
                window.removeEventListener('resize', onResize, false);
            };
        } else {
            const resizeObserverInstance = new window.ResizeObserver((entries)=>{
                if (!entries.length) return;
                onResize();
            });
            resizeObserverInstance.observe(element);
            return ()=>{
                if (element) resizeObserverInstance.unobserve(element);
            };
        }
    }, [
        onResize,
        ref
    ]);
}



function $6fc733991a9f977c$export$4debdb1a3f0fa79e(context, ref) {
    $78605a5d7424e31b$export$e5c5a5f917a5871c(()=>{
        if (context && context.ref && ref) {
            context.ref.current = ref.current;
            return ()=>{
                context.ref.current = null;
            };
        }
    }, [
        context,
        ref
    ]);
}


function $d796e7157ac96470$export$cfa2225e87938781(node) {
    while(node && !$d796e7157ac96470$var$isScrollable(node))node = node.parentElement;
    return node || document.scrollingElement || document.documentElement;
}
function $d796e7157ac96470$var$isScrollable(node) {
    let style = window.getComputedStyle(node);
    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
}



// @ts-ignore
let $8b24bab62f5c65ad$var$visualViewport = typeof window !== 'undefined' && window.visualViewport;
function $8b24bab62f5c65ad$export$d699905dd57c73ca() {
    let [size1, setSize] = $1Yh1N$react.useState(()=>$8b24bab62f5c65ad$var$getViewportSize()
    );
    $1Yh1N$react.useEffect(()=>{
        // Use visualViewport api to track available height even on iOS virtual keyboard opening
        let onResize = ()=>{
            setSize((size)=>{
                let newSize = $8b24bab62f5c65ad$var$getViewportSize();
                if (newSize.width === size.width && newSize.height === size.height) return size;
                return newSize;
            });
        };
        if (!$8b24bab62f5c65ad$var$visualViewport) window.addEventListener('resize', onResize);
        else $8b24bab62f5c65ad$var$visualViewport.addEventListener('resize', onResize);
        return ()=>{
            if (!$8b24bab62f5c65ad$var$visualViewport) window.removeEventListener('resize', onResize);
            else $8b24bab62f5c65ad$var$visualViewport.removeEventListener('resize', onResize);
        };
    }, []);
    return size1;
}
function $8b24bab62f5c65ad$var$getViewportSize() {
    return {
        width: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.width) || window.innerWidth,
        height: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.height) || window.innerHeight
    };
}




let $34da4502ea8120db$var$descriptionId = 0;
const $34da4502ea8120db$var$descriptionNodes = new Map();
function $34da4502ea8120db$export$f8aeda7b10753fa1(description) {
    let [id1, setId] = $1Yh1N$react.useState(undefined);
    $78605a5d7424e31b$export$e5c5a5f917a5871c(()=>{
        if (!description) return;
        let desc = $34da4502ea8120db$var$descriptionNodes.get(description);
        if (!desc) {
            let id = `react-aria-description-${$34da4502ea8120db$var$descriptionId++}`;
            setId(id);
            let node = document.createElement('div');
            node.id = id;
            node.style.display = 'none';
            node.textContent = description;
            document.body.appendChild(node);
            desc = {
                refCount: 0,
                element: node
            };
            $34da4502ea8120db$var$descriptionNodes.set(description, desc);
        } else setId(desc.element.id);
        desc.refCount++;
        return ()=>{
            if (--desc.refCount === 0) {
                desc.element.remove();
                $34da4502ea8120db$var$descriptionNodes.delete(description);
            }
        };
    }, [
        description
    ]);
    return {
        'aria-describedby': description ? id1 : undefined
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $9e20cff0af27e8cc$var$testUserAgent(re) {
    var ref;
    if (typeof window === 'undefined' || window.navigator == null) return false;
    return ((ref = window.navigator['userAgentData']) === null || ref === void 0 ? void 0 : ref.brands.some((brand)=>re.test(brand.brand)
    )) || re.test(window.navigator.userAgent);
}
function $9e20cff0af27e8cc$var$testPlatform(re) {
    var ref;
    return typeof window !== 'undefined' && window.navigator != null ? re.test(((ref = window.navigator['userAgentData']) === null || ref === void 0 ? void 0 : ref.platform) || window.navigator.platform) : false;
}
function $9e20cff0af27e8cc$export$9ac100e40613ea10() {
    return $9e20cff0af27e8cc$var$testPlatform(/^Mac/i);
}
function $9e20cff0af27e8cc$export$186c6964ca17d99() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPhone/i);
}
function $9e20cff0af27e8cc$export$7bef049ce92e4224() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPad/i) || $9e20cff0af27e8cc$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
}
function $9e20cff0af27e8cc$export$fedb369cb70207f1() {
    return $9e20cff0af27e8cc$export$186c6964ca17d99() || $9e20cff0af27e8cc$export$7bef049ce92e4224();
}
function $9e20cff0af27e8cc$export$e1865c3bedcd822b() {
    return $9e20cff0af27e8cc$export$9ac100e40613ea10() || $9e20cff0af27e8cc$export$fedb369cb70207f1();
}
function $9e20cff0af27e8cc$export$78551043582a6a98() {
    return $9e20cff0af27e8cc$var$testUserAgent(/AppleWebKit/i) && !$9e20cff0af27e8cc$export$6446a186d09e379e();
}
function $9e20cff0af27e8cc$export$6446a186d09e379e() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Chrome/i);
}
function $9e20cff0af27e8cc$export$a11b0059900ceec8() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Android/i);
}



function $2a8c0bb1629926c8$export$90fc3a17d93f704c(ref, event, handler1, options) {
    let handlerRef = $1Yh1N$react.useRef(handler1);
    handlerRef.current = handler1;
    let isDisabled = handler1 == null;
    $1Yh1N$react.useEffect(()=>{
        if (isDisabled) return;
        let element = ref.current;
        let handler = (e)=>handlerRef.current.call(this, e)
        ;
        element.addEventListener(event, handler, options);
        return ()=>{
            element.removeEventListener(event, handler, options);
        };
    }, [
        ref,
        event,
        options,
        isDisabled
    ]);
}




function $19a2307bfabafaf1$export$14d238f342723f25(defaultValue) {
    let [value, setValue] = $1Yh1N$react.useState(defaultValue);
    let valueRef = $1Yh1N$react.useRef(value);
    let effect = $1Yh1N$react.useRef(null);
    valueRef.current = value;
    // Store the function in a ref so we can always access the current version
    // which has the proper `value` in scope.
    let nextRef = $1Yh1N$react.useRef(null);
    nextRef.current = ()=>{
        // Run the generator to the next yield.
        let newValue = effect.current.next();
        // If the generator is done, reset the effect.
        if (newValue.done) {
            effect.current = null;
            return;
        }
        // If the value is the same as the current value,
        // then continue to the next yield. Otherwise,
        // set the value in state and wait for the next layout effect.
        if (value === newValue.value) nextRef.current();
        else setValue(newValue.value);
    };
    $78605a5d7424e31b$export$e5c5a5f917a5871c(()=>{
        // If there is an effect currently running, continue to the next yield.
        if (effect.current) nextRef.current();
    });
    let queue = $1Yh1N$react.useCallback((fn)=>{
        effect.current = fn(valueRef.current);
        nextRef.current();
    }, [
        effect,
        nextRef
    ]);
    return [
        value,
        queue
    ];
}


function $449412113267a1fe$export$53a0910f038337bd(scrollView, element) {
    let offsetX = $449412113267a1fe$var$relativeOffset(scrollView, element, 'left');
    let offsetY = $449412113267a1fe$var$relativeOffset(scrollView, element, 'top');
    let width = element.offsetWidth;
    let height = element.offsetHeight;
    let x = scrollView.scrollLeft;
    let y = scrollView.scrollTop;
    let maxX = x + scrollView.offsetWidth;
    let maxY = y + scrollView.offsetHeight;
    if (offsetX <= x) x = offsetX;
    else if (offsetX + width > maxX) x += offsetX + width - maxX;
    if (offsetY <= y) y = offsetY;
    else if (offsetY + height > maxY) y += offsetY + height - maxY;
    scrollView.scrollLeft = x;
    scrollView.scrollTop = y;
}
/**
 * Computes the offset left or top from child to ancestor by accumulating
 * offsetLeft or offsetTop through intervening offsetParents.
 */ function $449412113267a1fe$var$relativeOffset(ancestor, child, axis) {
    const prop = axis === 'left' ? 'offsetLeft' : 'offsetTop';
    let sum = 0;
    while(child.offsetParent){
        sum += child[prop];
        if (child.offsetParent === ancestor) break;
        else if (child.offsetParent.contains(ancestor)) {
            // If the ancestor is not `position:relative`, then we stop at
            // _its_ offset parent, and we subtract off _its_ offset, so that
            // we end up with the proper offset from child to ancestor.
            sum -= ancestor[prop];
            break;
        }
        child = child.offsetParent;
    }
    return sum;
}




function $577e795361f19be9$export$60278871457622de(event) {
    // JAWS/NVDA with Firefox.
    if (event.mozInputSource === 0 && event.isTrusted) return true;
    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead
    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check
    // to detect TalkBack virtual clicks.
    if ($9e20cff0af27e8cc$export$a11b0059900ceec8() && event.pointerType) return event.type === 'click' && event.buttons === 1;
    return event.detail === 0 && !event.pointerType;
}
function $577e795361f19be9$export$29bf1b5f2c56cf63(event) {
    // If the pointer size is zero, then we assume it's from a screen reader.
    // Android TalkBack double tap will sometimes return a event with width and height of 1
    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.
    // Cannot use "event.pressure === 0" as the sole check due to Safari pointer events always returning pressure === 0
    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush
    // Talkback double tap from Windows Firefox touch screen press
    return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'mouse';
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 20198:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $2Agrv$reactariautils = __webpack_require__(77335);
var $2Agrv$react = __webpack_require__(18038);
var $2Agrv$reactariainteractions = __webpack_require__(34353);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useVisuallyHidden", () => $b5c81b25cdf7a43c$export$a966af930f325cab);
$parcel$export(module.exports, "VisuallyHidden", () => $b5c81b25cdf7a43c$export$439d29a4e110a164);



const $b5c81b25cdf7a43c$var$styles = {
    border: 0,
    clip: 'rect(0 0 0 0)',
    clipPath: 'inset(50%)',
    height: 1,
    margin: '0 -1px -1px 0',
    overflow: 'hidden',
    padding: 0,
    position: 'absolute',
    width: 1,
    whiteSpace: 'nowrap'
};
function $b5c81b25cdf7a43c$export$a966af930f325cab(props = {
}) {
    let { style: style , isFocusable: isFocusable  } = props;
    let [isFocused, setFocused] = $2Agrv$react.useState(false);
    let { focusWithinProps: focusWithinProps  } = $2Agrv$reactariainteractions.useFocusWithin({
        isDisabled: !isFocusable,
        onFocusWithinChange: (val)=>setFocused(val)
    });
    // If focused, don't hide the element.
    let combinedStyles = $2Agrv$react.useMemo(()=>{
        if (isFocused) return style;
        else if (style) return {
            ...$b5c81b25cdf7a43c$var$styles,
            ...style
        };
        else return $b5c81b25cdf7a43c$var$styles;
    }, [
        isFocused
    ]);
    return {
        visuallyHiddenProps: {
            ...focusWithinProps,
            style: combinedStyles
        }
    };
}
function $b5c81b25cdf7a43c$export$439d29a4e110a164(props) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    let { children: children , elementType: Element = 'div' , isFocusable: isFocusable , style: style , ...otherProps } = props;
    let { visuallyHiddenProps: visuallyHiddenProps  } = $b5c81b25cdf7a43c$export$a966af930f325cab(props);
    return(/*#__PURE__*/ ($parcel$interopDefault($2Agrv$react)).createElement(Element, $2Agrv$reactariautils.mergeProps(otherProps, visuallyHiddenProps), children));
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 48289:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $jVLCf$reactstatelyutils = __webpack_require__(12259);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useCheckboxGroupState", () => $943f4c622056df75$export$daff6da51032a415);

function $943f4c622056df75$export$daff6da51032a415(props = {
}) {
    let [selectedValues, setValue] = $jVLCf$reactstatelyutils.useControlledState(props.value, props.defaultValue || [], props.onChange);
    const state = {
        value: selectedValues,
        setValue (value) {
            if (props.isReadOnly || props.isDisabled) return;
            setValue(value);
        },
        isDisabled: props.isDisabled || false,
        isReadOnly: props.isReadOnly || false,
        isSelected (value) {
            return selectedValues.includes(value);
        },
        addValue (value) {
            if (props.isReadOnly || props.isDisabled) return;
            if (!selectedValues.includes(value)) setValue(selectedValues.concat(value));
        },
        removeValue (value) {
            if (props.isReadOnly || props.isDisabled) return;
            if (selectedValues.includes(value)) setValue(selectedValues.filter((existingValue)=>existingValue !== value
            ));
        },
        toggleValue (value) {
            if (props.isReadOnly || props.isDisabled) return;
            if (selectedValues.includes(value)) setValue(selectedValues.filter((existingValue)=>existingValue !== value
            ));
            else setValue(selectedValues.concat(value));
        },
        validationState: props.validationState
    };
    return state;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 92775:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $4aZkW$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "Item", () => $c870f3b549c61b6b$export$6d08773d2e66f8f2);
$parcel$export(module.exports, "Section", () => $350f13aa4d8b327c$export$6e2c8f0811a474ce);
$parcel$export(module.exports, "useCollection", () => $98fc0fafaca75b6a$export$6cd28814d92fa9c9);
$parcel$export(module.exports, "getItemCount", () => $e749fe52977fe2c2$export$77d5aafae4e095b2);

function $c870f3b549c61b6b$var$Item(props) {
    return null;
}
$c870f3b549c61b6b$var$Item.getCollectionNode = function* getCollectionNode(props, context) {
    let { childItems: childItems , title: title , children: children  } = props;
    let rendered = props.title || props.children;
    let textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'] || '';
    // suppressTextValueWarning is used in components like Tabs, which don't have type to select support.
    if (!textValue && !(context === null || context === void 0 ? void 0 : context.suppressTextValueWarning)) console.warn('<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.');
    yield {
        type: 'item',
        props: props,
        rendered: rendered,
        textValue: textValue,
        'aria-label': props['aria-label'],
        hasChildNodes: $c870f3b549c61b6b$var$hasChildItems(props),
        *childNodes () {
            if (childItems) for (let child1 of childItems)yield {
                type: 'item',
                value: child1
            };
            else if (title) {
                let items = [];
                ($parcel$interopDefault($4aZkW$react)).Children.forEach(children, (child)=>{
                    items.push({
                        type: 'item',
                        element: child
                    });
                });
                yield* items;
            }
        }
    };
};
function $c870f3b549c61b6b$var$hasChildItems(props) {
    if (props.hasChildItems != null) return props.hasChildItems;
    if (props.childItems) return true;
    if (props.title && ($parcel$interopDefault($4aZkW$react)).Children.count(props.children) > 0) return true;
    return false;
}
// We don't want getCollectionNode to show up in the type definition
let $c870f3b549c61b6b$export$6d08773d2e66f8f2 = $c870f3b549c61b6b$var$Item;



function $350f13aa4d8b327c$var$Section(props) {
    return null;
}
$350f13aa4d8b327c$var$Section.getCollectionNode = function* getCollectionNode(props) {
    let { children: children , title: title , items: items1  } = props;
    yield {
        type: 'section',
        hasChildNodes: true,
        rendered: title,
        'aria-label': props['aria-label'],
        *childNodes () {
            if (typeof children === 'function') {
                if (!items1) throw new Error('props.children was a function but props.items is missing');
                for (let item of items1)yield {
                    type: 'item',
                    value: item,
                    renderer: children
                };
            } else {
                let items = [];
                ($parcel$interopDefault($4aZkW$react)).Children.forEach(children, (child)=>{
                    items.push({
                        type: 'item',
                        element: child
                    });
                });
                yield* items;
            }
        }
    };
};
// We don't want getCollectionNode to show up in the type definition
let $350f13aa4d8b327c$export$6e2c8f0811a474ce = $350f13aa4d8b327c$var$Section;



class $51588fd411aace25$export$bf788dd355e3a401 {
    build(props, context) {
        this.context = context;
        return $51588fd411aace25$var$iterable(()=>this.iterateCollection(props)
        );
    }
    *iterateCollection(props) {
        let { children: children , items: items  } = props;
        if (typeof children === 'function') {
            if (!items) throw new Error('props.children was a function but props.items is missing');
            for (let item of props.items)yield* this.getFullNode({
                value: item
            }, {
                renderer: children
            });
        } else {
            let items = [];
            ($parcel$interopDefault($4aZkW$react)).Children.forEach(children, (child)=>{
                items.push(child);
            });
            let index = 0;
            for (let item of items){
                let nodes = this.getFullNode({
                    element: item,
                    index: index
                }, {
                });
                for (let node of nodes){
                    index++;
                    yield node;
                }
            }
        }
    }
    getKey(item, partialNode, state, parentKey) {
        if (item.key != null) return item.key;
        if (partialNode.type === 'cell' && partialNode.key != null) return `${parentKey}${partialNode.key}`;
        let v = partialNode.value;
        if (v != null) {
            var _key;
            let key = (_key = v.key) !== null && _key !== void 0 ? _key : v.id;
            if (key == null) throw new Error('No key found for item');
            return key;
        }
        return parentKey ? `${parentKey}.${partialNode.index}` : `$.${partialNode.index}`;
    }
    getChildState(state, partialNode) {
        return {
            renderer: partialNode.renderer || state.renderer
        };
    }
    *getFullNode(partialNode, state, parentKey, parentNode) {
        // If there's a value instead of an element on the node, and a parent renderer function is available,
        // use it to render an element for the value.
        let element = partialNode.element;
        if (!element && partialNode.value && state && state.renderer) {
            let cached = this.cache.get(partialNode.value);
            if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {
                cached.index = partialNode.index;
                cached.parentKey = parentNode ? parentNode.key : null;
                yield cached;
                return;
            }
            element = state.renderer(partialNode.value);
        }
        // If there's an element with a getCollectionNode function on its type, then it's a supported component.
        // Call this function to get a partial node, and recursively build a full node from there.
        if (($parcel$interopDefault($4aZkW$react)).isValidElement(element)) {
            let type = element.type;
            if (typeof type !== 'function' && typeof type.getCollectionNode !== 'function') {
                let name = typeof element.type === 'function' ? element.type.name : element.type;
                throw new Error(`Unknown element <${name}> in collection.`);
            }
            let childNodes = type.getCollectionNode(element.props, this.context);
            let index = partialNode.index;
            let result = childNodes.next();
            while(!result.done && result.value){
                let childNode = result.value;
                partialNode.index = index;
                let nodeKey = childNode.key;
                if (!nodeKey) nodeKey = childNode.element ? null : this.getKey(element, partialNode, state, parentKey);
                let nodes = this.getFullNode({
                    ...childNode,
                    key: nodeKey,
                    index: index,
                    wrapper: $51588fd411aace25$var$compose(partialNode.wrapper, childNode.wrapper)
                }, this.getChildState(state, childNode), parentKey ? `${parentKey}${element.key}` : element.key, parentNode);
                let children = [
                    ...nodes
                ];
                for (let node of children){
                    // Cache the node based on its value
                    node.value = childNode.value || partialNode.value;
                    if (node.value) this.cache.set(node.value, node);
                    // The partial node may have specified a type for the child in order to specify a constraint.
                    // Verify that the full node that was built recursively matches this type.
                    if (partialNode.type && node.type !== partialNode.type) throw new Error(`Unsupported type <${$51588fd411aace25$var$capitalize(node.type)}> in <${$51588fd411aace25$var$capitalize(parentNode.type)}>. Only <${$51588fd411aace25$var$capitalize(partialNode.type)}> is supported.`);
                    index++;
                    yield node;
                }
                result = childNodes.next(children);
            }
            return;
        }
        // Ignore invalid elements
        if (partialNode.key == null) return;
        // Create full node
        let builder = this;
        let node = {
            type: partialNode.type,
            props: partialNode.props,
            key: partialNode.key,
            parentKey: parentNode ? parentNode.key : null,
            value: partialNode.value,
            level: parentNode ? parentNode.level + 1 : 0,
            index: partialNode.index,
            rendered: partialNode.rendered,
            textValue: partialNode.textValue,
            'aria-label': partialNode['aria-label'],
            wrapper: partialNode.wrapper,
            shouldInvalidate: partialNode.shouldInvalidate,
            hasChildNodes: partialNode.hasChildNodes,
            childNodes: $51588fd411aace25$var$iterable(function*() {
                if (!partialNode.hasChildNodes) return;
                let index = 0;
                for (let child of partialNode.childNodes()){
                    // Ensure child keys are globally unique by prepending the parent node's key
                    if (child.key != null) // TODO: Remove this line entirely and enforce that users always provide unique keys.
                    // Currently this line will have issues when a parent has a key `a` and a child with key `bc`
                    // but another parent has key `ab` and its child has a key `c`. The combined keys would result in both
                    // children having a key of `abc`.
                    child.key = `${node.key}${child.key}`;
                    child.index = index;
                    let nodes = builder.getFullNode(child, builder.getChildState(state, child), node.key, node);
                    for (let node1 of nodes){
                        index++;
                        yield node1;
                    }
                }
            })
        };
        yield node;
    }
    constructor(){
        this.cache = new WeakMap();
    }
}
// Wraps an iterator function as an iterable object, and caches the results.
function $51588fd411aace25$var$iterable(iterator) {
    let cache = [];
    let iterable = null;
    return {
        *[Symbol.iterator] () {
            for (let item of cache)yield item;
            if (!iterable) iterable = iterator();
            for (let item1 of iterable){
                cache.push(item1);
                yield item1;
            }
        }
    };
}
function $51588fd411aace25$var$compose(outer, inner) {
    if (outer && inner) return (element)=>outer(inner(element))
    ;
    if (outer) return outer;
    if (inner) return inner;
}
function $51588fd411aace25$var$capitalize(str) {
    return str[0].toUpperCase() + str.slice(1);
}



function $98fc0fafaca75b6a$export$6cd28814d92fa9c9(props, factory, context, invalidators = []) {
    let builder = $4aZkW$react.useMemo(()=>new $51588fd411aace25$export$bf788dd355e3a401()
    , []);
    let prev = $4aZkW$react.useRef(null);
    return $4aZkW$react.useMemo(()=>{
        let nodes = builder.build(props, context);
        prev.current = factory(nodes, prev.current);
        return prev.current;
    // Don't invalidate when any prop changes, just the two we care about.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        builder,
        props.children,
        props.items,
        context,
        ...invalidators
    ]);
}


const $e749fe52977fe2c2$var$cache = new WeakMap();
function $e749fe52977fe2c2$export$77d5aafae4e095b2(collection) {
    let count = $e749fe52977fe2c2$var$cache.get(collection);
    if (count != null) return count;
    count = 0;
    for (let item of collection)if (item.type === 'section') count += $e749fe52977fe2c2$export$77d5aafae4e095b2(item.childNodes);
    else count++;
    $e749fe52977fe2c2$var$cache.set(collection, count);
    return count;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 23385:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $kdbv0$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useAsyncList", () => $1cb48366e5c5533f$export$bc3384a35de93d66);
$parcel$export(module.exports, "useTreeData", () => $2d16d1aab63a81f4$export$d14e1352e21f4a16);
$parcel$export(module.exports, "useListData", () => $fbc1d750f520c94e$export$762f73dccccd255d);

function $fbc1d750f520c94e$export$762f73dccccd255d(options) {
    let { initialItems: initialItems = [] , initialSelectedKeys: initialSelectedKeys , getKey: getKey = (item)=>item.id || item.key
     , filter: filter , initialFilterText: initialFilterText = ''  } = options;
    // Store both items and filteredItems in state so we can go back to the unfiltered list
    let [state, setState] = $kdbv0$react.useState({
        items: initialItems,
        selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || []),
        filterText: initialFilterText
    });
    let filteredItems = $kdbv0$react.useMemo(()=>filter ? state.items.filter((item)=>filter(item, state.filterText)
        ) : state.items
    , [
        state.items,
        state.filterText,
        filter
    ]);
    return {
        ...state,
        items: filteredItems,
        ...$fbc1d750f520c94e$export$79c0c687a5963b0a({
            getKey: getKey
        }, setState),
        getItem (key) {
            return state.items.find((item)=>getKey(item) === key
            );
        }
    };
}
function $fbc1d750f520c94e$export$79c0c687a5963b0a(opts, dispatch) {
    let { cursor: cursor , getKey: getKey  } = opts;
    return {
        setSelectedKeys (selectedKeys) {
            dispatch((state)=>({
                    ...state,
                    selectedKeys: selectedKeys
                })
            );
        },
        setFilterText (filterText) {
            dispatch((state)=>({
                    ...state,
                    filterText: filterText
                })
            );
        },
        insert (index, ...values) {
            dispatch((state)=>$fbc1d750f520c94e$var$insert(state, index, ...values)
            );
        },
        insertBefore (key, ...values) {
            dispatch((state)=>{
                let index = state.items.findIndex((item)=>getKey(item) === key
                );
                if (index === -1) return;
                return $fbc1d750f520c94e$var$insert(state, index, ...values);
            });
        },
        insertAfter (key, ...values) {
            dispatch((state)=>{
                let index = state.items.findIndex((item)=>getKey(item) === key
                );
                if (index === -1) return;
                return $fbc1d750f520c94e$var$insert(state, index + 1, ...values);
            });
        },
        prepend (...values) {
            dispatch((state)=>$fbc1d750f520c94e$var$insert(state, 0, ...values)
            );
        },
        append (...values) {
            dispatch((state)=>$fbc1d750f520c94e$var$insert(state, state.items.length, ...values)
            );
        },
        remove (...keys) {
            dispatch((state)=>{
                let keySet = new Set(keys);
                let items = state.items.filter((item)=>!keySet.has(getKey(item))
                );
                let selection = 'all';
                if (state.selectedKeys !== 'all') {
                    selection = new Set(state.selectedKeys);
                    for (let key of keys)selection.delete(key);
                }
                if (cursor == null && items.length === 0) selection = new Set();
                return {
                    ...state,
                    items: items,
                    selectedKeys: selection
                };
            });
        },
        removeSelectedItems () {
            dispatch((state)=>{
                if (state.selectedKeys === 'all') return {
                    ...state,
                    items: [],
                    selectedKeys: new Set()
                };
                let selectedKeys = state.selectedKeys;
                let items = state.items.filter((item)=>!selectedKeys.has(getKey(item))
                );
                return {
                    ...state,
                    items: items,
                    selectedKeys: new Set()
                };
            });
        },
        move (key, toIndex) {
            dispatch((state)=>{
                let index = state.items.findIndex((item)=>getKey(item) === key
                );
                if (index === -1) return state;
                let copy = state.items.slice();
                let [item1] = copy.splice(index, 1);
                copy.splice(toIndex, 0, item1);
                return {
                    ...state,
                    items: copy
                };
            });
        },
        moveBefore (key1, keys) {
            dispatch((state)=>{
                let toIndex = state.items.findIndex((item)=>getKey(item) === key1
                );
                if (toIndex === -1) return state;
                // Find indices of keys to move. Sort them so that the order in the list is retained.
                let keyArray = Array.isArray(keys) ? keys : [
                    ...keys
                ];
                let indices = keyArray.map((key)=>state.items.findIndex((item)=>getKey(item) === key
                    )
                ).sort();
                return $fbc1d750f520c94e$var$move(state, indices, toIndex);
            });
        },
        moveAfter (key2, keys) {
            dispatch((state)=>{
                let toIndex = state.items.findIndex((item)=>getKey(item) === key2
                );
                if (toIndex === -1) return state;
                let keyArray = Array.isArray(keys) ? keys : [
                    ...keys
                ];
                let indices = keyArray.map((key)=>state.items.findIndex((item)=>getKey(item) === key
                    )
                ).sort();
                return $fbc1d750f520c94e$var$move(state, indices, toIndex + 1);
            });
        },
        update (key, newValue) {
            dispatch((state)=>{
                let index = state.items.findIndex((item)=>getKey(item) === key
                );
                if (index === -1) return state;
                return {
                    ...state,
                    items: [
                        ...state.items.slice(0, index),
                        newValue,
                        ...state.items.slice(index + 1)
                    ]
                };
            });
        }
    };
}
function $fbc1d750f520c94e$var$insert(state, index, ...values) {
    return {
        ...state,
        items: [
            ...state.items.slice(0, index),
            ...values,
            ...state.items.slice(index)
        ]
    };
}
function $fbc1d750f520c94e$var$move(state, indices, toIndex) {
    // Shift the target down by the number of items being moved from before the target
    for (let index of indices)if (index < toIndex) toIndex--;
    let moves = indices.map((from)=>({
            from: from,
            to: toIndex++
        })
    );
    // Shift later from indices down if they have a larger index
    for(let i = 0; i < moves.length; i++){
        let a = moves[i].from;
        for(let j = i; j < moves.length; j++){
            let b = moves[j].from;
            if (b > a) moves[j].from--;
        }
    }
    // Interleave the moves so they can be applied one by one rather than all at once
    for(let i1 = 0; i1 < moves.length; i1++){
        let a = moves[i1];
        for(let j = moves.length - 1; j > i1; j--){
            let b = moves[j];
            if (b.from < a.to) a.to++;
            else b.from++;
        }
    }
    let copy = state.items.slice();
    for (let move of moves){
        let [item] = copy.splice(move.from, 1);
        copy.splice(move.to, 0, item);
    }
    return {
        ...state,
        items: copy
    };
}



function $1cb48366e5c5533f$var$reducer(data, action) {
    let selectedKeys;
    switch(data.state){
        case 'idle':
        case 'error':
            switch(action.type){
                case 'loading':
                case 'loadingMore':
                case 'sorting':
                case 'filtering':
                    var _filterText, _sortDescriptor;
                    return {
                        ...data,
                        filterText: (_filterText = action.filterText) !== null && _filterText !== void 0 ? _filterText : data.filterText,
                        state: action.type,
                        // Reset items to an empty list if loading, but not when sorting.
                        items: action.type === 'loading' ? [] : data.items,
                        sortDescriptor: (_sortDescriptor = action.sortDescriptor) !== null && _sortDescriptor !== void 0 ? _sortDescriptor : data.sortDescriptor,
                        abortController: action.abortController
                    };
                case 'update':
                    return {
                        ...data,
                        ...action.updater(data)
                    };
                case 'success':
                case 'error':
                    return data;
                default:
                    throw new Error(`Invalid action "${action.type}" in state "${data.state}"`);
            }
        case 'loading':
        case 'sorting':
        case 'filtering':
            switch(action.type){
                case 'success':
                    // Ignore if there is a newer abortcontroller in state.
                    // This means that multiple requests were going at once.
                    // We want to take only the latest result.
                    if (action.abortController !== data.abortController) return data;
                    var _selectedKeys;
                    selectedKeys = (_selectedKeys = action.selectedKeys) !== null && _selectedKeys !== void 0 ? _selectedKeys : data.selectedKeys;
                    var _filterText1, _sortDescriptor1;
                    return {
                        ...data,
                        filterText: (_filterText1 = action.filterText) !== null && _filterText1 !== void 0 ? _filterText1 : data.filterText,
                        state: 'idle',
                        items: [
                            ...action.items
                        ],
                        selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),
                        sortDescriptor: (_sortDescriptor1 = action.sortDescriptor) !== null && _sortDescriptor1 !== void 0 ? _sortDescriptor1 : data.sortDescriptor,
                        abortController: null,
                        cursor: action.cursor
                    };
                case 'error':
                    if (action.abortController !== data.abortController) return data;
                    return {
                        ...data,
                        state: 'error',
                        error: action.error,
                        abortController: null
                    };
                case 'loading':
                case 'loadingMore':
                case 'sorting':
                case 'filtering':
                    // We're already loading, and another load was triggered at the same time.
                    // We need to abort the previous load and start a new one.
                    data.abortController.abort();
                    var _filterText2;
                    return {
                        ...data,
                        filterText: (_filterText2 = action.filterText) !== null && _filterText2 !== void 0 ? _filterText2 : data.filterText,
                        state: action.type,
                        // Reset items to an empty list if loading, but not when sorting.
                        items: action.type === 'loading' ? [] : data.items,
                        abortController: action.abortController
                    };
                case 'update':
                    // We're already loading, and an update happened at the same time (e.g. selectedKey changed).
                    // Update data but don't abort previous load.
                    return {
                        ...data,
                        ...action.updater(data)
                    };
                default:
                    throw new Error(`Invalid action "${action.type}" in state "${data.state}"`);
            }
        case 'loadingMore':
            switch(action.type){
                case 'success':
                    var _selectedKeys1;
                    selectedKeys = data.selectedKeys === 'all' || action.selectedKeys === 'all' ? 'all' : new Set([
                        ...data.selectedKeys,
                        ...(_selectedKeys1 = action.selectedKeys) !== null && _selectedKeys1 !== void 0 ? _selectedKeys1 : []
                    ]);
                    var _sortDescriptor2;
                    // Append the new items
                    return {
                        ...data,
                        state: 'idle',
                        items: [
                            ...data.items,
                            ...action.items
                        ],
                        selectedKeys: selectedKeys,
                        sortDescriptor: (_sortDescriptor2 = action.sortDescriptor) !== null && _sortDescriptor2 !== void 0 ? _sortDescriptor2 : data.sortDescriptor,
                        abortController: null,
                        cursor: action.cursor
                    };
                case 'error':
                    if (action.abortController !== data.abortController) return data;
                    return {
                        ...data,
                        state: 'error',
                        error: action.error
                    };
                case 'loading':
                case 'sorting':
                case 'filtering':
                    // We're already loading more, and another load was triggered at the same time.
                    // We need to abort the previous load more and start a new one.
                    data.abortController.abort();
                    var _filterText3;
                    return {
                        ...data,
                        filterText: (_filterText3 = action.filterText) !== null && _filterText3 !== void 0 ? _filterText3 : data.filterText,
                        state: action.type,
                        // Reset items to an empty list if loading, but not when sorting.
                        items: action.type === 'loading' ? [] : data.items,
                        abortController: action.abortController
                    };
                case 'loadingMore':
                    // If already loading more and another loading more is triggered, abort the new load more since
                    // it is a duplicate request since the cursor hasn't been updated.
                    // Do not overwrite the data.abortController
                    action.abortController.abort();
                    return data;
                case 'update':
                    // We're already loading, and an update happened at the same time (e.g. selectedKey changed).
                    // Update data but don't abort previous load.
                    return {
                        ...data,
                        ...action.updater(data)
                    };
                default:
                    throw new Error(`Invalid action "${action.type}" in state "${data.state}"`);
            }
        default:
            throw new Error(`Invalid state "${data.state}"`);
    }
}
function $1cb48366e5c5533f$export$bc3384a35de93d66(options) {
    const { load: load , sort: sort , initialSelectedKeys: initialSelectedKeys , initialSortDescriptor: initialSortDescriptor , getKey: getKey = (item)=>item.id || item.key
     , initialFilterText: initialFilterText = ''  } = options;
    let [data, dispatch] = $kdbv0$react.useReducer($1cb48366e5c5533f$var$reducer, {
        state: 'idle',
        error: null,
        items: [],
        selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),
        sortDescriptor: initialSortDescriptor,
        filterText: initialFilterText
    });
    const dispatchFetch = async (action, fn)=>{
        let abortController = new AbortController();
        try {
            dispatch({
                ...action,
                abortController: abortController
            });
            var _filterText;
            let previousFilterText = (_filterText = action.filterText) !== null && _filterText !== void 0 ? _filterText : data.filterText;
            var _sortDescriptor;
            let response = await fn({
                items: data.items.slice(),
                selectedKeys: data.selectedKeys,
                sortDescriptor: (_sortDescriptor = action.sortDescriptor) !== null && _sortDescriptor !== void 0 ? _sortDescriptor : data.sortDescriptor,
                signal: abortController.signal,
                cursor: action.type === 'loadingMore' ? data.cursor : null,
                filterText: previousFilterText
            });
            var _filterText4;
            let filterText = (_filterText4 = response.filterText) !== null && _filterText4 !== void 0 ? _filterText4 : previousFilterText;
            dispatch({
                type: 'success',
                ...response,
                abortController: abortController
            });
            // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText
            // Only do this if not aborted (e.g. user triggers another filter action before load completes)
            if (filterText && filterText !== previousFilterText && !abortController.signal.aborted) dispatchFetch({
                type: 'filtering',
                filterText: filterText
            }, load);
        } catch (e) {
            dispatch({
                type: 'error',
                error: e,
                abortController: abortController
            });
        }
    };
    $kdbv0$react.useEffect(()=>{
        dispatchFetch({
            type: 'loading'
        }, load);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    return {
        items: data.items,
        selectedKeys: data.selectedKeys,
        sortDescriptor: data.sortDescriptor,
        isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',
        loadingState: data.state,
        error: data.error,
        filterText: data.filterText,
        getItem (key) {
            return data.items.find((item)=>getKey(item) === key
            );
        },
        reload () {
            dispatchFetch({
                type: 'loading'
            }, load);
        },
        loadMore () {
            // Ignore if already loading more or if performing server side filtering.
            if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) return;
            dispatchFetch({
                type: 'loadingMore'
            }, load);
        },
        sort (sortDescriptor) {
            dispatchFetch({
                type: 'sorting',
                sortDescriptor: sortDescriptor
            }, sort || load);
        },
        ...$fbc1d750f520c94e$export$79c0c687a5963b0a({
            ...options,
            getKey: getKey,
            cursor: data.cursor
        }, (fn)=>{
            dispatch({
                type: 'update',
                updater: fn
            });
        }),
        setFilterText (filterText) {
            dispatchFetch({
                type: 'filtering',
                filterText: filterText
            }, load);
        }
    };
}



function $2d16d1aab63a81f4$export$d14e1352e21f4a16(options) {
    let { initialItems: initialItems1 = [] , initialSelectedKeys: initialSelectedKeys , getKey: getKey = (item)=>item.id || item.key
     , getChildren: getChildren = (item)=>item.children
      } = options;
    let map = $kdbv0$react.useMemo(()=>new Map()
    , []);
    // We only want to compute this on initial render.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    let initialNodes = $kdbv0$react.useMemo(()=>buildTree(initialItems1)
    , []);
    let [items1, setItems] = $kdbv0$react.useState(initialNodes);
    let [selectedKeys, setSelectedKeys] = $kdbv0$react.useState(new Set(initialSelectedKeys || []));
    function buildTree(initialItems = [], parentKey) {
        return initialItems.map((item)=>{
            let node = {
                key: getKey(item),
                parentKey: parentKey,
                value: item,
                children: null
            };
            node.children = buildTree(getChildren(item), node.key);
            map.set(node.key, node);
            return node;
        });
    }
    function updateTree(items, key, update) {
        let node = map.get(key);
        if (!node) return items;
        // Create a new node. If null, then delete the node, otherwise replace.
        let newNode = update(node);
        if (newNode == null) deleteNode(node);
        else addNode(newNode);
        // Walk up the tree and update each parent to refer to the new chilren.
        while(node.parentKey){
            let nextParent = map.get(node.parentKey);
            let copy = {
                key: nextParent.key,
                parentKey: nextParent.parentKey,
                value: nextParent.value,
                children: null
            };
            let children = nextParent.children;
            if (newNode == null) children = children.filter((c)=>c !== node
            );
            copy.children = children.map((child)=>{
                if (child === node) return newNode;
                return child;
            });
            map.set(copy.key, copy);
            newNode = copy;
            node = nextParent;
        }
        if (newNode == null) items = items.filter((c)=>c !== node
        );
        return items.map((item)=>{
            if (item === node) return newNode;
            return item;
        });
    }
    function addNode(node) {
        map.set(node.key, node);
        for (let child of node.children)addNode(child);
    }
    function deleteNode(node) {
        map.delete(node.key);
        for (let child of node.children)deleteNode(child);
    }
    return {
        items: items1,
        selectedKeys: selectedKeys,
        setSelectedKeys: setSelectedKeys,
        getItem (key) {
            return map.get(key);
        },
        insert (parentKey, index, ...values) {
            setItems((items)=>{
                let nodes = buildTree(values, parentKey);
                // If parentKey is null, insert into the root.
                if (parentKey == null) return [
                    ...items.slice(0, index),
                    ...nodes,
                    ...items.slice(index)
                ];
                // Otherwise, update the parent node and its ancestors.
                return updateTree(items, parentKey, (parentNode)=>({
                        key: parentNode.key,
                        parentKey: parentNode.parentKey,
                        value: parentNode.value,
                        children: [
                            ...parentNode.children.slice(0, index),
                            ...nodes,
                            ...parentNode.children.slice(index)
                        ]
                    })
                );
            });
        },
        insertBefore (key, ...values) {
            let node = map.get(key);
            if (!node) return;
            let parentNode = map.get(node.parentKey);
            let nodes = parentNode ? parentNode.children : items1;
            let index = nodes.indexOf(node);
            this.insert(parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index, ...values);
        },
        insertAfter (key, ...values) {
            let node = map.get(key);
            if (!node) return;
            let parentNode = map.get(node.parentKey);
            let nodes = parentNode ? parentNode.children : items1;
            let index = nodes.indexOf(node);
            this.insert(parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index + 1, ...values);
        },
        prepend (parentKey, ...values) {
            this.insert(parentKey, 0, ...values);
        },
        append (parentKey, ...values) {
            if (parentKey == null) this.insert(null, items1.length, ...values);
            else {
                let parentNode = map.get(parentKey);
                if (!parentNode) return;
                this.insert(parentKey, parentNode.children.length, ...values);
            }
        },
        remove (...keys) {
            let newItems = items1;
            for (let key of keys)newItems = updateTree(newItems, key, ()=>null
            );
            setItems(newItems);
            let selection = new Set(selectedKeys);
            for (let key1 of selectedKeys)if (!map.has(key1)) selection.delete(key1);
            setSelectedKeys(selection);
        },
        removeSelectedItems () {
            this.remove(...selectedKeys);
        },
        move (key, toParentKey, index) {
            setItems((items)=>{
                let node = map.get(key);
                if (!node) return items;
                items = updateTree(items, key, ()=>null
                );
                const movedNode = {
                    ...node,
                    parentKey: toParentKey
                };
                return updateTree(items, toParentKey, (parentNode)=>({
                        key: parentNode.key,
                        parentKey: parentNode.parentKey,
                        value: parentNode.value,
                        children: [
                            ...parentNode.children.slice(0, index),
                            movedNode,
                            ...parentNode.children.slice(index)
                        ]
                    })
                );
            });
        },
        update (oldKey, newValue) {
            setItems((items)=>updateTree(items, oldKey, (oldNode)=>{
                    let node = {
                        key: oldNode.key,
                        parentKey: oldNode.parentKey,
                        value: newValue,
                        children: null
                    };
                    node.children = buildTree(getChildren(newValue), node.key);
                    return node;
                })
            );
        }
    };
}





//# sourceMappingURL=main.js.map


/***/ }),

/***/ 96792:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $82f7L$reactstatelycollections = __webpack_require__(9486);
var $82f7L$react = __webpack_require__(18038);
var $82f7L$reactstatelyselection = __webpack_require__(4873);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useGridState", () => $38009b28e45912ea$export$4007ac09ff9c68ed);
$parcel$export(module.exports, "GridCollection", () => $8bb6a9101b052a66$export$de3fdf6493c353d);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $38009b28e45912ea$export$4007ac09ff9c68ed(props) {
    let { collection: collection , focusMode: focusMode  } = props;
    let selectionState = (0, $82f7L$reactstatelyselection.useMultipleSelectionState)(props);
    let disabledKeys = (0, $82f7L$react.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [
        props.disabledKeys
    ]);
    let setFocusedKey = selectionState.setFocusedKey;
    selectionState.setFocusedKey = (key, child)=>{
        // If focusMode is cell and an item is focused, focus a child cell instead.
        if (focusMode === "cell" && key != null) {
            let item = collection.getItem(key);
            if ((item === null || item === void 0 ? void 0 : item.type) === "item") {
                var _getLastItem, _getFirstItem;
                let children = (0, $82f7L$reactstatelycollections.getChildNodes)(item, collection);
                if (child === "last") key = (_getLastItem = (0, $82f7L$reactstatelycollections.getLastItem)(children)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;
                else key = (_getFirstItem = (0, $82f7L$reactstatelycollections.getFirstItem)(children)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;
            }
        }
        setFocusedKey(key, child);
    };
    let selectionManager = (0, $82f7L$react.useMemo)(()=>new (0, $82f7L$reactstatelyselection.SelectionManager)(collection, selectionState), [
        collection,
        selectionState
    ]);
    // Reset focused key if that item is deleted from the collection.
    const cachedCollection = (0, $82f7L$react.useRef)(null);
    (0, $82f7L$react.useEffect)(()=>{
        if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {
            const node = cachedCollection.current.getItem(selectionState.focusedKey);
            const parentNode = node.parentKey != null && (node.type === "cell" || node.type === "rowheader" || node.type === "column") ? cachedCollection.current.getItem(node.parentKey) : node;
            const cachedRows = cachedCollection.current.rows;
            const rows = collection.rows;
            const diff = cachedRows.length - rows.length;
            let index = Math.min(diff > 1 ? Math.max(parentNode.index - diff + 1, 0) : parentNode.index, rows.length - 1);
            let newRow;
            while(index >= 0){
                if (!selectionManager.isDisabled(rows[index].key) && rows[index].type !== "headerrow") {
                    newRow = rows[index];
                    break;
                }
                // Find next, not disabled row.
                if (index < rows.length - 1) index++;
                else {
                    if (index > parentNode.index) index = parentNode.index;
                    index--;
                }
            }
            if (newRow) {
                const childNodes = newRow.hasChildNodes ? [
                    ...(0, $82f7L$reactstatelycollections.getChildNodes)(newRow, collection)
                ] : [];
                const keyToFocus = newRow.hasChildNodes && parentNode !== node && node.index < childNodes.length ? childNodes[node.index].key : newRow.key;
                selectionState.setFocusedKey(keyToFocus);
            } else selectionState.setFocusedKey(null);
        }
        cachedCollection.current = collection;
    }, [
        collection,
        selectionManager,
        selectionState,
        selectionState.focusedKey
    ]);
    return {
        collection: collection,
        disabledKeys: disabledKeys,
        isKeyboardNavigationDisabled: false,
        selectionManager: selectionManager
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ class $8bb6a9101b052a66$export$de3fdf6493c353d {
    *[Symbol.iterator]() {
        yield* [
            ...this.rows
        ];
    }
    get size() {
        return [
            ...this.rows
        ].length;
    }
    getKeys() {
        return this.keyMap.keys();
    }
    getKeyBefore(key) {
        let node = this.keyMap.get(key);
        return node ? node.prevKey : null;
    }
    getKeyAfter(key) {
        let node = this.keyMap.get(key);
        return node ? node.nextKey : null;
    }
    getFirstKey() {
        var _;
        return (_ = [
            ...this.rows
        ][0]) === null || _ === void 0 ? void 0 : _.key;
    }
    getLastKey() {
        var _rows_;
        let rows = [
            ...this.rows
        ];
        return (_rows_ = rows[rows.length - 1]) === null || _rows_ === void 0 ? void 0 : _rows_.key;
    }
    getItem(key) {
        return this.keyMap.get(key);
    }
    at(idx) {
        const keys = [
            ...this.getKeys()
        ];
        return this.getItem(keys[idx]);
    }
    getChildren(key) {
        let node = this.keyMap.get(key);
        return (node === null || node === void 0 ? void 0 : node.childNodes) || [];
    }
    constructor(opts){
        this.keyMap = new Map();
        this.keyMap = new Map();
        this.columnCount = opts === null || opts === void 0 ? void 0 : opts.columnCount;
        this.rows = [];
        let visit = (node)=>{
            // If the node is the same object as the previous node for the same key,
            // we can skip this node and its children. We always visit columns though,
            // because we depend on order to build the columns array.
            let prevNode = this.keyMap.get(node.key);
            if (opts.visitNode) node = opts.visitNode(node);
            this.keyMap.set(node.key, node);
            let childKeys = new Set();
            let last;
            for (let child of node.childNodes){
                if (child.type === "cell" && child.parentKey == null) // if child is a cell parent key isn't already established by the collection, match child node to parent row
                child.parentKey = node.key;
                childKeys.add(child.key);
                if (last) {
                    last.nextKey = child.key;
                    child.prevKey = last.key;
                } else child.prevKey = null;
                visit(child);
                last = child;
            }
            if (last) last.nextKey = null;
            // Remove deleted nodes and their children from the key map
            if (prevNode) {
                for (let child of prevNode.childNodes)if (!childKeys.has(child.key)) remove(child);
            }
        };
        let remove = (node)=>{
            this.keyMap.delete(node.key);
            for (let child of node.childNodes)if (this.keyMap.get(child.key) === child) remove(child);
        };
        let last;
        opts.items.forEach((node, i)=>{
            let rowNode = {
                level: 0,
                key: "row-" + i,
                type: "row",
                value: undefined,
                hasChildNodes: true,
                childNodes: [
                    ...node.childNodes
                ],
                rendered: undefined,
                textValue: undefined,
                ...node,
                index: i
            };
            if (last) {
                last.nextKey = rowNode.key;
                rowNode.prevKey = last.key;
            } else rowNode.prevKey = null;
            this.rows.push(rowNode);
            visit(rowNode);
            last = rowNode;
        });
        if (last) last.nextKey = null;
    }
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 9486:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $4aZkW$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "Item", () => $c870f3b549c61b6b$export$6d08773d2e66f8f2);
$parcel$export(module.exports, "Section", () => $350f13aa4d8b327c$export$6e2c8f0811a474ce);
$parcel$export(module.exports, "useCollection", () => $98fc0fafaca75b6a$export$6cd28814d92fa9c9);
$parcel$export(module.exports, "getItemCount", () => $e749fe52977fe2c2$export$77d5aafae4e095b2);
$parcel$export(module.exports, "getChildNodes", () => $7a155683b0d79a6a$export$1005530eda016c13);
$parcel$export(module.exports, "getFirstItem", () => $7a155683b0d79a6a$export$fbdeaa6a76694f71);
$parcel$export(module.exports, "getLastItem", () => $7a155683b0d79a6a$export$7475b2c64539e4cf);
$parcel$export(module.exports, "getNthItem", () => $7a155683b0d79a6a$export$5f3398f8733f90e2);
$parcel$export(module.exports, "compareNodeOrder", () => $7a155683b0d79a6a$export$8c434b3a7a4dad6);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $c870f3b549c61b6b$var$Item(props) {
    return null;
}
$c870f3b549c61b6b$var$Item.getCollectionNode = function* getCollectionNode(props, context) {
    let { childItems: childItems , title: title , children: children  } = props;
    let rendered = props.title || props.children;
    let textValue = props.textValue || (typeof rendered === "string" ? rendered : "") || props["aria-label"] || "";
    // suppressTextValueWarning is used in components like Tabs, which don't have type to select support.
    if (!textValue && !(context === null || context === void 0 ? void 0 : context.suppressTextValueWarning)) console.warn("<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.");
    yield {
        type: "item",
        props: props,
        rendered: rendered,
        textValue: textValue,
        "aria-label": props["aria-label"],
        hasChildNodes: $c870f3b549c61b6b$var$hasChildItems(props),
        *childNodes () {
            if (childItems) for (let child of childItems)yield {
                type: "item",
                value: child
            };
            else if (title) {
                let items = [];
                (0, ($parcel$interopDefault($4aZkW$react))).Children.forEach(children, (child)=>{
                    items.push({
                        type: "item",
                        element: child
                    });
                });
                yield* items;
            }
        }
    };
};
function $c870f3b549c61b6b$var$hasChildItems(props) {
    if (props.hasChildItems != null) return props.hasChildItems;
    if (props.childItems) return true;
    if (props.title && (0, ($parcel$interopDefault($4aZkW$react))).Children.count(props.children) > 0) return true;
    return false;
}
// We don't want getCollectionNode to show up in the type definition
let $c870f3b549c61b6b$export$6d08773d2e66f8f2 = $c870f3b549c61b6b$var$Item;


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $350f13aa4d8b327c$var$Section(props) {
    return null;
}
$350f13aa4d8b327c$var$Section.getCollectionNode = function* getCollectionNode(props) {
    let { children: children , title: title , items: items  } = props;
    yield {
        type: "section",
        props: props,
        hasChildNodes: true,
        rendered: title,
        "aria-label": props["aria-label"],
        *childNodes () {
            if (typeof children === "function") {
                if (!items) throw new Error("props.children was a function but props.items is missing");
                for (let item of items)yield {
                    type: "item",
                    value: item,
                    renderer: children
                };
            } else {
                let items = [];
                (0, ($parcel$interopDefault($4aZkW$react))).Children.forEach(children, (child)=>{
                    items.push({
                        type: "item",
                        element: child
                    });
                });
                yield* items;
            }
        }
    };
};
// We don't want getCollectionNode to show up in the type definition
let $350f13aa4d8b327c$export$6e2c8f0811a474ce = $350f13aa4d8b327c$var$Section;


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
class $51588fd411aace25$export$bf788dd355e3a401 {
    build(props, context) {
        this.context = context;
        return $51588fd411aace25$var$iterable(()=>this.iterateCollection(props));
    }
    *iterateCollection(props) {
        let { children: children , items: items  } = props;
        if (typeof children === "function") {
            if (!items) throw new Error("props.children was a function but props.items is missing");
            for (let item of props.items)yield* this.getFullNode({
                value: item
            }, {
                renderer: children
            });
        } else {
            let items = [];
            (0, ($parcel$interopDefault($4aZkW$react))).Children.forEach(children, (child)=>{
                items.push(child);
            });
            let index = 0;
            for (let item of items){
                let nodes = this.getFullNode({
                    element: item,
                    index: index
                }, {});
                for (let node of nodes){
                    index++;
                    yield node;
                }
            }
        }
    }
    getKey(item, partialNode, state, parentKey) {
        if (item.key != null) return item.key;
        if (partialNode.type === "cell" && partialNode.key != null) return `${parentKey}${partialNode.key}`;
        let v = partialNode.value;
        if (v != null) {
            var _v_key;
            let key = (_v_key = v.key) !== null && _v_key !== void 0 ? _v_key : v.id;
            if (key == null) throw new Error("No key found for item");
            return key;
        }
        return parentKey ? `${parentKey}.${partialNode.index}` : `$.${partialNode.index}`;
    }
    getChildState(state, partialNode) {
        return {
            renderer: partialNode.renderer || state.renderer
        };
    }
    *getFullNode(partialNode, state, parentKey, parentNode) {
        // If there's a value instead of an element on the node, and a parent renderer function is available,
        // use it to render an element for the value.
        let element = partialNode.element;
        if (!element && partialNode.value && state && state.renderer) {
            let cached = this.cache.get(partialNode.value);
            if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {
                cached.index = partialNode.index;
                cached.parentKey = parentNode ? parentNode.key : null;
                yield cached;
                return;
            }
            element = state.renderer(partialNode.value);
        }
        // If there's an element with a getCollectionNode function on its type, then it's a supported component.
        // Call this function to get a partial node, and recursively build a full node from there.
        if ((0, ($parcel$interopDefault($4aZkW$react))).isValidElement(element)) {
            let type = element.type;
            if (typeof type !== "function" && typeof type.getCollectionNode !== "function") {
                let name = typeof element.type === "function" ? element.type.name : element.type;
                throw new Error(`Unknown element <${name}> in collection.`);
            }
            let childNodes = type.getCollectionNode(element.props, this.context);
            let index = partialNode.index;
            let result = childNodes.next();
            while(!result.done && result.value){
                let childNode = result.value;
                partialNode.index = index;
                let nodeKey = childNode.key;
                if (!nodeKey) nodeKey = childNode.element ? null : this.getKey(element, partialNode, state, parentKey);
                let nodes = this.getFullNode({
                    ...childNode,
                    key: nodeKey,
                    index: index,
                    wrapper: $51588fd411aace25$var$compose(partialNode.wrapper, childNode.wrapper)
                }, this.getChildState(state, childNode), parentKey ? `${parentKey}${element.key}` : element.key, parentNode);
                let children = [
                    ...nodes
                ];
                for (let node of children){
                    // Cache the node based on its value
                    node.value = childNode.value || partialNode.value;
                    if (node.value) this.cache.set(node.value, node);
                    // The partial node may have specified a type for the child in order to specify a constraint.
                    // Verify that the full node that was built recursively matches this type.
                    if (partialNode.type && node.type !== partialNode.type) throw new Error(`Unsupported type <${$51588fd411aace25$var$capitalize(node.type)}> in <${$51588fd411aace25$var$capitalize(parentNode.type)}>. Only <${$51588fd411aace25$var$capitalize(partialNode.type)}> is supported.`);
                    index++;
                    yield node;
                }
                result = childNodes.next(children);
            }
            return;
        }
        // Ignore invalid elements
        if (partialNode.key == null) return;
        // Create full node
        let builder = this;
        let node = {
            type: partialNode.type,
            props: partialNode.props,
            key: partialNode.key,
            parentKey: parentNode ? parentNode.key : null,
            value: partialNode.value,
            level: parentNode ? parentNode.level + 1 : 0,
            index: partialNode.index,
            rendered: partialNode.rendered,
            textValue: partialNode.textValue,
            "aria-label": partialNode["aria-label"],
            wrapper: partialNode.wrapper,
            shouldInvalidate: partialNode.shouldInvalidate,
            hasChildNodes: partialNode.hasChildNodes,
            childNodes: $51588fd411aace25$var$iterable(function*() {
                if (!partialNode.hasChildNodes) return;
                let index = 0;
                for (let child of partialNode.childNodes()){
                    // Ensure child keys are globally unique by prepending the parent node's key
                    if (child.key != null) // TODO: Remove this line entirely and enforce that users always provide unique keys.
                    // Currently this line will have issues when a parent has a key `a` and a child with key `bc`
                    // but another parent has key `ab` and its child has a key `c`. The combined keys would result in both
                    // children having a key of `abc`.
                    child.key = `${node.key}${child.key}`;
                    child.index = index;
                    let nodes = builder.getFullNode(child, builder.getChildState(state, child), node.key, node);
                    for (let node of nodes){
                        index++;
                        yield node;
                    }
                }
            })
        };
        yield node;
    }
    constructor(){
        this.cache = new WeakMap();
    }
}
// Wraps an iterator function as an iterable object, and caches the results.
function $51588fd411aace25$var$iterable(iterator) {
    let cache = [];
    let iterable = null;
    return {
        *[Symbol.iterator] () {
            for (let item of cache)yield item;
            if (!iterable) iterable = iterator();
            for (let item of iterable){
                cache.push(item);
                yield item;
            }
        }
    };
}
function $51588fd411aace25$var$compose(outer, inner) {
    if (outer && inner) return (element)=>outer(inner(element));
    if (outer) return outer;
    if (inner) return inner;
}
function $51588fd411aace25$var$capitalize(str) {
    return str[0].toUpperCase() + str.slice(1);
}



function $98fc0fafaca75b6a$export$6cd28814d92fa9c9(props, factory, context) {
    let builder = (0, $4aZkW$react.useMemo)(()=>new (0, $51588fd411aace25$export$bf788dd355e3a401)(), []);
    let { children: children , items: items , collection: collection  } = props;
    let result = (0, $4aZkW$react.useMemo)(()=>{
        if (collection) return collection;
        let nodes = builder.build({
            children: children,
            items: items
        }, context);
        return factory(nodes);
    }, [
        builder,
        children,
        items,
        collection,
        context,
        factory
    ]);
    return result;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $7a155683b0d79a6a$export$1005530eda016c13(node, collection) {
    // New API: call collection.getChildren with the node key.
    if (typeof collection.getChildren === "function") return collection.getChildren(node.key);
    // Old API: access childNodes directly.
    return node.childNodes;
}
function $7a155683b0d79a6a$export$fbdeaa6a76694f71(iterable) {
    return $7a155683b0d79a6a$export$5f3398f8733f90e2(iterable, 0);
}
function $7a155683b0d79a6a$export$5f3398f8733f90e2(iterable, index) {
    if (index < 0) return undefined;
    let i = 0;
    for (let item of iterable){
        if (i === index) return item;
        i++;
    }
}
function $7a155683b0d79a6a$export$7475b2c64539e4cf(iterable) {
    let lastItem = undefined;
    for (let value of iterable)lastItem = value;
    return lastItem;
}
function $7a155683b0d79a6a$export$8c434b3a7a4dad6(collection, a, b) {
    // If the two nodes have the same parent, compare their indices.
    if (a.parentKey === b.parentKey) return a.index - b.index;
    // Otherwise, collect all of the ancestors from each node, and find the first one that doesn't match starting from the root.
    let aAncestors = $7a155683b0d79a6a$var$getAncestors(collection, a);
    let bAncestors = $7a155683b0d79a6a$var$getAncestors(collection, b);
    let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a, i)=>a !== bAncestors[i]);
    if (firstNonMatchingAncestor !== -1) {
        // Compare the indices of two children within the common ancestor.
        a = aAncestors[firstNonMatchingAncestor];
        b = bAncestors[firstNonMatchingAncestor];
        return a.index - b.index;
    }
    // 🤷
    return -1;
}
function $7a155683b0d79a6a$var$getAncestors(collection, node) {
    let parents = [];
    while((node === null || node === void 0 ? void 0 : node.parentKey) != null){
        node = collection.getItem(node.parentKey);
        parents.unshift(node);
    }
    return parents;
}


const $e749fe52977fe2c2$var$cache = new WeakMap();
function $e749fe52977fe2c2$export$77d5aafae4e095b2(collection) {
    let count = $e749fe52977fe2c2$var$cache.get(collection);
    if (count != null) return count;
    count = 0;
    let countItems = (items)=>{
        for (let item of items)if (item.type === "section") countItems((0, $7a155683b0d79a6a$export$1005530eda016c13)(item, collection));
        else count++;
    };
    countItems(collection);
    $e749fe52977fe2c2$var$cache.set(collection, count);
    return count;
}





//# sourceMappingURL=main.js.map


/***/ }),

/***/ 66409:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $cAWze$reactstatelyoverlays = __webpack_require__(56586);
var $cAWze$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useMenuTriggerState", () => $f39cdb649cd48930$export$79fefeb1c2091ac3);


function $f39cdb649cd48930$export$79fefeb1c2091ac3(props) {
    let overlayTriggerState = $cAWze$reactstatelyoverlays.useOverlayTriggerState(props);
    let [focusStrategy1, setFocusStrategy] = $cAWze$react.useState(null);
    return {
        focusStrategy: focusStrategy1,
        ...overlayTriggerState,
        open (focusStrategy = null) {
            setFocusStrategy(focusStrategy);
            overlayTriggerState.open();
        },
        toggle (focusStrategy = null) {
            setFocusStrategy(focusStrategy);
            overlayTriggerState.toggle();
        }
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 56586:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $1rDpM$reactstatelyutils = __webpack_require__(12259);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useOverlayTriggerState", () => $5076d97fb6884665$export$61c6a8c84e605fb6);

function $5076d97fb6884665$export$61c6a8c84e605fb6(props) {
    let [isOpen, setOpen] = $1rDpM$reactstatelyutils.useControlledState(props.isOpen, props.defaultOpen || false, props.onOpenChange);
    return {
        isOpen: isOpen,
        setOpen: setOpen,
        open () {
            setOpen(true);
        },
        close () {
            setOpen(false);
        },
        toggle () {
            setOpen(!isOpen);
        }
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 4167:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $6fRYN$reactstatelyutils = __webpack_require__(12259);
var $6fRYN$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useRadioGroupState", () => $307db30b5687e2e8$export$bca9d026f8e704eb);


let $307db30b5687e2e8$var$instance = Math.round(Math.random() * 10000000000);
let $307db30b5687e2e8$var$i = 0;
function $307db30b5687e2e8$export$bca9d026f8e704eb(props) {
    // Preserved here for backward compatibility. React Aria now generates the name instead of stately.
    let name = $6fRYN$react.useMemo(()=>props.name || `radio-group-${$307db30b5687e2e8$var$instance}-${++$307db30b5687e2e8$var$i}`
    , [
        props.name
    ]);
    let [selectedValue, setSelected] = $6fRYN$reactstatelyutils.useControlledState(props.value, props.defaultValue, props.onChange);
    let [lastFocusedValue, setLastFocusedValue] = $6fRYN$react.useState(null);
    let setSelectedValue = (value)=>{
        if (!props.isReadOnly && !props.isDisabled) setSelected(value);
    };
    return {
        name: name,
        selectedValue: selectedValue,
        setSelectedValue: setSelectedValue,
        lastFocusedValue: lastFocusedValue,
        setLastFocusedValue: setLastFocusedValue,
        isDisabled: props.isDisabled || false,
        isReadOnly: props.isReadOnly || false,
        validationState: props.validationState
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 4873:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $83d9f$react = __webpack_require__(18038);
var $83d9f$reactstatelyutils = __webpack_require__(12259);
var $83d9f$reactstatelycollections = __webpack_require__(56450);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useMultipleSelectionState", () => $1adc19da2128bba9$export$253fe78d46329472);
$parcel$export(module.exports, "SelectionManager", () => $8112da6fa5bbc322$export$6c8a5aaad13c9852);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ class $21c847070f1f9569$export$52baac22726c72bf extends Set {
    constructor(keys, anchorKey, currentKey){
        super(keys);
        if (keys instanceof $21c847070f1f9569$export$52baac22726c72bf) {
            this.anchorKey = anchorKey || keys.anchorKey;
            this.currentKey = currentKey || keys.currentKey;
        } else {
            this.anchorKey = anchorKey;
            this.currentKey = currentKey;
        }
    }
}



function $1adc19da2128bba9$var$equalSets(setA, setB) {
    if (setA.size !== setB.size) return false;
    for (let item of setA){
        if (!setB.has(item)) return false;
    }
    return true;
}
function $1adc19da2128bba9$export$253fe78d46329472(props) {
    let { selectionMode: selectionMode = "none" , disallowEmptySelection: disallowEmptySelection , allowDuplicateSelectionEvents: allowDuplicateSelectionEvents , selectionBehavior: selectionBehaviorProp = "toggle" , disabledBehavior: disabledBehavior = "all"  } = props;
    // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.
    // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).
    let isFocusedRef = (0, $83d9f$react.useRef)(false);
    let [, setFocused] = (0, $83d9f$react.useState)(false);
    let focusedKeyRef = (0, $83d9f$react.useRef)(null);
    let childFocusStrategyRef = (0, $83d9f$react.useRef)(null);
    let [, setFocusedKey] = (0, $83d9f$react.useState)(null);
    let selectedKeysProp = (0, $83d9f$react.useMemo)(()=>$1adc19da2128bba9$var$convertSelection(props.selectedKeys), [
        props.selectedKeys
    ]);
    let defaultSelectedKeys = (0, $83d9f$react.useMemo)(()=>$1adc19da2128bba9$var$convertSelection(props.defaultSelectedKeys, new (0, $21c847070f1f9569$export$52baac22726c72bf)()), [
        props.defaultSelectedKeys
    ]);
    let [selectedKeys, setSelectedKeys] = (0, $83d9f$reactstatelyutils.useControlledState)(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);
    let disabledKeysProp = (0, $83d9f$react.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [
        props.disabledKeys
    ]);
    let [selectionBehavior, setSelectionBehavior] = (0, $83d9f$react.useState)(selectionBehaviorProp);
    // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press
    // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.
    if (selectionBehaviorProp === "replace" && selectionBehavior === "toggle" && typeof selectedKeys === "object" && selectedKeys.size === 0) setSelectionBehavior("replace");
    // If the selectionBehavior prop changes, update the state as well.
    let lastSelectionBehavior = (0, $83d9f$react.useRef)(selectionBehaviorProp);
    (0, $83d9f$react.useEffect)(()=>{
        if (selectionBehaviorProp !== lastSelectionBehavior.current) {
            setSelectionBehavior(selectionBehaviorProp);
            lastSelectionBehavior.current = selectionBehaviorProp;
        }
    }, [
        selectionBehaviorProp
    ]);
    return {
        selectionMode: selectionMode,
        disallowEmptySelection: disallowEmptySelection,
        selectionBehavior: selectionBehavior,
        setSelectionBehavior: setSelectionBehavior,
        get isFocused () {
            return isFocusedRef.current;
        },
        setFocused (f) {
            isFocusedRef.current = f;
            setFocused(f);
        },
        get focusedKey () {
            return focusedKeyRef.current;
        },
        get childFocusStrategy () {
            return childFocusStrategyRef.current;
        },
        setFocusedKey (k, childFocusStrategy = "first") {
            focusedKeyRef.current = k;
            childFocusStrategyRef.current = childFocusStrategy;
            setFocusedKey(k);
        },
        selectedKeys: selectedKeys,
        setSelectedKeys (keys) {
            if (allowDuplicateSelectionEvents || !$1adc19da2128bba9$var$equalSets(keys, selectedKeys)) setSelectedKeys(keys);
        },
        disabledKeys: disabledKeysProp,
        disabledBehavior: disabledBehavior
    };
}
function $1adc19da2128bba9$var$convertSelection(selection, defaultValue) {
    if (!selection) return defaultValue;
    return selection === "all" ? "all" : new (0, $21c847070f1f9569$export$52baac22726c72bf)(selection);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

class $8112da6fa5bbc322$export$6c8a5aaad13c9852 {
    /**
   * The type of selection that is allowed in the collection.
   */ get selectionMode() {
        return this.state.selectionMode;
    }
    /**
   * Whether the collection allows empty selection.
   */ get disallowEmptySelection() {
        return this.state.disallowEmptySelection;
    }
    /**
   * The selection behavior for the collection.
   */ get selectionBehavior() {
        return this.state.selectionBehavior;
    }
    /**
   * Sets the selection behavior for the collection.
   */ setSelectionBehavior(selectionBehavior) {
        this.state.setSelectionBehavior(selectionBehavior);
    }
    /**
   * Whether the collection is currently focused.
   */ get isFocused() {
        return this.state.isFocused;
    }
    /**
   * Sets whether the collection is focused.
   */ setFocused(isFocused) {
        this.state.setFocused(isFocused);
    }
    /**
   * The current focused key in the collection.
   */ get focusedKey() {
        return this.state.focusedKey;
    }
    /** Whether the first or last child of the focused key should receive focus. */ get childFocusStrategy() {
        return this.state.childFocusStrategy;
    }
    /**
   * Sets the focused key.
   */ setFocusedKey(key, childFocusStrategy) {
        if (key == null || this.collection.getItem(key)) this.state.setFocusedKey(key, childFocusStrategy);
    }
    /**
   * The currently selected keys in the collection.
   */ get selectedKeys() {
        return this.state.selectedKeys === "all" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;
    }
    /**
   * The raw selection value for the collection.
   * Either 'all' for select all, or a set of keys.
   */ get rawSelection() {
        return this.state.selectedKeys;
    }
    /**
   * Returns whether a key is selected.
   */ isSelected(key) {
        if (this.state.selectionMode === "none") return false;
        key = this.getKey(key);
        return this.state.selectedKeys === "all" ? this.canSelectItem(key) : this.state.selectedKeys.has(key);
    }
    /**
   * Whether the selection is empty.
   */ get isEmpty() {
        return this.state.selectedKeys !== "all" && this.state.selectedKeys.size === 0;
    }
    /**
   * Whether all items in the collection are selected.
   */ get isSelectAll() {
        if (this.isEmpty) return false;
        if (this.state.selectedKeys === "all") return true;
        if (this._isSelectAll != null) return this._isSelectAll;
        let allKeys = this.getSelectAllKeys();
        let selectedKeys = this.state.selectedKeys;
        this._isSelectAll = allKeys.every((k)=>selectedKeys.has(k));
        return this._isSelectAll;
    }
    get firstSelectedKey() {
        let first = null;
        for (let key of this.state.selectedKeys){
            let item = this.collection.getItem(key);
            if (!first || item && (0, $83d9f$reactstatelycollections.compareNodeOrder)(this.collection, item, first) < 0) first = item;
        }
        return first === null || first === void 0 ? void 0 : first.key;
    }
    get lastSelectedKey() {
        let last = null;
        for (let key of this.state.selectedKeys){
            let item = this.collection.getItem(key);
            if (!last || item && (0, $83d9f$reactstatelycollections.compareNodeOrder)(this.collection, item, last) > 0) last = item;
        }
        return last === null || last === void 0 ? void 0 : last.key;
    }
    get disabledKeys() {
        return this.state.disabledKeys;
    }
    get disabledBehavior() {
        return this.state.disabledBehavior;
    }
    /**
   * Extends the selection to the given key.
   */ extendSelection(toKey) {
        if (this.selectionMode === "none") return;
        if (this.selectionMode === "single") {
            this.replaceSelection(toKey);
            return;
        }
        toKey = this.getKey(toKey);
        let selection;
        // Only select the one key if coming from a select all.
        if (this.state.selectedKeys === "all") selection = new (0, $21c847070f1f9569$export$52baac22726c72bf)([
            toKey
        ], toKey, toKey);
        else {
            let selectedKeys = this.state.selectedKeys;
            let anchorKey = selectedKeys.anchorKey || toKey;
            selection = new (0, $21c847070f1f9569$export$52baac22726c72bf)(selectedKeys, anchorKey, toKey);
            for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey))selection.delete(key);
            for (let key of this.getKeyRange(toKey, anchorKey))if (this.canSelectItem(key)) selection.add(key);
        }
        this.state.setSelectedKeys(selection);
    }
    getKeyRange(from, to) {
        let fromItem = this.collection.getItem(from);
        let toItem = this.collection.getItem(to);
        if (fromItem && toItem) {
            if ((0, $83d9f$reactstatelycollections.compareNodeOrder)(this.collection, fromItem, toItem) <= 0) return this.getKeyRangeInternal(from, to);
            return this.getKeyRangeInternal(to, from);
        }
        return [];
    }
    getKeyRangeInternal(from, to) {
        let keys = [];
        let key = from;
        while(key){
            let item = this.collection.getItem(key);
            if (item && item.type === "item" || item.type === "cell" && this.allowsCellSelection) keys.push(key);
            if (key === to) return keys;
            key = this.collection.getKeyAfter(key);
        }
        return [];
    }
    getKey(key) {
        let item = this.collection.getItem(key);
        if (!item) // ¯\_(ツ)_/¯
        return key;
        // If cell selection is allowed, just return the key.
        if (item.type === "cell" && this.allowsCellSelection) return key;
        // Find a parent item to select
        while(item.type !== "item" && item.parentKey != null)item = this.collection.getItem(item.parentKey);
        if (!item || item.type !== "item") return null;
        return item.key;
    }
    /**
   * Toggles whether the given key is selected.
   */ toggleSelection(key) {
        if (this.selectionMode === "none") return;
        if (this.selectionMode === "single" && !this.isSelected(key)) {
            this.replaceSelection(key);
            return;
        }
        key = this.getKey(key);
        if (key == null) return;
        let keys = new (0, $21c847070f1f9569$export$52baac22726c72bf)(this.state.selectedKeys === "all" ? this.getSelectAllKeys() : this.state.selectedKeys);
        if (keys.has(key)) keys.delete(key);
        else if (this.canSelectItem(key)) {
            keys.add(key);
            keys.anchorKey = key;
            keys.currentKey = key;
        }
        if (this.disallowEmptySelection && keys.size === 0) return;
        this.state.setSelectedKeys(keys);
    }
    /**
   * Replaces the selection with only the given key.
   */ replaceSelection(key) {
        if (this.selectionMode === "none") return;
        key = this.getKey(key);
        if (key == null) return;
        let selection = this.canSelectItem(key) ? new (0, $21c847070f1f9569$export$52baac22726c72bf)([
            key
        ], key, key) : new (0, $21c847070f1f9569$export$52baac22726c72bf)();
        this.state.setSelectedKeys(selection);
    }
    /**
   * Replaces the selection with the given keys.
   */ setSelectedKeys(keys) {
        if (this.selectionMode === "none") return;
        let selection = new (0, $21c847070f1f9569$export$52baac22726c72bf)();
        for (let key of keys){
            key = this.getKey(key);
            if (key != null) {
                selection.add(key);
                if (this.selectionMode === "single") break;
            }
        }
        this.state.setSelectedKeys(selection);
    }
    getSelectAllKeys() {
        let keys = [];
        let addKeys = (key)=>{
            while(key){
                if (this.canSelectItem(key)) {
                    let item = this.collection.getItem(key);
                    if (item.type === "item") keys.push(key);
                    // Add child keys. If cell selection is allowed, then include item children too.
                    if (item.hasChildNodes && (this.allowsCellSelection || item.type !== "item")) addKeys((0, $83d9f$reactstatelycollections.getFirstItem)((0, $83d9f$reactstatelycollections.getChildNodes)(item, this.collection)).key);
                }
                key = this.collection.getKeyAfter(key);
            }
        };
        addKeys(this.collection.getFirstKey());
        return keys;
    }
    /**
   * Selects all items in the collection.
   */ selectAll() {
        if (!this.isSelectAll && this.selectionMode === "multiple") this.state.setSelectedKeys("all");
    }
    /**
   * Removes all keys from the selection.
   */ clearSelection() {
        if (!this.disallowEmptySelection && (this.state.selectedKeys === "all" || this.state.selectedKeys.size > 0)) this.state.setSelectedKeys(new (0, $21c847070f1f9569$export$52baac22726c72bf)());
    }
    /**
   * Toggles between select all and an empty selection.
   */ toggleSelectAll() {
        if (this.isSelectAll) this.clearSelection();
        else this.selectAll();
    }
    select(key, e) {
        if (this.selectionMode === "none") return;
        if (this.selectionMode === "single") {
            if (this.isSelected(key) && !this.disallowEmptySelection) this.toggleSelection(key);
            else this.replaceSelection(key);
        } else if (this.selectionBehavior === "toggle" || e && (e.pointerType === "touch" || e.pointerType === "virtual")) // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys
        this.toggleSelection(key);
        else this.replaceSelection(key);
    }
    /**
   * Returns whether the current selection is equal to the given selection.
   */ isSelectionEqual(selection) {
        if (selection === this.state.selectedKeys) return true;
        // Check if the set of keys match.
        let selectedKeys = this.selectedKeys;
        if (selection.size !== selectedKeys.size) return false;
        for (let key of selection){
            if (!selectedKeys.has(key)) return false;
        }
        for (let key of selectedKeys){
            if (!selection.has(key)) return false;
        }
        return true;
    }
    canSelectItem(key) {
        if (this.state.selectionMode === "none" || this.state.disabledKeys.has(key)) return false;
        let item = this.collection.getItem(key);
        if (!item || item.type === "cell" && !this.allowsCellSelection) return false;
        return true;
    }
    isDisabled(key) {
        return this.state.disabledKeys.has(key) && this.state.disabledBehavior === "all";
    }
    constructor(collection, state, options){
        this.collection = collection;
        this.state = state;
        var _options_allowsCellSelection;
        this.allowsCellSelection = (_options_allowsCellSelection = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && _options_allowsCellSelection !== void 0 ? _options_allowsCellSelection : false;
        this._isSelectAll = null;
    }
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 56450:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $4aZkW$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "Item", () => $c870f3b549c61b6b$export$6d08773d2e66f8f2);
$parcel$export(module.exports, "Section", () => $350f13aa4d8b327c$export$6e2c8f0811a474ce);
$parcel$export(module.exports, "useCollection", () => $98fc0fafaca75b6a$export$6cd28814d92fa9c9);
$parcel$export(module.exports, "getItemCount", () => $e749fe52977fe2c2$export$77d5aafae4e095b2);
$parcel$export(module.exports, "getChildNodes", () => $7a155683b0d79a6a$export$1005530eda016c13);
$parcel$export(module.exports, "getFirstItem", () => $7a155683b0d79a6a$export$fbdeaa6a76694f71);
$parcel$export(module.exports, "getLastItem", () => $7a155683b0d79a6a$export$7475b2c64539e4cf);
$parcel$export(module.exports, "getNthItem", () => $7a155683b0d79a6a$export$5f3398f8733f90e2);
$parcel$export(module.exports, "compareNodeOrder", () => $7a155683b0d79a6a$export$8c434b3a7a4dad6);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $c870f3b549c61b6b$var$Item(props) {
    return null;
}
$c870f3b549c61b6b$var$Item.getCollectionNode = function* getCollectionNode(props, context) {
    let { childItems: childItems , title: title , children: children  } = props;
    let rendered = props.title || props.children;
    let textValue = props.textValue || (typeof rendered === "string" ? rendered : "") || props["aria-label"] || "";
    // suppressTextValueWarning is used in components like Tabs, which don't have type to select support.
    if (!textValue && !(context === null || context === void 0 ? void 0 : context.suppressTextValueWarning)) console.warn("<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.");
    yield {
        type: "item",
        props: props,
        rendered: rendered,
        textValue: textValue,
        "aria-label": props["aria-label"],
        hasChildNodes: $c870f3b549c61b6b$var$hasChildItems(props),
        *childNodes () {
            if (childItems) for (let child of childItems)yield {
                type: "item",
                value: child
            };
            else if (title) {
                let items = [];
                (0, ($parcel$interopDefault($4aZkW$react))).Children.forEach(children, (child)=>{
                    items.push({
                        type: "item",
                        element: child
                    });
                });
                yield* items;
            }
        }
    };
};
function $c870f3b549c61b6b$var$hasChildItems(props) {
    if (props.hasChildItems != null) return props.hasChildItems;
    if (props.childItems) return true;
    if (props.title && (0, ($parcel$interopDefault($4aZkW$react))).Children.count(props.children) > 0) return true;
    return false;
}
// We don't want getCollectionNode to show up in the type definition
let $c870f3b549c61b6b$export$6d08773d2e66f8f2 = $c870f3b549c61b6b$var$Item;


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $350f13aa4d8b327c$var$Section(props) {
    return null;
}
$350f13aa4d8b327c$var$Section.getCollectionNode = function* getCollectionNode(props) {
    let { children: children , title: title , items: items  } = props;
    yield {
        type: "section",
        props: props,
        hasChildNodes: true,
        rendered: title,
        "aria-label": props["aria-label"],
        *childNodes () {
            if (typeof children === "function") {
                if (!items) throw new Error("props.children was a function but props.items is missing");
                for (let item of items)yield {
                    type: "item",
                    value: item,
                    renderer: children
                };
            } else {
                let items = [];
                (0, ($parcel$interopDefault($4aZkW$react))).Children.forEach(children, (child)=>{
                    items.push({
                        type: "item",
                        element: child
                    });
                });
                yield* items;
            }
        }
    };
};
// We don't want getCollectionNode to show up in the type definition
let $350f13aa4d8b327c$export$6e2c8f0811a474ce = $350f13aa4d8b327c$var$Section;


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
class $51588fd411aace25$export$bf788dd355e3a401 {
    build(props, context) {
        this.context = context;
        return $51588fd411aace25$var$iterable(()=>this.iterateCollection(props));
    }
    *iterateCollection(props) {
        let { children: children , items: items  } = props;
        if (typeof children === "function") {
            if (!items) throw new Error("props.children was a function but props.items is missing");
            for (let item of props.items)yield* this.getFullNode({
                value: item
            }, {
                renderer: children
            });
        } else {
            let items = [];
            (0, ($parcel$interopDefault($4aZkW$react))).Children.forEach(children, (child)=>{
                items.push(child);
            });
            let index = 0;
            for (let item of items){
                let nodes = this.getFullNode({
                    element: item,
                    index: index
                }, {});
                for (let node of nodes){
                    index++;
                    yield node;
                }
            }
        }
    }
    getKey(item, partialNode, state, parentKey) {
        if (item.key != null) return item.key;
        if (partialNode.type === "cell" && partialNode.key != null) return `${parentKey}${partialNode.key}`;
        let v = partialNode.value;
        if (v != null) {
            var _v_key;
            let key = (_v_key = v.key) !== null && _v_key !== void 0 ? _v_key : v.id;
            if (key == null) throw new Error("No key found for item");
            return key;
        }
        return parentKey ? `${parentKey}.${partialNode.index}` : `$.${partialNode.index}`;
    }
    getChildState(state, partialNode) {
        return {
            renderer: partialNode.renderer || state.renderer
        };
    }
    *getFullNode(partialNode, state, parentKey, parentNode) {
        // If there's a value instead of an element on the node, and a parent renderer function is available,
        // use it to render an element for the value.
        let element = partialNode.element;
        if (!element && partialNode.value && state && state.renderer) {
            let cached = this.cache.get(partialNode.value);
            if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {
                cached.index = partialNode.index;
                cached.parentKey = parentNode ? parentNode.key : null;
                yield cached;
                return;
            }
            element = state.renderer(partialNode.value);
        }
        // If there's an element with a getCollectionNode function on its type, then it's a supported component.
        // Call this function to get a partial node, and recursively build a full node from there.
        if ((0, ($parcel$interopDefault($4aZkW$react))).isValidElement(element)) {
            let type = element.type;
            if (typeof type !== "function" && typeof type.getCollectionNode !== "function") {
                let name = typeof element.type === "function" ? element.type.name : element.type;
                throw new Error(`Unknown element <${name}> in collection.`);
            }
            let childNodes = type.getCollectionNode(element.props, this.context);
            let index = partialNode.index;
            let result = childNodes.next();
            while(!result.done && result.value){
                let childNode = result.value;
                partialNode.index = index;
                let nodeKey = childNode.key;
                if (!nodeKey) nodeKey = childNode.element ? null : this.getKey(element, partialNode, state, parentKey);
                let nodes = this.getFullNode({
                    ...childNode,
                    key: nodeKey,
                    index: index,
                    wrapper: $51588fd411aace25$var$compose(partialNode.wrapper, childNode.wrapper)
                }, this.getChildState(state, childNode), parentKey ? `${parentKey}${element.key}` : element.key, parentNode);
                let children = [
                    ...nodes
                ];
                for (let node of children){
                    // Cache the node based on its value
                    node.value = childNode.value || partialNode.value;
                    if (node.value) this.cache.set(node.value, node);
                    // The partial node may have specified a type for the child in order to specify a constraint.
                    // Verify that the full node that was built recursively matches this type.
                    if (partialNode.type && node.type !== partialNode.type) throw new Error(`Unsupported type <${$51588fd411aace25$var$capitalize(node.type)}> in <${$51588fd411aace25$var$capitalize(parentNode.type)}>. Only <${$51588fd411aace25$var$capitalize(partialNode.type)}> is supported.`);
                    index++;
                    yield node;
                }
                result = childNodes.next(children);
            }
            return;
        }
        // Ignore invalid elements
        if (partialNode.key == null) return;
        // Create full node
        let builder = this;
        let node = {
            type: partialNode.type,
            props: partialNode.props,
            key: partialNode.key,
            parentKey: parentNode ? parentNode.key : null,
            value: partialNode.value,
            level: parentNode ? parentNode.level + 1 : 0,
            index: partialNode.index,
            rendered: partialNode.rendered,
            textValue: partialNode.textValue,
            "aria-label": partialNode["aria-label"],
            wrapper: partialNode.wrapper,
            shouldInvalidate: partialNode.shouldInvalidate,
            hasChildNodes: partialNode.hasChildNodes,
            childNodes: $51588fd411aace25$var$iterable(function*() {
                if (!partialNode.hasChildNodes) return;
                let index = 0;
                for (let child of partialNode.childNodes()){
                    // Ensure child keys are globally unique by prepending the parent node's key
                    if (child.key != null) // TODO: Remove this line entirely and enforce that users always provide unique keys.
                    // Currently this line will have issues when a parent has a key `a` and a child with key `bc`
                    // but another parent has key `ab` and its child has a key `c`. The combined keys would result in both
                    // children having a key of `abc`.
                    child.key = `${node.key}${child.key}`;
                    child.index = index;
                    let nodes = builder.getFullNode(child, builder.getChildState(state, child), node.key, node);
                    for (let node of nodes){
                        index++;
                        yield node;
                    }
                }
            })
        };
        yield node;
    }
    constructor(){
        this.cache = new WeakMap();
    }
}
// Wraps an iterator function as an iterable object, and caches the results.
function $51588fd411aace25$var$iterable(iterator) {
    let cache = [];
    let iterable = null;
    return {
        *[Symbol.iterator] () {
            for (let item of cache)yield item;
            if (!iterable) iterable = iterator();
            for (let item of iterable){
                cache.push(item);
                yield item;
            }
        }
    };
}
function $51588fd411aace25$var$compose(outer, inner) {
    if (outer && inner) return (element)=>outer(inner(element));
    if (outer) return outer;
    if (inner) return inner;
}
function $51588fd411aace25$var$capitalize(str) {
    return str[0].toUpperCase() + str.slice(1);
}



function $98fc0fafaca75b6a$export$6cd28814d92fa9c9(props, factory, context) {
    let builder = (0, $4aZkW$react.useMemo)(()=>new (0, $51588fd411aace25$export$bf788dd355e3a401)(), []);
    let { children: children , items: items , collection: collection  } = props;
    let result = (0, $4aZkW$react.useMemo)(()=>{
        if (collection) return collection;
        let nodes = builder.build({
            children: children,
            items: items
        }, context);
        return factory(nodes);
    }, [
        builder,
        children,
        items,
        collection,
        context,
        factory
    ]);
    return result;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $7a155683b0d79a6a$export$1005530eda016c13(node, collection) {
    // New API: call collection.getChildren with the node key.
    if (typeof collection.getChildren === "function") return collection.getChildren(node.key);
    // Old API: access childNodes directly.
    return node.childNodes;
}
function $7a155683b0d79a6a$export$fbdeaa6a76694f71(iterable) {
    return $7a155683b0d79a6a$export$5f3398f8733f90e2(iterable, 0);
}
function $7a155683b0d79a6a$export$5f3398f8733f90e2(iterable, index) {
    if (index < 0) return undefined;
    let i = 0;
    for (let item of iterable){
        if (i === index) return item;
        i++;
    }
}
function $7a155683b0d79a6a$export$7475b2c64539e4cf(iterable) {
    let lastItem = undefined;
    for (let value of iterable)lastItem = value;
    return lastItem;
}
function $7a155683b0d79a6a$export$8c434b3a7a4dad6(collection, a, b) {
    // If the two nodes have the same parent, compare their indices.
    if (a.parentKey === b.parentKey) return a.index - b.index;
    // Otherwise, collect all of the ancestors from each node, and find the first one that doesn't match starting from the root.
    let aAncestors = $7a155683b0d79a6a$var$getAncestors(collection, a);
    let bAncestors = $7a155683b0d79a6a$var$getAncestors(collection, b);
    let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a, i)=>a !== bAncestors[i]);
    if (firstNonMatchingAncestor !== -1) {
        // Compare the indices of two children within the common ancestor.
        a = aAncestors[firstNonMatchingAncestor];
        b = bAncestors[firstNonMatchingAncestor];
        return a.index - b.index;
    }
    // 🤷
    return -1;
}
function $7a155683b0d79a6a$var$getAncestors(collection, node) {
    let parents = [];
    while((node === null || node === void 0 ? void 0 : node.parentKey) != null){
        node = collection.getItem(node.parentKey);
        parents.unshift(node);
    }
    return parents;
}


const $e749fe52977fe2c2$var$cache = new WeakMap();
function $e749fe52977fe2c2$export$77d5aafae4e095b2(collection) {
    let count = $e749fe52977fe2c2$var$cache.get(collection);
    if (count != null) return count;
    count = 0;
    let countItems = (items)=>{
        for (let item of items)if (item.type === "section") countItems((0, $7a155683b0d79a6a$export$1005530eda016c13)(item, collection));
        else count++;
    };
    countItems(collection);
    $e749fe52977fe2c2$var$cache.set(collection, count);
    return count;
}





//# sourceMappingURL=main.js.map


/***/ }),

/***/ 96886:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $56JBj$reactstatelycollections = __webpack_require__(92775);
var $56JBj$react = __webpack_require__(18038);
var $56JBj$reactstatelygrid = __webpack_require__(96792);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useTableColumnResizeState", () => $7aa22d80cd4ca621$export$cb895dcf85db1319);
$parcel$export(module.exports, "useTableState", () => $e3f7784147dde23d$export$907bcc6c48325fd6);
$parcel$export(module.exports, "TableHeader", () => $f45775f5d6f744fa$export$f850895b287ef28e);
$parcel$export(module.exports, "TableBody", () => $6ec527db6a3a5692$export$76ccd210b9029917);
$parcel$export(module.exports, "Column", () => $714483d9f6ca4c55$export$816b5d811295e6bc);
$parcel$export(module.exports, "Row", () => $9ec6912e32cc0d81$export$b59bdbef9ce70de2);
$parcel$export(module.exports, "Cell", () => $ad4ab0a21c733e1f$export$f6f0c3fe4ec306ea);
$parcel$export(module.exports, "Section", () => $56JBj$reactstatelycollections.Section);
function $3122b463430f41b1$export$f61abf052f87399f(widths) {
    return Array.from(widths).map((e)=>e[1]
    ).reduce((acc, cur)=>acc + cur
    , 0);
}
function $3122b463430f41b1$export$1994a077b98ee0d5(width) {
    return width != null && (!isNaN(width) || String(width).match(/^(\d+)(?=%$)/) !== null);
}
function $3122b463430f41b1$var$parseFractionalUnit(width) {
    if (!width) return 1;
    let match = width.match(/^(\d+)(?=fr$)/);
    // if width is the incorrect format, just deafult it to a 1fr
    if (!match) {
        console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`, 'defaulting to \'1fr\'');
        return 1;
    }
    return parseInt(match[0], 10);
}
function $3122b463430f41b1$export$7bbad27896f7ae9f(width, tableWidth) {
    if (typeof width === 'string') {
        let match = width.match(/^(\d+)(?=%$)/);
        if (!match) throw new Error('Only percentages or numbers are supported for static column widths');
        return tableWidth * (parseInt(match[0], 10) / 100);
    }
    return width;
}
function $3122b463430f41b1$export$59185c62a7544aa0(maxWidth, tableWidth) {
    return maxWidth != null ? $3122b463430f41b1$export$7bbad27896f7ae9f(maxWidth, tableWidth) : Number.MAX_SAFE_INTEGER;
}
function $3122b463430f41b1$export$f556054ce4358701(minWidth, tableWidth) {
    return minWidth != null ? $3122b463430f41b1$export$7bbad27896f7ae9f(minWidth, tableWidth) : 75;
}
function $3122b463430f41b1$var$mapDynamicColumns(dynamicColumns, availableSpace, tableWidth) {
    let fractions = dynamicColumns.reduce((sum, column)=>sum + $3122b463430f41b1$var$parseFractionalUnit(column.props.defaultWidth)
    , 0);
    let columns = dynamicColumns.map((column, index)=>{
        const targetWidth = $3122b463430f41b1$var$parseFractionalUnit(column.props.defaultWidth) * availableSpace / fractions;
        const delta = Math.max($3122b463430f41b1$export$f556054ce4358701(column.props.minWidth, tableWidth) - targetWidth, targetWidth - $3122b463430f41b1$export$59185c62a7544aa0(column.props.maxWidth, tableWidth));
        return {
            ...column,
            index: index,
            delta: delta
        };
    });
    return columns;
}
function $3122b463430f41b1$var$findDynamicColumnWidths(dynamicColumns, availableSpace, tableWidth) {
    let fractions = dynamicColumns.reduce((sum, col)=>sum + $3122b463430f41b1$var$parseFractionalUnit(col.props.defaultWidth)
    , 0);
    const columns = dynamicColumns.map((column)=>{
        const targetWidth = $3122b463430f41b1$var$parseFractionalUnit(column.props.defaultWidth) * availableSpace / fractions;
        let width = Math.max($3122b463430f41b1$export$f556054ce4358701(column.props.minWidth, tableWidth), Math.min(Math.floor(targetWidth), $3122b463430f41b1$export$59185c62a7544aa0(column.props.maxWidth, tableWidth)));
        column.calculatedWidth = width;
        availableSpace -= width;
        fractions -= $3122b463430f41b1$var$parseFractionalUnit(column.props.defaultWidth);
        return column;
    });
    return columns;
}
function $3122b463430f41b1$export$a870e6692ac5ccb2(dynamicColumns, availableSpace, tableWidth) {
    let columns = $3122b463430f41b1$var$mapDynamicColumns(dynamicColumns, availableSpace, tableWidth);
    columns.sort((a, b)=>b.delta - a.delta
    );
    columns = $3122b463430f41b1$var$findDynamicColumnWidths(columns, availableSpace, tableWidth);
    columns.sort((a, b)=>a.index - b.index
    );
    return columns;
}



function $7aa22d80cd4ca621$export$cb895dcf85db1319(props, state) {
    const { getDefaultWidth: getDefaultWidth , tableWidth: defaultTableWidth = null  } = props;
    const { columns: columns1  } = state;
    const columnsRef = $56JBj$react.useRef([]);
    const tableWidth = $56JBj$react.useRef(defaultTableWidth);
    const isResizing = $56JBj$react.useRef(null);
    const startResizeContentWidth = $56JBj$react.useRef();
    const [columnWidths, setColumnWidths] = $56JBj$react.useState(new Map(columns1.map((col)=>[
            col.key,
            0
        ]
    )));
    const columnWidthsRef = $56JBj$react.useRef(columnWidths);
    const affectedColumnWidthsRef = $56JBj$react.useRef([]);
    const [resizedColumns, setResizedColumns] = $56JBj$react.useState(new Set());
    const resizedColumnsRef = $56JBj$react.useRef(resizedColumns);
    const [currentlyResizingColumn, setCurrentlyResizingColumn] = $56JBj$react.useState(null);
    function setColumnWidthsForRef(newWidths) {
        columnWidthsRef.current = newWidths;
        // new map so that change detection is triggered
        setColumnWidths(newWidths);
    }
    /*
    returns the resolved column width in this order:
    previously calculated width -> controlled width prop -> uncontrolled defaultWidth prop -> dev assigned width -> default dynamic width
  */ let getResolvedColumnWidth = $56JBj$react.useCallback((column)=>{
        let columnProps = column.props;
        var _width, ref, ref1;
        return (resizedColumns === null || resizedColumns === void 0 ? void 0 : resizedColumns.has(column.key)) ? columnWidthsRef.current.get(column.key) : (ref1 = (ref = (_width = columnProps.width) !== null && _width !== void 0 ? _width : columnProps.defaultWidth) !== null && ref !== void 0 ? ref : getDefaultWidth === null || getDefaultWidth === void 0 ? void 0 : getDefaultWidth(column.props)) !== null && ref1 !== void 0 ? ref1 : '1fr';
    }, [
        getDefaultWidth,
        resizedColumns
    ]);
    let getStaticAndDynamicColumns = $56JBj$react.useCallback((columns)=>columns.reduce((acc, column)=>{
            let width = getResolvedColumnWidth(column);
            return $3122b463430f41b1$export$1994a077b98ee0d5(width) ? {
                ...acc,
                staticColumns: [
                    ...acc.staticColumns,
                    column
                ]
            } : {
                ...acc,
                dynamicColumns: [
                    ...acc.dynamicColumns,
                    column
                ]
            };
        }, {
            staticColumns: [],
            dynamicColumns: []
        })
    , [
        getResolvedColumnWidth
    ]);
    let buildColumnWidths = $56JBj$react.useCallback((affectedColumns, availableSpace)=>{
        const widths = new Map();
        let remainingSpace = availableSpace;
        const { staticColumns: staticColumns , dynamicColumns: dynamicColumns  } = getStaticAndDynamicColumns(affectedColumns);
        staticColumns.forEach((column)=>{
            let width = getResolvedColumnWidth(column);
            let w = $3122b463430f41b1$export$7bbad27896f7ae9f(width, tableWidth.current);
            widths.set(column.key, w);
            remainingSpace -= w;
        });
        // dynamic columns
        if (dynamicColumns.length > 0) {
            const newColumnWidths = $3122b463430f41b1$export$a870e6692ac5ccb2(dynamicColumns, remainingSpace, tableWidth.current);
            for (let column of newColumnWidths)widths.set(column.key, column.calculatedWidth);
        }
        return widths;
    }, [
        getStaticAndDynamicColumns,
        getResolvedColumnWidth
    ]);
    const prevColKeys = columnsRef.current.map((col)=>col.key
    );
    const colKeys = columns1.map((col)=>col.key
    );
    // if the columns change, need to rebuild widths.
    if (prevColKeys.length !== colKeys.length || !colKeys.every((col, i)=>col === prevColKeys[i]
    )) {
        columnsRef.current = columns1;
        const widths = buildColumnWidths(columns1, tableWidth.current);
        setColumnWidthsForRef(widths);
    }
    function setTableWidth(width) {
        if (width && width !== tableWidth.current) {
            tableWidth.current = width;
            if (!isResizing.current) {
                const widths = buildColumnWidths(columns1, width);
                setColumnWidthsForRef(widths);
            }
        }
    }
    function onColumnResizeStart(column) {
        setCurrentlyResizingColumn(column.key);
        isResizing.current = true;
        startResizeContentWidth.current = $3122b463430f41b1$export$f61abf052f87399f(columnWidthsRef.current);
    }
    function onColumnResize(column, width) {
        let widthsObj = resizeColumn(column, width);
        affectedColumnWidthsRef.current = widthsObj;
        props.onColumnResize && props.onColumnResize(affectedColumnWidthsRef.current);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    function onColumnResizeEnd(column) {
        props.onColumnResizeEnd && isResizing.current && props.onColumnResizeEnd(affectedColumnWidthsRef.current);
        setCurrentlyResizingColumn(null);
        isResizing.current = false;
        affectedColumnWidthsRef.current = [];
        let widths = new Map(columnWidthsRef.current);
        setColumnWidthsForRef(widths);
    }
    function resizeColumn(column1, newWidth) {
        let boundedWidth = Math.max($3122b463430f41b1$export$f556054ce4358701(column1.props.minWidth, tableWidth.current), Math.min(Math.floor(newWidth), $3122b463430f41b1$export$59185c62a7544aa0(column1.props.maxWidth, tableWidth.current)));
        // copy the columnWidths map and set the new width for the column being resized
        let widths = new Map(columnWidthsRef.current);
        widths.set(column1.key, boundedWidth);
        // keep track of all columns that have been sized
        resizedColumnsRef.current.add(column1.key);
        setResizedColumns(resizedColumnsRef.current);
        // get the columns affected by resize and remaining space
        const resizeIndex = columnsRef.current.findIndex((col)=>col.key === column1.key
        );
        let affectedColumns = columnsRef.current.slice(resizeIndex + 1);
        // we only care about the columns that CAN be resized, we ignore static columns.
        let { dynamicColumns: dynamicColumns  } = getStaticAndDynamicColumns(affectedColumns);
        // available space for affected columns
        let availableSpace = columnsRef.current.reduce((acc, column, index)=>{
            if (index <= resizeIndex || $3122b463430f41b1$export$1994a077b98ee0d5(getResolvedColumnWidth(column))) return acc - widths.get(column.key);
            return acc;
        }, tableWidth.current);
        // merge the unaffected column widths and the recalculated column widths
        let recalculatedColumnWidths = buildColumnWidths(dynamicColumns, availableSpace);
        widths = new Map([
            ...widths,
            ...recalculatedColumnWidths
        ]);
        setColumnWidthsForRef(widths);
        /*
     when getting recalculated columns above, the column being resized is not considered "recalculated"
     so we need to add it to the list of affected columns
    */ let allAffectedColumns = [
            [
                column1.key,
                boundedWidth
            ],
            ...recalculatedColumnWidths
        ].map(([key, width])=>({
                key: key,
                width: width
            })
        );
        return allAffectedColumns;
    }
    var ref2;
    // This function is regenerated whenever columnWidthsRef.current changes in order to get the new correct ref value.
    let getColumnWidth = $56JBj$react.useCallback((key)=>(ref2 = columnWidthsRef.current.get(key)) !== null && ref2 !== void 0 ? ref2 : 0
    , [
        columnWidthsRef.current
    ]);
    let getColumnMinWidth = $56JBj$react.useCallback((key)=>{
        const columnIndex = columns1.findIndex((col)=>col.key === key
        );
        if (columnIndex === -1) return;
        return $3122b463430f41b1$export$f556054ce4358701(columns1[columnIndex].props.minWidth, tableWidth.current);
    }, [
        columns1
    ]);
    let getColumnMaxWidth = $56JBj$react.useCallback((key)=>{
        const columnIndex = columns1.findIndex((col)=>col.key === key
        );
        if (columnIndex === -1) return;
        return $3122b463430f41b1$export$59185c62a7544aa0(columns1[columnIndex].props.maxWidth, tableWidth.current);
    }, [
        columns1
    ]);
    return {
        columnWidths: columnWidthsRef,
        setTableWidth: setTableWidth,
        onColumnResize: onColumnResize,
        onColumnResizeStart: onColumnResizeStart,
        onColumnResizeEnd: onColumnResizeEnd,
        getColumnWidth: getColumnWidth,
        getColumnMinWidth: getColumnMinWidth,
        getColumnMaxWidth: getColumnMaxWidth,
        currentlyResizingColumn: currentlyResizingColumn
    };
}





const $7f5a58334d8866a5$var$ROW_HEADER_COLUMN_KEY = 'row-header-column-' + Math.random().toString(36).slice(2);
function $7f5a58334d8866a5$var$buildHeaderRows(keyMap, columnNodes) {
    let columns = [];
    let seen = new Map();
    for (let column of columnNodes){
        let parentKey = column.parentKey;
        let col = [
            column
        ];
        while(parentKey){
            let parent = keyMap.get(parentKey);
            // If we've already seen this parent, than it is shared
            // with a previous column. If the current column is taller
            // than the previous column, than we need to shift the parent
            // in the previous column so it's level with the current column.
            if (seen.has(parent)) {
                parent.colspan++;
                let { column: column , index: index  } = seen.get(parent);
                if (index > col.length) break;
                for(let i = index; i < col.length; i++)column.splice(i, 0, null);
                // Adjust shifted indices
                for(let i1 = col.length; i1 < column.length; i1++)if (column[i1] && seen.has(column[i1])) seen.get(column[i1]).index = i1;
            } else {
                parent.colspan = 1;
                col.push(parent);
                seen.set(parent, {
                    column: col,
                    index: col.length - 1
                });
            }
            parentKey = parent.parentKey;
        }
        columns.push(col);
        column.index = columns.length - 1;
    }
    let maxLength = Math.max(...columns.map((c)=>c.length
    ));
    let headerRows = Array(maxLength).fill(0).map(()=>[]
    );
    // Convert columns into rows.
    let colIndex = 0;
    for (let column1 of columns){
        let i = maxLength - 1;
        for (let item of column1){
            if (item) {
                // Fill the space up until the current column with a placeholder
                let row = headerRows[i];
                let rowLength = row.reduce((p, c)=>p + c.colspan
                , 0);
                if (rowLength < colIndex) {
                    let placeholder = {
                        type: 'placeholder',
                        key: 'placeholder-' + item.key,
                        colspan: colIndex - rowLength,
                        index: rowLength,
                        value: null,
                        rendered: null,
                        level: i,
                        hasChildNodes: false,
                        childNodes: [],
                        textValue: null
                    };
                    if (row.length > 0) {
                        row[row.length - 1].nextKey = placeholder.key;
                        placeholder.prevKey = row[row.length - 1].key;
                    }
                    row.push(placeholder);
                }
                if (row.length > 0) {
                    row[row.length - 1].nextKey = item.key;
                    item.prevKey = row[row.length - 1].key;
                }
                item.level = i;
                item.colIndex = colIndex;
                row.push(item);
            }
            i--;
        }
        colIndex++;
    }
    // Add placeholders at the end of each row that is shorter than the maximum
    let i = 0;
    for (let row1 of headerRows){
        let rowLength = row1.reduce((p, c)=>p + c.colspan
        , 0);
        if (rowLength < columnNodes.length) {
            let placeholder = {
                type: 'placeholder',
                key: 'placeholder-' + row1[row1.length - 1].key,
                colspan: columnNodes.length - rowLength,
                index: rowLength,
                value: null,
                rendered: null,
                level: i,
                hasChildNodes: false,
                childNodes: [],
                textValue: null,
                prevKey: row1[row1.length - 1].key
            };
            row1.push(placeholder);
        }
        i++;
    }
    return headerRows.map((childNodes, index)=>{
        let row = {
            type: 'headerrow',
            key: 'headerrow-' + index,
            index: index,
            value: null,
            rendered: null,
            level: 0,
            hasChildNodes: true,
            childNodes: childNodes,
            textValue: null
        };
        return row;
    });
}
var tmp = Symbol.iterator;
class $7f5a58334d8866a5$export$596e1b2e2cf93690 extends $56JBj$reactstatelygrid.GridCollection {
    *[tmp]() {
        yield* this.body.childNodes;
    }
    get size() {
        return [
            ...this.body.childNodes
        ].length;
    }
    getKeys() {
        return this.keyMap.keys();
    }
    getKeyBefore(key) {
        let node = this.keyMap.get(key);
        return node ? node.prevKey : null;
    }
    getKeyAfter(key) {
        let node = this.keyMap.get(key);
        return node ? node.nextKey : null;
    }
    getFirstKey() {
        var ref;
        return (ref = [
            ...this.body.childNodes
        ][0]) === null || ref === void 0 ? void 0 : ref.key;
    }
    getLastKey() {
        var ref;
        let rows = [
            ...this.body.childNodes
        ];
        return (ref = rows[rows.length - 1]) === null || ref === void 0 ? void 0 : ref.key;
    }
    getItem(key) {
        return this.keyMap.get(key);
    }
    at(idx) {
        const keys = [
            ...this.getKeys()
        ];
        return this.getItem(keys[idx]);
    }
    constructor(nodes, prev, opts){
        let rowHeaderColumnKeys = new Set();
        let body;
        let columns = [];
        // Add cell for selection checkboxes if needed.
        if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {
            let rowHeaderColumn = {
                type: 'column',
                key: $7f5a58334d8866a5$var$ROW_HEADER_COLUMN_KEY,
                value: null,
                textValue: '',
                level: 0,
                index: 0,
                hasChildNodes: false,
                rendered: null,
                childNodes: [],
                props: {
                    isSelectionCell: true
                }
            };
            columns.unshift(rowHeaderColumn);
        }
        let rows = [];
        let columnKeyMap = new Map();
        let visit = (node)=>{
            switch(node.type){
                case 'body':
                    body = node;
                    break;
                case 'column':
                    columnKeyMap.set(node.key, node);
                    if (!node.hasChildNodes) {
                        columns.push(node);
                        if (node.props.isRowHeader) rowHeaderColumnKeys.add(node.key);
                    }
                    break;
                case 'item':
                    rows.push(node);
                    return; // do not go into childNodes
            }
            for (let child of node.childNodes)visit(child);
        };
        for (let node1 of nodes)visit(node1);
        let headerRows = $7f5a58334d8866a5$var$buildHeaderRows(columnKeyMap, columns);
        headerRows.forEach((row, i)=>rows.splice(i, 0, row)
        );
        super({
            columnCount: columns.length,
            items: rows,
            visitNode: (node)=>{
                node.column = columns[node.index];
                return node;
            }
        });
        this.columns = columns;
        this.rowHeaderColumnKeys = rowHeaderColumnKeys;
        this.body = body;
        this.headerRows = headerRows;
        // Default row header column to the first one.
        if (this.rowHeaderColumnKeys.size === 0) this.rowHeaderColumnKeys.add(this.columns[(opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) ? 1 : 0].key);
    }
}



const $e3f7784147dde23d$var$OPPOSITE_SORT_DIRECTION = {
    ascending: 'descending',
    descending: 'ascending'
};
function $e3f7784147dde23d$export$907bcc6c48325fd6(props) {
    let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = $56JBj$react.useState(false);
    let { selectionMode: selectionMode = 'none'  } = props;
    let context = $56JBj$react.useMemo(()=>({
            showSelectionCheckboxes: props.showSelectionCheckboxes && selectionMode !== 'none',
            selectionMode: selectionMode,
            columns: []
        })
    , [
        props.children,
        props.showSelectionCheckboxes,
        selectionMode
    ]);
    let collection = $56JBj$reactstatelycollections.useCollection(props, (nodes, prev)=>new $7f5a58334d8866a5$export$596e1b2e2cf93690(nodes, prev, context)
    , context);
    let { disabledKeys: disabledKeys , selectionManager: selectionManager  } = $56JBj$reactstatelygrid.useGridState({
        ...props,
        collection: collection
    });
    return {
        collection: collection,
        disabledKeys: disabledKeys,
        selectionManager: selectionManager,
        showSelectionCheckboxes: props.showSelectionCheckboxes || false,
        sortDescriptor: props.sortDescriptor,
        isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,
        setKeyboardNavigationDisabled: setKeyboardNavigationDisabled,
        sort (columnKey, direction) {
            var ref;
            props.onSortChange({
                column: columnKey,
                direction: direction !== null && direction !== void 0 ? direction : ((ref = props.sortDescriptor) === null || ref === void 0 ? void 0 : ref.column) === columnKey ? $e3f7784147dde23d$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : 'ascending'
            });
        }
    };
}



function $f45775f5d6f744fa$var$TableHeader(props) {
    return null;
}
$f45775f5d6f744fa$var$TableHeader.getCollectionNode = function* getCollectionNode(props) {
    let { children: children , columns: columns  } = props;
    if (typeof children === 'function') {
        if (!columns) throw new Error('props.children was a function but props.columns is missing');
        for (let column of columns)yield {
            type: 'column',
            value: column,
            renderer: children
        };
    } else {
        let columns = [];
        ($parcel$interopDefault($56JBj$react)).Children.forEach(children, (column)=>{
            columns.push({
                type: 'column',
                element: column
            });
        });
        yield* columns;
    }
};
/**
 * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined
 * as children, or generated dynamically using a function based on the data passed to the `columns` prop.
 */ // We don't want getCollectionNode to show up in the type definition
let $f45775f5d6f744fa$export$f850895b287ef28e = $f45775f5d6f744fa$var$TableHeader;



function $6ec527db6a3a5692$var$TableBody(props) {
    return null;
}
$6ec527db6a3a5692$var$TableBody.getCollectionNode = function* getCollectionNode(props) {
    let { children: children , items: items1  } = props;
    yield {
        type: 'body',
        hasChildNodes: true,
        props: props,
        *childNodes () {
            if (typeof children === 'function') {
                if (!items1) throw new Error('props.children was a function but props.items is missing');
                for (let item of items1)yield {
                    type: 'item',
                    value: item,
                    renderer: children
                };
            } else {
                let items = [];
                ($parcel$interopDefault($56JBj$react)).Children.forEach(children, (item)=>{
                    items.push({
                        type: 'item',
                        element: item
                    });
                });
                yield* items;
            }
        }
    };
};
/**
 * A TableBody is a container for the Row elements of a Table. Rows can be statically defined
 * as children, or generated dynamically using a function based on the data passed to the `items` prop.
 */ // We don't want getCollectionNode to show up in the type definition
let $6ec527db6a3a5692$export$76ccd210b9029917 = $6ec527db6a3a5692$var$TableBody;



function $714483d9f6ca4c55$var$Column(props) {
    return null;
}
$714483d9f6ca4c55$var$Column.getCollectionNode = function* getCollectionNode(props, context1) {
    let { title: title , children: children , childColumns: childColumns1  } = props;
    let rendered = title || children;
    let textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'];
    let fullNodes = yield {
        type: 'column',
        hasChildNodes: !!childColumns1 || title && ($parcel$interopDefault($56JBj$react)).Children.count(children) > 0,
        rendered: rendered,
        textValue: textValue,
        props: props,
        *childNodes () {
            if (childColumns1) for (let child1 of childColumns1)yield {
                type: 'column',
                value: child1
            };
            else if (title) {
                let childColumns = [];
                ($parcel$interopDefault($56JBj$react)).Children.forEach(children, (child)=>{
                    childColumns.push({
                        type: 'column',
                        element: child
                    });
                });
                yield* childColumns;
            }
        },
        shouldInvalidate (newContext) {
            // This is a bit of a hack, but it works.
            // If this method is called, then there's a cached version of this node available.
            // But, we need to keep the list of columns in the new context up to date.
            updateContext(newContext);
            return false;
        }
    };
    let updateContext = (context)=>{
        // register leaf columns on the context so that <Row> can access them
        for (let node of fullNodes)if (!node.hasChildNodes) context.columns.push(node);
    };
    updateContext(context1);
};
/**
 * A Column represents a field of each item within a Table. Columns may also contain nested
 * Column elements to represent column groups. Nested columns can be statically defined as
 * children, or dynamically generated using a function based on the `childColumns` prop.
 */ // We don't want getCollectionNode to show up in the type definition
let $714483d9f6ca4c55$export$816b5d811295e6bc = $714483d9f6ca4c55$var$Column;



function $9ec6912e32cc0d81$var$Row(props) {
    return null;
}
$9ec6912e32cc0d81$var$Row.getCollectionNode = function* getCollectionNode(props, context) {
    let { children: children , textValue: textValue  } = props;
    yield {
        type: 'item',
        props: props,
        textValue: textValue,
        'aria-label': props['aria-label'],
        hasChildNodes: true,
        *childNodes () {
            // Process cells first
            if (context.showSelectionCheckboxes && context.selectionMode !== 'none') yield {
                type: 'cell',
                key: 'header',
                props: {
                    isSelectionCell: true
                }
            };
            if (typeof children === 'function') for (let column of context.columns)yield {
                type: 'cell',
                element: children(column.key),
                key: column.key // this is combined with the row key by CollectionBuilder
            };
            else {
                let cells = [];
                ($parcel$interopDefault($56JBj$react)).Children.forEach(children, (cell)=>{
                    cells.push({
                        type: 'cell',
                        element: cell
                    });
                });
                if (cells.length !== context.columns.length) throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);
                yield* cells;
            }
        },
        shouldInvalidate (newContext) {
            // Invalidate all rows if the columns changed.
            return newContext.columns.length !== context.columns.length || newContext.columns.some((c, i)=>c.key !== context.columns[i].key
            ) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.selectionMode !== context.selectionMode;
        }
    };
};
/**
 * A Row represents a single item in a Table and contains Cell elements for each column.
 * Cells can be statically defined as children, or generated dynamically using a function
 * based on the columns defined in the TableHeader.
 */ // We don't want getCollectionNode to show up in the type definition
let $9ec6912e32cc0d81$export$b59bdbef9ce70de2 = $9ec6912e32cc0d81$var$Row;


function $ad4ab0a21c733e1f$var$Cell(props) {
    return null;
}
$ad4ab0a21c733e1f$var$Cell.getCollectionNode = function* getCollectionNode(props) {
    let { children: children  } = props;
    let textValue = props.textValue || (typeof children === 'string' ? children : '') || props['aria-label'] || '';
    yield {
        type: 'cell',
        props: props,
        rendered: children,
        textValue: textValue,
        'aria-label': props['aria-label'],
        hasChildNodes: false
    };
};
/**
 * A Cell represents the value of a single Column within a Table Row.
 */ // We don't want getCollectionNode to show up in the type definition
let $ad4ab0a21c733e1f$export$f6f0c3fe4ec306ea = $ad4ab0a21c733e1f$var$Cell;





//# sourceMappingURL=main.js.map


/***/ }),

/***/ 841:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $2JeFo$reactstatelyutils = __webpack_require__(12259);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useToggleState", () => $d84f98b140466b44$export$8042c6c013fd5226);

function $d84f98b140466b44$export$8042c6c013fd5226(props = {
}) {
    let { isReadOnly: isReadOnly  } = props;
    // have to provide an empty function so useControlledState doesn't throw a fit
    // can't use useControlledState's prop calling because we need the event object from the change
    let [isSelected, setSelected] = $2JeFo$reactstatelyutils.useControlledState(props.isSelected, props.defaultSelected || false, props.onChange);
    function updateSelected(value) {
        if (!isReadOnly) setSelected(value);
    }
    function toggleState() {
        if (!isReadOnly) setSelected(!isSelected);
    }
    return {
        isSelected: isSelected,
        setSelected: updateSelected,
        toggle: toggleState
    };
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 62051:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $cfIzB$react = __webpack_require__(18038);
var $cfIzB$reactstatelyselection = __webpack_require__(4873);
var $cfIzB$reactstatelycollections = __webpack_require__(92775);
var $cfIzB$reactstatelyutils = __webpack_require__(12259);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useTreeState", () => $38effb299000faaf$export$728d6ba534403756);


var tmp = Symbol.iterator;
class $fae56b53b03726ff$export$863faf230ee2118a {
    *[tmp]() {
        yield* this.iterable;
    }
    get size() {
        return this.keyMap.size;
    }
    getKeys() {
        return this.keyMap.keys();
    }
    getKeyBefore(key) {
        let node = this.keyMap.get(key);
        return node ? node.prevKey : null;
    }
    getKeyAfter(key) {
        let node = this.keyMap.get(key);
        return node ? node.nextKey : null;
    }
    getFirstKey() {
        return this.firstKey;
    }
    getLastKey() {
        return this.lastKey;
    }
    getItem(key) {
        return this.keyMap.get(key);
    }
    at(idx) {
        const keys = [
            ...this.getKeys()
        ];
        return this.getItem(keys[idx]);
    }
    constructor(nodes, { expandedKeys: expandedKeys  } = {
    }){
        this.keyMap = new Map();
        this.iterable = nodes;
        expandedKeys = expandedKeys || new Set();
        let visit = (node)=>{
            this.keyMap.set(node.key, node);
            if (node.childNodes && (node.type === 'section' || expandedKeys.has(node.key))) for (let child of node.childNodes)visit(child);
        };
        for (let node2 of nodes)visit(node2);
        let last;
        let index = 0;
        for (let [key, node1] of this.keyMap){
            if (last) {
                last.nextKey = key;
                node1.prevKey = last.key;
            } else {
                this.firstKey = key;
                node1.prevKey = undefined;
            }
            if (node1.type === 'item') node1.index = index++;
            last = node1;
            // Set nextKey as undefined since this might be the last node
            // If it isn't the last node, last.nextKey will properly set at start of new loop
            last.nextKey = undefined;
        }
        this.lastKey = last === null || last === void 0 ? void 0 : last.key;
    }
}




function $38effb299000faaf$export$728d6ba534403756(props) {
    let [expandedKeys, setExpandedKeys] = $cfIzB$reactstatelyutils.useControlledState(props.expandedKeys ? new Set(props.expandedKeys) : undefined, props.defaultExpandedKeys ? new Set(props.defaultExpandedKeys) : new Set(), props.onExpandedChange);
    let selectionState = $cfIzB$reactstatelyselection.useMultipleSelectionState(props);
    let disabledKeys = $cfIzB$react.useMemo(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set()
    , [
        props.disabledKeys
    ]);
    let tree = $cfIzB$reactstatelycollections.useCollection(props, (nodes)=>new $fae56b53b03726ff$export$863faf230ee2118a(nodes, {
            expandedKeys: expandedKeys
        })
    , null, [
        expandedKeys
    ]);
    // Reset focused key if that item is deleted from the collection.
    $cfIzB$react.useEffect(()=>{
        if (selectionState.focusedKey != null && !tree.getItem(selectionState.focusedKey)) selectionState.setFocusedKey(null);
    }, [
        tree,
        selectionState.focusedKey
    ]);
    let onToggle = (key)=>{
        setExpandedKeys($38effb299000faaf$var$toggleKey(expandedKeys, key));
    };
    return {
        collection: tree,
        expandedKeys: expandedKeys,
        disabledKeys: disabledKeys,
        toggleKey: onToggle,
        selectionManager: new $cfIzB$reactstatelyselection.SelectionManager(tree, selectionState)
    };
}
function $38effb299000faaf$var$toggleKey(set, key) {
    let res = new Set(set);
    if (res.has(key)) res.delete(key);
    else res.add(key);
    return res;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 12259:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $kC0mY$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "useControlledState", () => $8d8fdfab47455712$export$40bfa8c7b0832715);
$parcel$export(module.exports, "clamp", () => $ac8e4d4816275668$export$7d15b64cf5a3a4c4);
$parcel$export(module.exports, "snapValueToStep", () => $ac8e4d4816275668$export$cb6e0bb50bc19463);
$parcel$export(module.exports, "toFixedNumber", () => $ac8e4d4816275668$export$b6268554fba451f);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $8d8fdfab47455712$export$40bfa8c7b0832715(value, defaultValue, onChange) {
    let [stateValue, setStateValue] = (0, $kC0mY$react.useState)(value || defaultValue);
    let isControlledRef = (0, $kC0mY$react.useRef)(value !== undefined);
    let isControlled = value !== undefined;
    (0, $kC0mY$react.useEffect)(()=>{
        let wasControlled = isControlledRef.current;
        if (wasControlled !== isControlled) console.warn(`WARN: A component changed from ${wasControlled ? "controlled" : "uncontrolled"} to ${isControlled ? "controlled" : "uncontrolled"}.`);
        isControlledRef.current = isControlled;
    }, [
        isControlled
    ]);
    let currentValue = isControlled ? value : stateValue;
    let setValue = (0, $kC0mY$react.useCallback)((value, ...args)=>{
        let onChangeCaller = (value, ...onChangeArgs)=>{
            if (onChange) {
                if (!Object.is(currentValue, value)) onChange(value, ...onChangeArgs);
            }
            if (!isControlled) // If uncontrolled, mutate the currentValue local variable so that
            // calling setState multiple times with the same value only emits onChange once.
            // We do not use a ref for this because we specifically _do_ want the value to
            // reset every render, and assigning to a ref in render breaks aborted suspended renders.
            // eslint-disable-next-line react-hooks/exhaustive-deps
            currentValue = value;
        };
        if (typeof value === "function") {
            console.warn("We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320");
            // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates
            // when someone using useControlledState calls setControlledState(myFunc)
            // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc
            // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning
            // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same
            let updateFunction = (oldValue, ...functionArgs)=>{
                let interceptedValue = value(isControlled ? currentValue : oldValue, ...functionArgs);
                onChangeCaller(interceptedValue, ...args);
                if (!isControlled) return interceptedValue;
                return oldValue;
            };
            setStateValue(updateFunction);
        } else {
            if (!isControlled) setStateValue(value);
            onChangeCaller(value, ...args);
        }
    }, [
        isControlled,
        currentValue,
        onChange
    ]);
    return [
        currentValue,
        setValue
    ];
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /**
 * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.
 */ function $ac8e4d4816275668$export$7d15b64cf5a3a4c4(value, min = -Infinity, max = Infinity) {
    let newValue = Math.min(Math.max(value, min), max);
    return newValue;
}
function $ac8e4d4816275668$export$cb6e0bb50bc19463(value, min, max, step) {
    let remainder = (value - (isNaN(min) ? 0 : min)) % step;
    let snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;
    if (!isNaN(min)) {
        if (snappedValue < min) snappedValue = min;
        else if (!isNaN(max) && snappedValue > max) snappedValue = min + Math.floor((max - min) / step) * step;
    } else if (!isNaN(max) && snappedValue > max) snappedValue = Math.floor(max / step) * step;
    // correct floating point behavior by rounding to step precision
    let string = step.toString();
    let index = string.indexOf(".");
    let precision = index >= 0 ? string.length - index : 0;
    if (precision > 0) {
        let pow = Math.pow(10, precision);
        snappedValue = Math.round(snappedValue * pow) / pow;
    }
    return snappedValue;
}
function $ac8e4d4816275668$export$b6268554fba451f(value, digits, base = 10) {
    const pow = Math.pow(base, digits);
    return Math.round(value * pow) / pow;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 35958:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $aEpNF$react = __webpack_require__(18038);
var $aEpNF$reactariautils = __webpack_require__(47770);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "Layout", () => $ac14d65a0ec196dd$export$c84671f46d6a1ca);
$parcel$export(module.exports, "LayoutInfo", () => $8a899922c0a55745$export$7e0eeb9da702a085);
$parcel$export(module.exports, "Point", () => $f89f15d7f52bce29$export$baf26146a414f24a);
$parcel$export(module.exports, "Rect", () => $41b7691783731623$export$c79fc6492f3af13d);
$parcel$export(module.exports, "Size", () => $064492b79924894c$export$cb6da89c6af1a8ec);
$parcel$export(module.exports, "ReusableView", () => $197a1781bd47f5b9$export$1a5223887c560441);
$parcel$export(module.exports, "useVirtualizerState", () => $f02ef43b5e8eee9b$export$1505db82fe357e65);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ class $ac14d65a0ec196dd$export$c84671f46d6a1ca {
    /**
   * Returns whether the layout should invalidate in response to
   * visible rectangle changes. By default, it only invalidates
   * when the collection view's size changes. Return true always
   * to make the layout invalidate while scrolling (e.g. sticky headers).
   */ shouldInvalidate(newRect, oldRect) {
        // By default, invalidate when the size changes
        return newRect.width !== oldRect.width || newRect.height !== oldRect.height;
    }
    /**
   * This method allows the layout to perform any pre-computation
   * it needs to in order to prepare {@link LayoutInfo}s for retrieval.
   * Called by the collection view before {@link getVisibleLayoutInfos}
   * or {@link getLayoutInfo} are called.
   */ validate(invalidationContext) {}
    /**
   * Returns a {@link DragTarget} describing a view at the given point to be dragged.
   * Return `null` to cancel the drag. The default implementation returns the view at the given point.
   * @param point The point at which the drag occurred.
   */ // getDragTarget(point: Point): DragTarget | null {
    //   let target = this.virtualizer.keyAtPoint(point);
    //   if (!target) {
    //     return null;
    //   }
    //   return {
    //     type: 'item',
    //     key: target
    //   };
    // }
    /**
   * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`
   * to reject the drop. The dropped items will be inserted before the resulting target.
   * @param point The point at which the drop occurred.
   */ // getDropTarget(point: Point): DropTarget | null {
    //   return null;
    // }
    /**
   * Returns the starting attributes for an animated insertion.
   * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.
   * The default implementation just returns its input.
   *
   * @param layoutInfo The proposed LayoutInfo for this view.
   */ getInitialLayoutInfo(layoutInfo) {
        return layoutInfo;
    }
    /**
   * Returns the ending attributes for an animated removal.
   * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}
   * to the one returned by this method. The default implementation returns its input.
   *
   * @param layoutInfo The original LayoutInfo for this view.
   */ getFinalLayoutInfo(layoutInfo) {
        return layoutInfo;
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ class $8a899922c0a55745$export$7e0eeb9da702a085 {
    /**
   * Returns a copy of the LayoutInfo.
   */ copy() {
        let res = new $8a899922c0a55745$export$7e0eeb9da702a085(this.type, this.key, this.rect.copy());
        res.estimatedSize = this.estimatedSize;
        res.opacity = this.opacity;
        res.transform = this.transform;
        res.parentKey = this.parentKey;
        res.isSticky = this.isSticky;
        res.zIndex = this.zIndex;
        res.allowOverflow = this.allowOverflow;
        return res;
    }
    /**
   * @param type A string representing the view type. Should be `'item'` for item views.
                            Other types are used by supplementary views.
   * @param key The unique key for this view.
   * @param rect The rectangle describing the size and position of this view.
   */ constructor(type, key, rect){
        this.type = type;
        this.key = key;
        this.parentKey = null;
        this.rect = rect;
        this.estimatedSize = false;
        this.isSticky = false;
        this.opacity = 1;
        this.transform = null;
        this.zIndex = 0;
        this.allowOverflow = false;
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ class $f89f15d7f52bce29$export$baf26146a414f24a {
    /**
   * Returns a copy of this point.
   */ copy() {
        return new $f89f15d7f52bce29$export$baf26146a414f24a(this.x, this.y);
    }
    /**
   * Checks if two points are equal.
   */ equals(point) {
        return this.x === point.x && this.y === point.y;
    }
    /**
   * Returns true if this point is the origin.
   */ isOrigin() {
        return this.x === 0 && this.y === 0;
    }
    constructor(x = 0, y = 0){
        this.x = x;
        this.y = y;
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
class $41b7691783731623$export$c79fc6492f3af13d {
    /**
   * The maximum x-coordinate in the rectangle.
   */ get maxX() {
        return this.x + this.width;
    }
    /**
   * The maximum y-coordinate in the rectangle.
   */ get maxY() {
        return this.y + this.height;
    }
    /**
   * The area of the rectangle.
   */ get area() {
        return this.width * this.height;
    }
    /**
   * The top left corner of the rectangle.
   */ get topLeft() {
        return new (0, $f89f15d7f52bce29$export$baf26146a414f24a)(this.x, this.y);
    }
    /**
   * The top right corner of the rectangle.
   */ get topRight() {
        return new (0, $f89f15d7f52bce29$export$baf26146a414f24a)(this.maxX, this.y);
    }
    /**
   * The bottom left corner of the rectangle.
   */ get bottomLeft() {
        return new (0, $f89f15d7f52bce29$export$baf26146a414f24a)(this.x, this.maxY);
    }
    /**
   * The bottom right corner of the rectangle.
   */ get bottomRight() {
        return new (0, $f89f15d7f52bce29$export$baf26146a414f24a)(this.maxX, this.maxY);
    }
    /**
   * Returns whether this rectangle intersects another rectangle.
   * @param rect - The rectangle to check.
   */ intersects(rect) {
        return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;
    }
    /**
   * Returns whether this rectangle fully contains another rectangle.
   * @param rect - The rectangle to check.
   */ containsRect(rect) {
        return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;
    }
    /**
   * Returns whether the rectangle contains the given point.
   * @param point - The point to check.
   */ containsPoint(point) {
        return this.x <= point.x && this.y <= point.y && this.maxX >= point.x && this.maxY >= point.y;
    }
    /**
   * Returns the first corner of this rectangle (from top to bottom, left to right)
   * that is contained in the given rectangle, or null of the rectangles do not intersect.
   * @param rect - The rectangle to check.
   */ getCornerInRect(rect) {
        for (let key of [
            "topLeft",
            "topRight",
            "bottomLeft",
            "bottomRight"
        ]){
            if (rect.containsPoint(this[key])) return key;
        }
        return null;
    }
    equals(rect) {
        return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;
    }
    pointEquals(point) {
        return this.x === point.x && this.y === point.y;
    }
    sizeEquals(size) {
        return this.width === size.width && this.height === size.height;
    }
    /**
   * Returns the union of this Rect and another.
   */ union(other) {
        let x = Math.min(this.x, other.x);
        let y = Math.min(this.y, other.y);
        let width = Math.max(this.maxX, other.maxX) - x;
        let height = Math.max(this.maxY, other.maxY) - y;
        return new $41b7691783731623$export$c79fc6492f3af13d(x, y, width, height);
    }
    /**
   * Returns the intersection of this Rect with another.
   * If the rectangles do not intersect, an all zero Rect is returned.
   */ intersection(other) {
        if (!this.intersects(other)) return new $41b7691783731623$export$c79fc6492f3af13d(0, 0, 0, 0);
        let x = Math.max(this.x, other.x);
        let y = Math.max(this.y, other.y);
        return new $41b7691783731623$export$c79fc6492f3af13d(x, y, Math.min(this.maxX, other.maxX) - x, Math.min(this.maxY, other.maxY) - y);
    }
    /**
   * Returns a copy of this rectangle.
   */ copy() {
        return new $41b7691783731623$export$c79fc6492f3af13d(this.x, this.y, this.width, this.height);
    }
    constructor(x = 0, y = 0, width = 0, height = 0){
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ class $064492b79924894c$export$cb6da89c6af1a8ec {
    /**
   * Returns a copy of this size.
   */ copy() {
        return new $064492b79924894c$export$cb6da89c6af1a8ec(this.width, this.height);
    }
    /**
   * Returns whether this size is equal to another one.
   */ equals(other) {
        return this.width === other.width && this.height === other.height;
    }
    /**
   * The total area of the Size.
   */ get area() {
        return this.width * this.height;
    }
    constructor(width = 0, height = 0){
        this.width = width;
        this.height = height;
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ let $197a1781bd47f5b9$var$KEY = 0;
class $197a1781bd47f5b9$export$1a5223887c560441 {
    /**
   * Prepares the view for reuse. Called just before the view is removed from the DOM.
   */ prepareForReuse() {
        this.content = null;
        this.rendered = null;
        this.layoutInfo = null;
    }
    constructor(virtualizer){
        this.virtualizer = virtualizer;
        this.key = ++$197a1781bd47f5b9$var$KEY;
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// use high res timer if available
let $57c5d36217e1f286$var$perf = typeof window !== "undefined" ? window.performance : null;
// @ts-ignore
let $57c5d36217e1f286$var$perfNow = $57c5d36217e1f286$var$perf && ($57c5d36217e1f286$var$perf.now || $57c5d36217e1f286$var$perf.webkitNow || $57c5d36217e1f286$var$perf.msNow || $57c5d36217e1f286$var$perf.mozNow);
let $57c5d36217e1f286$var$getTime = $57c5d36217e1f286$var$perfNow ? $57c5d36217e1f286$var$perfNow.bind($57c5d36217e1f286$var$perf) : function() {
    return Date.now ? Date.now() : new Date().getTime();
};
let $57c5d36217e1f286$var$fixTs;
function $57c5d36217e1f286$export$dc0b63720788090c(begin, end, duration, ease, fn) {
    let canceled = false;
    let raf_id;
    let promise = new Promise((resolve)=>{
        let start = $57c5d36217e1f286$var$getTime();
        let diffX = end.x - begin.x;
        let diffY = end.y - begin.y;
        raf_id = requestAnimationFrame(function run(t) {
            // if we're using a high res timer, make sure timestamp is not the old epoch-based value.
            // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
            if ($57c5d36217e1f286$var$fixTs == null) $57c5d36217e1f286$var$fixTs = t > 1e12 !== $57c5d36217e1f286$var$getTime() > 1e12;
            if ($57c5d36217e1f286$var$fixTs) t = $57c5d36217e1f286$var$getTime();
            // check if we're done
            let delta = t - start;
            if (delta > duration) {
                fn(end);
                resolve();
            } else {
                // call frame callback after computing eased time and get the next frame
                let proceed = fn(new (0, $f89f15d7f52bce29$export$baf26146a414f24a)(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));
                if (proceed !== false && !canceled) raf_id = requestAnimationFrame(run);
            }
        });
    });
    promise.cancel = function() {
        canceled = true;
        cancelAnimationFrame(raf_id);
    };
    return promise;
}
function $57c5d36217e1f286$export$77860c106b4a6a2e(t) {
    return t;
}
function $57c5d36217e1f286$export$57636bb43b1ccbb0(t) {
    return Math.sin(t * Math.PI / 2);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $abed55ea619a7a17$export$37a26b283fd7740e(a, b) {
    let res = new Set();
    for (let key of a.keys())if (!b.has(key)) res.add(key);
    return res;
}
function $abed55ea619a7a17$export$acaf96a27438246b(a, b) {
    let toRemove = $abed55ea619a7a17$export$37a26b283fd7740e(a, b);
    let toAdd = $abed55ea619a7a17$export$37a26b283fd7740e(b, a);
    let toUpdate = new Set;
    for (let key of a.keys())if (b.has(key)) toUpdate.add(key);
    return {
        toRemove: toRemove,
        toAdd: toAdd,
        toUpdate: toUpdate
    };
}
function* $abed55ea619a7a17$export$cfc14088dfefce5f(...iterators) {
    for (let iterator of iterators)yield* iterator;
}
function $abed55ea619a7a17$export$6897c284b6f9f4dc(object) {
    let res = {};
    for(let key in object)res[object[key]] = key;
    return res;
}
function $abed55ea619a7a17$export$a8d0d0c8d1c5df64(a, b) {
    if (a === b) return true;
    if (a.size !== b.size) return false;
    for (let key of a){
        if (!b.has(key)) return false;
    }
    return true;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

class $191a033606d4fda1$var$RollingAverage {
    addSample(sample) {
        this.count++;
        this.value += (sample - this.value) / this.count;
    }
    constructor(){
        this.count = 0;
        this.value = 0;
    }
}
class $191a033606d4fda1$export$4455ee6afb38dcbb {
    setVisibleRect(rect) {
        let time = performance.now() - this.startTime;
        if (time < 500) {
            this.averageTime.addSample(time);
            if (rect.x !== this.visibleRect.x && time > 0) this.velocity.x = (rect.x - this.visibleRect.x) / time;
            if (rect.y !== this.visibleRect.y && time > 0) this.velocity.y = (rect.y - this.visibleRect.y) / time;
        }
        this.startTime = performance.now();
        this.visibleRect = rect;
    }
    collectMetrics() {
        let time = performance.now() - this.startTime;
        if (time < 500) this.averagePerf.addSample(time);
        if (this.visibleRect.height > 0) {
            let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));
            this.overscanY.addSample(o);
        }
        if (this.visibleRect.width > 0) {
            let o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));
            this.overscanX.addSample(o);
        }
    }
    getOverscannedRect() {
        let overscanned = this.visibleRect.copy();
        let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;
        if (this.velocity.y > 0) {
            overscanned.y -= overscanY * 0.2;
            overscanned.height += overscanY + overscanY * 0.2;
        } else {
            overscanned.y -= overscanY;
            overscanned.height += overscanY + overscanY * 0.2;
        }
        let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;
        if (this.velocity.x > 0) {
            overscanned.x -= overscanX * 0.2;
            overscanned.width += overscanX + overscanX * 0.2;
        } else {
            overscanned.x -= overscanX;
            overscanned.width += overscanX + overscanX * 0.2;
        }
        return overscanned;
    }
    constructor(){
        this.startTime = 0;
        this.averagePerf = new $191a033606d4fda1$var$RollingAverage();
        this.averageTime = new $191a033606d4fda1$var$RollingAverage();
        this.velocity = new (0, $f89f15d7f52bce29$export$baf26146a414f24a)(5, 5);
        this.overscanX = new $191a033606d4fda1$var$RollingAverage();
        this.overscanY = new $191a033606d4fda1$var$RollingAverage();
        this.visibleRect = new (0, $41b7691783731623$export$c79fc6492f3af13d)();
    }
}






/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ class $d288159e8347722a$export$febc5573c75cefb0 {
    constructor(){
        this.level = 0;
        this.actions = [];
        this.animated = true;
        this.initialMap = new Map();
        this.finalMap = new Map();
        this.initialLayoutInfo = new Map();
        this.finalLayoutInfo = new Map();
        this.removed = new Map();
        this.toRemove = new Map();
    }
}


class $e1bc15d49d21df0e$export$89be5a243e59c4b2 {
    _setContentSize(size) {
        this._contentSize = size;
        this.delegate.setContentSize(size);
    }
    _setContentOffset(offset) {
        let rect = new (0, $41b7691783731623$export$c79fc6492f3af13d)(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);
        this.delegate.setVisibleRect(rect);
    }
    /**
   * Get the size of the scrollable content.
   */ get contentSize() {
        return this._contentSize;
    }
    /**
   * Get the collection view's currently visible rectangle.
   */ get visibleRect() {
        return this._visibleRect;
    }
    /**
   * Set the collection view's currently visible rectangle.
   */ set visibleRect(rect) {
        this._setVisibleRect(rect);
    }
    _setVisibleRect(rect, forceUpdate = false) {
        let current = this._visibleRect;
        // Ignore if the rects are equal
        if (rect.equals(current)) return;
        if (this.shouldOverscan) this._overscanManager.setVisibleRect(rect);
        let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);
        this._resetAnimatedContentOffset();
        this._visibleRect = rect;
        if (shouldInvalidate) // We are already in a layout effect when this method is called, so relayoutNow is appropriate.
        this.relayoutNow({
            offsetChanged: !rect.pointEquals(current),
            sizeChanged: !rect.sizeEquals(current)
        });
        else this.updateSubviews(forceUpdate);
    }
    get collection() {
        return this._collection;
    }
    set collection(data) {
        this._setData(data);
    }
    _setData(data) {
        if (data === this._collection) return;
        if (this._collection) this._runTransaction(()=>{
            this._collection = data;
        }, this.transitionDuration > 0);
        else {
            this._collection = data;
            this.reloadData();
        }
    }
    /**
   * Reloads the data from the data source and relayouts the collection view.
   * Does not animate any changes. Equivalent to re-assigning the same data source
   * to the collection view.
   */ reloadData() {
        this.relayout({
            contentChanged: true
        });
    }
    /**
   * Returns the item with the given key.
   */ getItem(key) {
        return this._collection ? this._collection.getItem(key) : null;
    }
    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ get persistedKeys() {
        return this._persistedKeys;
    }
    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ set persistedKeys(persistedKeys) {
        if (!(0, $abed55ea619a7a17$export$a8d0d0c8d1c5df64)(persistedKeys, this._persistedKeys)) {
            this._persistedKeys = persistedKeys;
            this.updateSubviews();
        }
    }
    /** Returns whether the given key, or an ancestor, is persisted. */ isPersistedKey(key) {
        // Quick check if the key is directly in the set of persisted keys.
        if (this._persistedKeys.has(key)) return true;
        // If not, check if the key is an ancestor of any of the persisted keys.
        for (let k of this._persistedKeys)while(k != null){
            let layoutInfo = this.layout.getLayoutInfo(k);
            if (!layoutInfo) break;
            k = layoutInfo.parentKey;
            if (k === key) return true;
        }
        return false;
    }
    /**
   * Get the collection view's layout.
   */ get layout() {
        return this._layout;
    }
    /**
   * Set the collection view's layout.
   */ set layout(layout) {
        this.setLayout(layout);
    }
    /**
   * Sets the collection view's layout, optionally with an animated transition
   * from the current layout to the new layout.
   * @param layout The layout to switch to.
   * @param animated Whether to animate the layout change.
   */ setLayout(layout, animated = false) {
        if (layout === this._layout) return;
        let applyLayout = ()=>{
            if (this._layout) // @ts-ignore
            this._layout.virtualizer = null;
            layout.virtualizer = this;
            this._layout = layout;
        };
        if (animated) // Animated layout transitions are really simple, thanks to our transaction support.
        // We just set the layout inside a transaction action, which runs after the initial
        // layout infos for the animation are retrieved from the previous layout. Then, the
        // final layout infos are retrieved from the new layout, and animations occur.
        this._runTransaction(applyLayout);
        else {
            applyLayout();
            this.relayout();
        }
    }
    _getReuseType(layoutInfo, content) {
        if (layoutInfo.type === "item" && content) {
            let type = this.delegate.getType ? this.delegate.getType(content) : "item";
            let reuseType = type === "item" ? "item" : layoutInfo.type + "_" + type;
            return {
                type: type,
                reuseType: reuseType
            };
        }
        return {
            type: layoutInfo.type,
            reuseType: layoutInfo.type
        };
    }
    getReusableView(layoutInfo) {
        let content = this.getItem(layoutInfo.key);
        let { reuseType: reuseType  } = this._getReuseType(layoutInfo, content);
        if (!this._reusableViews[reuseType]) this._reusableViews[reuseType] = [];
        let reusable = this._reusableViews[reuseType];
        let view = reusable.length > 0 ? reusable.pop() : new (0, $197a1781bd47f5b9$export$1a5223887c560441)(this);
        view.viewType = reuseType;
        if (!this._animatedContentOffset.isOrigin()) {
            layoutInfo = layoutInfo.copy();
            layoutInfo.rect.x += this._animatedContentOffset.x;
            layoutInfo.rect.y += this._animatedContentOffset.y;
        }
        view.layoutInfo = layoutInfo;
        this._renderView(view);
        return view;
    }
    _renderView(reusableView) {
        let { type: type , key: key  } = reusableView.layoutInfo;
        reusableView.content = this.getItem(key);
        reusableView.rendered = this._renderContent(type, reusableView.content);
    }
    _renderContent(type, content) {
        let cached = this._renderedContent.get(content);
        if (cached != null) return cached;
        let rendered = this.delegate.renderView(type, content);
        if (content) this._renderedContent.set(content, rendered);
        return rendered;
    }
    /**
   * Returns an array of all currently visible views, including both
   * item views and supplementary views.
   */ get visibleViews() {
        return Array.from(this._visibleViews.values());
    }
    /**
   * Gets the visible view for the given type and key. Returns null if
   * the view is not currently visible.
   *
   * @param key The key of the view to retrieve.
   */ getView(key) {
        return this._visibleViews.get(key) || null;
    }
    /**
   * Returns an array of visible views matching the given type.
   * @param type The view type to find.
   */ getViewsOfType(type) {
        return this.visibleViews.filter((v)=>v.layoutInfo && v.layoutInfo.type === type);
    }
    /**
   * Returns the key for the given view. Returns null
   * if the view is not currently visible.
   */ keyForView(view) {
        if (view && view.layoutInfo) return view.layoutInfo.key;
        return null;
    }
    /**
   * Returns the key for the item view currently at the given point.
   */ keyAtPoint(point) {
        let rect = new (0, $41b7691783731623$export$c79fc6492f3af13d)(point.x, point.y, 1, 1);
        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);
        // Layout may return multiple layout infos in the case of
        // persisted keys, so find the first one that actually intersects.
        for (let layoutInfo of layoutInfos){
            if (layoutInfo.rect.intersects(rect)) return layoutInfo.key;
        }
        return null;
    }
    /**
   * Cleanup for when the Virtualizer will be unmounted.
   */ willUnmount() {
        cancelAnimationFrame(this._relayoutRaf);
    }
    /**
   * Triggers a layout invalidation, and updates the visible subviews.
   */ relayout(context = {}) {
        // Ignore relayouts while animating the scroll position
        if (this._scrollAnimation || typeof requestAnimationFrame === "undefined") return;
        // If we already scheduled a relayout, extend the invalidation
        // context so we coalesce multiple relayouts in the same frame.
        if (this._invalidationContext) {
            Object.assign(this._invalidationContext, context);
            return;
        }
        this._invalidationContext = context;
    }
    /**
   * Performs a relayout immediately. Prefer {@link relayout} over this method
   * where possible, since it coalesces multiple layout passes in the same tick.
   */ relayoutNow(context = this._invalidationContext || {}) {
        // Cancel the scheduled relayout, since we're doing it now.
        if (this._relayoutRaf) {
            cancelAnimationFrame(this._relayoutRaf);
            this._relayoutRaf = null;
            // Update the provided context with the current invalidationContext since we are cancelling
            // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)
            context = {
                ...this._invalidationContext,
                ...context
            };
        }
        // Reset the invalidation context
        this._invalidationContext = null;
        // Do nothing if we don't have a layout or content, or we are
        // in the middle of an animated scroll transition.
        if (!this.layout || !this._collection || this._scrollAnimation) return;
        let scrollAnchor = this._getScrollAnchor();
        // Trigger the beforeLayout hook, if provided
        if (typeof context.beforeLayout === "function") context.beforeLayout();
        // Validate the layout
        this.layout.validate(context);
        this._setContentSize(this.layout.getContentSize());
        // Trigger the afterLayout hook, if provided
        if (typeof context.afterLayout === "function") context.afterLayout();
        // Adjust scroll position based on scroll anchor, and constrain.
        // If the content changed, scroll to the top.
        let visibleRect = this.getVisibleRect();
        let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);
        let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;
        let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;
        contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));
        contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));
        let hasLayoutUpdates = false;
        if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {
            // If this is an animated relayout, we do not immediately scroll because it would be jittery.
            // Save the difference between the current and new content offsets, and apply it to the
            // individual content items instead. At the end of the animation, we'll reset and set the
            // scroll offset for real. This ensures jitter-free animation since we don't need to sync
            // the scroll animation and the content animation.
            if (context.animated || !this._animatedContentOffset.isOrigin()) {
                this._animatedContentOffset.x += visibleRect.x - contentOffsetX;
                this._animatedContentOffset.y += visibleRect.y - contentOffsetY;
                hasLayoutUpdates = this.updateSubviews(context.contentChanged);
            } else this._setContentOffset(new (0, $f89f15d7f52bce29$export$baf26146a414f24a)(contentOffsetX, contentOffsetY));
        } else hasLayoutUpdates = this.updateSubviews(context.contentChanged);
        // Apply layout infos, unless this is coming from an animated transaction
        if (!(context.transaction && context.animated)) this._applyLayoutInfos();
        // Wait for animations, and apply the afterAnimation hook, if provided
        if (context.animated && hasLayoutUpdates) {
            this._enableTransitions();
            let done = ()=>{
                this._disableTransitions();
                // Reset scroll position after animations (see above comment).
                if (!this._animatedContentOffset.isOrigin()) {
                    // Get the content offset to scroll to, taking _animatedContentOffset into account.
                    let { x: x , y: y  } = this.getVisibleRect();
                    this._resetAnimatedContentOffset();
                    this._setContentOffset(new (0, $f89f15d7f52bce29$export$baf26146a414f24a)(x, y));
                }
                if (typeof context.afterAnimation === "function") context.afterAnimation();
            };
            // Sometimes the animation takes slightly longer than expected.
            setTimeout(done, this.transitionDuration + 100);
            return;
        } else if (typeof context.afterAnimation === "function") context.afterAnimation();
    }
    /**
   * Corrects DOM order of visible views to match item order of collection.
   */ _correctItemOrder() {
        // Defer until after scrolling and animated transactions are complete
        if (this._isScrolling || this._transaction) return;
        for (let key of this._visibleLayoutInfos.keys()){
            let view = this._visibleViews.get(key);
            this._children.delete(view);
            this._children.add(view);
        }
    }
    _enableTransitions() {
        this.delegate.beginAnimations();
    }
    _disableTransitions() {
        this.delegate.endAnimations();
    }
    _getScrollAnchor() {
        if (!this.anchorScrollPosition) return null;
        let visibleRect = this.getVisibleRect();
        // Ask the delegate to provide a scroll anchor, if possible
        if (this.delegate.getScrollAnchor) {
            let key = this.delegate.getScrollAnchor(visibleRect);
            if (key != null) {
                let layoutInfo = this.layout.getLayoutInfo(key);
                let corner = layoutInfo.rect.getCornerInRect(visibleRect);
                if (corner) {
                    let key = layoutInfo.key;
                    let offset = layoutInfo.rect[corner].y - visibleRect.y;
                    return {
                        key: key,
                        layoutInfo: layoutInfo,
                        corner: corner,
                        offset: offset
                    };
                }
            }
        }
        // No need to anchor the scroll position if it is at the top
        if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) return null;
        // Find a view with a visible corner that has the smallest distance to the top of the collection view
        let cornerAnchor = null;
        for (let [key, view] of this._visibleViews){
            let layoutInfo = view.layoutInfo;
            if (layoutInfo && layoutInfo.rect.area > 0) {
                let corner = layoutInfo.rect.getCornerInRect(visibleRect);
                if (corner) {
                    let offset = layoutInfo.rect[corner].y - visibleRect.y;
                    if (!cornerAnchor || offset < cornerAnchor.offset) cornerAnchor = {
                        key: key,
                        layoutInfo: layoutInfo,
                        corner: corner,
                        offset: offset
                    };
                }
            }
        }
        return cornerAnchor;
    }
    _restoreScrollAnchor(scrollAnchor, context) {
        let contentOffset = this.getVisibleRect();
        if (scrollAnchor) {
            var _context_transaction;
            let finalAnchor = ((_context_transaction = context.transaction) === null || _context_transaction === void 0 ? void 0 : _context_transaction.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);
            if (finalAnchor) {
                let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;
                contentOffset.y += adjustment;
            }
        }
        return contentOffset;
    }
    getVisibleRect() {
        let v = this.visibleRect;
        let x = v.x - this._animatedContentOffset.x;
        let y = v.y - this._animatedContentOffset.y;
        return new (0, $41b7691783731623$export$c79fc6492f3af13d)(x, y, v.width, v.height);
    }
    getVisibleLayoutInfos() {
        let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();
        this._visibleLayoutInfos = this._getLayoutInfoMap(rect);
        return this._visibleLayoutInfos;
    }
    _getLayoutInfoMap(rect, copy = false) {
        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);
        let map = new Map;
        for (let layoutInfo of layoutInfos){
            if (copy) layoutInfo = layoutInfo.copy();
            map.set(layoutInfo.key, layoutInfo);
        }
        return map;
    }
    updateSubviews(forceUpdate = false) {
        if (!this._collection) return;
        let visibleLayoutInfos = this.getVisibleLayoutInfos();
        let currentlyVisible = this._visibleViews;
        let toAdd, toRemove, toUpdate;
        // If this is a force update, remove and re-add all views.
        // Otherwise, find and update the diff.
        if (forceUpdate) {
            toAdd = visibleLayoutInfos;
            toRemove = currentlyVisible;
            toUpdate = new Set();
        } else {
            ({ toAdd: toAdd , toRemove: toRemove , toUpdate: toUpdate  } = (0, $abed55ea619a7a17$export$acaf96a27438246b)(currentlyVisible, visibleLayoutInfos));
            for (let key of toUpdate){
                let view = currentlyVisible.get(key);
                if (!view || !view.layoutInfo) continue;
                let item = this.getItem(visibleLayoutInfos.get(key).key);
                if (view.content === item) toUpdate.delete(key);
                else {
                    // If the view type changes, delete and recreate the view instead of updating
                    let { reuseType: reuseType  } = this._getReuseType(view.layoutInfo, item);
                    if (view.viewType !== reuseType) {
                        toUpdate.delete(key);
                        toAdd.add(key);
                        toRemove.add(key);
                    }
                }
            }
            // We are done if the sets are equal
            if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {
                if (this._transaction) this._applyLayoutInfos();
                return;
            }
        }
        // Track views that should be removed. They are not removed from
        // the DOM immediately, since we may reuse and need to re-insert
        // them back into the DOM anyway.
        let removed = new Set();
        for (let key of toRemove.keys()){
            let view = this._visibleViews.get(key);
            if (view) {
                removed.add(view);
                this._visibleViews.delete(key);
                // If we are in the middle of a transaction, wait until the end
                // of the animations to remove the views from the DOM. Also means
                // we can't reuse those views immediately.
                if (this._transaction) this._transaction.toRemove.set(key, view);
                else this.reuseView(view);
            }
        }
        for (let key of toAdd.keys()){
            let layoutInfo = visibleLayoutInfos.get(key);
            let view;
            // If we're in a transaction, and a layout change happens
            // during the animations such that a view that was going
            // to be removed is now not, we don't create a new view
            // since the old one is still in the DOM, marked as toRemove.
            if (this._transaction) {
                // if transaction, get initial layout attributes for the animation
                if (this._transaction.initialLayoutInfo.has(key)) layoutInfo = this._transaction.initialLayoutInfo.get(key);
                view = this._transaction.toRemove.get(key);
                if (view) {
                    this._transaction.toRemove.delete(key);
                    this._applyLayoutInfo(view, layoutInfo);
                }
            }
            if (!view) {
                // Create or reuse a view for this row
                view = this.getReusableView(layoutInfo);
                // Add the view to the DOM if needed
                if (!removed.has(view)) this._children.add(view);
            }
            this._visibleViews.set(key, view);
            removed.delete(view);
        }
        for (let key of toUpdate){
            let view = currentlyVisible.get(key);
            this._renderedContent.delete(key);
            this._renderView(view);
        }
        // Remove the remaining rows to delete from the DOM
        if (!this._transaction) this.removeViews(removed);
        this._correctItemOrder();
        this._flushVisibleViews();
        let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());
        if (hasLayoutUpdates) requestAnimationFrame(()=>{
            // If we're in a transaction, apply animations to visible views
            // and "to be removed" views, which animate off screen.
            if (this._transaction) requestAnimationFrame(()=>this._applyLayoutInfos());
        });
        return hasLayoutUpdates;
    }
    afterRender() {
        if (this._transactionQueue.length > 0) this._processTransactionQueue();
        else if (this._invalidationContext) this.relayoutNow();
        if (this.shouldOverscan) this._overscanManager.collectMetrics();
    }
    _flushVisibleViews() {
        // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy
        // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy
        // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper
        // method to build the final tree.
        let viewsByParentKey = new Map([
            [
                null,
                []
            ]
        ]);
        for (let view of this._children){
            var _view_layoutInfo, _viewsByParentKey_get, _view_layoutInfo1, _view_layoutInfo2, _view_layoutInfo3;
            if (((_view_layoutInfo = view.layoutInfo) === null || _view_layoutInfo === void 0 ? void 0 : _view_layoutInfo.parentKey) != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) viewsByParentKey.set(view.layoutInfo.parentKey, []);
            (_viewsByParentKey_get = viewsByParentKey.get((_view_layoutInfo1 = view.layoutInfo) === null || _view_layoutInfo1 === void 0 ? void 0 : _view_layoutInfo1.parentKey)) === null || _viewsByParentKey_get === void 0 ? void 0 : _viewsByParentKey_get.push(view);
            if (!viewsByParentKey.has((_view_layoutInfo2 = view.layoutInfo) === null || _view_layoutInfo2 === void 0 ? void 0 : _view_layoutInfo2.key)) viewsByParentKey.set((_view_layoutInfo3 = view.layoutInfo) === null || _view_layoutInfo3 === void 0 ? void 0 : _view_layoutInfo3.key, []);
        }
        let buildTree = (parent, views)=>views.map((view)=>{
                let children = viewsByParentKey.get(view.layoutInfo.key);
                return this.delegate.renderWrapper(parent, view, children, (childViews)=>buildTree(view, childViews));
            });
        let children = buildTree(null, viewsByParentKey.get(null));
        this.delegate.setVisibleViews(children);
    }
    _applyLayoutInfo(view, layoutInfo) {
        if (view.layoutInfo === layoutInfo) return false;
        view.layoutInfo = layoutInfo;
        return true;
    }
    _applyLayoutInfos() {
        let updated = false;
        // Apply layout infos to visible views
        for (let view of this._visibleViews.values()){
            let cur = view.layoutInfo;
            if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {
                let layoutInfo = this.layout.getLayoutInfo(cur.key);
                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;
            }
        }
        // Apply final layout infos for views that will be removed
        if (this._transaction) {
            for (let view of this._transaction.toRemove.values()){
                let cur = view.layoutInfo;
                if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {
                    let layoutInfo = this.layout.getLayoutInfo(cur.key);
                    if (this._applyLayoutInfo(view, layoutInfo)) updated = true;
                }
            }
            for (let view of this._transaction.removed.values()){
                let cur = view.layoutInfo;
                let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;
                layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());
                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;
            }
        }
        if (updated) this._flushVisibleViews();
    }
    _hasLayoutUpdates() {
        if (!this._transaction) return false;
        for (let view of this._visibleViews.values()){
            let cur = view.layoutInfo;
            if (!cur) return true;
            let layoutInfo = this.layout.getLayoutInfo(cur.key);
            if (// Uses equals rather than pointEquals so that width/height changes are taken into account
            !cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) return true;
        }
        return false;
    }
    reuseView(view) {
        view.prepareForReuse();
        this._reusableViews[view.viewType].push(view);
    }
    removeViews(toRemove) {
        for (let view of toRemove)this._children.delete(view);
    }
    updateItemSize(key, size) {
        // TODO: we should be able to invalidate a single index path
        // @ts-ignore
        if (!this.layout.updateItemSize) return;
        // If the scroll position is currently animating, add the update
        // to a queue to be processed after the animation is complete.
        if (this._scrollAnimation) {
            this._sizeUpdateQueue.set(key, size);
            return;
        }
        // @ts-ignore
        let changed = this.layout.updateItemSize(key, size);
        if (changed) this.relayout();
    }
    startScrolling() {
        this._isScrolling = true;
    }
    endScrolling() {
        this._isScrolling = false;
        this._correctItemOrder();
        this._flushVisibleViews();
    }
    _resetAnimatedContentOffset() {
        // Reset the animated content offset of subviews. See comment in relayoutNow for details.
        if (!this._animatedContentOffset.isOrigin()) {
            this._animatedContentOffset = new (0, $f89f15d7f52bce29$export$baf26146a414f24a)(0, 0);
            this._applyLayoutInfos();
        }
    }
    /**
   * Scrolls the item with the given key into view, optionally with an animation.
   * @param key The key of the item to scroll into view.
   * @param duration The duration of the scroll animation.
   */ scrollToItem(key, options) {
        // key can be 0, so check if null or undefined
        if (key == null) return;
        let layoutInfo = this.layout.getLayoutInfo(key);
        if (!layoutInfo) return;
        let { duration: duration = 300 , shouldScrollX: shouldScrollX = true , shouldScrollY: shouldScrollY = true , offsetX: offsetX = 0 , offsetY: offsetY = 0  } = options;
        let x = this.visibleRect.x;
        let y = this.visibleRect.y;
        let minX = layoutInfo.rect.x - offsetX;
        let minY = layoutInfo.rect.y - offsetY;
        let maxX = x + this.visibleRect.width;
        let maxY = y + this.visibleRect.height;
        if (shouldScrollX) {
            if (minX <= x || maxX === 0) x = minX;
            else if (layoutInfo.rect.maxX > maxX) x += layoutInfo.rect.maxX - maxX;
        }
        if (shouldScrollY) {
            if (minY <= y || maxY === 0) y = minY;
            else if (layoutInfo.rect.maxY > maxY) y += layoutInfo.rect.maxY - maxY;
        }
        return this.scrollTo(new (0, $f89f15d7f52bce29$export$baf26146a414f24a)(x, y), duration);
    }
    /**
   * Performs an animated scroll to the given offset.
   * @param offset - The offset to scroll to.
   * @param duration The duration of the animation.
   * @returns A promise that resolves when the animation is complete.
   */ scrollTo(offset, duration = 300) {
        // Cancel the current scroll animation
        if (this._scrollAnimation) {
            this._scrollAnimation.cancel();
            this._scrollAnimation = null;
        }
        // Set the content offset synchronously if the duration is zero
        if (duration <= 0 || this.visibleRect.pointEquals(offset)) {
            this._setContentOffset(offset);
            return Promise.resolve();
        }
        this.startScrolling();
        this._scrollAnimation = (0, $57c5d36217e1f286$export$dc0b63720788090c)(this.visibleRect, offset, duration, (0, $57c5d36217e1f286$export$57636bb43b1ccbb0), (offset)=>{
            this._setContentOffset(offset);
        });
        this._scrollAnimation.then(()=>{
            this._scrollAnimation = null;
            // Process view size updates that occurred during the animation.
            // Only views that are still visible will be actually updated.
            for (let [key, size] of this._sizeUpdateQueue)this.updateItemSize(key, size);
            this._sizeUpdateQueue.clear();
            this.relayout();
            this._processTransactionQueue();
            this.endScrolling();
        });
        return this._scrollAnimation;
    }
    _runTransaction(action, animated) {
        this._startTransaction();
        if (this._nextTransaction) this._nextTransaction.actions.push(action);
        this._endTransaction(animated);
    }
    _startTransaction() {
        if (!this._nextTransaction) this._nextTransaction = new (0, $d288159e8347722a$export$febc5573c75cefb0);
        this._nextTransaction.level++;
    }
    _endTransaction(animated) {
        if (!this._nextTransaction) return false;
        // Save whether the transaction should be animated.
        if (animated != null) this._nextTransaction.animated = animated;
        // If we haven't reached level 0, we are still in a
        // nested transaction. Wait for the parent to end.
        if (--this._nextTransaction.level > 0) return false;
        // Do nothing for empty transactions
        if (this._nextTransaction.actions.length === 0) {
            this._nextTransaction = null;
            return false;
        }
        // Default animations to true
        if (this._nextTransaction.animated == null) this._nextTransaction.animated = true;
        // Enqueue the transaction
        this._transactionQueue.push(this._nextTransaction);
        this._nextTransaction = null;
        return true;
    }
    _processTransactionQueue() {
        // If the current transaction is animating, wait until the end
        // to process the next transaction.
        if (this._transaction || this._scrollAnimation) return;
        let next = this._transactionQueue.shift();
        if (next) this._performTransaction(next);
    }
    _getContentRect() {
        return new (0, $41b7691783731623$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);
    }
    _performTransaction(transaction) {
        this._transaction = transaction;
        this.relayoutNow({
            transaction: transaction,
            animated: transaction.animated,
            beforeLayout: ()=>{
                // Get the initial layout infos for all views before the updates
                // so we can figure out which views to add and remove.
                if (transaction.animated) transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);
                // Apply the actions that occurred during this transaction
                for (let action of transaction.actions)action();
            },
            afterLayout: ()=>{
                // Get the final layout infos after the updates
                if (transaction.animated) {
                    transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());
                    this._setupTransactionAnimations(transaction);
                } else this._transaction = null;
            },
            afterAnimation: ()=>{
                // Remove and reuse views when animations are done
                if (transaction.toRemove.size > 0 || transaction.removed.size > 0) for (let view of (0, $abed55ea619a7a17$export$cfc14088dfefce5f)(transaction.toRemove.values(), transaction.removed.values())){
                    this._children.delete(view);
                    this.reuseView(view);
                }
                this._transaction = null;
                // Ensure DOM order is correct for accessibility after animations are complete
                this._correctItemOrder();
                this._flushVisibleViews();
                this._processTransactionQueue();
            }
        });
    }
    _setupTransactionAnimations(transaction) {
        let { initialMap: initialMap , finalMap: finalMap  } = transaction;
        // Store initial and final layout infos for animations
        for (let [key, layoutInfo] of initialMap)if (finalMap.has(key)) // Store the initial layout info for use during animations.
        transaction.initialLayoutInfo.set(key, layoutInfo);
        else // This view was removed. Store the layout info for use
        // in Layout#getFinalLayoutInfo during animations.
        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);
        // Get initial layout infos for views that were added
        for (let [key, layoutInfo] of finalMap)if (!initialMap.has(key)) {
            let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());
            transaction.initialLayoutInfo.set(key, initialLayoutInfo);
        }
        // Figure out which views were removed.
        for (let [key, view] of this._visibleViews)// If an item has a width of 0, there is no need to remove it from the _visibleViews.
        // Removing an item with  width of 0 can cause a loop where the item gets added, removed,
        // added, removed... etc in a loop.
        if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {
            transaction.removed.set(key, view);
            this._visibleViews.delete(key);
            // In case something weird happened, where we have a view but no
            // initial layout info, use the one attached to the view.
            if (view.layoutInfo) {
                if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);
            }
        }
    }
    constructor(options = {}){
        this._contentSize = new (0, $064492b79924894c$export$cb6da89c6af1a8ec);
        this._visibleRect = new (0, $41b7691783731623$export$c79fc6492f3af13d);
        this._reusableViews = {};
        this._visibleLayoutInfos = new Map();
        this._visibleViews = new Map();
        this._renderedContent = new WeakMap();
        this._children = new Set();
        this._invalidationContext = null;
        this._overscanManager = new (0, $191a033606d4fda1$export$4455ee6afb38dcbb)();
        this._persistedKeys = new Set();
        this._scrollAnimation = null;
        this._isScrolling = false;
        this._sizeUpdateQueue = new Map();
        this._animatedContentOffset = new (0, $f89f15d7f52bce29$export$baf26146a414f24a)(0, 0);
        this._transaction = null;
        this._nextTransaction = null;
        this._transactionQueue = [];
        var _options_transitionDuration;
        // Set options from passed object if given
        this.transitionDuration = (_options_transitionDuration = options.transitionDuration) !== null && _options_transitionDuration !== void 0 ? _options_transitionDuration : 500;
        this.anchorScrollPosition = options.anchorScrollPosition || false;
        this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;
        this.shouldOverscan = options.shouldOverscan !== false;
        for (let key of [
            "delegate",
            "size",
            "layout",
            "collection"
        ])if (options[key]) this[key] = options[key];
    }
}


function $f02ef43b5e8eee9b$export$1505db82fe357e65(opts) {
    let [visibleViews, setVisibleViews] = (0, $aEpNF$react.useState)([]);
    let [contentSize, setContentSize] = (0, $aEpNF$react.useState)(new (0, $064492b79924894c$export$cb6da89c6af1a8ec)());
    let [isAnimating, setAnimating] = (0, $aEpNF$react.useState)(false);
    let [isScrolling, setScrolling] = (0, $aEpNF$react.useState)(false);
    let virtualizer = (0, $aEpNF$react.useMemo)(()=>new (0, $e1bc15d49d21df0e$export$89be5a243e59c4b2)(), []);
    virtualizer.delegate = {
        setVisibleViews: setVisibleViews,
        setVisibleRect (rect) {
            virtualizer.visibleRect = rect;
            opts.onVisibleRectChange(rect);
        },
        setContentSize: setContentSize,
        renderView: opts.renderView,
        renderWrapper: opts.renderWrapper,
        beginAnimations: ()=>setAnimating(true),
        endAnimations: ()=>setAnimating(false),
        getScrollAnchor: opts.getScrollAnchor
    };
    virtualizer.layout = opts.layout;
    virtualizer.collection = opts.collection;
    virtualizer.transitionDuration = opts.transitionDuration;
    (0, $aEpNF$reactariautils.useLayoutEffect)(()=>{
        virtualizer.afterRender();
    });
    // eslint-disable-next-line arrow-body-style
    (0, $aEpNF$react.useEffect)(()=>{
        return ()=>virtualizer.willUnmount();
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    let setVisibleRect = (0, $aEpNF$react.useCallback)((rect)=>{
        virtualizer.visibleRect = rect;
    }, [
        virtualizer
    ]);
    let startScrolling = (0, $aEpNF$react.useCallback)(()=>{
        virtualizer.startScrolling();
        setScrolling(true);
    }, [
        virtualizer
    ]);
    let endScrolling = (0, $aEpNF$react.useCallback)(()=>{
        virtualizer.endScrolling();
        setScrolling(false);
    }, [
        virtualizer
    ]);
    let state = (0, $aEpNF$react.useMemo)(()=>({
            virtualizer: virtualizer,
            visibleViews: visibleViews,
            setVisibleRect: setVisibleRect,
            contentSize: contentSize,
            isAnimating: isAnimating,
            isScrolling: isScrolling,
            startScrolling: startScrolling,
            endScrolling: endScrolling
        }), [
        virtualizer,
        visibleViews,
        setVisibleRect,
        contentSize,
        isAnimating,
        isScrolling,
        startScrolling,
        endScrolling
    ]);
    return state;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 38416:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $4hxXn$react = __webpack_require__(18038);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "SSRProvider", () => $29383e587d62412a$export$9f8ac96af4b1b2ae);
$parcel$export(module.exports, "useSSRSafeId", () => $29383e587d62412a$export$619500959fc48b26);
$parcel$export(module.exports, "useIsSSR", () => $29383e587d62412a$export$535bd6ca7f90a273);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We must avoid a circular dependency with @react-aria/utils, and this useLayoutEffect is
// guarded by a check that it only runs on the client side.
// eslint-disable-next-line rulesdir/useLayoutEffectRule

// Default context value to use in case there is no SSRProvider. This is fine for
// client-only apps. In order to support multiple copies of React Aria potentially
// being on the page at once, the prefix is set to a random number. SSRProvider
// will reset this to zero for consistency between server and client, so in the
// SSR case multiple copies of React Aria is not supported.
const $29383e587d62412a$var$defaultContext = {
    prefix: String(Math.round(Math.random() * 10000000000)),
    current: 0,
    isSSR: false
};
const $29383e587d62412a$var$SSRContext = /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createContext($29383e587d62412a$var$defaultContext);
// This is only used in React < 18.
function $29383e587d62412a$var$LegacySSRProvider(props) {
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let counter = $29383e587d62412a$var$useCounter(cur === $29383e587d62412a$var$defaultContext);
    let [isSSR, setIsSSR] = (0, $4hxXn$react.useState)(true);
    let value = (0, $4hxXn$react.useMemo)(()=>({
            // If this is the first SSRProvider, start with an empty string prefix, otherwise
            // append and increment the counter.
            prefix: cur === $29383e587d62412a$var$defaultContext ? "" : `${cur.prefix}-${counter}`,
            current: 0,
            isSSR: isSSR
        }), [
        cur,
        counter,
        isSSR
    ]);
    // If on the client, and the component was initially server rendered,
    // then schedule a layout effect to update the component after hydration.
    if (typeof window !== "undefined") // This if statement technically breaks the rules of hooks, but is safe
    // because the condition never changes after mounting.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, $4hxXn$react.useLayoutEffect)(()=>{
        setIsSSR(false);
    }, []);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$SSRContext.Provider, {
        value: value
    }, props.children);
}
let $29383e587d62412a$var$warnedAboutSSRProvider = false;
function $29383e587d62412a$export$9f8ac96af4b1b2ae(props) {
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function") {
        if (!$29383e587d62412a$var$warnedAboutSSRProvider) {
            console.warn("In React 18, SSRProvider is not necessary and is a noop. You can remove it from your app.");
            $29383e587d62412a$var$warnedAboutSSRProvider = true;
        }
        return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement((0, ($parcel$interopDefault($4hxXn$react))).Fragment, null, props.children);
    }
    return /*#__PURE__*/ (0, ($parcel$interopDefault($4hxXn$react))).createElement($29383e587d62412a$var$LegacySSRProvider, props);
}
let $29383e587d62412a$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
let $29383e587d62412a$var$componentIds = new WeakMap();
function $29383e587d62412a$var$useCounter(isDisabled = false) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    let ref = (0, $4hxXn$react.useRef)(null);
    // eslint-disable-next-line rulesdir/pure-render
    if (ref.current === null && !isDisabled) {
        var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner;
        // In strict mode, React renders components twice, and the ref will be reset to null on the second render.
        // This means our id counter will be incremented twice instead of once. This is a problem because on the
        // server, components are only rendered once and so ids generated on the server won't match the client.
        // In React 18, useId was introduced to solve this, but it is not available in older versions. So to solve this
        // we need to use some React internals to access the underlying Fiber instance, which is stable between renders.
        // This is exposed as ReactCurrentOwner in development, which is all we need since StrictMode only runs in development.
        // To ensure that we only increment the global counter once, we store the starting id for this component in
        // a weak map associated with the Fiber. On the second render, we reset the global counter to this value.
        // Since React runs the second render immediately after the first, this is safe.
        // @ts-ignore
        let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, ($parcel$interopDefault($4hxXn$react))).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;
        if (currentOwner) {
            let prevComponentValue = $29383e587d62412a$var$componentIds.get(currentOwner);
            if (prevComponentValue == null) // On the first render, and first call to useId, store the id and state in our weak map.
            $29383e587d62412a$var$componentIds.set(currentOwner, {
                id: ctx.current,
                state: currentOwner.memoizedState
            });
            else if (currentOwner.memoizedState !== prevComponentValue.state) {
                // On the second render, the memoizedState gets reset by React.
                // Reset the counter, and remove from the weak map so we don't
                // do this for subsequent useId calls.
                ctx.current = prevComponentValue.id;
                $29383e587d62412a$var$componentIds.delete(currentOwner);
            }
        }
        // eslint-disable-next-line rulesdir/pure-render
        ref.current = ++ctx.current;
    }
    // eslint-disable-next-line rulesdir/pure-render
    return ref.current;
}
function $29383e587d62412a$var$useLegacySSRSafeId(defaultId) {
    let ctx = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    // If we are rendering in a non-DOM environment, and there's no SSRProvider,
    // provide a warning to hint to the developer to add one.
    if (ctx === $29383e587d62412a$var$defaultContext && !$29383e587d62412a$var$canUseDOM) console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
    let counter = $29383e587d62412a$var$useCounter(!!defaultId);
    return defaultId || `react-aria${ctx.prefix}-${counter}`;
}
function $29383e587d62412a$var$useModernSSRSafeId(defaultId) {
    // @ts-ignore
    let id = (0, ($parcel$interopDefault($4hxXn$react))).useId();
    let [didSSR] = (0, $4hxXn$react.useState)($29383e587d62412a$export$535bd6ca7f90a273());
    let prefix = didSSR ? "react-aria" : `react-aria${$29383e587d62412a$var$defaultContext.prefix}`;
    return defaultId || `${prefix}-${id}`;
}
const $29383e587d62412a$export$619500959fc48b26 = typeof (0, ($parcel$interopDefault($4hxXn$react)))["useId"] === "function" ? $29383e587d62412a$var$useModernSSRSafeId : $29383e587d62412a$var$useLegacySSRSafeId;
function $29383e587d62412a$var$getSnapshot() {
    return false;
}
function $29383e587d62412a$var$getServerSnapshot() {
    return true;
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function $29383e587d62412a$var$subscribe(onStoreChange) {
    // noop
    return ()=>{};
}
function $29383e587d62412a$export$535bd6ca7f90a273() {
    // In React 18, we can use useSyncExternalStore to detect if we're server rendering or hydrating.
    if (typeof (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"] === "function") return (0, ($parcel$interopDefault($4hxXn$react)))["useSyncExternalStore"]($29383e587d62412a$var$subscribe, $29383e587d62412a$var$getSnapshot, $29383e587d62412a$var$getServerSnapshot);
    // eslint-disable-next-line react-hooks/rules-of-hooks
    let cur = (0, $4hxXn$react.useContext)($29383e587d62412a$var$SSRContext);
    return cur.isSSR;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 47770:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $1Yh1N$reactstatelyutils = __webpack_require__(12259);
var $1Yh1N$react = __webpack_require__(18038);
var $1Yh1N$reactariassr = __webpack_require__(38416);
var $1Yh1N$clsx = __webpack_require__(14889);

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useId", () => $8c61827343eed941$export$f680877a34711e37);
$parcel$export(module.exports, "mergeIds", () => $8c61827343eed941$export$cd8c9cb68f842629);
$parcel$export(module.exports, "useSlotId", () => $8c61827343eed941$export$b4cc09c592e8fdb8);
$parcel$export(module.exports, "chain", () => $1e2191638e54f613$export$e08e3b67e392101e);
$parcel$export(module.exports, "mergeProps", () => $f847cd1382ea7cd4$export$9d1611c77c2fe928);
$parcel$export(module.exports, "mergeRefs", () => $f05dc24eafaeb7e2$export$c9058316764c140e);
$parcel$export(module.exports, "filterDOMProps", () => $8d15d0e1797d4238$export$457c3d6518dd4c6f);
$parcel$export(module.exports, "focusWithoutScrolling", () => $1117b6c0d4c4c164$export$de79e2c695e052f3);
$parcel$export(module.exports, "getOffset", () => $16ec41ef3e36c19c$export$622cea445a1c5b7d);
$parcel$export(module.exports, "runAfterTransition", () => $e8117ebcab55be6a$export$24490316f764c430);
$parcel$export(module.exports, "useDrag1D", () => $28ed3fb20343b78b$export$7bbed75feba39706);
$parcel$export(module.exports, "useGlobalListeners", () => $4571ff54ac709100$export$4eaf04e54aa8eed6);
$parcel$export(module.exports, "useLabels", () => $6ec78bde395c477d$export$d6875122194c7b44);
$parcel$export(module.exports, "useObjectRef", () => $475b35fe72ba49b3$export$4338b53315abf666);
$parcel$export(module.exports, "useUpdateEffect", () => $29293a6f5c75b37e$export$496315a1608d9602);
$parcel$export(module.exports, "useLayoutEffect", () => $78605a5d7424e31b$export$e5c5a5f917a5871c);
$parcel$export(module.exports, "useResizeObserver", () => $37733e1652f47193$export$683480f191c0e3ea);
$parcel$export(module.exports, "useSyncRef", () => $6fc733991a9f977c$export$4debdb1a3f0fa79e);
$parcel$export(module.exports, "getScrollParent", () => $d796e7157ac96470$export$cfa2225e87938781);
$parcel$export(module.exports, "isScrollable", () => $d796e7157ac96470$export$2bb74740c4e19def);
$parcel$export(module.exports, "useViewportSize", () => $8b24bab62f5c65ad$export$d699905dd57c73ca);
$parcel$export(module.exports, "useDescription", () => $34da4502ea8120db$export$f8aeda7b10753fa1);
$parcel$export(module.exports, "isMac", () => $9e20cff0af27e8cc$export$9ac100e40613ea10);
$parcel$export(module.exports, "isIPhone", () => $9e20cff0af27e8cc$export$186c6964ca17d99);
$parcel$export(module.exports, "isIPad", () => $9e20cff0af27e8cc$export$7bef049ce92e4224);
$parcel$export(module.exports, "isIOS", () => $9e20cff0af27e8cc$export$fedb369cb70207f1);
$parcel$export(module.exports, "isAppleDevice", () => $9e20cff0af27e8cc$export$e1865c3bedcd822b);
$parcel$export(module.exports, "isWebKit", () => $9e20cff0af27e8cc$export$78551043582a6a98);
$parcel$export(module.exports, "isChrome", () => $9e20cff0af27e8cc$export$6446a186d09e379e);
$parcel$export(module.exports, "isAndroid", () => $9e20cff0af27e8cc$export$a11b0059900ceec8);
$parcel$export(module.exports, "useEvent", () => $2a8c0bb1629926c8$export$90fc3a17d93f704c);
$parcel$export(module.exports, "useValueEffect", () => $19a2307bfabafaf1$export$14d238f342723f25);
$parcel$export(module.exports, "scrollIntoView", () => $449412113267a1fe$export$53a0910f038337bd);
$parcel$export(module.exports, "scrollIntoViewport", () => $449412113267a1fe$export$c826860796309d1b);
$parcel$export(module.exports, "clamp", () => $1Yh1N$reactstatelyutils.clamp);
$parcel$export(module.exports, "snapValueToStep", () => $1Yh1N$reactstatelyutils.snapValueToStep);
$parcel$export(module.exports, "isVirtualClick", () => $577e795361f19be9$export$60278871457622de);
$parcel$export(module.exports, "isVirtualPointerEvent", () => $577e795361f19be9$export$29bf1b5f2c56cf63);
$parcel$export(module.exports, "useEffectEvent", () => $1254e5bb94ac8761$export$7f54fc3180508a52);
$parcel$export(module.exports, "useDeepMemo", () => $20e6e72fbf5dc81e$export$722debc0e56fea39);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $78605a5d7424e31b$export$e5c5a5f917a5871c = typeof window !== "undefined" ? (0, ($parcel$interopDefault($1Yh1N$react))).useLayoutEffect : ()=>{};



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $19a2307bfabafaf1$export$14d238f342723f25(defaultValue) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultValue);
    let valueRef = (0, $1Yh1N$react.useRef)(value);
    let effect = (0, $1Yh1N$react.useRef)(null);
    // Must be stable so that `queue` is stable.
    let nextIter = (0, $1Yh1N$react.useCallback)(()=>{
        // Run the generator to the next yield.
        let newValue = effect.current.next();
        while(!newValue.done && valueRef.current === newValue.value)// If the value is the same as the current value,
        // then continue to the next yield. Otherwise,
        // set the value in state and wait for the next layout effect.
        newValue = effect.current.next();
        // If the generator is done, reset the effect.
        if (newValue.done) {
            effect.current = null;
            return;
        }
        // Always update valueRef when setting the state.
        // This is needed because the function is not regenerated with the new state value since
        // they must be stable across renders. Instead, it gets carried in the ref, but the setState
        // is also needed in order to cause a rerender.
        setValue(newValue.value);
        valueRef.current = newValue.value;
    // this list of dependencies is stable, setState and refs never change after first render.
    }, [
        setValue,
        valueRef,
        effect
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        // If there is an effect currently running, continue to the next yield.
        if (effect.current) nextIter();
    });
    // queue must be a stable function, much like setState.
    let queue = (0, $1Yh1N$react.useCallback)((fn)=>{
        effect.current = fn(valueRef.current);
        nextIter();
    // this list of dependencies is stable, setState and refs never change after first render.
    // in addition, nextIter is stable as outlined above
    }, [
        nextIter,
        effect,
        valueRef
    ]);
    return [
        value,
        queue
    ];
}


let $8c61827343eed941$var$idsUpdaterMap = new Map();
function $8c61827343eed941$export$f680877a34711e37(defaultId) {
    let [value, setValue] = (0, $1Yh1N$react.useState)(defaultId);
    let nextId = (0, $1Yh1N$react.useRef)(null);
    let res = (0, $1Yh1N$reactariassr.useSSRSafeId)(value);
    let updateValue = (0, $1Yh1N$react.useCallback)((val)=>{
        nextId.current = val;
    }, []);
    $8c61827343eed941$var$idsUpdaterMap.set(res, updateValue);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        let r = res;
        return ()=>{
            $8c61827343eed941$var$idsUpdaterMap.delete(r);
        };
    }, [
        res
    ]);
    // This cannot cause an infinite loop because the ref is updated first.
    // eslint-disable-next-line
    (0, $1Yh1N$react.useEffect)(()=>{
        let newId = nextId.current;
        if (newId) {
            nextId.current = null;
            setValue(newId);
        }
    });
    return res;
}
function $8c61827343eed941$export$cd8c9cb68f842629(idA, idB) {
    if (idA === idB) return idA;
    let setIdA = $8c61827343eed941$var$idsUpdaterMap.get(idA);
    if (setIdA) {
        setIdA(idB);
        return idB;
    }
    let setIdB = $8c61827343eed941$var$idsUpdaterMap.get(idB);
    if (setIdB) {
        setIdB(idA);
        return idA;
    }
    return idB;
}
function $8c61827343eed941$export$b4cc09c592e8fdb8(depArray = []) {
    let id = $8c61827343eed941$export$f680877a34711e37();
    let [resolvedId, setResolvedId] = (0, $19a2307bfabafaf1$export$14d238f342723f25)(id);
    let updateId = (0, $1Yh1N$react.useCallback)(()=>{
        setResolvedId(function*() {
            yield id;
            yield document.getElementById(id) ? id : undefined;
        });
    }, [
        id,
        setResolvedId
    ]);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(updateId, [
        id,
        updateId,
        ...depArray
    ]);
    return resolvedId;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /**
 * Calls all functions in the order they were chained with the same arguments.
 */ function $1e2191638e54f613$export$e08e3b67e392101e(...callbacks) {
    return (...args)=>{
        for (let callback of callbacks)if (typeof callback === "function") callback(...args);
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $f847cd1382ea7cd4$export$9d1611c77c2fe928(...args) {
    // Start with a base clone of the first argument. This is a lot faster than starting
    // with an empty object and adding properties as we go.
    let result = {
        ...args[0]
    };
    for(let i = 1; i < args.length; i++){
        let props = args[i];
        for(let key in props){
            let a = result[key];
            let b = props[key];
            // Chain events
            if (typeof a === "function" && typeof b === "function" && // This is a lot faster than a regex.
            key[0] === "o" && key[1] === "n" && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = (0, $1e2191638e54f613$export$e08e3b67e392101e)(a, b);
            else if ((key === "className" || key === "UNSAFE_className") && typeof a === "string" && typeof b === "string") result[key] = (0, ($parcel$interopDefault($1Yh1N$clsx)))(a, b);
            else if (key === "id" && a && b) result.id = (0, $8c61827343eed941$export$cd8c9cb68f842629)(a, b);
            else result[key] = b !== undefined ? b : a;
        }
    }
    return result;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $f05dc24eafaeb7e2$export$c9058316764c140e(...refs) {
    if (refs.length === 1) return refs[0];
    return (value)=>{
        for (let ref of refs){
            if (typeof ref === "function") ref(value);
            else if (ref != null) ref.current = value;
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ const $8d15d0e1797d4238$var$DOMPropNames = new Set([
    "id"
]);
const $8d15d0e1797d4238$var$labelablePropNames = new Set([
    "aria-label",
    "aria-labelledby",
    "aria-describedby",
    "aria-details"
]);
const $8d15d0e1797d4238$var$propRe = /^(data-.*)$/;
function $8d15d0e1797d4238$export$457c3d6518dd4c6f(props, opts = {}) {
    let { labelable: labelable , propNames: propNames  } = opts;
    let filteredProps = {};
    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($8d15d0e1797d4238$var$DOMPropNames.has(prop) || labelable && $8d15d0e1797d4238$var$labelablePropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $8d15d0e1797d4238$var$propRe.test(prop))) filteredProps[prop] = props[prop];
    return filteredProps;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $1117b6c0d4c4c164$export$de79e2c695e052f3(element) {
    if ($1117b6c0d4c4c164$var$supportsPreventScroll()) element.focus({
        preventScroll: true
    });
    else {
        let scrollableElements = $1117b6c0d4c4c164$var$getScrollableElements(element);
        element.focus();
        $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements);
    }
}
let $1117b6c0d4c4c164$var$supportsPreventScrollCached = null;
function $1117b6c0d4c4c164$var$supportsPreventScroll() {
    if ($1117b6c0d4c4c164$var$supportsPreventScrollCached == null) {
        $1117b6c0d4c4c164$var$supportsPreventScrollCached = false;
        try {
            var focusElem = document.createElement("div");
            focusElem.focus({
                get preventScroll () {
                    $1117b6c0d4c4c164$var$supportsPreventScrollCached = true;
                    return true;
                }
            });
        } catch (e) {
        // Ignore
        }
    }
    return $1117b6c0d4c4c164$var$supportsPreventScrollCached;
}
function $1117b6c0d4c4c164$var$getScrollableElements(element) {
    var parent = element.parentNode;
    var scrollableElements = [];
    var rootScrollingElement = document.scrollingElement || document.documentElement;
    while(parent instanceof HTMLElement && parent !== rootScrollingElement){
        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({
            element: parent,
            scrollTop: parent.scrollTop,
            scrollLeft: parent.scrollLeft
        });
        parent = parent.parentNode;
    }
    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
        element: rootScrollingElement,
        scrollTop: rootScrollingElement.scrollTop,
        scrollLeft: rootScrollingElement.scrollLeft
    });
    return scrollableElements;
}
function $1117b6c0d4c4c164$var$restoreScrollPosition(scrollableElements) {
    for (let { element: element , scrollTop: scrollTop , scrollLeft: scrollLeft  } of scrollableElements){
        element.scrollTop = scrollTop;
        element.scrollLeft = scrollLeft;
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $16ec41ef3e36c19c$export$622cea445a1c5b7d(element, reverse, orientation = "horizontal") {
    let rect = element.getBoundingClientRect();
    if (reverse) return orientation === "horizontal" ? rect.right : rect.bottom;
    return orientation === "horizontal" ? rect.left : rect.top;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We store a global list of elements that are currently transitioning,
// mapped to a set of CSS properties that are transitioning for that element.
// This is necessary rather than a simple count of transitions because of browser
// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather
// than one or the other. So we need to track what's actually transitioning so that
// we can ignore these duplicate events.
let $e8117ebcab55be6a$var$transitionsByElement = new Map();
// A list of callbacks to call once there are no transitioning elements.
let $e8117ebcab55be6a$var$transitionCallbacks = new Set();
function $e8117ebcab55be6a$var$setupGlobalEvents() {
    if (typeof window === "undefined") return;
    let onTransitionStart = (e)=>{
        // Add the transitioning property to the list for this element.
        let transitions = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!transitions) {
            transitions = new Set();
            $e8117ebcab55be6a$var$transitionsByElement.set(e.target, transitions);
            // The transitioncancel event must be registered on the element itself, rather than as a global
            // event. This enables us to handle when the node is deleted from the document while it is transitioning.
            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.
            e.target.addEventListener("transitioncancel", onTransitionEnd);
        }
        transitions.add(e.propertyName);
    };
    let onTransitionEnd = (e)=>{
        // Remove property from list of transitioning properties.
        let properties = $e8117ebcab55be6a$var$transitionsByElement.get(e.target);
        if (!properties) return;
        properties.delete(e.propertyName);
        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.
        if (properties.size === 0) {
            e.target.removeEventListener("transitioncancel", onTransitionEnd);
            $e8117ebcab55be6a$var$transitionsByElement.delete(e.target);
        }
        // If no transitioning elements, call all of the queued callbacks.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) {
            for (let cb of $e8117ebcab55be6a$var$transitionCallbacks)cb();
            $e8117ebcab55be6a$var$transitionCallbacks.clear();
        }
    };
    document.body.addEventListener("transitionrun", onTransitionStart);
    document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $e8117ebcab55be6a$var$setupGlobalEvents();
    else document.addEventListener("DOMContentLoaded", $e8117ebcab55be6a$var$setupGlobalEvents);
}
function $e8117ebcab55be6a$export$24490316f764c430(fn) {
    // Wait one frame to see if an animation starts, e.g. a transition on mount.
    requestAnimationFrame(()=>{
        // If no transitions are running, call the function immediately.
        // Otherwise, add it to a list of callbacks to run at the end of the animation.
        if ($e8117ebcab55be6a$var$transitionsByElement.size === 0) fn();
        else $e8117ebcab55be6a$var$transitionCallbacks.add(fn);
    });
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 

// Keep track of elements that we are currently handling dragging for via useDrag1D.
// If there's an ancestor and a descendant both using useDrag1D(), and the user starts
// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.
const $28ed3fb20343b78b$var$draggingElements = [];
function $28ed3fb20343b78b$export$7bbed75feba39706(props) {
    console.warn("useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html");
    let { containerRef: containerRef , reverse: reverse , orientation: orientation , onHover: onHover , onDrag: onDrag , onPositionChange: onPositionChange , onIncrement: onIncrement , onDecrement: onDecrement , onIncrementToMax: onIncrementToMax , onDecrementToMin: onDecrementToMin , onCollapseToggle: onCollapseToggle  } = props;
    let getPosition = (e)=>orientation === "horizontal" ? e.clientX : e.clientY;
    let getNextOffset = (e)=>{
        let containerOffset = (0, $16ec41ef3e36c19c$export$622cea445a1c5b7d)(containerRef.current, reverse, orientation);
        let mouseOffset = getPosition(e);
        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;
        return nextOffset;
    };
    let dragging = (0, $1Yh1N$react.useRef)(false);
    let prevPosition = (0, $1Yh1N$react.useRef)(0);
    // Keep track of the current handlers in a ref so that the events can access them.
    let handlers = (0, $1Yh1N$react.useRef)({
        onPositionChange: onPositionChange,
        onDrag: onDrag
    });
    handlers.current.onDrag = onDrag;
    handlers.current.onPositionChange = onPositionChange;
    let onMouseDragged = (e)=>{
        e.preventDefault();
        let nextOffset = getNextOffset(e);
        if (!dragging.current) {
            dragging.current = true;
            if (handlers.current.onDrag) handlers.current.onDrag(true);
            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        }
        if (prevPosition.current === nextOffset) return;
        prevPosition.current = nextOffset;
        if (onPositionChange) onPositionChange(nextOffset);
    };
    let onMouseUp = (e)=>{
        const target = e.target;
        dragging.current = false;
        let nextOffset = getNextOffset(e);
        if (handlers.current.onDrag) handlers.current.onDrag(false);
        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        $28ed3fb20343b78b$var$draggingElements.splice($28ed3fb20343b78b$var$draggingElements.indexOf(target), 1);
        window.removeEventListener("mouseup", onMouseUp, false);
        window.removeEventListener("mousemove", onMouseDragged, false);
    };
    let onMouseDown = (e)=>{
        const target = e.currentTarget;
        // If we're already handling dragging on a descendant with useDrag1D, then
        // we don't want to handle the drag motion on this target as well.
        if ($28ed3fb20343b78b$var$draggingElements.some((elt)=>target.contains(elt))) return;
        $28ed3fb20343b78b$var$draggingElements.push(target);
        window.addEventListener("mousemove", onMouseDragged, false);
        window.addEventListener("mouseup", onMouseUp, false);
    };
    let onMouseEnter = ()=>{
        if (onHover) onHover(true);
    };
    let onMouseOut = ()=>{
        if (onHover) onHover(false);
    };
    let onKeyDown = (e)=>{
        switch(e.key){
            case "Left":
            case "ArrowLeft":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Up":
            case "ArrowUp":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Right":
            case "ArrowRight":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Down":
            case "ArrowDown":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Home":
                e.preventDefault();
                if (onDecrementToMin) onDecrementToMin();
                break;
            case "End":
                e.preventDefault();
                if (onIncrementToMax) onIncrementToMax();
                break;
            case "Enter":
                e.preventDefault();
                if (onCollapseToggle) onCollapseToggle();
                break;
        }
    };
    return {
        onMouseDown: onMouseDown,
        onMouseEnter: onMouseEnter,
        onMouseOut: onMouseOut,
        onKeyDown: onKeyDown
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $4571ff54ac709100$export$4eaf04e54aa8eed6() {
    let globalListeners = (0, $1Yh1N$react.useRef)(new Map());
    let addGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        // Make sure we remove the listener after it is called with the `once` option.
        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{
            globalListeners.current.delete(listener);
            listener(...args);
        } : listener;
        globalListeners.current.set(listener, {
            type: type,
            eventTarget: eventTarget,
            fn: fn,
            options: options
        });
        eventTarget.addEventListener(type, listener, options);
    }, []);
    let removeGlobalListener = (0, $1Yh1N$react.useCallback)((eventTarget, type, listener, options)=>{
        var _globalListeners_current_get;
        let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
        eventTarget.removeEventListener(type, fn, options);
        globalListeners.current.delete(listener);
    }, []);
    let removeAllGlobalListeners = (0, $1Yh1N$react.useCallback)(()=>{
        globalListeners.current.forEach((value, key)=>{
            removeGlobalListener(value.eventTarget, value.type, key, value.options);
        });
    }, [
        removeGlobalListener
    ]);
    // eslint-disable-next-line arrow-body-style
    (0, $1Yh1N$react.useEffect)(()=>{
        return removeAllGlobalListeners;
    }, [
        removeAllGlobalListeners
    ]);
    return {
        addGlobalListener: addGlobalListener,
        removeGlobalListener: removeGlobalListener,
        removeAllGlobalListeners: removeAllGlobalListeners
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6ec78bde395c477d$export$d6875122194c7b44(props, defaultLabel) {
    let { id: id , "aria-label": label , "aria-labelledby": labelledBy  } = props;
    // If there is both an aria-label and aria-labelledby,
    // combine them by pointing to the element itself.
    id = (0, $8c61827343eed941$export$f680877a34711e37)(id);
    if (labelledBy && label) {
        let ids = new Set([
            id,
            ...labelledBy.trim().split(/\s+/)
        ]);
        labelledBy = [
            ...ids
        ].join(" ");
    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\s+/).join(" ");
    // If no labels are provided, use the default
    if (!label && !labelledBy && defaultLabel) label = defaultLabel;
    return {
        id: id,
        "aria-label": label,
        "aria-labelledby": labelledBy
    };
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $475b35fe72ba49b3$export$4338b53315abf666(forwardedRef) {
    const objRef = (0, $1Yh1N$react.useRef)();
    return (0, $1Yh1N$react.useMemo)(()=>({
            get current () {
                return objRef.current;
            },
            set current (value){
                objRef.current = value;
                if (typeof forwardedRef === "function") forwardedRef(value);
                else if (forwardedRef) forwardedRef.current = value;
            }
        }), [
        forwardedRef
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $29293a6f5c75b37e$export$496315a1608d9602(effect, dependencies) {
    const isInitialMount = (0, $1Yh1N$react.useRef)(true);
    const lastDeps = (0, $1Yh1N$react.useRef)(null);
    (0, $1Yh1N$react.useEffect)(()=>{
        isInitialMount.current = true;
        return ()=>{
            isInitialMount.current = false;
        };
    }, []);
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isInitialMount.current) isInitialMount.current = false;
        else if (!lastDeps.current || dependencies.some((dep, i)=>!Object.is(dep, lastDeps[i]))) effect();
        lastDeps.current = dependencies;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencies);
}




function $37733e1652f47193$var$hasResizeObserver() {
    return typeof window.ResizeObserver !== "undefined";
}
function $37733e1652f47193$export$683480f191c0e3ea(options) {
    const { ref: ref , onResize: onResize  } = options;
    (0, $1Yh1N$react.useEffect)(()=>{
        let element = ref === null || ref === void 0 ? void 0 : ref.current;
        if (!element) return;
        if (!$37733e1652f47193$var$hasResizeObserver()) {
            window.addEventListener("resize", onResize, false);
            return ()=>{
                window.removeEventListener("resize", onResize, false);
            };
        } else {
            const resizeObserverInstance = new window.ResizeObserver((entries)=>{
                if (!entries.length) return;
                onResize();
            });
            resizeObserverInstance.observe(element);
            return ()=>{
                if (element) resizeObserverInstance.unobserve(element);
            };
        }
    }, [
        onResize,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6fc733991a9f977c$export$4debdb1a3f0fa79e(context, ref) {
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (context && context.ref && ref) {
            context.ref.current = ref.current;
            return ()=>{
                context.ref.current = null;
            };
        }
    }, [
        context,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $d796e7157ac96470$export$cfa2225e87938781(node) {
    if ($d796e7157ac96470$export$2bb74740c4e19def(node)) node = node.parentElement;
    while(node && !$d796e7157ac96470$export$2bb74740c4e19def(node))node = node.parentElement;
    return node || document.scrollingElement || document.documentElement;
}
function $d796e7157ac96470$export$2bb74740c4e19def(node) {
    let style = window.getComputedStyle(node);
    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// @ts-ignore
let $8b24bab62f5c65ad$var$visualViewport = typeof window !== "undefined" && window.visualViewport;
function $8b24bab62f5c65ad$export$d699905dd57c73ca() {
    let [size, setSize] = (0, $1Yh1N$react.useState)(()=>$8b24bab62f5c65ad$var$getViewportSize());
    (0, $1Yh1N$react.useEffect)(()=>{
        // Use visualViewport api to track available height even on iOS virtual keyboard opening
        let onResize = ()=>{
            setSize((size)=>{
                let newSize = $8b24bab62f5c65ad$var$getViewportSize();
                if (newSize.width === size.width && newSize.height === size.height) return size;
                return newSize;
            });
        };
        if (!$8b24bab62f5c65ad$var$visualViewport) window.addEventListener("resize", onResize);
        else $8b24bab62f5c65ad$var$visualViewport.addEventListener("resize", onResize);
        return ()=>{
            if (!$8b24bab62f5c65ad$var$visualViewport) window.removeEventListener("resize", onResize);
            else $8b24bab62f5c65ad$var$visualViewport.removeEventListener("resize", onResize);
        };
    }, []);
    return size;
}
function $8b24bab62f5c65ad$var$getViewportSize() {
    return {
        width: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.width) || window.innerWidth,
        height: ($8b24bab62f5c65ad$var$visualViewport === null || $8b24bab62f5c65ad$var$visualViewport === void 0 ? void 0 : $8b24bab62f5c65ad$var$visualViewport.height) || window.innerHeight
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

let $34da4502ea8120db$var$descriptionId = 0;
const $34da4502ea8120db$var$descriptionNodes = new Map();
function $34da4502ea8120db$export$f8aeda7b10753fa1(description) {
    let [id, setId] = (0, $1Yh1N$react.useState)(undefined);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        if (!description) return;
        let desc = $34da4502ea8120db$var$descriptionNodes.get(description);
        if (!desc) {
            let id = `react-aria-description-${$34da4502ea8120db$var$descriptionId++}`;
            setId(id);
            let node = document.createElement("div");
            node.id = id;
            node.style.display = "none";
            node.textContent = description;
            document.body.appendChild(node);
            desc = {
                refCount: 0,
                element: node
            };
            $34da4502ea8120db$var$descriptionNodes.set(description, desc);
        } else setId(desc.element.id);
        desc.refCount++;
        return ()=>{
            if (--desc.refCount === 0) {
                desc.element.remove();
                $34da4502ea8120db$var$descriptionNodes.delete(description);
            }
        };
    }, [
        description
    ]);
    return {
        "aria-describedby": description ? id : undefined
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $9e20cff0af27e8cc$var$testUserAgent(re) {
    var _window_navigator_userAgentData;
    if (typeof window === "undefined" || window.navigator == null) return false;
    return ((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand)=>re.test(brand.brand))) || re.test(window.navigator.userAgent);
}
function $9e20cff0af27e8cc$var$testPlatform(re) {
    var _window_navigator_userAgentData;
    return typeof window !== "undefined" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $9e20cff0af27e8cc$export$9ac100e40613ea10() {
    return $9e20cff0af27e8cc$var$testPlatform(/^Mac/i);
}
function $9e20cff0af27e8cc$export$186c6964ca17d99() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPhone/i);
}
function $9e20cff0af27e8cc$export$7bef049ce92e4224() {
    return $9e20cff0af27e8cc$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
    $9e20cff0af27e8cc$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
}
function $9e20cff0af27e8cc$export$fedb369cb70207f1() {
    return $9e20cff0af27e8cc$export$186c6964ca17d99() || $9e20cff0af27e8cc$export$7bef049ce92e4224();
}
function $9e20cff0af27e8cc$export$e1865c3bedcd822b() {
    return $9e20cff0af27e8cc$export$9ac100e40613ea10() || $9e20cff0af27e8cc$export$fedb369cb70207f1();
}
function $9e20cff0af27e8cc$export$78551043582a6a98() {
    return $9e20cff0af27e8cc$var$testUserAgent(/AppleWebKit/i) && !$9e20cff0af27e8cc$export$6446a186d09e379e();
}
function $9e20cff0af27e8cc$export$6446a186d09e379e() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Chrome/i);
}
function $9e20cff0af27e8cc$export$a11b0059900ceec8() {
    return $9e20cff0af27e8cc$var$testUserAgent(/Android/i);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $1254e5bb94ac8761$export$7f54fc3180508a52(fn) {
    const ref = (0, $1Yh1N$react.useRef)(null);
    (0, $78605a5d7424e31b$export$e5c5a5f917a5871c)(()=>{
        ref.current = fn;
    }, [
        fn
    ]);
    return (0, $1Yh1N$react.useCallback)((...args)=>{
        const f = ref.current;
        return f(...args);
    }, []);
}


function $2a8c0bb1629926c8$export$90fc3a17d93f704c(ref, event, handler, options) {
    let handleEvent = (0, $1254e5bb94ac8761$export$7f54fc3180508a52)(handler);
    let isDisabled = handler == null;
    (0, $1Yh1N$react.useEffect)(()=>{
        if (isDisabled) return;
        let element = ref.current;
        element.addEventListener(event, handleEvent, options);
        return ()=>{
            element.removeEventListener(event, handleEvent, options);
        };
    }, [
        ref,
        event,
        options,
        isDisabled,
        handleEvent
    ]);
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $449412113267a1fe$export$53a0910f038337bd(scrollView, element) {
    let offsetX = $449412113267a1fe$var$relativeOffset(scrollView, element, "left");
    let offsetY = $449412113267a1fe$var$relativeOffset(scrollView, element, "top");
    let width = element.offsetWidth;
    let height = element.offsetHeight;
    let x = scrollView.scrollLeft;
    let y = scrollView.scrollTop;
    // Account for top/left border offsetting the scroll top/Left
    let { borderTopWidth: borderTopWidth , borderLeftWidth: borderLeftWidth  } = getComputedStyle(scrollView);
    let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);
    let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);
    // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width
    let maxX = borderAdjustedX + scrollView.clientWidth;
    let maxY = borderAdjustedY + scrollView.clientHeight;
    if (offsetX <= x) x = offsetX - parseInt(borderLeftWidth, 10);
    else if (offsetX + width > maxX) x += offsetX + width - maxX;
    if (offsetY <= borderAdjustedY) y = offsetY - parseInt(borderTopWidth, 10);
    else if (offsetY + height > maxY) y += offsetY + height - maxY;
    scrollView.scrollLeft = x;
    scrollView.scrollTop = y;
}
/**
 * Computes the offset left or top from child to ancestor by accumulating
 * offsetLeft or offsetTop through intervening offsetParents.
 */ function $449412113267a1fe$var$relativeOffset(ancestor, child, axis) {
    const prop = axis === "left" ? "offsetLeft" : "offsetTop";
    let sum = 0;
    while(child.offsetParent){
        sum += child[prop];
        if (child.offsetParent === ancestor) break;
        else if (child.offsetParent.contains(ancestor)) {
            // If the ancestor is not `position:relative`, then we stop at
            // _its_ offset parent, and we subtract off _its_ offset, so that
            // we end up with the proper offset from child to ancestor.
            sum -= ancestor[prop];
            break;
        }
        child = child.offsetParent;
    }
    return sum;
}
function $449412113267a1fe$export$c826860796309d1b(targetElement, opts) {
    if (document.contains(targetElement)) {
        let root = document.scrollingElement || document.documentElement;
        let isScrollPrevented = window.getComputedStyle(root).overflow === "hidden";
        // If scrolling is not currently prevented then we aren’t in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view
        if (!isScrollPrevented) {
            var // use scrollIntoView({block: 'nearest'}) instead of .focus to check if the element is fully in view or not since .focus()
            // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically
            _targetElement_scrollIntoView;
            let { left: originalLeft , top: originalTop  } = targetElement.getBoundingClientRect();
            targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {
                block: "nearest"
            });
            let { left: newLeft , top: newTop  } = targetElement.getBoundingClientRect();
            // Account for sub pixel differences from rounding
            if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {
                var _opts_containingElement, _opts_containingElement_scrollIntoView, _targetElement_scrollIntoView1;
                opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {
                    block: "center",
                    inline: "center"
                });
                (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {
                    block: "nearest"
                });
            }
        } else {
            let scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.
            while(targetElement && scrollParent && targetElement !== root && scrollParent !== root){
                $449412113267a1fe$export$53a0910f038337bd(scrollParent, targetElement);
                targetElement = scrollParent;
                scrollParent = (0, $d796e7157ac96470$export$cfa2225e87938781)(targetElement);
            }
        }
    }
}



/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $577e795361f19be9$export$60278871457622de(event) {
    // JAWS/NVDA with Firefox.
    if (event.mozInputSource === 0 && event.isTrusted) return true;
    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead
    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check
    // to detect TalkBack virtual clicks.
    if ((0, $9e20cff0af27e8cc$export$a11b0059900ceec8)() && event.pointerType) return event.type === "click" && event.buttons === 1;
    return event.detail === 0 && !event.pointerType;
}
function $577e795361f19be9$export$29bf1b5f2c56cf63(event) {
    // If the pointer size is zero, then we assume it's from a screen reader.
    // Android TalkBack double tap will sometimes return a event with width and height of 1
    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.
    // Cannot use "event.pressure === 0" as the sole check due to Safari pointer events always returning pressure === 0
    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush
    // Talkback double tap from Windows Firefox touch screen press
    return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse";
}



/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 
function $20e6e72fbf5dc81e$export$722debc0e56fea39(value, isEqual) {
    // Using a ref during render is ok here because it's only an optimization – both values are equivalent.
    // If a render is thrown away, it'll still work the same no matter if the next render is the same or not.
    let lastValue = (0, $1Yh1N$react.useRef)(null);
    if (value && lastValue.current && isEqual(value, lastValue.current)) value = lastValue.current;
    lastValue.current = value;
    return value;
}




//# sourceMappingURL=main.js.map


/***/ }),

/***/ 14889:
/***/ ((module) => {

function e(r){var o,t,f="";if("string"==typeof r||"number"==typeof r)f+=r;else if("object"==typeof r)if(Array.isArray(r))for(o=0;o<r.length;o++)r[o]&&(t=e(r[o]))&&(f&&(f+=" "),f+=t);else for(o in r)r[o]&&(f&&(f+=" "),f+=o);return f}function r(){for(var r,o,t=0,f="";t<arguments.length;)(r=arguments[t++])&&(o=e(r))&&(f&&(f+=" "),f+=o);return f}module.exports=r,module.exports.clsx=r;

/***/ }),

/***/ 34559:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
Copyright (c) 2014, Yahoo! Inc. All rights reserved.
Copyrights licensed under the New BSD License.
See the accompanying LICENSE file for terms.
*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(61915);
var core_1 = __webpack_require__(45583);
tslib_1.__exportStar(__webpack_require__(71982), exports);
tslib_1.__exportStar(__webpack_require__(45583), exports);
tslib_1.__exportStar(__webpack_require__(89534), exports);
exports["default"] = core_1.IntlMessageFormat;


/***/ }),

/***/ 45583:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
Copyright (c) 2014, Yahoo! Inc. All rights reserved.
Copyrights licensed under the New BSD License.
See the accompanying LICENSE file for terms.
*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IntlMessageFormat = void 0;
var tslib_1 = __webpack_require__(61915);
var icu_messageformat_parser_1 = __webpack_require__(28553);
var fast_memoize_1 = __webpack_require__(24622);
var formatters_1 = __webpack_require__(71982);
// -- MessageFormat --------------------------------------------------------
function mergeConfig(c1, c2) {
    if (!c2) {
        return c1;
    }
    return tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, (c1 || {})), (c2 || {})), Object.keys(c1).reduce(function (all, k) {
        all[k] = tslib_1.__assign(tslib_1.__assign({}, c1[k]), (c2[k] || {}));
        return all;
    }, {}));
}
function mergeConfigs(defaultConfig, configs) {
    if (!configs) {
        return defaultConfig;
    }
    return Object.keys(defaultConfig).reduce(function (all, k) {
        all[k] = mergeConfig(defaultConfig[k], configs[k]);
        return all;
    }, tslib_1.__assign({}, defaultConfig));
}
function createFastMemoizeCache(store) {
    return {
        create: function () {
            return {
                get: function (key) {
                    return store[key];
                },
                set: function (key, value) {
                    store[key] = value;
                },
            };
        },
    };
}
function createDefaultFormatters(cache) {
    if (cache === void 0) { cache = {
        number: {},
        dateTime: {},
        pluralRules: {},
    }; }
    return {
        getNumberFormat: (0, fast_memoize_1.memoize)(function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new ((_a = Intl.NumberFormat).bind.apply(_a, tslib_1.__spreadArray([void 0], args, false)))();
        }, {
            cache: createFastMemoizeCache(cache.number),
            strategy: fast_memoize_1.strategies.variadic,
        }),
        getDateTimeFormat: (0, fast_memoize_1.memoize)(function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new ((_a = Intl.DateTimeFormat).bind.apply(_a, tslib_1.__spreadArray([void 0], args, false)))();
        }, {
            cache: createFastMemoizeCache(cache.dateTime),
            strategy: fast_memoize_1.strategies.variadic,
        }),
        getPluralRules: (0, fast_memoize_1.memoize)(function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new ((_a = Intl.PluralRules).bind.apply(_a, tslib_1.__spreadArray([void 0], args, false)))();
        }, {
            cache: createFastMemoizeCache(cache.pluralRules),
            strategy: fast_memoize_1.strategies.variadic,
        }),
    };
}
var IntlMessageFormat = exports.IntlMessageFormat = /** @class */ (function () {
    function IntlMessageFormat(message, locales, overrideFormats, opts) {
        if (locales === void 0) { locales = IntlMessageFormat.defaultLocale; }
        var _this = this;
        this.formatterCache = {
            number: {},
            dateTime: {},
            pluralRules: {},
        };
        this.format = function (values) {
            var parts = _this.formatToParts(values);
            // Hot path for straight simple msg translations
            if (parts.length === 1) {
                return parts[0].value;
            }
            var result = parts.reduce(function (all, part) {
                if (!all.length ||
                    part.type !== formatters_1.PART_TYPE.literal ||
                    typeof all[all.length - 1] !== 'string') {
                    all.push(part.value);
                }
                else {
                    all[all.length - 1] += part.value;
                }
                return all;
            }, []);
            if (result.length <= 1) {
                return result[0] || '';
            }
            return result;
        };
        this.formatToParts = function (values) {
            return (0, formatters_1.formatToParts)(_this.ast, _this.locales, _this.formatters, _this.formats, values, undefined, _this.message);
        };
        this.resolvedOptions = function () {
            var _a;
            return ({
                locale: ((_a = _this.resolvedLocale) === null || _a === void 0 ? void 0 : _a.toString()) ||
                    Intl.NumberFormat.supportedLocalesOf(_this.locales)[0],
            });
        };
        this.getAst = function () { return _this.ast; };
        // Defined first because it's used to build the format pattern.
        this.locales = locales;
        this.resolvedLocale = IntlMessageFormat.resolveLocale(locales);
        if (typeof message === 'string') {
            this.message = message;
            if (!IntlMessageFormat.__parse) {
                throw new TypeError('IntlMessageFormat.__parse must be set to process `message` of type `string`');
            }
            var _a = opts || {}, formatters = _a.formatters, parseOpts = tslib_1.__rest(_a, ["formatters"]);
            // Parse string messages into an AST.
            this.ast = IntlMessageFormat.__parse(message, tslib_1.__assign(tslib_1.__assign({}, parseOpts), { locale: this.resolvedLocale }));
        }
        else {
            this.ast = message;
        }
        if (!Array.isArray(this.ast)) {
            throw new TypeError('A message must be provided as a String or AST.');
        }
        // Creates a new object with the specified `formats` merged with the default
        // formats.
        this.formats = mergeConfigs(IntlMessageFormat.formats, overrideFormats);
        this.formatters =
            (opts && opts.formatters) || createDefaultFormatters(this.formatterCache);
    }
    Object.defineProperty(IntlMessageFormat, "defaultLocale", {
        get: function () {
            if (!IntlMessageFormat.memoizedDefaultLocale) {
                IntlMessageFormat.memoizedDefaultLocale =
                    new Intl.NumberFormat().resolvedOptions().locale;
            }
            return IntlMessageFormat.memoizedDefaultLocale;
        },
        enumerable: false,
        configurable: true
    });
    IntlMessageFormat.memoizedDefaultLocale = null;
    IntlMessageFormat.resolveLocale = function (locales) {
        if (typeof Intl.Locale === 'undefined') {
            return;
        }
        var supportedLocales = Intl.NumberFormat.supportedLocalesOf(locales);
        if (supportedLocales.length > 0) {
            return new Intl.Locale(supportedLocales[0]);
        }
        return new Intl.Locale(typeof locales === 'string' ? locales : locales[0]);
    };
    IntlMessageFormat.__parse = icu_messageformat_parser_1.parse;
    // Default format options used as the prototype of the `formats` provided to the
    // constructor. These are used when constructing the internal Intl.NumberFormat
    // and Intl.DateTimeFormat instances.
    IntlMessageFormat.formats = {
        number: {
            integer: {
                maximumFractionDigits: 0,
            },
            currency: {
                style: 'currency',
            },
            percent: {
                style: 'percent',
            },
        },
        date: {
            short: {
                month: 'numeric',
                day: 'numeric',
                year: '2-digit',
            },
            medium: {
                month: 'short',
                day: 'numeric',
                year: 'numeric',
            },
            long: {
                month: 'long',
                day: 'numeric',
                year: 'numeric',
            },
            full: {
                weekday: 'long',
                month: 'long',
                day: 'numeric',
                year: 'numeric',
            },
        },
        time: {
            short: {
                hour: 'numeric',
                minute: 'numeric',
            },
            medium: {
                hour: 'numeric',
                minute: 'numeric',
                second: 'numeric',
            },
            long: {
                hour: 'numeric',
                minute: 'numeric',
                second: 'numeric',
                timeZoneName: 'short',
            },
            full: {
                hour: 'numeric',
                minute: 'numeric',
                second: 'numeric',
                timeZoneName: 'short',
            },
        },
    };
    return IntlMessageFormat;
}());


/***/ }),

/***/ 89534:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MissingValueError = exports.InvalidValueTypeError = exports.InvalidValueError = exports.FormatError = exports.ErrorCode = void 0;
var tslib_1 = __webpack_require__(61915);
var ErrorCode;
(function (ErrorCode) {
    // When we have a placeholder but no value to format
    ErrorCode["MISSING_VALUE"] = "MISSING_VALUE";
    // When value supplied is invalid
    ErrorCode["INVALID_VALUE"] = "INVALID_VALUE";
    // When we need specific Intl API but it's not available
    ErrorCode["MISSING_INTL_API"] = "MISSING_INTL_API";
})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
var FormatError = /** @class */ (function (_super) {
    tslib_1.__extends(FormatError, _super);
    function FormatError(msg, code, originalMessage) {
        var _this = _super.call(this, msg) || this;
        _this.code = code;
        _this.originalMessage = originalMessage;
        return _this;
    }
    FormatError.prototype.toString = function () {
        return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
    };
    return FormatError;
}(Error));
exports.FormatError = FormatError;
var InvalidValueError = /** @class */ (function (_super) {
    tslib_1.__extends(InvalidValueError, _super);
    function InvalidValueError(variableId, value, options, originalMessage) {
        return _super.call(this, "Invalid values for \"".concat(variableId, "\": \"").concat(value, "\". Options are \"").concat(Object.keys(options).join('", "'), "\""), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueError;
}(FormatError));
exports.InvalidValueError = InvalidValueError;
var InvalidValueTypeError = /** @class */ (function (_super) {
    tslib_1.__extends(InvalidValueTypeError, _super);
    function InvalidValueTypeError(value, type, originalMessage) {
        return _super.call(this, "Value for \"".concat(value, "\" must be of type ").concat(type), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueTypeError;
}(FormatError));
exports.InvalidValueTypeError = InvalidValueTypeError;
var MissingValueError = /** @class */ (function (_super) {
    tslib_1.__extends(MissingValueError, _super);
    function MissingValueError(variableId, originalMessage) {
        return _super.call(this, "The intl string context variable \"".concat(variableId, "\" was not provided to the string \"").concat(originalMessage, "\""), ErrorCode.MISSING_VALUE, originalMessage) || this;
    }
    return MissingValueError;
}(FormatError));
exports.MissingValueError = MissingValueError;


/***/ }),

/***/ 71982:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatToParts = exports.isFormatXMLElementFn = exports.PART_TYPE = void 0;
var icu_messageformat_parser_1 = __webpack_require__(28553);
var error_1 = __webpack_require__(89534);
var PART_TYPE;
(function (PART_TYPE) {
    PART_TYPE[PART_TYPE["literal"] = 0] = "literal";
    PART_TYPE[PART_TYPE["object"] = 1] = "object";
})(PART_TYPE = exports.PART_TYPE || (exports.PART_TYPE = {}));
function mergeLiteral(parts) {
    if (parts.length < 2) {
        return parts;
    }
    return parts.reduce(function (all, part) {
        var lastPart = all[all.length - 1];
        if (!lastPart ||
            lastPart.type !== PART_TYPE.literal ||
            part.type !== PART_TYPE.literal) {
            all.push(part);
        }
        else {
            lastPart.value += part.value;
        }
        return all;
    }, []);
}
function isFormatXMLElementFn(el) {
    return typeof el === 'function';
}
exports.isFormatXMLElementFn = isFormatXMLElementFn;
// TODO(skeleton): add skeleton support
function formatToParts(els, locales, formatters, formats, values, currentPluralValue, 
// For debugging
originalMessage) {
    // Hot path for straight simple msg translations
    if (els.length === 1 && (0, icu_messageformat_parser_1.isLiteralElement)(els[0])) {
        return [
            {
                type: PART_TYPE.literal,
                value: els[0].value,
            },
        ];
    }
    var result = [];
    for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
        var el = els_1[_i];
        // Exit early for string parts.
        if ((0, icu_messageformat_parser_1.isLiteralElement)(el)) {
            result.push({
                type: PART_TYPE.literal,
                value: el.value,
            });
            continue;
        }
        // TODO: should this part be literal type?
        // Replace `#` in plural rules with the actual numeric value.
        if ((0, icu_messageformat_parser_1.isPoundElement)(el)) {
            if (typeof currentPluralValue === 'number') {
                result.push({
                    type: PART_TYPE.literal,
                    value: formatters.getNumberFormat(locales).format(currentPluralValue),
                });
            }
            continue;
        }
        var varName = el.value;
        // Enforce that all required values are provided by the caller.
        if (!(values && varName in values)) {
            throw new error_1.MissingValueError(varName, originalMessage);
        }
        var value = values[varName];
        if ((0, icu_messageformat_parser_1.isArgumentElement)(el)) {
            if (!value || typeof value === 'string' || typeof value === 'number') {
                value =
                    typeof value === 'string' || typeof value === 'number'
                        ? String(value)
                        : '';
            }
            result.push({
                type: typeof value === 'string' ? PART_TYPE.literal : PART_TYPE.object,
                value: value,
            });
            continue;
        }
        // Recursively format plural and select parts' option — which can be a
        // nested pattern structure. The choosing of the option to use is
        // abstracted-by and delegated-to the part helper object.
        if ((0, icu_messageformat_parser_1.isDateElement)(el)) {
            var style = typeof el.style === 'string'
                ? formats.date[el.style]
                : (0, icu_messageformat_parser_1.isDateTimeSkeleton)(el.style)
                    ? el.style.parsedOptions
                    : undefined;
            result.push({
                type: PART_TYPE.literal,
                value: formatters
                    .getDateTimeFormat(locales, style)
                    .format(value),
            });
            continue;
        }
        if ((0, icu_messageformat_parser_1.isTimeElement)(el)) {
            var style = typeof el.style === 'string'
                ? formats.time[el.style]
                : (0, icu_messageformat_parser_1.isDateTimeSkeleton)(el.style)
                    ? el.style.parsedOptions
                    : formats.time.medium;
            result.push({
                type: PART_TYPE.literal,
                value: formatters
                    .getDateTimeFormat(locales, style)
                    .format(value),
            });
            continue;
        }
        if ((0, icu_messageformat_parser_1.isNumberElement)(el)) {
            var style = typeof el.style === 'string'
                ? formats.number[el.style]
                : (0, icu_messageformat_parser_1.isNumberSkeleton)(el.style)
                    ? el.style.parsedOptions
                    : undefined;
            if (style && style.scale) {
                value =
                    value *
                        (style.scale || 1);
            }
            result.push({
                type: PART_TYPE.literal,
                value: formatters
                    .getNumberFormat(locales, style)
                    .format(value),
            });
            continue;
        }
        if ((0, icu_messageformat_parser_1.isTagElement)(el)) {
            var children = el.children, value_1 = el.value;
            var formatFn = values[value_1];
            if (!isFormatXMLElementFn(formatFn)) {
                throw new error_1.InvalidValueTypeError(value_1, 'function', originalMessage);
            }
            var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);
            var chunks = formatFn(parts.map(function (p) { return p.value; }));
            if (!Array.isArray(chunks)) {
                chunks = [chunks];
            }
            result.push.apply(result, chunks.map(function (c) {
                return {
                    type: typeof c === 'string' ? PART_TYPE.literal : PART_TYPE.object,
                    value: c,
                };
            }));
        }
        if ((0, icu_messageformat_parser_1.isSelectElement)(el)) {
            var opt = el.options[value] || el.options.other;
            if (!opt) {
                throw new error_1.InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
            }
            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));
            continue;
        }
        if ((0, icu_messageformat_parser_1.isPluralElement)(el)) {
            var opt = el.options["=".concat(value)];
            if (!opt) {
                if (!Intl.PluralRules) {
                    throw new error_1.FormatError("Intl.PluralRules is not available in this environment.\nTry polyfilling it using \"@formatjs/intl-pluralrules\"\n", error_1.ErrorCode.MISSING_INTL_API, originalMessage);
                }
                var rule = formatters
                    .getPluralRules(locales, { type: el.pluralType })
                    .select(value - (el.offset || 0));
                opt = el.options[rule] || el.options.other;
            }
            if (!opt) {
                throw new error_1.InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
            }
            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));
            continue;
        }
    }
    return mergeLiteral(result);
}
exports.formatToParts = formatToParts;


/***/ }),

/***/ 27574:
/***/ ((module) => {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 85254:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var e,t="colors",r="sizes",n="space",i={gap:n,gridGap:n,columnGap:n,gridColumnGap:n,rowGap:n,gridRowGap:n,inset:n,insetBlock:n,insetBlockEnd:n,insetBlockStart:n,insetInline:n,insetInlineEnd:n,insetInlineStart:n,margin:n,marginTop:n,marginRight:n,marginBottom:n,marginLeft:n,marginBlock:n,marginBlockEnd:n,marginBlockStart:n,marginInline:n,marginInlineEnd:n,marginInlineStart:n,padding:n,paddingTop:n,paddingRight:n,paddingBottom:n,paddingLeft:n,paddingBlock:n,paddingBlockEnd:n,paddingBlockStart:n,paddingInline:n,paddingInlineEnd:n,paddingInlineStart:n,top:n,right:n,bottom:n,left:n,scrollMargin:n,scrollMarginTop:n,scrollMarginRight:n,scrollMarginBottom:n,scrollMarginLeft:n,scrollMarginX:n,scrollMarginY:n,scrollMarginBlock:n,scrollMarginBlockEnd:n,scrollMarginBlockStart:n,scrollMarginInline:n,scrollMarginInlineEnd:n,scrollMarginInlineStart:n,scrollPadding:n,scrollPaddingTop:n,scrollPaddingRight:n,scrollPaddingBottom:n,scrollPaddingLeft:n,scrollPaddingX:n,scrollPaddingY:n,scrollPaddingBlock:n,scrollPaddingBlockEnd:n,scrollPaddingBlockStart:n,scrollPaddingInline:n,scrollPaddingInlineEnd:n,scrollPaddingInlineStart:n,fontSize:"fontSizes",background:t,backgroundColor:t,backgroundImage:t,borderImage:t,border:t,borderBlock:t,borderBlockEnd:t,borderBlockStart:t,borderBottom:t,borderBottomColor:t,borderColor:t,borderInline:t,borderInlineEnd:t,borderInlineStart:t,borderLeft:t,borderLeftColor:t,borderRight:t,borderRightColor:t,borderTop:t,borderTopColor:t,caretColor:t,color:t,columnRuleColor:t,fill:t,outline:t,outlineColor:t,stroke:t,textDecorationColor:t,fontFamily:"fonts",fontWeight:"fontWeights",lineHeight:"lineHeights",letterSpacing:"letterSpacings",blockSize:r,minBlockSize:r,maxBlockSize:r,inlineSize:r,minInlineSize:r,maxInlineSize:r,width:r,minWidth:r,maxWidth:r,height:r,minHeight:r,maxHeight:r,flexBasis:r,gridTemplateColumns:r,gridTemplateRows:r,borderWidth:"borderWidths",borderTopWidth:"borderWidths",borderRightWidth:"borderWidths",borderBottomWidth:"borderWidths",borderLeftWidth:"borderWidths",borderStyle:"borderStyles",borderTopStyle:"borderStyles",borderRightStyle:"borderStyles",borderBottomStyle:"borderStyles",borderLeftStyle:"borderStyles",borderRadius:"radii",borderTopLeftRadius:"radii",borderTopRightRadius:"radii",borderBottomRightRadius:"radii",borderBottomLeftRadius:"radii",boxShadow:"shadows",textShadow:"shadows",transition:"transitions",zIndex:"zIndices"},o=(e,t)=>"function"==typeof t?{"()":Function.prototype.toString.call(t)}:t,l=()=>{const e=Object.create(null);return(t,r,...n)=>{const i=(e=>JSON.stringify(e,o))(t);return i in e?e[i]:e[i]=r(t,...n)}},s=Symbol.for("sxs.internal"),a=(e,t)=>Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)),c=e=>{for(const t in e)return!0;return!1},{hasOwnProperty:d}=Object.prototype,g=e=>e.includes("-")?e:e.replace(/[A-Z]/g,(e=>"-"+e.toLowerCase())),p=/\s+(?![^()]*\))/,u=e=>t=>e(..."string"==typeof t?String(t).split(p):[t]),h={appearance:e=>({WebkitAppearance:e,appearance:e}),backfaceVisibility:e=>({WebkitBackfaceVisibility:e,backfaceVisibility:e}),backdropFilter:e=>({WebkitBackdropFilter:e,backdropFilter:e}),backgroundClip:e=>({WebkitBackgroundClip:e,backgroundClip:e}),boxDecorationBreak:e=>({WebkitBoxDecorationBreak:e,boxDecorationBreak:e}),clipPath:e=>({WebkitClipPath:e,clipPath:e}),content:e=>({content:e.includes('"')||e.includes("'")||/^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e)?e:`"${e}"`}),hyphens:e=>({WebkitHyphens:e,hyphens:e}),maskImage:e=>({WebkitMaskImage:e,maskImage:e}),maskSize:e=>({WebkitMaskSize:e,maskSize:e}),tabSize:e=>({MozTabSize:e,tabSize:e}),textSizeAdjust:e=>({WebkitTextSizeAdjust:e,textSizeAdjust:e}),userSelect:e=>({WebkitUserSelect:e,userSelect:e}),marginBlock:u(((e,t)=>({marginBlockStart:e,marginBlockEnd:t||e}))),marginInline:u(((e,t)=>({marginInlineStart:e,marginInlineEnd:t||e}))),maxSize:u(((e,t)=>({maxBlockSize:e,maxInlineSize:t||e}))),minSize:u(((e,t)=>({minBlockSize:e,minInlineSize:t||e}))),paddingBlock:u(((e,t)=>({paddingBlockStart:e,paddingBlockEnd:t||e}))),paddingInline:u(((e,t)=>({paddingInlineStart:e,paddingInlineEnd:t||e})))},f=/([\d.]+)([^]*)/,m=(e,t)=>e.length?e.reduce(((e,r)=>(e.push(...t.map((e=>e.includes("&")?e.replace(/&/g,/[ +>|~]/.test(r)&&/&.*&/.test(e)?`:is(${r})`:r):r+" "+e))),e)),[]):t,b=(e,t)=>e in S&&"string"==typeof t?t.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/,((t,r,n,i)=>r+("stretch"===n?`-moz-available${i};${g(e)}:${r}-webkit-fill-available`:`-moz-fit-content${i};${g(e)}:${r}fit-content`)+i)):String(t),S={blockSize:1,height:1,inlineSize:1,maxBlockSize:1,maxHeight:1,maxInlineSize:1,maxWidth:1,minBlockSize:1,minHeight:1,minInlineSize:1,minWidth:1,width:1},y=e=>e?e+"-":"",k=(e,t,r)=>e.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g,((e,n,i,o,l)=>"$"==o==!!i?e:(n||"--"==o?"calc(":"")+"var(--"+("$"===o?y(t)+(l.includes("$")?"":y(r))+l.replace(/\$/g,"-"):l)+")"+(n||"--"==o?"*"+(n||"")+(i||"1")+")":""))),B=/\s*,\s*(?![^()]*\))/,$=Object.prototype.toString,x=(e,t,r,n,i)=>{let o,l,s;const a=(e,t,r)=>{let c,d;const p=e=>{for(c in e){const x=64===c.charCodeAt(0),z=x&&Array.isArray(e[c])?e[c]:[e[c]];for(d of z){const e=/[A-Z]/.test(S=c)?S:S.replace(/-[^]/g,(e=>e[1].toUpperCase())),z="object"==typeof d&&d&&d.toString===$&&(!n.utils[e]||!t.length);if(e in n.utils&&!z){const t=n.utils[e];if(t!==l){l=t,p(t(d)),l=null;continue}}else if(e in h){const t=h[e];if(t!==s){s=t,p(t(d)),s=null;continue}}if(x&&(u=c.slice(1)in n.media?"@media "+n.media[c.slice(1)]:c,c=u.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g,((e,t,r,n,i,o)=>{const l=f.test(t),s=.0625*(l?-1:1),[a,c]=l?[n,t]:[t,n];return"("+("="===r[0]?"":">"===r[0]===l?"max-":"min-")+a+":"+("="!==r[0]&&1===r.length?c.replace(f,((e,t,n)=>Number(t)+s*(">"===r?1:-1)+n)):c)+(i?") and ("+(">"===i[0]?"min-":"max-")+a+":"+(1===i.length?o.replace(f,((e,t,r)=>Number(t)+s*(">"===i?-1:1)+r)):o):"")+")"}))),z){const e=x?r.concat(c):[...r],n=x?[...t]:m(t,c.split(B));void 0!==o&&i(I(...o)),o=void 0,a(d,n,e)}else void 0===o&&(o=[[],t,r]),c=x||36!==c.charCodeAt(0)?c:`--${y(n.prefix)}${c.slice(1).replace(/\$/g,"-")}`,d=z?d:"number"==typeof d?d&&e in R?String(d)+"px":String(d):k(b(e,null==d?"":d),n.prefix,n.themeMap[e]),o[0].push(`${x?`${c} `:`${g(c)}:`}${d}`)}}var u,S};p(e),void 0!==o&&i(I(...o)),o=void 0};a(e,t,r)},I=(e,t,r)=>`${r.map((e=>`${e}{`)).join("")}${t.length?`${t.join(",")}{`:""}${e.join(";")}${t.length?"}":""}${Array(r.length?r.length+1:0).join("}")}`,R={animationDelay:1,animationDuration:1,backgroundSize:1,blockSize:1,border:1,borderBlock:1,borderBlockEnd:1,borderBlockEndWidth:1,borderBlockStart:1,borderBlockStartWidth:1,borderBlockWidth:1,borderBottom:1,borderBottomLeftRadius:1,borderBottomRightRadius:1,borderBottomWidth:1,borderEndEndRadius:1,borderEndStartRadius:1,borderInlineEnd:1,borderInlineEndWidth:1,borderInlineStart:1,borderInlineStartWidth:1,borderInlineWidth:1,borderLeft:1,borderLeftWidth:1,borderRadius:1,borderRight:1,borderRightWidth:1,borderSpacing:1,borderStartEndRadius:1,borderStartStartRadius:1,borderTop:1,borderTopLeftRadius:1,borderTopRightRadius:1,borderTopWidth:1,borderWidth:1,bottom:1,columnGap:1,columnRule:1,columnRuleWidth:1,columnWidth:1,containIntrinsicSize:1,flexBasis:1,fontSize:1,gap:1,gridAutoColumns:1,gridAutoRows:1,gridTemplateColumns:1,gridTemplateRows:1,height:1,inlineSize:1,inset:1,insetBlock:1,insetBlockEnd:1,insetBlockStart:1,insetInline:1,insetInlineEnd:1,insetInlineStart:1,left:1,letterSpacing:1,margin:1,marginBlock:1,marginBlockEnd:1,marginBlockStart:1,marginBottom:1,marginInline:1,marginInlineEnd:1,marginInlineStart:1,marginLeft:1,marginRight:1,marginTop:1,maxBlockSize:1,maxHeight:1,maxInlineSize:1,maxWidth:1,minBlockSize:1,minHeight:1,minInlineSize:1,minWidth:1,offsetDistance:1,offsetRotate:1,outline:1,outlineOffset:1,outlineWidth:1,overflowClipMargin:1,padding:1,paddingBlock:1,paddingBlockEnd:1,paddingBlockStart:1,paddingBottom:1,paddingInline:1,paddingInlineEnd:1,paddingInlineStart:1,paddingLeft:1,paddingRight:1,paddingTop:1,perspective:1,right:1,rowGap:1,scrollMargin:1,scrollMarginBlock:1,scrollMarginBlockEnd:1,scrollMarginBlockStart:1,scrollMarginBottom:1,scrollMarginInline:1,scrollMarginInlineEnd:1,scrollMarginInlineStart:1,scrollMarginLeft:1,scrollMarginRight:1,scrollMarginTop:1,scrollPadding:1,scrollPaddingBlock:1,scrollPaddingBlockEnd:1,scrollPaddingBlockStart:1,scrollPaddingBottom:1,scrollPaddingInline:1,scrollPaddingInlineEnd:1,scrollPaddingInlineStart:1,scrollPaddingLeft:1,scrollPaddingRight:1,scrollPaddingTop:1,shapeMargin:1,textDecoration:1,textDecorationThickness:1,textIndent:1,textUnderlineOffset:1,top:1,transitionDelay:1,transitionDuration:1,verticalAlign:1,width:1,wordSpacing:1},z=e=>String.fromCharCode(e+(e>25?39:97)),W=e=>(e=>{let t,r="";for(t=Math.abs(e);t>52;t=t/52|0)r=z(t%52)+r;return z(t%52)+r})(((e,t)=>{let r=t.length;for(;r;)e=33*e^t.charCodeAt(--r);return e})(5381,JSON.stringify(e))>>>0),j=["themed","global","styled","onevar","resonevar","allvar","inline"],E=e=>{if(e.href&&!e.href.startsWith(location.origin))return!1;try{return!!e.cssRules}catch(e){return!1}},T=e=>{let t;const r=()=>{const{cssRules:e}=t.sheet;return[].map.call(e,((r,n)=>{const{cssText:i}=r;let o="";if(i.startsWith("--sxs"))return"";if(e[n-1]&&(o=e[n-1].cssText).startsWith("--sxs")){if(!r.cssRules.length)return"";for(const e in t.rules)if(t.rules[e].group===r)return`--sxs{--sxs:${[...t.rules[e].cache].join(" ")}}${i}`;return r.cssRules.length?`${o}${i}`:""}return i})).join("")},n=()=>{if(t){const{rules:e,sheet:r}=t;if(!r.deleteRule){for(;3===Object(Object(r.cssRules)[0]).type;)r.cssRules.splice(0,1);r.cssRules=[]}for(const t in e)delete e[t]}const i=Object(e).styleSheets||[];for(const e of i)if(E(e)){for(let i=0,o=e.cssRules;o[i];++i){const l=Object(o[i]);if(1!==l.type)continue;const s=Object(o[i+1]);if(4!==s.type)continue;++i;const{cssText:a}=l;if(!a.startsWith("--sxs"))continue;const c=a.slice(14,-3).trim().split(/\s+/),d=j[c[0]];d&&(t||(t={sheet:e,reset:n,rules:{},toString:r}),t.rules[d]={group:s,index:i,cache:new Set(c)})}if(t)break}if(!t){const i=(e,t)=>({type:t,cssRules:[],insertRule(e,t){this.cssRules.splice(t,0,i(e,{import:3,undefined:1}[(e.toLowerCase().match(/^@([a-z]+)/)||[])[1]]||4))},get cssText(){return"@media{}"===e?`@media{${[].map.call(this.cssRules,(e=>e.cssText)).join("")}}`:e}});t={sheet:e?(e.head||e).appendChild(document.createElement("style")).sheet:i("","text/css"),rules:{},reset:n,toString:r}}const{sheet:o,rules:l}=t;for(let e=j.length-1;e>=0;--e){const t=j[e];if(!l[t]){const r=j[e+1],n=l[r]?l[r].index:o.cssRules.length;o.insertRule("@media{}",n),o.insertRule(`--sxs{--sxs:${e}}`,n),l[t]={group:o.cssRules[n+1],index:n,cache:new Set([e])}}M(l[t])}};return n(),t},M=e=>{const t=e.group;let r=t.cssRules.length;e.apply=e=>{try{t.insertRule(e,r),++r}catch(e){}}},v=Symbol(),w=l(),C=(e,t)=>w(e,(()=>(...r)=>{let n={type:null,composers:new Set};for(const t of r)if(null!=t)if(t[s]){null==n.type&&(n.type=t[s].type);for(const e of t[s].composers)n.composers.add(e)}else t.constructor!==Object||t.$$typeof?null==n.type&&(n.type=t):n.composers.add(P(t,e));return null==n.type&&(n.type="span"),n.composers.size||n.composers.add(["PJLV",{},[],[],{},[]]),L(e,n,t)})),P=(e,t)=>{let{variants:r,compoundVariants:n,defaultVariants:i,...o}=e;const l=`${y(t.prefix)}c-${W(o)}`,s=[],a=[],g=Object.create(null),p=[];for(const e in i)g[e]=String(i[e]);if("object"==typeof r&&r)for(const e in r){u=g,h=e,d.call(u,h)||(g[e]="undefined");const t=r[e];for(const r in t){const n={[e]:String(r)};"undefined"===String(r)&&p.push(e);const i=t[r],o=[n,i,!c(i)];s.push(o)}}var u,h;if("object"==typeof n&&n)for(const e of n){let{css:t,...r}=e;t="object"==typeof t&&t||{};for(const e in r)r[e]=String(r[e]);const n=[r,t,!c(t)];a.push(n)}return[l,o,s,a,g,p]},L=(e,t,r)=>{const[n,i,o,l]=O(t.composers),c="function"==typeof t.type||t.type.$$typeof?(e=>{function t(){for(let r=0;r<t[v].length;r++){const[n,i]=t[v][r];e.rules[n].apply(i)}return t[v]=[],null}return t[v]=[],t.rules={},j.forEach((e=>t.rules[e]={apply:r=>t[v].push([e,r])})),t})(r):null,d=(c||r).rules,g=`.${n}${i.length>1?`:where(.${i.slice(1).join(".")})`:""}`,p=s=>{s="object"==typeof s&&s||N;const{css:a,...p}=s,u={};for(const e in o)if(delete p[e],e in s){let t=s[e];"object"==typeof t&&t?u[e]={"@initial":o[e],...t}:(t=String(t),u[e]="undefined"!==t||l.has(e)?t:o[e])}else u[e]=o[e];const h=new Set([...i]);for(const[n,i,o,l]of t.composers){r.rules.styled.cache.has(n)||(r.rules.styled.cache.add(n),x(i,[`.${n}`],[],e,(e=>{d.styled.apply(e)})));const t=A(o,u,e.media),s=A(l,u,e.media,!0);for(const i of t)if(void 0!==i)for(const[t,o,l]of i){const i=`${n}-${W(o)}-${t}`;h.add(i);const s=(l?r.rules.resonevar:r.rules.onevar).cache,a=l?d.resonevar:d.onevar;s.has(i)||(s.add(i),x(o,[`.${i}`],[],e,(e=>{a.apply(e)})))}for(const t of s)if(void 0!==t)for(const[i,o]of t){const t=`${n}-${W(o)}-${i}`;h.add(t),r.rules.allvar.cache.has(t)||(r.rules.allvar.cache.add(t),x(o,[`.${t}`],[],e,(e=>{d.allvar.apply(e)})))}}if("object"==typeof a&&a){const t=`${n}-i${W(a)}-css`;h.add(t),r.rules.inline.cache.has(t)||(r.rules.inline.cache.add(t),x(a,[`.${t}`],[],e,(e=>{d.inline.apply(e)})))}for(const e of String(s.className||"").trim().split(/\s+/))e&&h.add(e);const f=p.className=[...h].join(" ");return{type:t.type,className:f,selector:g,props:p,toString:()=>f,deferredInjector:c}};return a(p,{className:n,selector:g,[s]:t,toString:()=>(r.rules.styled.cache.has(n)||p(),n)})},O=e=>{let t="";const r=[],n={},i=[];for(const[o,,,,l,s]of e){""===t&&(t=o),r.push(o),i.push(...s);for(const e in l){const t=l[e];(void 0===n[e]||"undefined"!==t||s.includes(t))&&(n[e]=t)}}return[t,r,n,new Set(i)]},A=(e,t,r,n)=>{const i=[];e:for(let[o,l,s]of e){if(s)continue;let e,a=0,c=!1;for(e in o){const n=o[e];let i=t[e];if(i!==n){if("object"!=typeof i||!i)continue e;{let e,t,o=0;for(const l in i){if(n===String(i[l])){if("@initial"!==l){const e=l.slice(1);(t=t||[]).push(e in r?r[e]:l.replace(/^@media ?/,"")),c=!0}a+=o,e=!0}++o}if(t&&t.length&&(l={["@media "+t.join(", ")]:l}),!e)continue e}}}(i[a]=i[a]||[]).push([n?"cv":`${e}-${o[e]}`,l,c])}return i},N={},D=l(),H=(e,t)=>D(e,(()=>(...r)=>{const n=()=>{for(let n of r){n="object"==typeof n&&n||{};let r=W(n);if(!t.rules.global.cache.has(r)){if(t.rules.global.cache.add(r),"@import"in n){let e=[].indexOf.call(t.sheet.cssRules,t.rules.themed.group)-1;for(let r of[].concat(n["@import"]))r=r.includes('"')||r.includes("'")?r:`"${r}"`,t.sheet.insertRule(`@import ${r};`,e++);delete n["@import"]}x(n,[],[],e,(e=>{t.rules.global.apply(e)}))}}return""};return a(n,{toString:n})})),V=l(),G=(e,t)=>V(e,(()=>r=>{const n=`${y(e.prefix)}k-${W(r)}`,i=()=>{if(!t.rules.global.cache.has(n)){t.rules.global.cache.add(n);const i=[];x(r,[],[],e,(e=>i.push(e)));const o=`@keyframes ${n}{${i.join("")}}`;t.rules.global.apply(o)}return n};return a(i,{get name(){return i()},toString:i})})),F=class{constructor(e,t,r,n){this.token=null==e?"":String(e),this.value=null==t?"":String(t),this.scale=null==r?"":String(r),this.prefix=null==n?"":String(n)}get computedValue(){return"var("+this.variable+")"}get variable(){return"--"+y(this.prefix)+y(this.scale)+this.token}toString(){return this.computedValue}},J=l(),U=(e,t)=>J(e,(()=>(r,n)=>{n="object"==typeof r&&r||Object(n);const i=`.${r=(r="string"==typeof r?r:"")||`${y(e.prefix)}t-${W(n)}`}`,o={},l=[];for(const t in n){o[t]={};for(const r in n[t]){const i=`--${y(e.prefix)}${t}-${r}`,s=k(String(n[t][r]),e.prefix,t);o[t][r]=new F(r,s,t,e.prefix),l.push(`${i}:${s}`)}}const s=()=>{if(l.length&&!t.rules.themed.cache.has(r)){t.rules.themed.cache.add(r);const i=`${n===e.theme?":root,":""}.${r}{${l.join(";")}}`;t.rules.themed.apply(i)}return r};return{...o,get className(){return s()},selector:i,toString:s}})),Z=l(),q=__webpack_require__(18038),X=l(),Y=e=>{const t=(e=>{let t=!1;const r=Z(e,(e=>{t=!0;const r="prefix"in(e="object"==typeof e&&e||{})?String(e.prefix):"",n="object"==typeof e.media&&e.media||{},o="object"==typeof e.root?e.root||null:globalThis.document||null,l="object"==typeof e.theme&&e.theme||{},s={prefix:r,media:n,theme:l,themeMap:"object"==typeof e.themeMap&&e.themeMap||{...i},utils:"object"==typeof e.utils&&e.utils||{}},a=T(o),c={css:C(s,a),globalCss:H(s,a),keyframes:G(s,a),createTheme:U(s,a),reset(){a.reset(),c.theme.toString()},theme:{},sheet:a,config:s,prefix:r,getCssText:a.toString,toString:a.toString};return String(c.theme=c.createTheme(l)),c}));return t||r.reset(),r})(e);return t.styled=(e=>{let{config:t,sheet:r}=e;return X(t,(()=>{const e=C(t,r);return(...t)=>{const r=e(...t),n=r[s].type,i=q.forwardRef(((e,t)=>{const i=e&&e.as||n,{props:o,deferredInjector:l}=r(e);return delete o.as,o.ref=t,l?q.createElement(q.Fragment,null,q.createElement(i,o),q.createElement(l,null)):q.createElement(i,o)}));return i.className=r.className,i.displayName=`Styled.${n.displayName||n.name||n}`,i.selector=r.selector,i.toString=()=>r.selector,i[s]=r[s],i}}))})(t),t},K=()=>e||(e=Y());module.exports={createStitches:Y,createTheme:(...e)=>K().createTheme(...e),css:(...e)=>K().css(...e),defaultThemeMap:i,globalCss:(...e)=>K().globalCss(...e),keyframes:(...e)=>K().keyframes(...e),styled:(...e)=>K().styled(...e)};
//# sourceMappingUrl=index.map

/***/ }),

/***/ 73732:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports._ = exports._check_private_redeclaration = _check_private_redeclaration;
function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}


/***/ }),

/***/ 62789:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _check_private_redeclaration = __webpack_require__(73732);

exports._ = exports._class_private_field_init = _class_private_field_init;
function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration._(obj, privateMap);
    privateMap.set(obj, value);
}


/***/ }),

/***/ 61915:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __addDisposableResource: () => (/* binding */ __addDisposableResource),
/* harmony export */   __assign: () => (/* binding */ __assign),
/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),
/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),
/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),
/* harmony export */   __await: () => (/* binding */ __await),
/* harmony export */   __awaiter: () => (/* binding */ __awaiter),
/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),
/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   __createBinding: () => (/* binding */ __createBinding),
/* harmony export */   __decorate: () => (/* binding */ __decorate),
/* harmony export */   __disposeResources: () => (/* binding */ __disposeResources),
/* harmony export */   __esDecorate: () => (/* binding */ __esDecorate),
/* harmony export */   __exportStar: () => (/* binding */ __exportStar),
/* harmony export */   __extends: () => (/* binding */ __extends),
/* harmony export */   __generator: () => (/* binding */ __generator),
/* harmony export */   __importDefault: () => (/* binding */ __importDefault),
/* harmony export */   __importStar: () => (/* binding */ __importStar),
/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),
/* harmony export */   __metadata: () => (/* binding */ __metadata),
/* harmony export */   __param: () => (/* binding */ __param),
/* harmony export */   __propKey: () => (/* binding */ __propKey),
/* harmony export */   __read: () => (/* binding */ __read),
/* harmony export */   __rest: () => (/* binding */ __rest),
/* harmony export */   __runInitializers: () => (/* binding */ __runInitializers),
/* harmony export */   __setFunctionName: () => (/* binding */ __setFunctionName),
/* harmony export */   __spread: () => (/* binding */ __spread),
/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),
/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),
/* harmony export */   __values: () => (/* binding */ __values),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object") throw new TypeError("Object expected.");
    var dispose;
    if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
      }
      catch (e) {
          fail(e);
      }
    }
    if (env.hasError) throw env.error;
  }
  return next();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
});


/***/ })

};
;